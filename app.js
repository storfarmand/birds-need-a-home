/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 102);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyFunction = __webpack_require__(10);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var DOMProperty = __webpack_require__(16);
var ReactDOMComponentFlags = __webpack_require__(68);

var invariant = __webpack_require__(1);

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var Flags = ReactDOMComponentFlags;

var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

/**
 * Check if a given node should be cached.
 */
function shouldPrecacheNode(node, nodeID) {
  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
}

/**
 * Drill down (through composites and empty components) until we get a host or
 * host text component.
 *
 * This is pretty polymorphic but unavoidable with the current structure we have
 * for `_renderedChildren`.
 */
function getRenderedHostOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}

/**
 * Populate `_hostNode` on the rendered host/text component with the given
 * DOM node. The passed `inst` can be a composite.
 */
function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}

function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}

/**
 * Populate `_hostNode` on each child of `inst`, assuming that the children
 * match up with the DOM (element) children of `node`.
 *
 * We cache entire levels at once to avoid an n^2 problem where we access the
 * children of a node sequentially and have to walk from the start to our target
 * node every time.
 *
 * Since we update `_renderedChildren` and the actual DOM at (slightly)
 * different times, we could race here and see a newer `_renderedChildren` than
 * the DOM nodes we see. To avoid this, ReactMultiChild calls
 * `prepareToManageChildren` before we change `_renderedChildren`, at which
 * time the container's child nodes are always cached (until it unmounts).
 */
function precacheChildNodes(inst, node) {
  if (inst._flags & Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (shouldPrecacheNode(childNode, childID)) {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
  }
  inst._flags |= Flags.hasCachedChildNodes;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null && inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}

var ReactDOMComponentTree = {
  getClosestInstanceFromNode: getClosestInstanceFromNode,
  getInstanceFromNode: getInstanceFromNode,
  getNodeFromInstance: getNodeFromInstance,
  precacheChildNodes: precacheChildNodes,
  precacheNode: precacheNode,
  uncacheNode: uncacheNode
};

module.exports = ReactDOMComponentTree;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(20);

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withRouter = exports.matchPath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.MemoryRouter = undefined;

var _MemoryRouter2 = __webpack_require__(204);

var _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2);

var _Prompt2 = __webpack_require__(209);

var _Prompt3 = _interopRequireDefault(_Prompt2);

var _Redirect2 = __webpack_require__(210);

var _Redirect3 = _interopRequireDefault(_Redirect2);

var _Route2 = __webpack_require__(93);

var _Route3 = _interopRequireDefault(_Route2);

var _Router2 = __webpack_require__(59);

var _Router3 = _interopRequireDefault(_Router2);

var _StaticRouter2 = __webpack_require__(213);

var _StaticRouter3 = _interopRequireDefault(_StaticRouter2);

var _Switch2 = __webpack_require__(214);

var _Switch3 = _interopRequireDefault(_Switch2);

var _matchPath2 = __webpack_require__(60);

var _matchPath3 = _interopRequireDefault(_matchPath2);

var _withRouter2 = __webpack_require__(215);

var _withRouter3 = _interopRequireDefault(_withRouter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.MemoryRouter = _MemoryRouter3.default;
exports.Prompt = _Prompt3.default;
exports.Redirect = _Redirect3.default;
exports.Route = _Route3.default;
exports.Router = _Router3.default;
exports.StaticRouter = _StaticRouter3.default;
exports.Switch = _Switch3.default;
exports.matchPath = _matchPath3.default;
exports.withRouter = _withRouter3.default;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(21);

var ReactCurrentOwner = __webpack_require__(13);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty
  // Strip regex characters so we can use it for regex
  ).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&'
  // Remove hasOwnProperty from the template to make it generic
  ).replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function setItem(id, item) {
    itemMap.set(id, item);
  };
  getItem = function getItem(id) {
    return itemMap.get(id);
  };
  removeItem = function removeItem(id) {
    itemMap['delete'](id);
  };
  getItemIDs = function getItemIDs() {
    return Array.from(itemMap.keys());
  };

  addRoot = function addRoot(id) {
    rootIDSet.add(id);
  };
  removeRoot = function removeRoot(id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function getRootIDs() {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function getKeyFromID(id) {
    return '.' + id;
  };
  var getIDFromKey = function getIDFromKey(key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function setItem(id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function getItem(id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function removeItem(id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function getItemIDs() {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function addRoot(id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function removeRoot(id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function getRootIDs() {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function _getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function onSetChildren(id, nextChildIDs) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || _typeof(nextChild.element) !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function onBeforeMountComponent(id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function onBeforeUpdateComponent(id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function onMountComponent(id) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function onUpdateComponent(id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function onUnmountComponent(id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function purgeUnmountedComponents() {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function isMounted(id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function getCurrentStackAddendum(topElement) {
    var info = '';
    if (topElement) {
      var name = _getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function getStackAddendumByID(id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function getChildIDs(id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function getDisplayName(id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return _getDisplayName(element);
  },
  getElement: function getElement(id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function getOwnerID(id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function getParentID(id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function getSource(id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function getText(id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function getUpdateCount(id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },

  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs,

  pushNonStandardWarningStack: function pushNonStandardWarningStack(isCreatingElement, currentSource) {
    if (typeof console.reactStack !== 'function') {
      return;
    }

    var stack = [];
    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    try {
      if (isCreatingElement) {
        stack.push({
          name: id ? ReactComponentTreeHook.getDisplayName(id) : null,
          fileName: currentSource ? currentSource.fileName : null,
          lineNumber: currentSource ? currentSource.lineNumber : null
        });
      }

      while (id) {
        var element = ReactComponentTreeHook.getElement(id);
        var parentID = ReactComponentTreeHook.getParentID(id);
        var ownerID = ReactComponentTreeHook.getOwnerID(id);
        var ownerName = ownerID ? ReactComponentTreeHook.getDisplayName(ownerID) : null;
        var source = element && element._source;
        stack.push({
          name: ownerName,
          fileName: source ? source.fileName : null,
          lineNumber: source ? source.lineNumber : null
        });
        id = parentID;
      }
    } catch (err) {
      // Internal state is messed up.
      // Stop building the stack (it's just a nice to have).
    }

    console.reactStack(stack);
  },
  popNonStandardWarningStack: function popNonStandardWarningStack() {
    if (typeof console.reactStackEnd !== 'function') {
      return;
    }
    console.reactStackEnd();
  }
};

module.exports = ReactComponentTreeHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// Trust the developer to only use ReactInstrumentation with a __DEV__ check

var debugTool = null;

if (process.env.NODE_ENV !== 'production') {
  var ReactDebugTool = __webpack_require__(129);
  debugTool = ReactDebugTool;
}

module.exports = { debugTool: debugTool };
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(67)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(205)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */

var ReactCurrentOwner = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null
};

module.exports = ReactCurrentOwner;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(6);

var CallbackQueue = __webpack_require__(72);
var PooledClass = __webpack_require__(18);
var ReactFeatureFlags = __webpack_require__(73);
var ReactReconciler = __webpack_require__(22);
var Transaction = __webpack_require__(32);

var invariant = __webpack_require__(1);

var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
}

var NESTED_UPDATES = {
  initialize: function initialize() {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function close() {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function initialize() {
    this.callbackQueue.reset();
  },
  close: function close() {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}

_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
  getTransactionWrappers: function getTransactionWrappers() {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function destructor() {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function perform(method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  // Any updates enqueued while reconciling must be performed after this entire
  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
  // C, B could update twice in a single batch if C's render enqueues an update
  // to B (since B would have already updated, we should skip it, and the only
  // way we can know to do so is by checking the batch counter).
  updateBatchNumber++;

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      // Duck type TopLevelWrapper. This is probably always true.
      if (component._currentElement.type.isReactTopLevelWrapper) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

    if (markerName) {
      console.timeEnd(markerName);
    }

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function flushBatchedUpdates() {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var PooledClass = __webpack_require__(18);

var emptyFunction = __webpack_require__(10);
var warning = __webpack_require__(2);

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function timeStamp(event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  if (process.env.NODE_ENV !== 'production') {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    if (process.env.NODE_ENV !== 'production') {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {
  preventDefault: function preventDefault() {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
      // eslint-disable-next-line valid-typeof
    } else if (typeof event.returnValue !== 'unknown') {
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function stopPropagation() {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
      // eslint-disable-next-line valid-typeof
    } else if (typeof event.cancelBubble !== 'unknown') {
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function persist() {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function destructor() {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (process.env.NODE_ENV !== 'production') {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      } else {
        this[propName] = null;
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    if (process.env.NODE_ENV !== 'production') {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }
});

SyntheticEvent.Interface = EventInterface;

if (process.env.NODE_ENV !== 'production') {
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function construct(target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function apply(constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function set(target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), "This synthetic event is reused for performance reasons. If you're " + "seeing this, you're adding a new property in the synthetic event object. " + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}
/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function E() {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;

/**
  * Helper to nullify syntheticEvent instance properties when destructing
  *
  * @param {object} SyntheticEvent
  * @param {String} propName
  * @return {object} defineProperty object
  */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    process.env.NODE_ENV !== 'production' ? warning(warningCondition, "This synthetic event is reused for performance reasons. If you're seeing this, " + "you're %s `%s` on a released/nullified synthetic event. %s. " + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

      if (process.env.NODE_ENV !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if (process.env.NODE_ENV !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {
  ID_ATTRIBUTE_NAME: 'data-reactid',
  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   *
   * autofocus is predefined, because adding it to the property whitelist
   * causes unintended side effects.
   *
   * @type {Object}
   */
  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function isCustomAttribute(attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _assign = __webpack_require__(38);

var ReactCurrentOwner = __webpack_require__(13);

var warning = __webpack_require__(2);
var canDefineProperty = __webpack_require__(29);
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = __webpack_require__(63);

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function warnAboutAccessingKey() {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function warnAboutAccessingRef() {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (process.env.NODE_ENV !== 'production') {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function standardReleaser(instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function warning() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function warning(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.length < 10 || /^[s\W]*$/.test(format)) {
      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(38);

var ReactBaseClasses = __webpack_require__(61);
var ReactChildren = __webpack_require__(103);
var ReactDOMFactories = __webpack_require__(107);
var ReactElement = __webpack_require__(17);
var ReactPropTypes = __webpack_require__(111);
var ReactVersion = __webpack_require__(113);

var createReactClass = __webpack_require__(114);
var onlyChild = __webpack_require__(117);

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  var lowPriorityWarning = __webpack_require__(39);
  var canDefineProperty = __webpack_require__(29);
  var ReactElementValidator = __webpack_require__(65);
  var didWarnPropTypesDeprecated = false;
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;
var createMixin = function createMixin(mixin) {
  return mixin;
};

if (process.env.NODE_ENV !== 'production') {
  var warnedForSpread = false;
  var warnedForCreateMixin = false;
  __spread = function __spread() {
    lowPriorityWarning(warnedForSpread, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.');
    warnedForSpread = true;
    return _assign.apply(null, arguments);
  };

  createMixin = function createMixin(mixin) {
    lowPriorityWarning(warnedForCreateMixin, 'React.createMixin is deprecated and should not be used. ' + 'In React v16.0, it will be removed. ' + 'You can use this mixin directly instead. ' + 'See https://fb.me/createmixin-was-never-implemented for more info.');
    warnedForCreateMixin = true;
    return mixin;
  };
}

var React = {
  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactBaseClasses.Component,
  PureComponent: ReactBaseClasses.PureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: createReactClass,
  createFactory: createFactory,
  createMixin: createMixin,

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

if (process.env.NODE_ENV !== 'production') {
  var warnedForCreateClass = false;
  if (canDefineProperty) {
    Object.defineProperty(React, 'PropTypes', {
      get: function get() {
        lowPriorityWarning(didWarnPropTypesDeprecated, 'Accessing PropTypes via the main React package is deprecated,' + ' and will be removed in  React v16.0.' + ' Use the latest available v15.* prop-types package from npm instead.' + ' For info on usage, compatibility, migration and more, see ' + 'https://fb.me/prop-types-docs');
        didWarnPropTypesDeprecated = true;
        return ReactPropTypes;
      }
    });

    Object.defineProperty(React, 'createClass', {
      get: function get() {
        lowPriorityWarning(warnedForCreateClass, 'Accessing createClass via the main React package is deprecated,' + ' and will be removed in React v16.0.' + " Use a plain JavaScript class instead. If you're not yet " + 'ready to migrate, create-react-class v15.* is available ' + 'on npm as a temporary, drop-in replacement. ' + 'For more info see https://fb.me/react-create-class');
        warnedForCreateClass = true;
        return createReactClass;
      }
    });
  }

  // React.DOM factories are deprecated. Wrap these methods so that
  // invocations of the React.DOM namespace and alert users to switch
  // to the `react-dom-factories` package.
  React.DOM = {};
  var warnedForFactories = false;
  Object.keys(ReactDOMFactories).forEach(function (factory) {
    React.DOM[factory] = function () {
      if (!warnedForFactories) {
        lowPriorityWarning(false, 'Accessing factories like React.DOM.%s has been deprecated ' + 'and will be removed in v16.0+. Use the ' + 'react-dom-factories package instead. ' + ' Version 1.0 provides a drop-in replacement.' + ' For more info, see https://fb.me/react-dom-factories', factory);
        warnedForFactories = true;
      }
      return ReactDOMFactories[factory].apply(ReactDOMFactories, arguments);
    };
  });
}

module.exports = React;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactRef = __webpack_require__(127);
var ReactInstrumentation = __webpack_require__(11);

var warning = __webpack_require__(2);

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {
  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing host component instance
   * @param {?object} info about the host container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function mountComponent(internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID) // 0 in production and for roots
  {
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
      }
    }
    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
      }
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getHostNode: function getHostNode(internalInstance) {
    return internalInstance.getHostNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function unmountComponent(internalInstance, safely) {
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
      }
    }
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
      }
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }

    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      // The component's enqueued batch number should always be the current
      // batch or the following one.
      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
      }
    }
    internalInstance.performUpdateIfNecessary(transaction);
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  }
};

module.exports = ReactReconciler;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMNamespaces = __webpack_require__(47);
var setInnerHTML = __webpack_require__(34);

var createMicrosoftUnsafeLocalFunction = __webpack_require__(48);
var setTextContent = __webpack_require__(77);

var ELEMENT_NODE_TYPE = 1;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * In IE (8-11) and Edge, appending nodes with no children is dramatically
 * faster than appending a full subtree, so we essentially queue up the
 * .appendChild calls here and apply them so each node is added to its parent
 * before any children are added.
 *
 * In other browsers, doing so is slower or neutral compared to the other order
 * (in Firefox, twice as slow) so we only do this inversion in IE.
 *
 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
 */
var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

function insertTreeChildren(tree) {
  if (!enableLazy) {
    return;
  }
  var node = tree.node;
  var children = tree.children;
  if (children.length) {
    for (var i = 0; i < children.length; i++) {
      insertTreeBefore(node, children[i], null);
    }
  } else if (tree.html != null) {
    setInnerHTML(node, tree.html);
  } else if (tree.text != null) {
    setTextContent(node, tree.text);
  }
}

var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some <object> plugins (like Flash Player) will read
  // <param> nodes immediately upon insertion into the DOM, so <object>
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
});

function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}

function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}

function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML(tree.node, html);
  }
}

function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}

function toString() {
  return this.node.nodeName;
}

function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}

DOMLazyTree.insertTreeBefore = insertTreeBefore;
DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
DOMLazyTree.queueChild = queueChild;
DOMLazyTree.queueHTML = queueHTML;
DOMLazyTree.queueText = queueText;

module.exports = DOMLazyTree;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(25);
var EventPluginUtils = __webpack_require__(41);

var accumulateInto = __webpack_require__(69);
var forEachAccumulated = __webpack_require__(70);
var warning = __webpack_require__(2);

var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(3);

var EventPluginRegistry = __webpack_require__(31);
var EventPluginUtils = __webpack_require__(41);
var ReactErrorUtils = __webpack_require__(42);

var accumulateInto = __webpack_require__(69);
var forEachAccumulated = __webpack_require__(70);
var invariant = __webpack_require__(1);

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
  return executeDispatchesAndRelease(e, false);
};

var getDictionaryKey = function getDictionaryKey(inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {
  /**
   * Methods for injecting dependencies.
   */
  injection: {
    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
  },

  /**
   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {function} listener The callback to store.
   */
  putListener: function putListener(inst, registrationName, listener) {
    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : _prodInvariant('94', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : void 0;

    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[key] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function getListener(inst, registrationName) {
    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
    // live here; needs to be moved to a better place soon
    var bankForRegistrationName = listenerBank[registrationName];
    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
      return null;
    }
    var key = getDictionaryKey(inst);
    return bankForRegistrationName && bankForRegistrationName[key];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function deleteListener(inst, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      var key = getDictionaryKey(inst);
      delete bankForRegistrationName[key];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {object} inst The instance, which is the source of events.
   */
  deleteAllListeners: function deleteAllListeners(inst) {
    var key = getDictionaryKey(inst);
    for (var registrationName in listenerBank) {
      if (!listenerBank.hasOwnProperty(registrationName)) {
        continue;
      }

      if (!listenerBank[registrationName][key]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      delete listenerBank[registrationName][key];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function enqueueEvents(events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function processEventQueue(simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function __purge() {
    listenerBank = {};
  },

  __getListenerBank: function __getListenerBank() {
    return listenerBank;
  }
};

module.exports = EventPluginHub;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(15);

var getEventTarget = __webpack_require__(43);

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function view(event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function detail(event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap = {
  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function remove(key) {
    key._reactInternalInstance = undefined;
  },

  get: function get(key) {
    return key._reactInternalInstance;
  },

  has: function has(key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function set(key, value) {
    key._reactInternalInstance = value;
  }
};

module.exports = ReactInstanceMap;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var addLeadingSlash = exports.addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = exports.stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = exports.hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = exports.stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = exports.stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = exports.parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = exports.createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;

  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function get() {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  if (process.env.NODE_ENV !== 'production') {
    var lowerCasedName = registrationName.toLowerCase();
    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {
  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in __DEV__.
   * @type {Object}
   */
  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
  // Trust the developer to only use possibleRegistrationNames in __DEV__

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function injectEventPluginOrder(injectedEventPluginOrder) {
    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var pluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
        namesToPlugins[pluginName] = pluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    if (dispatchConfig.phasedRegistrationNames !== undefined) {
      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
      // that it is not undefined.
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

      for (var phase in phasedRegistrationNames) {
        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
          continue;
        }
        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
        if (pluginModule) {
          return pluginModule;
        }
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function _resetEventPlugins() {
    eventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
      for (var lowerCasedName in possibleRegistrationNames) {
        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
          delete possibleRegistrationNames[lowerCasedName];
        }
      }
    }
  }
};

module.exports = EventPluginRegistry;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

var OBSERVED_ERROR = {};

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var TransactionImpl = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function reinitializeTransaction() {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function isInTransaction() {
    return !!this._isInTransaction;
  },

  /* eslint-disable space-before-function-paren */

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function perform(method, scope, a, b, c, d, e, f) {
    /* eslint-enable space-before-function-paren */
    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function initializeAll(startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function closeAll(startIndex) {
    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

module.exports = TransactionImpl;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(26);
var ViewportMetrics = __webpack_require__(76);

var getEventModifierState = __webpack_require__(45);

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function button(event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function relatedTarget(event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function pageX(event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function pageY(event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(7);
var DOMNamespaces = __webpack_require__(47);

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

var createMicrosoftUnsafeLocalFunction = __webpack_require__(48);

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node
  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function setInnerHTML(node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xfeff) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
  testElement = null;
}

module.exports = setInnerHTML;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * Based on the escape-html library, which is used under the MIT License below:
 *
 * Copyright (c) 2012-2013 TJ Holowaychuk
 * Copyright (c) 2015 Andreas Lubbe
 * Copyright (c) 2015 Tiancheng "Timothy" Gu
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */



// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// end code copied and modified from escape-html

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }
  return escapeHtml(text);
}

module.exports = escapeTextContentForBrowser;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var EventPluginRegistry = __webpack_require__(31);
var ReactEventEmitterMixin = __webpack_require__(153);
var ViewportMetrics = __webpack_require__(76);

var getVendorPrefixedEventName = __webpack_require__(154);
var isEventSupported = __webpack_require__(44);

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var hasEventPageXY;
var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {
  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function setEnabled(enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function isEnabled() {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function listenTo(registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === 'topWheel') {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === 'topScroll') {
          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {
          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Protect against document.createEvent() returning null
   * Some popup blocker extensions appear to do this:
   * https://github.com/facebook/react/issues/6887
   */
  supportsEventPageXY: function supportsEventPageXY() {
    if (!document.createEvent) {
      return false;
    }
    var ev = document.createEvent('MouseEvent');
    return ev != null && 'pageX' in ev;
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
   * pageX/pageY isn't supported (legacy browsers).
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
    }
    if (!hasEventPageXY && !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  }
});

module.exports = ReactBrowserEventEmitter;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function lowPriorityWarning() {};

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function lowPriorityWarning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = lowPriorityWarning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactErrorUtils = __webpack_require__(42);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

/**
 * Injected dependencies:
 */

/**
 * - `ComponentTree`: [required] Module that can convert between React instances
 *   and actual node references.
 */
var ComponentTree;
var TreeTraversal;
var injection = {
  injectComponentTree: function injectComponentTree(Injected) {
    ComponentTree = Injected;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
    }
  },
  injectTreeTraversal: function injectTreeTraversal(Injected) {
    TreeTraversal = Injected;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
    }
  }
};

function isEndish(topLevelType) {
  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
}

function isMoveish(topLevelType) {
  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
}
function isStartish(topLevelType) {
  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
}

var validateEventDispatches;
if (process.env.NODE_ENV !== 'production') {
  validateEventDispatches = function validateEventDispatches(event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getInstanceFromNode: function getInstanceFromNode(node) {
    return ComponentTree.getInstanceFromNode(node);
  },
  getNodeFromInstance: function getNodeFromInstance(node) {
    return ComponentTree.getNodeFromInstance(node);
  },
  isAncestor: function isAncestor(a, b) {
    return TreeTraversal.isAncestor(a, b);
  },
  getLowestCommonAncestor: function getLowestCommonAncestor(a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function getParentInstance(inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function traverseTwoPhase(target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function traverseEnterLeave(from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function rethrowCaughtError() {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if (process.env.NODE_ENV !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = func.bind(null, a);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(7);

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  Alt: 'altKey',
  Control: 'ctrlKey',
  Meta: 'metaKey',
  Shift: 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMLazyTree = __webpack_require__(23);
var Danger = __webpack_require__(138);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactInstrumentation = __webpack_require__(11);

var createMicrosoftUnsafeLocalFunction = __webpack_require__(48);
var setInnerHTML = __webpack_require__(34);
var setTextContent = __webpack_require__(77);

function getNodeAfter(parentNode, node) {
  // Special case for text components, which return [open, close] comments
  // from getHostNode.
  if (Array.isArray(node)) {
    node = node[1];
  }
  return node ? node.nextSibling : parentNode.firstChild;
}

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
  // We rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
  // we are careful to use `null`.)
  parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
  if (Array.isArray(childNode)) {
    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
  } else {
    insertChildAt(parentNode, childNode, referenceNode);
  }
}

function removeChild(parentNode, childNode) {
  if (Array.isArray(childNode)) {
    var closingComment = childNode[1];
    childNode = childNode[0];
    removeDelimitedText(parentNode, childNode, closingComment);
    parentNode.removeChild(closingComment);
  }
  parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
  var node = openingComment;
  while (true) {
    var nextNode = node.nextSibling;
    insertChildAt(parentNode, node, referenceNode);
    if (node === closingComment) {
      break;
    }
    node = nextNode;
  }
}

function removeDelimitedText(parentNode, startNode, closingComment) {
  while (true) {
    var node = startNode.nextSibling;
    if (node === closingComment) {
      // The closing comment is removed by ReactMultiChild.
      break;
    } else {
      parentNode.removeChild(node);
    }
  }
}

function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if (process.env.NODE_ENV !== 'production') {
  dangerouslyReplaceNodeWithMarkup = function dangerouslyReplaceNodeWithMarkup(oldChild, markup, prevInstance) {
    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
    if (prevInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: prevInstance._debugID,
        type: 'replace with',
        payload: markup.toString()
      });
    } else {
      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
      if (nextInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: nextInstance._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {
  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

  replaceDelimitedText: replaceDelimitedText,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  processUpdates: function processUpdates(parentNode, updates) {
    if (process.env.NODE_ENV !== 'production') {
      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
    }

    for (var k = 0; k < updates.length; k++) {
      var update = updates[k];
      switch (update.type) {
        case 'INSERT_MARKUP':
          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'insert child',
              payload: {
                toIndex: update.toIndex,
                content: update.content.toString()
              }
            });
          }
          break;
        case 'MOVE_EXISTING':
          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'move child',
              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
            });
          }
          break;
        case 'SET_MARKUP':
          setInnerHTML(parentNode, update.content);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace children',
              payload: update.content.toString()
            });
          }
          break;
        case 'TEXT_CONTENT':
          setTextContent(parentNode, update.content);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace text',
              payload: update.content.toString()
            });
          }
          break;
        case 'REMOVE_NODE':
          removeChild(parentNode, update.fromNode);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'remove child',
              payload: { fromIndex: update.fromIndex }
            });
          }
          break;
      }
    }
  }
};

module.exports = DOMChildrenOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMNamespaces = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

module.exports = DOMNamespaces;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals MSApp */



/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

var createMicrosoftUnsafeLocalFunction = function createMicrosoftUnsafeLocalFunction(func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

module.exports = createMicrosoftUnsafeLocalFunction;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactPropTypesSecret = __webpack_require__(81);
var propTypesFactory = __webpack_require__(66);

var React = __webpack_require__(20);
var PropTypes = propTypesFactory(React.isValidElement);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var hasReadOnlyValue = {
  button: true,
  checkbox: true,
  image: true,
  hidden: true,
  radio: true,
  reset: true,
  submit: true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
}

var propTypes = {
  value: function value(props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function checked(props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: PropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function checkPropTypes(tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function getValue(inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function getChecked(inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function executeOnChange(inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

var injected = false;

var ReactComponentEnvironment = {
  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkup: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function injectEnvironment(environment) {
      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }
};

module.exports = ReactComponentEnvironment;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}

module.exports = shouldUpdateReactComponent;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(3);

var ReactCurrentOwner = __webpack_require__(13);
var ReactInstanceMap = __webpack_require__(27);
var ReactInstrumentation = __webpack_require__(11);
var ReactUpdates = __webpack_require__(14);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function formatUnexpectedArgument(arg) {
  var type = typeof arg === 'undefined' ? 'undefined' : _typeof(arg);
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var ctor = publicInstance.constructor;
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
    }
    return null;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + "within `render` or another component's constructor). Render methods " + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function isMounted(publicInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function enqueueCallback(publicInstance, callback, callerName) {
    ReactUpdateQueue.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    // Future-proof 15.5
    if (callback !== undefined && callback !== null) {
      ReactUpdateQueue.validateCallback(callback, 'replaceState');
      if (internalInstance._pendingCallbacks) {
        internalInstance._pendingCallbacks.push(callback);
      } else {
        internalInstance._pendingCallbacks = [callback];
      }
    }

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onSetState();
      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
    }

    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function enqueueElementInternal(internalInstance, nextElement, nextContext) {
    internalInstance._pendingElement = nextElement;
    // TODO: introduce _pendingContext instead of setting it directly.
    internalInstance._context = nextContext;
    enqueueUpdate(internalInstance);
  },

  validateCallback: function validateCallback(callback, callerName) {
    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
  }
};

module.exports = ReactUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var emptyFunction = __webpack_require__(10);
var warning = __webpack_require__(2);

var validateDOMNesting = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':
      case 'pre':
      case 'listing':
      case 'table':
      case 'hr':
      case 'xmp':
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function findOwnerStack(instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    do {
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function validateDOMNesting(childTag, childText, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      var tagDisplayName = childTag;
      var whitespaceInfo = '';
      if (childTag === '#text') {
        if (/\S/.test(childText)) {
          tagDisplayName = 'Text nodes';
        } else {
          tagDisplayName = 'Whitespace text nodes';
          whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + 'each line of your source code.';
        }
      } else {
        tagDisplayName = '<' + childTag + '>';
      }

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
      }
    }
  };

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
exports.locationsAreEqual = exports.createLocation = undefined;

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _resolvePathname = __webpack_require__(207);

var _resolvePathname2 = _interopRequireDefault(_resolvePathname);

var _valueEqual = __webpack_require__(208);

var _valueEqual2 = _interopRequireDefault(_valueEqual);

var _PathUtils = __webpack_require__(28);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var createLocation = exports.createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = exports.locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && (0, _valueEqual2.default)(a.state, b.state);
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _warning = __webpack_require__(19);

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

exports.default = createTransitionManager;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(19);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(37);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for putting history on context.
 */

var Router = function (_React$Component) {
  _inherits(Router, _React$Component);

  function Router() {
    var _temp, _this, _ret;

    _classCallCheck(this, Router);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props.history.location.pathname)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Router.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        history: this.props.history,
        route: {
          location: this.props.history.location,
          match: this.state.match
        }
      })
    };
  };

  Router.prototype.computeMatch = function computeMatch(pathname) {
    return {
      path: '/',
      url: '/',
      params: {},
      isExact: pathname === '/'
    };
  };

  Router.prototype.componentWillMount = function componentWillMount() {
    var _this2 = this;

    var _props = this.props,
        children = _props.children,
        history = _props.history;

    (0, _invariant2.default)(children == null || _react2.default.Children.count(children) === 1, 'A <Router> may have only one child element');

    // Do this here so we can setState when a <Redirect> changes the
    // location in componentWillMount. This happens e.g. when doing
    // server rendering using a <StaticRouter>.
    this.unlisten = history.listen(function () {
      _this2.setState({
        match: _this2.computeMatch(history.location.pathname)
      });
    });
  };

  Router.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    (0, _warning2.default)(this.props.history === nextProps.history, 'You cannot change <Router history>');
  };

  Router.prototype.componentWillUnmount = function componentWillUnmount() {
    this.unlisten();
  };

  Router.prototype.render = function render() {
    var children = this.props.children;

    return children ? _react2.default.Children.only(children) : null;
  };

  return Router;
}(_react2.default.Component);

Router.propTypes = {
  history: _propTypes2.default.object.isRequired,
  children: _propTypes2.default.node
};
Router.contextTypes = {
  router: _propTypes2.default.object
};
Router.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = Router;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pathToRegexp = __webpack_require__(211);

var _pathToRegexp2 = _interopRequireDefault(_pathToRegexp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var patternCache = {};
var cacheLimit = 10000;
var cacheCount = 0;

var compilePath = function compilePath(pattern, options) {
  var cacheKey = '' + options.end + options.strict;
  var cache = patternCache[cacheKey] || (patternCache[cacheKey] = {});

  if (cache[pattern]) return cache[pattern];

  var keys = [];
  var re = (0, _pathToRegexp2.default)(pattern, keys, options);
  var compiledPattern = { re: re, keys: keys };

  if (cacheCount < cacheLimit) {
    cache[pattern] = compiledPattern;
    cacheCount++;
  }

  return compiledPattern;
};

/**
 * Public API for matching a URL pathname to a path pattern.
 */
var matchPath = function matchPath(pathname) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof options === 'string') options = { path: options };

  var _options = options,
      _options$path = _options.path,
      path = _options$path === undefined ? '/' : _options$path,
      _options$exact = _options.exact,
      exact = _options$exact === undefined ? false : _options$exact,
      _options$strict = _options.strict,
      strict = _options$strict === undefined ? false : _options$strict;

  var _compilePath = compilePath(path, { end: exact, strict: strict }),
      re = _compilePath.re,
      keys = _compilePath.keys;

  var match = re.exec(pathname);

  if (!match) return null;

  var url = match[0],
      values = match.slice(1);

  var isExact = pathname === url;

  if (exact && !isExact) return null;

  return {
    path: path, // the path pattern used to match
    url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL
    isExact: isExact, // whether or not we matched exactly
    params: keys.reduce(function (memo, key, index) {
      memo[key.name] = values[index];
      return memo;
    }, {})
  };
};

exports.default = matchPath;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(21),
    _assign = __webpack_require__(38);

var ReactNoopUpdateQueue = __webpack_require__(62);

var canDefineProperty = __webpack_require__(29);
var emptyObject = __webpack_require__(30);
var invariant = __webpack_require__(1);
var lowPriorityWarning = __webpack_require__(39);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function get() {
          lowPriorityWarning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = {
  Component: ReactComponent,
  PureComponent: ReactPureComponent
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var warning = __webpack_require__(2);

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {
  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function isMounted(publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function enqueueCallback(publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var ReactCurrentOwner = __webpack_require__(13);
var ReactComponentTreeHook = __webpack_require__(9);
var ReactElement = __webpack_require__(17);

var checkReactTypeSpec = __webpack_require__(108);

var canDefineProperty = __webpack_require__(29);
var getIteratorFn = __webpack_require__(64);
var warning = __webpack_require__(2);
var lowPriorityWarning = __webpack_require__(39);

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

function getSourceInfoErrorAddendum(elementProps) {
  if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
    var source = elementProps.__source;
    var fileName = source.fileName.replace(/^.*[\\\/]/, '');
    var lineNumber = source.lineNumber;
    return ' Check your code at ' + fileName + ':' + lineNumber + '.';
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {
  createElement: function createElement(type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += ReactComponentTreeHook.getCurrentStackAddendum();

        var currentSource = props !== null && props !== undefined && props.__source !== undefined ? props.__source : null;
        ReactComponentTreeHook.pushNonStandardWarningStack(true, currentSource);
        process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info) : void 0;
        ReactComponentTreeHook.popNonStandardWarningStack();
      }
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function createFactory(type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            lowPriorityWarning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function cloneElement(element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }
};

module.exports = ReactElementValidator;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



// React 15.5 references this module, and assumes PropTypes are still callable in production.
// Therefore we re-export development-only version with all the PropTypes checks here.
// However if one is migrating to the `prop-types` npm library, they will go through the
// `index.js` entry point, and it will branch depending on the environment.

var factory = __webpack_require__(67);
module.exports = function (isValidElement) {
  // It is still allowed in 15.5.
  var throwOnDirectAccess = false;
  return factory(isValidElement, throwOnDirectAccess);
};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyFunction = __webpack_require__(10);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var ReactPropTypesSecret = __webpack_require__(40);
var checkPropTypes = __webpack_require__(112);

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(false, 'Invalid argument supplid to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMComponentFlags = {
  hasCachedChildNodes: 1 << 0
};

module.exports = ReactDOMComponentFlags;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

module.exports = forEachAccumulated;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(7);

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var PooledClass = __webpack_require__(18);

var invariant = __webpack_require__(1);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
  function CallbackQueue(arg) {
    _classCallCheck(this, CallbackQueue);

    this._callbacks = null;
    this._contexts = null;
    this._arg = arg;
  }

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */

  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._callbacks.push(callback);
    this._contexts = this._contexts || [];
    this._contexts.push(context);
  };

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */

  CallbackQueue.prototype.notifyAll = function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    var arg = this._arg;
    if (callbacks && contexts) {
      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i], arg);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  };

  CallbackQueue.prototype.checkpoint = function checkpoint() {
    return this._callbacks ? this._callbacks.length : 0;
  };

  CallbackQueue.prototype.rollback = function rollback(len) {
    if (this._callbacks && this._contexts) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  };

  /**
   * Resets the internal queue.
   *
   * @internal
   */

  CallbackQueue.prototype.reset = function reset() {
    this._callbacks = null;
    this._contexts = null;
  };

  /**
   * `PooledClass` looks for this.
   */

  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.addPoolingTo(CallbackQueue);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactFeatureFlags = {
  // When true, call console.time() before and .timeEnd() after each top-level
  // render (both initial renders and updates). Useful when looking at prod-mode
  // timeline profiles in Chrome, for example.
  logTopLevelRenders: false
};

module.exports = ReactFeatureFlags;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMComponentTree = __webpack_require__(4);

function isCheckable(elem) {
  var type = elem.type;
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (type === 'checkbox' || type === 'radio');
}

function getTracker(inst) {
  return inst._wrapperState.valueTracker;
}

function attachTracker(inst, tracker) {
  inst._wrapperState.valueTracker = tracker;
}

function detachTracker(inst) {
  delete inst._wrapperState.valueTracker;
}

function getValueFromNode(node) {
  var value;
  if (node) {
    value = isCheckable(node) ? '' + node.checked : node.value;
  }
  return value;
}

var inputValueTracking = {
  // exposed for testing
  _getTrackerFromNode: function _getTrackerFromNode(node) {
    return getTracker(ReactDOMComponentTree.getInstanceFromNode(node));
  },

  track: function track(inst) {
    if (getTracker(inst)) {
      return;
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var valueField = isCheckable(node) ? 'checked' : 'value';
    var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);

    var currentValue = '' + node[valueField];

    // if someone has already defined a value or Safari, then bail
    // and don't track value will cause over reporting of changes,
    // but it's better then a hard failure
    // (needed for certain tests that spyOn input values and Safari)
    if (node.hasOwnProperty(valueField) || typeof descriptor.get !== 'function' || typeof descriptor.set !== 'function') {
      return;
    }

    Object.defineProperty(node, valueField, {
      enumerable: descriptor.enumerable,
      configurable: true,
      get: function get() {
        return descriptor.get.call(this);
      },
      set: function set(value) {
        currentValue = '' + value;
        descriptor.set.call(this, value);
      }
    });

    attachTracker(inst, {
      getValue: function getValue() {
        return currentValue;
      },
      setValue: function setValue(value) {
        currentValue = '' + value;
      },
      stopTracking: function stopTracking() {
        detachTracker(inst);
        delete node[valueField];
      }
    });
  },

  updateValueIfChanged: function updateValueIfChanged(inst) {
    if (!inst) {
      return false;
    }
    var tracker = getTracker(inst);

    if (!tracker) {
      inputValueTracking.track(inst);
      return true;
    }

    var lastValue = tracker.getValue();
    var nextValue = getValueFromNode(ReactDOMComponentTree.getNodeFromInstance(inst));

    if (nextValue !== lastValue) {
      tracker.setValue(nextValue);
      return true;
    }

    return false;
  },
  stopTracking: function stopTracking(inst) {
    var tracker = getTracker(inst);
    if (tracker) {
      tracker.stopTracking();
    }
  }
};

module.exports = inputValueTracking;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  color: true,
  date: true,
  datetime: true,
  'datetime-local': true,
  email: true,
  month: true,
  number: true,
  password: true,
  range: true,
  search: true,
  tel: true,
  text: true,
  time: true,
  url: true,
  week: true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

module.exports = isTextInputElement;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ViewportMetrics = {
  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function refreshScrollValues(scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }
};

module.exports = ViewportMetrics;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(7);
var escapeTextContentForBrowser = __webpack_require__(35);
var setInnerHTML = __webpack_require__(34);

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function setTextContent(node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function setTextContent(node, text) {
      if (node.nodeType === 3) {
        node.nodeValue = text;
        return;
      }
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(16);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactInstrumentation = __webpack_require__(11);

var quoteAttributeValueForBrowser = __webpack_require__(152);
var warning = __webpack_require__(2);

var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {
  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function createMarkupForID(id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function setAttributeForID(node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  createMarkupForRoot: function createMarkupForRoot() {
    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
  },

  setAttributeForRoot: function setAttributeForRoot(node) {
    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function createMarkupForProperty(name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function setValueForProperty(node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        // Contrary to `setAttribute`, object properties are properly
        // `toString`ed by IE8/9.
        node[propertyInfo.propertyName] = value;
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  setValueForAttribute: function setValueForAttribute(node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }

    if (process.env.NODE_ENV !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  /**
   * Deletes an attributes from a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForAttribute: function deleteValueForAttribute(node, name) {
    node.removeAttribute(name);
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function deleteValueForProperty(node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          node[propName] = false;
        } else {
          node[propName] = '';
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    }

    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  }
};

module.exports = DOMPropertyOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var LinkedValueUtils = __webpack_require__(49);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactUpdates = __webpack_require__(14);

var warning = __webpack_require__(2);

var didWarnValueLink = false;
var didWarnValueDefaultValue = false;

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  if (props.valueLink !== undefined && !didWarnValueLink) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
    didWarnValueLink = true;
  }

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    } else if (!props.multiple && isArray) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  getHostProps: function getHostProps(inst, props) {
    return _assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function mountWrapper(inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
      didWarnValueDefaultValue = true;
    }
  },

  getSelectValueContext: function getSelectValueContext(inst) {
    // ReactDOMOption looks at this initial value so the initial generated
    // markup has correct `selected` attributes
    return inst._wrapperState.initialValue;
  },

  postUpdateWrapper: function postUpdateWrapper(inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  if (this._rootNodeID) {
    this._wrapperState.pendingUpdate = true;
  }
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(6);

var ReactCompositeComponent = __webpack_require__(160);
var ReactEmptyComponent = __webpack_require__(85);
var ReactHostComponent = __webpack_require__(86);

var getNextDebugID = __webpack_require__(163);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper(element) {
  this.construct(element);
};

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {boolean} shouldHaveDebugID
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node, shouldHaveDebugID) {
  var instance;

  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
    var element = node;
    var type = element.type;
    if (typeof type !== 'function' && typeof type !== 'string') {
      var info = '';
      if (process.env.NODE_ENV !== 'production') {
        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
        }
      }
      info += getDeclarationErrorAddendum(element._owner);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info) : _prodInvariant('130', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info) : void 0;
    }

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactHostComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);

      // We renamed this. Allow the old name for compat. :(
      if (!instance.getHostNode) {
        instance.getHostNode = instance.getNativeNode;
      }
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactHostComponent.createInstanceForText(node);
  } else {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : _prodInvariant('131', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : void 0;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if (process.env.NODE_ENV !== 'production') {
    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if (process.env.NODE_ENV !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
  _instantiateReactComponent: instantiateReactComponent
});

module.exports = instantiateReactComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var React = __webpack_require__(20);

var invariant = __webpack_require__(1);

var ReactNodeTypes = {
  HOST: 0,
  COMPOSITE: 1,
  EMPTY: 2,

  getType: function getType(node) {
    if (node === null || node === false) {
      return ReactNodeTypes.EMPTY;
    } else if (React.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes.COMPOSITE;
      } else {
        return ReactNodeTypes.HOST;
      }
    }
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
  }
};

module.exports = ReactNodeTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyComponentFactory;

var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function injectEmptyComponentFactory(factory) {
    emptyComponentFactory = factory;
  }
};

var ReactEmptyComponent = {
  create: function create(instantiate) {
    return emptyComponentFactory(instantiate);
  }
};

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

var genericComponentClass = null;
var textComponentClass = null;

var ReactHostComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function injectTextComponentClass(componentClass) {
    textComponentClass = componentClass;
  }
};

/**
 * Get a host internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
  return new genericComponentClass(element);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactHostComponent = {
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactHostComponentInjection
};

module.exports = ReactHostComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(3);

var ReactCurrentOwner = __webpack_require__(13);
var REACT_ELEMENT_TYPE = __webpack_require__(164);

var getIteratorFn = __webpack_require__(165);
var invariant = __webpack_require__(1);
var KeyEscapeUtils = __webpack_require__(53);
var warning = __webpack_require__(2);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(10);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMSelection = __webpack_require__(177);

var containsNode = __webpack_require__(179);
var focusNode = __webpack_require__(78);
var getActiveElement = __webpack_require__(90);

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {
  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function getSelectionInformation() {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function restoreSelection(priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function getSelection(input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function setSelection(input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */

function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var DOMLazyTree = __webpack_require__(23);
var DOMProperty = __webpack_require__(16);
var React = __webpack_require__(20);
var ReactBrowserEventEmitter = __webpack_require__(36);
var ReactCurrentOwner = __webpack_require__(13);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactDOMContainerInfo = __webpack_require__(194);
var ReactDOMFeatureFlags = __webpack_require__(195);
var ReactFeatureFlags = __webpack_require__(73);
var ReactInstanceMap = __webpack_require__(27);
var ReactInstrumentation = __webpack_require__(11);
var ReactMarkupChecksum = __webpack_require__(196);
var ReactReconciler = __webpack_require__(22);
var ReactUpdateQueue = __webpack_require__(54);
var ReactUpdates = __webpack_require__(14);

var emptyObject = __webpack_require__(30);
var instantiateReactComponent = __webpack_require__(83);
var invariant = __webpack_require__(1);
var setInnerHTML = __webpack_require__(34);
var shouldUpdateReactComponent = __webpack_require__(52);
var warning = __webpack_require__(2);

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var instancesByReactRootID = {};

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
  var markerName;
  if (ReactFeatureFlags.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props.child;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
    console.time(markerName);
  }

  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
  );

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onBeginFlush();
  }
  ReactReconciler.unmountComponent(instance, safely);
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onEndFlush();
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(container) {
  var rootEl = getReactRootElementInContainer(container);
  if (rootEl) {
    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return !!(inst && inst._hostParent);
  }
}

/**
 * True if the supplied DOM node is a React DOM element and
 * it has been rendered by another copy of React.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM has been rendered by another copy of React
 * @internal
 */
function nodeIsRenderedByOtherInstance(container) {
  var rootEl = getReactRootElementInContainer(container);
  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
}

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
}

/**
 * True if the supplied DOM node is a valid React node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid React DOM node.
 * @internal
 */
function isReactNode(node) {
  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
}

function getHostRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
}

function getTopLevelWrapperInContainer(container) {
  var root = getHostRootInstanceInContainer(container);
  return root ? root._hostContainerInfo._topLevelWrapper : null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var topLevelRootCounter = 1;
var TopLevelWrapper = function TopLevelWrapper() {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
if (process.env.NODE_ENV !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  return this.props.child;
};
TopLevelWrapper.isReactTopLevelWrapper = true;

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {
  TopLevelWrapper: TopLevelWrapper,

  /**
   * Used by devtools. The keys are not important.
   */
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function scrollMonitor(container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, nextContext, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    return prevComponent;
  },

  /**
   * Render a new component into the DOM. Hooked by hooks!
   *
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    var componentInstance = instantiateReactComponent(nextElement, false);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? " Instead of passing a string like 'div', pass " + "React.createElement('div') or <div />." : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

    var nextWrappedElement = React.createElement(TopLevelWrapper, {
      child: nextElement
    });

    var nextContext;
    if (parentComponent) {
      var parentInst = ReactInstanceMap.get(parentComponent);
      nextContext = parentInst._processChildContext(parentInst._context);
    } else {
      nextContext = emptyObject;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props.child;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function render(nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function unmountComponentAtNode(container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by another copy of React.') : void 0;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);
    if (!prevComponent) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, "unmountComponentAtNode(): The node you're attempting to unmount " + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
      }

      return false;
    }
    delete instancesByReactRootID[prevComponent._instance.rootID];
    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
    return true;
  },

  _mountImageIntoNode: function _mountImageIntoNode(markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        ReactDOMComponentTree.precacheNode(instance, rootElement);
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if (process.env.NODE_ENV !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      DOMLazyTree.insertTreeBefore(container, markup, null);
    } else {
      setInnerHTML(container, markup);
      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
    }

    if (process.env.NODE_ENV !== 'production') {
      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
      if (hostNode._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: hostNode._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  }
};

module.exports = ReactMount;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactNodeTypes = __webpack_require__(84);

function getHostComponentFromComposite(inst) {
  var type;

  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
    inst = inst._renderedComponent;
  }

  if (type === ReactNodeTypes.HOST) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes.EMPTY) {
    return null;
  }
}

module.exports = getHostComponentFromComposite;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _warning = __webpack_require__(19);

var _warning2 = _interopRequireDefault(_warning);

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _matchPath = __webpack_require__(60);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for matching a single path and rendering.
 */

var Route = function (_React$Component) {
  _inherits(Route, _React$Component);

  function Route() {
    var _temp, _this, _ret;

    _classCallCheck(this, Route);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      match: _this.computeMatch(_this.props, _this.context.router)
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Route.prototype.getChildContext = function getChildContext() {
    return {
      router: _extends({}, this.context.router, {
        route: {
          location: this.props.location || this.context.router.route.location,
          match: this.state.match
        }
      })
    };
  };

  Route.prototype.computeMatch = function computeMatch(_ref, _ref2) {
    var computedMatch = _ref.computedMatch,
        location = _ref.location,
        path = _ref.path,
        strict = _ref.strict,
        exact = _ref.exact;
    var route = _ref2.route;

    if (computedMatch) return computedMatch; // <Switch> already computed the match for us

    var pathname = (location || route.location).pathname;

    return path ? (0, _matchPath2.default)(pathname, { path: path, strict: strict, exact: exact }) : route.match;
  };

  Route.prototype.componentWillMount = function componentWillMount() {
    var _props = this.props,
        component = _props.component,
        render = _props.render,
        children = _props.children;

    (0, _warning2.default)(!(component && render), 'You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored');

    (0, _warning2.default)(!(component && children), 'You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored');

    (0, _warning2.default)(!(render && children), 'You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored');
  };

  Route.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
    (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');

    this.setState({
      match: this.computeMatch(nextProps, nextContext.router)
    });
  };

  Route.prototype.render = function render() {
    var match = this.state.match;
    var _props2 = this.props,
        children = _props2.children,
        component = _props2.component,
        render = _props2.render;
    var _context$router = this.context.router,
        history = _context$router.history,
        route = _context$router.route,
        staticContext = _context$router.staticContext;

    var location = this.props.location || route.location;
    var props = { match: match, location: location, history: history, staticContext: staticContext };

    return component ? // component prop gets first priority, only called if there's a match
    match ? _react2.default.createElement(component, props) : null : render ? // render prop is next, only called if there's a match
    match ? render(props) : null : children ? // children come last, always called
    typeof children === 'function' ? children(props) : !Array.isArray(children) || children.length ? // Preact defaults to empty children array
    _react2.default.Children.only(children) : null : null;
  };

  return Route;
}(_react2.default.Component);

Route.propTypes = {
  computedMatch: _propTypes2.default.object, // private, from <Switch>
  path: _propTypes2.default.string,
  exact: _propTypes2.default.bool,
  strict: _propTypes2.default.bool,
  component: _propTypes2.default.func,
  render: _propTypes2.default.func,
  children: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.node]),
  location: _propTypes2.default.object
};
Route.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.object.isRequired,
    route: _propTypes2.default.object.isRequired,
    staticContext: _propTypes2.default.object
  })
};
Route.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = Route;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _warning = __webpack_require__(19);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(37);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(57);

var _PathUtils = __webpack_require__(28);

var _createTransitionManager = __webpack_require__(58);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(95);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;

    var path = pathname + search + hash;

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;

      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createBrowserHistory;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = exports.supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = exports.supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = exports.supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = exports.isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = {"title":"Birds Need A Home God Dammit!","metadata":[{"name":"description","content":"Birds need a home of course"},{"name":"author","content":"John Hummel"},{"charset":"utf-8"}],"houses":[{"id":1,"title":"House title 1","desc":"House desc 1"}],"galleries":[{"id":1,"houseId":1,"title":"Gallery title 1","desc":"Gallery desc 1"}],"pics":[{"id":1,"type":"G","xid":1,"title":"Pic title for gallery 1","desc":"Pic desc for gallery 1","src":"http://via.placeholder.com/150x200/fff/000.png?text=Gallery%201"},{"id":2,"type":"H","xid":1,"title":"Pic title for house 1","desc":"Pic desc for house 1","src":"http://via.placeholder.com/150x200/fff/000.png?text=House%201"}]}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.withRouter = exports.matchPath = exports.Switch = exports.StaticRouter = exports.Router = exports.Route = exports.Redirect = exports.Prompt = exports.NavLink = exports.MemoryRouter = exports.Link = exports.HashRouter = exports.BrowserRouter = undefined;

var _BrowserRouter2 = __webpack_require__(222);

var _BrowserRouter3 = _interopRequireDefault(_BrowserRouter2);

var _HashRouter2 = __webpack_require__(223);

var _HashRouter3 = _interopRequireDefault(_HashRouter2);

var _Link2 = __webpack_require__(98);

var _Link3 = _interopRequireDefault(_Link2);

var _MemoryRouter2 = __webpack_require__(225);

var _MemoryRouter3 = _interopRequireDefault(_MemoryRouter2);

var _NavLink2 = __webpack_require__(226);

var _NavLink3 = _interopRequireDefault(_NavLink2);

var _Prompt2 = __webpack_require__(227);

var _Prompt3 = _interopRequireDefault(_Prompt2);

var _Redirect2 = __webpack_require__(228);

var _Redirect3 = _interopRequireDefault(_Redirect2);

var _Route2 = __webpack_require__(229);

var _Route3 = _interopRequireDefault(_Route2);

var _Router2 = __webpack_require__(230);

var _Router3 = _interopRequireDefault(_Router2);

var _StaticRouter2 = __webpack_require__(231);

var _StaticRouter3 = _interopRequireDefault(_StaticRouter2);

var _Switch2 = __webpack_require__(232);

var _Switch3 = _interopRequireDefault(_Switch2);

var _matchPath2 = __webpack_require__(233);

var _matchPath3 = _interopRequireDefault(_matchPath2);

var _withRouter2 = __webpack_require__(234);

var _withRouter3 = _interopRequireDefault(_withRouter2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.BrowserRouter = _BrowserRouter3.default;
exports.HashRouter = _HashRouter3.default;
exports.Link = _Link3.default;
exports.MemoryRouter = _MemoryRouter3.default;
exports.NavLink = _NavLink3.default;
exports.Prompt = _Prompt3.default;
exports.Redirect = _Redirect3.default;
exports.Route = _Route3.default;
exports.Router = _Router3.default;
exports.StaticRouter = _StaticRouter3.default;
exports.Switch = _Switch3.default;
exports.matchPath = _matchPath3.default;
exports.withRouter = _withRouter3.default;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var isModifiedEvent = function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
};

/**
 * The public API for rendering a history-aware <a>.
 */

var Link = function (_React$Component) {
  _inherits(Link, _React$Component);

  function Link() {
    var _temp, _this, _ret;

    _classCallCheck(this, Link);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.handleClick = function (event) {
      if (_this.props.onClick) _this.props.onClick(event);

      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore right clicks
      !_this.props.target && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event) // ignore clicks with modifier keys
      ) {
          event.preventDefault();

          var history = _this.context.router.history;
          var _this$props = _this.props,
              replace = _this$props.replace,
              to = _this$props.to;

          if (replace) {
            history.replace(to);
          } else {
            history.push(to);
          }
        }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  Link.prototype.render = function render() {
    var _props = this.props,
        replace = _props.replace,
        to = _props.to,
        props = _objectWithoutProperties(_props, ['replace', 'to']); // eslint-disable-line no-unused-vars

    var href = this.context.router.history.createHref(typeof to === 'string' ? { pathname: to } : to);

    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick, href: href }));
  };

  return Link;
}(_react2.default.Component);

Link.propTypes = {
  onClick: _propTypes2.default.func,
  target: _propTypes2.default.string,
  replace: _propTypes2.default.bool,
  to: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]).isRequired
};
Link.defaultProps = {
  replace: false
};
Link.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      push: _propTypes2.default.func.isRequired,
      replace: _propTypes2.default.func.isRequired,
      createHref: _propTypes2.default.func.isRequired
    }).isRequired
  }).isRequired
};

exports.default = Link;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = "data:application/vnd.ms-fontobject;base64,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"

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = "data:application/vnd.ms-fontobject;base64,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ACAASwBpAG0AYgBlAHIAbAB5ACAARwBlAHMAdwBlAGkAbgAuAEsAaQBtAGIAZQByAGwAeQAgAEcAZQBzAHcAZQBpAG4ASwBpAG0AYgBlAHIAbAB5ACAARwBlAHMAdwBlAGkAbgBDAG8AcAB5AHIAaQBnAGgAdAAgACgAYwApACAAMgAwADAANgAgAGIAeQAgAEsAaQBtAGIAZQByAGwAeQAgAEcAZQBzAHcAZQBpAG4ALgAgAEEAbABsACAAcgBpAGcAaAB0AHMAIAByAGUAcwBlAHIAdgBlAGQALgBoAHQAdABwADoALwAvAGsAaQBtAGIAZQByAGwAeQBnAGUAcwB3AGUAaQBuAC4AYwBvAG0AaAB0AHQAcAA6AC8ALwBrAGkAbQBiAGUAcgBsAHkAZwBlAHMAdwBlAGkAbgAuAGMAbwBtAEMAbwBwAHkAcgBpAGcAaAB0ACAAKABjACkAIAAyADAAMQAwACwAIABLAGkAbQBiAGUAcgBsAHkAIABHAGUAcwB3AGUAaQBuACAAKABrAGkAbQBiAGUAcgBsAHkAZwBlAHMAdwBlAGkAbgAuAGMAbwBtACkADQBUAGgAaQBzACAARgBvAG4AdAAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGwAaQBjAGUAbgBzAGUAZAAgAHUAbgBkAGUAcgAgAHQAaABlACAAUwBJAEwAIABPAHAAZQBuACAARgBvAG4AdAAgAEwAaQBjAGUAbgBzAGUALAAgAFYAZQByAHMAaQBvAG4AIAAxAC4AMQAuACAAIABUAGgAaQBzACAAbABpAGMAZQBuAHMAZQAgAGkAcwAgAGEAdgBhAGkAbABhAGIAbABlACAAdwBpAHQAaAAgAGEAIABGAEEAUQAgAGEAdAA6ACAAIABoAHQAdABwADoALwAvAHMAYwByAGkAcAB0AHMALgBzAGkAbAAuAG8AcgBnAC8ATwBGAEwAaAB0AHQAcAA6AC8ALwBzAGMAcgBpAHAAdABzAC4AcwBpAGwALgBvAHIAZwAvAE8ARgBMAEwAbwB2AGUAZAAgAGIAeQAgAHQAaABlACAASwBpAG4AZwBXAGUAYgBmAG8AbgB0ACAAMQAuADAAVAB1AGUAIABKAHUAbgAgADEANAAgADAANAA6ADQANwA6ADEAMQAgADIAMAAxADYAAgAAAAAAAP8hAJoAAAAAAAAAAAAAAAAAAAAAAAAAAADnAAABAgEDAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQEEAKMAhACFAL0AlgDoAIYAjgCLAJ0AqQCkAQUAigDaAIMAkwEGAQcAjQCIAMMA3gEIAJ4AqgD1APQA9gCiAK0AyQDHAK4AYgBjAJAAZADLAGUAyADKAM8AzADNAM4A6QBmANMA0ADRAK8AZwDwAJEA1gDUANUAaADrAO0AiQBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3AOoAeAB6AHkAewB9AHwAuAChAH8AfgCAAIEA7ADuALoAsACxALsA2ADZAQkBCgELAQwBDQEOAQ8BEAERARIBEwEUARUBFgCyALMAtgC3AMQAtAC1AMUAhwCrARcAvgC/ARgBGQCMARoBGwEcBmdseXBoMQd1bmkwMDBEB3VuaTAwQTAHdW5pMDBBRAd1bmkwMEIyB3VuaTAwQjMHdW5pMDBCOQd1bmkyMDAwB3VuaTIwMDEHdW5pMjAwMgd1bmkyMDAzB3VuaTIwMDQHdW5pMjAwNQd1bmkyMDA2B3VuaTIwMDcHdW5pMjAwOAd1bmkyMDA5B3VuaTIwMEEHdW5pMjAxMAd1bmkyMDExCmZpZ3VyZWRhc2gHdW5pMjAyRgd1bmkyMDVGBEV1cm8HdW5pMjVGQwd1bmlGQjAxB3VuaUZCMDIAuAH/hbABjQBLsAhQWLEBAY5ZsUYGK1ghsBBZS7AUUlghsIBZHbAGK1xYALADIEWwAytEsAQgRbIDFQIrsAMrRLAFIEWyBBUCK7ADK0SwBiBFsgU8AiuwAytEsAcgRbIGMQIrsAMrRLAIIEWyBysCK7ADK0SwCSBFsgghAiuwAytEsAogRbIJHgIrsAMrRLALIEWyChwCK7ADK0SwDCBFsgsbAiuwAytEsA0gRbIMGwIrsAMrRAGwDiBFsAMrRLAPIEWyDksCK7EDRnYrRLAQIEW6AA5//wACK7EDRnYrRLARIEWyEF0CK7EDRnYrRFmwFCsAAAABV1/EjwAA"

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(118);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _reactRouter = __webpack_require__(8);

var _createBrowserHistory = __webpack_require__(94);

var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);

var _constants = __webpack_require__(217);

var _constants2 = _interopRequireDefault(_constants);

var _config = __webpack_require__(218);

var _config2 = _interopRequireDefault(_config);

var _content = __webpack_require__(96);

var _content2 = _interopRequireDefault(_content);

var _Home = __webpack_require__(219);

var _Home2 = _interopRequireDefault(_Home);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var customHistory = (0, _createBrowserHistory2.default)();

__webpack_require__(238);

var app = document.getElementById('app');
_reactDom2.default.render(_react2.default.createElement(
  _reactRouter.Router,
  { history: customHistory },
  _react2.default.createElement(
    _reactRouter.Switch,
    null,
    _react2.default.createElement(_reactRouter.Route, { exact: true, path: '/', render: function render() {
        return _react2.default.createElement(_Home2.default, { config: _config2.default, constants: _constants2.default, content: _content2.default });
      } }),
    _react2.default.createElement(_reactRouter.Route, { path: '/gallery/:galleryId', render: function render() {
        return _react2.default.createElement(_Home2.default, { config: _config2.default, constants: _constants2.default, content: _content2.default, page: 'gallery' });
      } }),
    _react2.default.createElement(_reactRouter.Route, { path: '/structure', render: function render() {
        return _react2.default.createElement(_Home2.default, { config: _config2.default, constants: _constants2.default, content: _content2.default, page: 'structure' });
      } }),
    _react2.default.createElement(_reactRouter.Route, { render: function render() {
        return _react2.default.createElement(_Home2.default, { config: _config2.default, constants: _constants2.default, content: _content2.default });
      } })
  )
), app);

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var PooledClass = __webpack_require__(104);
var ReactElement = __webpack_require__(17);

var emptyFunction = __webpack_require__(10);
var traverseAllChildren = __webpack_require__(105);

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;

  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(21);

var invariant = __webpack_require__(1);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function standardReleaser(instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(21);

var ReactCurrentOwner = __webpack_require__(13);
var REACT_ELEMENT_TYPE = __webpack_require__(63);

var getIteratorFn = __webpack_require__(64);
var invariant = __webpack_require__(1);
var KeyEscapeUtils = __webpack_require__(106);
var warning = __webpack_require__(2);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && (typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = " It looks like you're using an element created by a different " + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactElement = __webpack_require__(17);

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if (process.env.NODE_ENV !== 'production') {
  var ReactElementValidator = __webpack_require__(65);
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(21);

var ReactPropTypeLocationNames = __webpack_require__(109);
var ReactPropTypesSecret = __webpack_require__(110);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(9);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(9);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _require = __webpack_require__(17),
    isValidElement = _require.isValidElement;

var factory = __webpack_require__(66);

module.exports = factory(isValidElement);

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(1);
  var warning = __webpack_require__(2);
  var ReactPropTypesSecret = __webpack_require__(40);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', location, typeSpecName);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.6.1';

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _require = __webpack_require__(61),
    Component = _require.Component;

var _require2 = __webpack_require__(17),
    isValidElement = _require2.isValidElement;

var ReactNoopUpdateQueue = __webpack_require__(62);
var factory = __webpack_require__(115);

module.exports = factory(Component, isValidElement, ReactNoopUpdateQueue);

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _assign = __webpack_require__(116);

var emptyObject = __webpack_require__(30);
var _invariant = __webpack_require__(1);

if (process.env.NODE_ENV !== 'production') {
  var warning = __webpack_require__(2);
}

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

var ReactPropTypeLocationNames;
if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
} else {
  ReactPropTypeLocationNames = {};
}

function factory(ReactComponent, isValidElement, ReactNoopUpdateQueue) {
  /**
   * Policies that describe methods in `ReactClassInterface`.
   */

  var injectedMixins = [];

  /**
   * Composite components are higher-level components that compose other composite
   * or host components.
   *
   * To create a new type of `ReactClass`, pass a specification of
   * your new class to `React.createClass`. The only requirement of your class
   * specification is that you implement a `render` method.
   *
   *   var MyComponent = React.createClass({
   *     render: function() {
   *       return <div>Hello World</div>;
   *     }
   *   });
   *
   * The class specification supports a specific protocol of methods that have
   * special meaning (e.g. `render`). See `ReactClassInterface` for
   * more the comprehensive protocol. Any other properties and methods in the
   * class specification will be available on the prototype.
   *
   * @interface ReactClassInterface
   * @internal
   */
  var ReactClassInterface = {
    /**
     * An array of Mixin objects to include when defining your component.
     *
     * @type {array}
     * @optional
     */
    mixins: 'DEFINE_MANY',

    /**
     * An object containing properties and methods that should be defined on
     * the component's constructor instead of its prototype (static methods).
     *
     * @type {object}
     * @optional
     */
    statics: 'DEFINE_MANY',

    /**
     * Definition of prop types for this component.
     *
     * @type {object}
     * @optional
     */
    propTypes: 'DEFINE_MANY',

    /**
     * Definition of context types for this component.
     *
     * @type {object}
     * @optional
     */
    contextTypes: 'DEFINE_MANY',

    /**
     * Definition of context types this component sets for its children.
     *
     * @type {object}
     * @optional
     */
    childContextTypes: 'DEFINE_MANY',

    // ==== Definition methods ====

    /**
     * Invoked when the component is mounted. Values in the mapping will be set on
     * `this.props` if that prop is not specified (i.e. using an `in` check).
     *
     * This method is invoked before `getInitialState` and therefore cannot rely
     * on `this.state` or use `this.setState`.
     *
     * @return {object}
     * @optional
     */
    getDefaultProps: 'DEFINE_MANY_MERGED',

    /**
     * Invoked once before the component is mounted. The return value will be used
     * as the initial value of `this.state`.
     *
     *   getInitialState: function() {
     *     return {
     *       isOn: false,
     *       fooBaz: new BazFoo()
     *     }
     *   }
     *
     * @return {object}
     * @optional
     */
    getInitialState: 'DEFINE_MANY_MERGED',

    /**
     * @return {object}
     * @optional
     */
    getChildContext: 'DEFINE_MANY_MERGED',

    /**
     * Uses props from `this.props` and state from `this.state` to render the
     * structure of the component.
     *
     * No guarantees are made about when or how often this method is invoked, so
     * it must not have side effects.
     *
     *   render: function() {
     *     var name = this.props.name;
     *     return <div>Hello, {name}!</div>;
     *   }
     *
     * @return {ReactComponent}
     * @required
     */
    render: 'DEFINE_ONCE',

    // ==== Delegate methods ====

    /**
     * Invoked when the component is initially created and about to be mounted.
     * This may have side effects, but any external subscriptions or data created
     * by this method must be cleaned up in `componentWillUnmount`.
     *
     * @optional
     */
    componentWillMount: 'DEFINE_MANY',

    /**
     * Invoked when the component has been mounted and has a DOM representation.
     * However, there is no guarantee that the DOM node is in the document.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been mounted (initialized and rendered) for the first time.
     *
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidMount: 'DEFINE_MANY',

    /**
     * Invoked before the component receives new props.
     *
     * Use this as an opportunity to react to a prop transition by updating the
     * state using `this.setState`. Current props are accessed via `this.props`.
     *
     *   componentWillReceiveProps: function(nextProps, nextContext) {
     *     this.setState({
     *       likesIncreasing: nextProps.likeCount > this.props.likeCount
     *     });
     *   }
     *
     * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
     * transition may cause a state change, but the opposite is not true. If you
     * need it, you are probably looking for `componentWillUpdate`.
     *
     * @param {object} nextProps
     * @optional
     */
    componentWillReceiveProps: 'DEFINE_MANY',

    /**
     * Invoked while deciding if the component should be updated as a result of
     * receiving new props, state and/or context.
     *
     * Use this as an opportunity to `return false` when you're certain that the
     * transition to the new props/state/context will not require a component
     * update.
     *
     *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
     *     return !equal(nextProps, this.props) ||
     *       !equal(nextState, this.state) ||
     *       !equal(nextContext, this.context);
     *   }
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @return {boolean} True if the component should update.
     * @optional
     */
    shouldComponentUpdate: 'DEFINE_ONCE',

    /**
     * Invoked when the component is about to update due to a transition from
     * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
     * and `nextContext`.
     *
     * Use this as an opportunity to perform preparation before an update occurs.
     *
     * NOTE: You **cannot** use `this.setState()` in this method.
     *
     * @param {object} nextProps
     * @param {?object} nextState
     * @param {?object} nextContext
     * @param {ReactReconcileTransaction} transaction
     * @optional
     */
    componentWillUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component's DOM representation has been updated.
     *
     * Use this as an opportunity to operate on the DOM when the component has
     * been updated.
     *
     * @param {object} prevProps
     * @param {?object} prevState
     * @param {?object} prevContext
     * @param {DOMElement} rootNode DOM element representing the component.
     * @optional
     */
    componentDidUpdate: 'DEFINE_MANY',

    /**
     * Invoked when the component is about to be removed from its parent and have
     * its DOM representation destroyed.
     *
     * Use this as an opportunity to deallocate any external resources.
     *
     * NOTE: There is no `componentDidUnmount` since your component will have been
     * destroyed by that point.
     *
     * @optional
     */
    componentWillUnmount: 'DEFINE_MANY',

    // ==== Advanced methods ====

    /**
     * Updates the component's currently mounted DOM representation.
     *
     * By default, this implements React's rendering and reconciliation algorithm.
     * Sophisticated clients may wish to override this.
     *
     * @param {ReactReconcileTransaction} transaction
     * @internal
     * @overridable
     */
    updateComponent: 'OVERRIDE_BASE'
  };

  /**
   * Mapping from class specification keys to special processing functions.
   *
   * Although these are declared like instance properties in the specification
   * when defining classes using `React.createClass`, they are actually static
   * and are accessible on the constructor instead of the prototype. Despite
   * being static, they must be defined outside of the "statics" key under
   * which all other static methods are defined.
   */
  var RESERVED_SPEC_KEYS = {
    displayName: function displayName(Constructor, _displayName) {
      Constructor.displayName = _displayName;
    },
    mixins: function mixins(Constructor, _mixins) {
      if (_mixins) {
        for (var i = 0; i < _mixins.length; i++) {
          mixSpecIntoComponent(Constructor, _mixins[i]);
        }
      }
    },
    childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, _childContextTypes, 'childContext');
      }
      Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
    },
    contextTypes: function contextTypes(Constructor, _contextTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, _contextTypes, 'context');
      }
      Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
    },
    /**
     * Special case getDefaultProps which should move into statics but requires
     * automatic merging.
     */
    getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
      } else {
        Constructor.getDefaultProps = _getDefaultProps;
      }
    },
    propTypes: function propTypes(Constructor, _propTypes) {
      if (process.env.NODE_ENV !== 'production') {
        validateTypeDef(Constructor, _propTypes, 'prop');
      }
      Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
    },
    statics: function statics(Constructor, _statics) {
      mixStaticSpecIntoComponent(Constructor, _statics);
    },
    autobind: function autobind() {}
  };

  function validateTypeDef(Constructor, typeDef, location) {
    for (var propName in typeDef) {
      if (typeDef.hasOwnProperty(propName)) {
        // use a warning instead of an _invariant so components
        // don't show up in prod but only in __DEV__
        if (process.env.NODE_ENV !== 'production') {
          warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName);
        }
      }
    }
  }

  function validateMethodOverride(isAlreadyDefined, name) {
    var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

    // Disallow overriding of base class methods unless explicitly allowed.
    if (ReactClassMixin.hasOwnProperty(name)) {
      _invariant(specPolicy === 'OVERRIDE_BASE', 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name);
    }

    // Disallow defining methods more than once unless explicitly allowed.
    if (isAlreadyDefined) {
      _invariant(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED', 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name);
    }
  }

  /**
   * Mixin helper which handles policy validation and reserved
   * specification keys when building React classes.
   */
  function mixSpecIntoComponent(Constructor, spec) {
    if (!spec) {
      if (process.env.NODE_ENV !== 'production') {
        var typeofSpec = typeof spec === 'undefined' ? 'undefined' : _typeof(spec);
        var isMixinValid = typeofSpec === 'object' && spec !== null;

        if (process.env.NODE_ENV !== 'production') {
          warning(isMixinValid, "%s: You're attempting to include a mixin that is either null " + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec);
        }
      }

      return;
    }

    _invariant(typeof spec !== 'function', "ReactClass: You're attempting to " + 'use a component class or function as a mixin. Instead, just use a ' + 'regular object.');
    _invariant(!isValidElement(spec), "ReactClass: You're attempting to " + 'use a component as a mixin. Instead, just use a regular object.');

    var proto = Constructor.prototype;
    var autoBindPairs = proto.__reactAutoBindPairs;

    // By handling mixins before any other properties, we ensure the same
    // chaining order is applied to methods with DEFINE_MANY policy, whether
    // mixins are listed before or after these methods in the spec.
    if (spec.hasOwnProperty(MIXINS_KEY)) {
      RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
    }

    for (var name in spec) {
      if (!spec.hasOwnProperty(name)) {
        continue;
      }

      if (name === MIXINS_KEY) {
        // We have already handled mixins in a special case above.
        continue;
      }

      var property = spec[name];
      var isAlreadyDefined = proto.hasOwnProperty(name);
      validateMethodOverride(isAlreadyDefined, name);

      if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
        RESERVED_SPEC_KEYS[name](Constructor, property);
      } else {
        // Setup methods on prototype:
        // The following member methods should not be automatically bound:
        // 1. Expected ReactClass methods (in the "interface").
        // 2. Overridden methods (that were mixed in).
        var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
        var isFunction = typeof property === 'function';
        var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

        if (shouldAutoBind) {
          autoBindPairs.push(name, property);
          proto[name] = property;
        } else {
          if (isAlreadyDefined) {
            var specPolicy = ReactClassInterface[name];

            // These cases should already be caught by validateMethodOverride.
            _invariant(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY'), 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name);

            // For methods which are defined more than once, call the existing
            // methods before calling the new property, merging if appropriate.
            if (specPolicy === 'DEFINE_MANY_MERGED') {
              proto[name] = createMergedResultFunction(proto[name], property);
            } else if (specPolicy === 'DEFINE_MANY') {
              proto[name] = createChainedFunction(proto[name], property);
            }
          } else {
            proto[name] = property;
            if (process.env.NODE_ENV !== 'production') {
              // Add verbose displayName to the function, which helps when looking
              // at profiling tools.
              if (typeof property === 'function' && spec.displayName) {
                proto[name].displayName = spec.displayName + '_' + name;
              }
            }
          }
        }
      }
    }
  }

  function mixStaticSpecIntoComponent(Constructor, statics) {
    if (!statics) {
      return;
    }
    for (var name in statics) {
      var property = statics[name];
      if (!statics.hasOwnProperty(name)) {
        continue;
      }

      var isReserved = name in RESERVED_SPEC_KEYS;
      _invariant(!isReserved, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name);

      var isInherited = name in Constructor;
      _invariant(!isInherited, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name);
      Constructor[name] = property;
    }
  }

  /**
   * Merge two objects, but throw if both contain the same key.
   *
   * @param {object} one The first object, which is mutated.
   * @param {object} two The second object
   * @return {object} one after it has been mutated to contain everything in two.
   */
  function mergeIntoWithNoDuplicateKeys(one, two) {
    _invariant(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object', 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.');

    for (var key in two) {
      if (two.hasOwnProperty(key)) {
        _invariant(one[key] === undefined, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key);
        one[key] = two[key];
      }
    }
    return one;
  }

  /**
   * Creates a function that invokes two functions and merges their return values.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createMergedResultFunction(one, two) {
    return function mergedResult() {
      var a = one.apply(this, arguments);
      var b = two.apply(this, arguments);
      if (a == null) {
        return b;
      } else if (b == null) {
        return a;
      }
      var c = {};
      mergeIntoWithNoDuplicateKeys(c, a);
      mergeIntoWithNoDuplicateKeys(c, b);
      return c;
    };
  }

  /**
   * Creates a function that invokes two functions and ignores their return vales.
   *
   * @param {function} one Function to invoke first.
   * @param {function} two Function to invoke second.
   * @return {function} Function that invokes the two argument functions.
   * @private
   */
  function createChainedFunction(one, two) {
    return function chainedFunction() {
      one.apply(this, arguments);
      two.apply(this, arguments);
    };
  }

  /**
   * Binds a method to the component.
   *
   * @param {object} component Component whose method is going to be bound.
   * @param {function} method Method to be bound.
   * @return {function} The bound method.
   */
  function bindAutoBindMethod(component, method) {
    var boundMethod = method.bind(component);
    if (process.env.NODE_ENV !== 'production') {
      boundMethod.__reactBoundContext = component;
      boundMethod.__reactBoundMethod = method;
      boundMethod.__reactBoundArguments = null;
      var componentName = component.constructor.displayName;
      var _bind = boundMethod.bind;
      boundMethod.bind = function (newThis) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        // User is trying to bind() an autobound method; we effectively will
        // ignore the value of "this" that the user is trying to use, so
        // let's warn.
        if (newThis !== component && newThis !== null) {
          if (process.env.NODE_ENV !== 'production') {
            warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName);
          }
        } else if (!args.length) {
          if (process.env.NODE_ENV !== 'production') {
            warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName);
          }
          return boundMethod;
        }
        var reboundMethod = _bind.apply(boundMethod, arguments);
        reboundMethod.__reactBoundContext = component;
        reboundMethod.__reactBoundMethod = method;
        reboundMethod.__reactBoundArguments = args;
        return reboundMethod;
      };
    }
    return boundMethod;
  }

  /**
   * Binds all auto-bound methods in a component.
   *
   * @param {object} component Component whose method is going to be bound.
   */
  function bindAutoBindMethods(component) {
    var pairs = component.__reactAutoBindPairs;
    for (var i = 0; i < pairs.length; i += 2) {
      var autoBindKey = pairs[i];
      var method = pairs[i + 1];
      component[autoBindKey] = bindAutoBindMethod(component, method);
    }
  }

  var IsMountedPreMixin = {
    componentDidMount: function componentDidMount() {
      this.__isMounted = true;
    }
  };

  var IsMountedPostMixin = {
    componentWillUnmount: function componentWillUnmount() {
      this.__isMounted = false;
    }
  };

  /**
   * Add more to the ReactClass base class. These are all legacy features and
   * therefore not already part of the modern ReactComponent.
   */
  var ReactClassMixin = {
    /**
     * TODO: This will be deprecated because state should always keep a consistent
     * type signature and the only use case for this, is to avoid that.
     */
    replaceState: function replaceState(newState, callback) {
      this.updater.enqueueReplaceState(this, newState, callback);
    },

    /**
     * Checks whether or not this composite component is mounted.
     * @return {boolean} True if mounted, false otherwise.
     * @protected
     * @final
     */
    isMounted: function isMounted() {
      if (process.env.NODE_ENV !== 'production') {
        warning(this.__didWarnIsMounted, '%s: isMounted is deprecated. Instead, make sure to clean up ' + 'subscriptions and pending requests in componentWillUnmount to ' + 'prevent memory leaks.', this.constructor && this.constructor.displayName || this.name || 'Component');
        this.__didWarnIsMounted = true;
      }
      return !!this.__isMounted;
    }
  };

  var ReactClassComponent = function ReactClassComponent() {};
  _assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  function createClass(spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory');
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      _invariant((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState), '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent');

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, IsMountedPreMixin);
    mixSpecIntoComponent(Constructor, spec);
    mixSpecIntoComponent(Constructor, IsMountedPostMixin);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    _invariant(Constructor.prototype.render, 'createClass(...): Class specification must implement a `render` method.');

    if (process.env.NODE_ENV !== 'production') {
      warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component');
      warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component');
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  }

  return createClass;
}

module.exports = factory;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */


var _prodInvariant = __webpack_require__(21);

var ReactElement = __webpack_require__(17);

var invariant = __webpack_require__(1);

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(119);

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/



var ReactDOMComponentTree = __webpack_require__(4);
var ReactDefaultInjection = __webpack_require__(120);
var ReactMount = __webpack_require__(91);
var ReactReconciler = __webpack_require__(22);
var ReactUpdates = __webpack_require__(14);
var ReactVersion = __webpack_require__(198);

var findDOMNode = __webpack_require__(199);
var getHostComponentFromComposite = __webpack_require__(92);
var renderSubtreeIntoContainer = __webpack_require__(200);
var warning = __webpack_require__(2);

ReactDefaultInjection.inject();

var ReactDOM = {
  findDOMNode: findDOMNode,
  render: ReactMount.render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
  /* eslint-enable camelcase */
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    ComponentTree: {
      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
      getNodeFromInstance: function getNodeFromInstance(inst) {
        // inst is an internal instance (but could be a composite)
        if (inst._renderedComponent) {
          inst = getHostComponentFromComposite(inst);
        }
        if (inst) {
          return ReactDOMComponentTree.getNodeFromInstance(inst);
        } else {
          return null;
        }
      }
    },
    Mount: ReactMount,
    Reconciler: ReactReconciler
  });
}

if (process.env.NODE_ENV !== 'production') {
  var ExecutionEnvironment = __webpack_require__(7);
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        // Firefox does not have the issue with devtools loaded over file://
        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    var testFunc = function testFn() {};
    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, "It looks like you're using a minified copy of the development build " + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
        break;
      }
    }
  }
}

if (process.env.NODE_ENV !== 'production') {
  var ReactInstrumentation = __webpack_require__(11);
  var ReactDOMUnknownPropertyHook = __webpack_require__(201);
  var ReactDOMNullInputValuePropHook = __webpack_require__(202);
  var ReactDOMInvalidARIAHook = __webpack_require__(203);

  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
}

module.exports = ReactDOM;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ARIADOMPropertyConfig = __webpack_require__(121);
var BeforeInputEventPlugin = __webpack_require__(122);
var ChangeEventPlugin = __webpack_require__(126);
var DefaultEventPluginOrder = __webpack_require__(134);
var EnterLeaveEventPlugin = __webpack_require__(135);
var HTMLDOMPropertyConfig = __webpack_require__(136);
var ReactComponentBrowserEnvironment = __webpack_require__(137);
var ReactDOMComponent = __webpack_require__(143);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactDOMEmptyComponent = __webpack_require__(169);
var ReactDOMTreeTraversal = __webpack_require__(170);
var ReactDOMTextComponent = __webpack_require__(171);
var ReactDefaultBatchingStrategy = __webpack_require__(172);
var ReactEventListener = __webpack_require__(173);
var ReactInjection = __webpack_require__(175);
var ReactReconcileTransaction = __webpack_require__(176);
var SVGDOMPropertyConfig = __webpack_require__(182);
var SelectEventPlugin = __webpack_require__(183);
var SimpleEventPlugin = __webpack_require__(184);

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}

module.exports = {
  inject: inject
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ARIADOMPropertyConfig = {
  Properties: {
    // Global States and Properties
    'aria-current': 0, // state
    'aria-details': 0,
    'aria-disabled': 0, // state
    'aria-hidden': 0, // state
    'aria-invalid': 0, // state
    'aria-keyshortcuts': 0,
    'aria-label': 0,
    'aria-roledescription': 0,
    // Widget Attributes
    'aria-autocomplete': 0,
    'aria-checked': 0,
    'aria-expanded': 0,
    'aria-haspopup': 0,
    'aria-level': 0,
    'aria-modal': 0,
    'aria-multiline': 0,
    'aria-multiselectable': 0,
    'aria-orientation': 0,
    'aria-placeholder': 0,
    'aria-pressed': 0,
    'aria-readonly': 0,
    'aria-required': 0,
    'aria-selected': 0,
    'aria-sort': 0,
    'aria-valuemax': 0,
    'aria-valuemin': 0,
    'aria-valuenow': 0,
    'aria-valuetext': 0,
    // Live Region Attributes
    'aria-atomic': 0,
    'aria-busy': 0,
    'aria-live': 0,
    'aria-relevant': 0,
    // Drag-and-Drop Attributes
    'aria-dropeffect': 0,
    'aria-grabbed': 0,
    // Relationship Attributes
    'aria-activedescendant': 0,
    'aria-colcount': 0,
    'aria-colindex': 0,
    'aria-colspan': 0,
    'aria-controls': 0,
    'aria-describedby': 0,
    'aria-errormessage': 0,
    'aria-flowto': 0,
    'aria-labelledby': 0,
    'aria-owns': 0,
    'aria-posinset': 0,
    'aria-rowcount': 0,
    'aria-rowindex': 0,
    'aria-rowspan': 0,
    'aria-setsize': 0
  },
  DOMAttributeNames: {},
  DOMPropertyNames: {}
};

module.exports = ARIADOMPropertyConfig;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var EventPropagators = __webpack_require__(24);
var ExecutionEnvironment = __webpack_require__(7);
var FallbackCompositionState = __webpack_require__(123);
var SyntheticCompositionEvent = __webpack_require__(124);
var SyntheticInputEvent = __webpack_require__(125);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (currentComposition) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var PooledClass = __webpack_require__(18);

var getTextContentAccessor = __webpack_require__(71);

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

_assign(FallbackCompositionState.prototype, {
  destructor: function destructor() {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function getText() {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function getData() {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(15);

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(15);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(25);
var EventPropagators = __webpack_require__(24);
var ExecutionEnvironment = __webpack_require__(7);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactUpdates = __webpack_require__(14);
var SyntheticEvent = __webpack_require__(15);

var inputValueTracking = __webpack_require__(74);
var getEventTarget = __webpack_require__(43);
var isEventSupported = __webpack_require__(44);
var isTextInputElement = __webpack_require__(75);

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

function createAndAccumulateChangeEvent(inst, nativeEvent, target) {
  var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, target);
  event.type = 'change';
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}
/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = createAndAccumulateChangeEvent(activeElementInst, nativeEvent, getEventTarget(nativeEvent));

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementInst = null;
}

function getInstIfValueChanged(targetInst, nativeEvent) {
  var updated = inputValueTracking.updateValueIfChanged(targetInst);
  var simulated = nativeEvent.simulated === true && ChangeEventPlugin._allowSimulatedPassThrough;

  if (updated || simulated) {
    return targetInst;
  }
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}

function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.

  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
}

/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onpropertychange', handlePropertyChange);
}

/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onpropertychange', handlePropertyChange);

  activeElement = null;
  activeElementInst = null;
}

/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  if (getInstIfValueChanged(activeElementInst, nativeEvent)) {
    manualDispatchChangeEvent(nativeEvent);
  }
}

function handleEventsForInputEventPolyfill(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType, targetInst, nativeEvent) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    return getInstIfValueChanged(activeElementInst, nativeEvent);
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  var nodeName = elem.nodeName;
  return nodeName && nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst, nativeEvent) {
  if (topLevelType === 'topClick') {
    return getInstIfValueChanged(targetInst, nativeEvent);
  }
}

function getTargetInstForInputOrChangeEvent(topLevelType, targetInst, nativeEvent) {
  if (topLevelType === 'topInput' || topLevelType === 'topChange') {
    return getInstIfValueChanged(targetInst, nativeEvent);
  }
}

function handleControlledInputBlur(inst, node) {
  // TODO: In IE, inst is occasionally null. Why?
  if (inst == null) {
    return;
  }

  // Fiber and ReactDOM keep wrapper state in separate places
  var state = inst._wrapperState || node._wrapperState;

  if (!state || !state.controlled || node.type !== 'number') {
    return;
  }

  // If controlled, assign the value attribute to the current value on blur
  var value = '' + node.value;
  if (node.getAttribute('value') !== value) {
    node.setAttribute('value', value);
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {
  eventTypes: eventTypes,

  _allowSimulatedPassThrough: true,
  _isInputEventSupported: isInputEventSupported,

  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      if (doesChangeEventBubble) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputOrChangeEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventPolyfill;
        handleEventFunc = handleEventsForInputEventPolyfill;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst, nativeEvent);
      if (inst) {
        var event = createAndAccumulateChangeEvent(inst, nativeEvent, nativeEventTarget);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }

    // When blurring, set the value attribute for number inputs
    if (topLevelType === 'topBlur') {
      handleControlledInputBlur(targetInst, targetNode);
    }
  }
};

module.exports = ChangeEventPlugin;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var ReactOwner = __webpack_require__(128);

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null && (typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement)) === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null && (typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement)) === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don't update refs
  typeof nextRef === 'string' && nextOwner !== prevOwner;
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid owner.
 * @final
 */
function isValidOwner(object) {
  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
}

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {
  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }
};

module.exports = ReactOwner;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var ReactInvalidSetStateWarningHook = __webpack_require__(130);
var ReactHostOperationHistoryHook = __webpack_require__(131);
var ReactComponentTreeHook = __webpack_require__(9);
var ExecutionEnvironment = __webpack_require__(7);

var performanceNow = __webpack_require__(132);
var warning = __webpack_require__(2);

var hooks = [];
var didHookThrowForEvent = {};

function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
  try {
    fn.call(context, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
    didHookThrowForEvent[event] = true;
  }
}

function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    var fn = hook[event];
    if (fn) {
      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
    }
  }
}

var _isProfiling = false;
var flushHistory = [];
var lifeCycleTimerStack = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = [];
var currentFlushStartTime = 0;
var currentTimerDebugID = null;
var currentTimerStartTime = 0;
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;

var lifeCycleTimerHasWarned = false;

function clearHistory() {
  ReactComponentTreeHook.purgeUnmountedComponents();
  ReactHostOperationHistoryHook.clearHistory();
}

function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeHook.getOwnerID(id);
    var parentID = ReactComponentTreeHook.getParentID(id);
    tree[id] = {
      displayName: ReactComponentTreeHook.getDisplayName(id),
      text: ReactComponentTreeHook.getText(id),
      updateCount: ReactComponentTreeHook.getUpdateCount(id),
      childIDs: ReactComponentTreeHook.getChildIDs(id),
      // Text nodes don't have owners but this is close enough.
      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
      parentID: parentID
    };
    return tree;
  }, {});
}

function resetMeasurements() {
  var previousStartTime = currentFlushStartTime;
  var previousMeasurements = currentFlushMeasurements;
  var previousOperations = ReactHostOperationHistoryHook.getHistory();

  if (currentFlushNesting === 0) {
    currentFlushStartTime = 0;
    currentFlushMeasurements = [];
    clearHistory();
    return;
  }

  if (previousMeasurements.length || previousOperations.length) {
    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
    flushHistory.push({
      duration: performanceNow() - previousStartTime,
      measurements: previousMeasurements || [],
      operations: previousOperations || [],
      treeSnapshot: getTreeSnapshot(registeredIDs)
    });
  }

  clearHistory();
  currentFlushStartTime = performanceNow();
  currentFlushMeasurements = [];
}

function checkDebugID(debugID) {
  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (allowRoot && debugID === 0) {
    return;
  }
  if (!debugID) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
  }
}

function beginLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType && !lifeCycleTimerHasWarned) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  currentTimerStartTime = performanceNow();
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

function endLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  if (_isProfiling) {
    currentFlushMeasurements.push({
      timerType: timerType,
      instanceID: debugID,
      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
    });
  }
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function pauseCurrentLifeCycleTimer() {
  var currentTimer = {
    startTime: currentTimerStartTime,
    nestedFlushStartTime: performanceNow(),
    debugID: currentTimerDebugID,
    timerType: currentTimerType
  };
  lifeCycleTimerStack.push(currentTimer);
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function resumeCurrentLifeCycleTimer() {
  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
      startTime = _lifeCycleTimerStack$.startTime,
      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
      debugID = _lifeCycleTimerStack$.debugID,
      timerType = _lifeCycleTimerStack$.timerType;

  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
  currentTimerStartTime = startTime;
  currentTimerNestedFlushDuration += nestedFlushDuration;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

var lastMarkTimeStamp = 0;
var canUsePerformanceMeasure = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

function shouldMark(debugID) {
  if (!_isProfiling || !canUsePerformanceMeasure) {
    return false;
  }
  var element = ReactComponentTreeHook.getElement(debugID);
  if (element == null || (typeof element === 'undefined' ? 'undefined' : _typeof(element)) !== 'object') {
    return false;
  }
  var isHostElement = typeof element.type === 'string';
  if (isHostElement) {
    return false;
  }
  return true;
}

function markBegin(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  lastMarkTimeStamp = performanceNow();
  performance.mark(markName);
}

function markEnd(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

  // Chrome has an issue of dropping markers recorded too fast:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
  // To work around this, we will not report very small measurements.
  // I determined the magic number by tweaking it back and forth.
  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
  // When the bug is fixed, we can `measure()` unconditionally if we want to.
  var timeStamp = performanceNow();
  if (timeStamp - lastMarkTimeStamp > 0.1) {
    var measurementName = displayName + ' [' + markType + ']';
    performance.measure(measurementName, markName);
  }

  performance.clearMarks(markName);
  if (measurementName) {
    performance.clearMeasures(measurementName);
  }
}

var ReactDebugTool = {
  addHook: function addHook(hook) {
    hooks.push(hook);
  },
  removeHook: function removeHook(hook) {
    for (var i = 0; i < hooks.length; i++) {
      if (hooks[i] === hook) {
        hooks.splice(i, 1);
        i--;
      }
    }
  },
  isProfiling: function isProfiling() {
    return _isProfiling;
  },
  beginProfiling: function beginProfiling() {
    if (_isProfiling) {
      return;
    }

    _isProfiling = true;
    flushHistory.length = 0;
    resetMeasurements();
    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
  },
  endProfiling: function endProfiling() {
    if (!_isProfiling) {
      return;
    }

    _isProfiling = false;
    resetMeasurements();
    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
  },
  getFlushHistory: function getFlushHistory() {
    return flushHistory;
  },
  onBeginFlush: function onBeginFlush() {
    currentFlushNesting++;
    resetMeasurements();
    pauseCurrentLifeCycleTimer();
    emitEvent('onBeginFlush');
  },
  onEndFlush: function onEndFlush() {
    resetMeasurements();
    currentFlushNesting--;
    resumeCurrentLifeCycleTimer();
    emitEvent('onEndFlush');
  },
  onBeginLifeCycleTimer: function onBeginLifeCycleTimer(debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    markBegin(debugID, timerType);
    beginLifeCycleTimer(debugID, timerType);
  },
  onEndLifeCycleTimer: function onEndLifeCycleTimer(debugID, timerType) {
    checkDebugID(debugID);
    endLifeCycleTimer(debugID, timerType);
    markEnd(debugID, timerType);
    emitEvent('onEndLifeCycleTimer', debugID, timerType);
  },
  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
    emitEvent('onBeginProcessingChildContext');
  },
  onEndProcessingChildContext: function onEndProcessingChildContext() {
    emitEvent('onEndProcessingChildContext');
  },
  onHostOperation: function onHostOperation(operation) {
    checkDebugID(operation.instanceID);
    emitEvent('onHostOperation', operation);
  },
  onSetState: function onSetState() {
    emitEvent('onSetState');
  },
  onSetChildren: function onSetChildren(debugID, childDebugIDs) {
    checkDebugID(debugID);
    childDebugIDs.forEach(checkDebugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);
  },
  onBeforeMountComponent: function onBeforeMountComponent(debugID, element, parentDebugID) {
    checkDebugID(debugID);
    checkDebugID(parentDebugID, true);
    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
    markBegin(debugID, 'mount');
  },
  onMountComponent: function onMountComponent(debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'mount');
    emitEvent('onMountComponent', debugID);
  },
  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
    checkDebugID(debugID);
    emitEvent('onBeforeUpdateComponent', debugID, element);
    markBegin(debugID, 'update');
  },
  onUpdateComponent: function onUpdateComponent(debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'update');
    emitEvent('onUpdateComponent', debugID);
  },
  onBeforeUnmountComponent: function onBeforeUnmountComponent(debugID) {
    checkDebugID(debugID);
    emitEvent('onBeforeUnmountComponent', debugID);
    markBegin(debugID, 'unmount');
  },
  onUnmountComponent: function onUnmountComponent(debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'unmount');
    emitEvent('onUnmountComponent', debugID);
  },
  onTestEvent: function onTestEvent() {
    emitEvent('onTestEvent');
  }
};

// TODO remove these when RN/www gets updated
ReactDebugTool.addDevtool = ReactDebugTool.addHook;
ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool.addHook(ReactComponentTreeHook);
var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
if (/[?&]react_perf\b/.test(url)) {
  ReactDebugTool.beginProfiling();
}

module.exports = ReactDebugTool;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var warning = __webpack_require__(2);

if (process.env.NODE_ENV !== 'production') {
  var processingChildContext = false;

  var warnInvalidSetState = function warnInvalidSetState() {
    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
  };
}

var ReactInvalidSetStateWarningHook = {
  onBeginProcessingChildContext: function onBeginProcessingChildContext() {
    processingChildContext = true;
  },
  onEndProcessingChildContext: function onEndProcessingChildContext() {
    processingChildContext = false;
  },
  onSetState: function onSetState() {
    warnInvalidSetState();
  }
};

module.exports = ReactInvalidSetStateWarningHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var history = [];

var ReactHostOperationHistoryHook = {
  onHostOperation: function onHostOperation(operation) {
    history.push(operation);
  },
  clearHistory: function clearHistory() {
    if (ReactHostOperationHistoryHook._preventClearing) {
      // Should only be used for tests.
      return;
    }

    history = [];
  },
  getHistory: function getHistory() {
    return history;
  }
};

module.exports = ReactHostOperationHistoryHook;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var performance = __webpack_require__(133);

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function performanceNow() {
    return performance.now();
  };
} else {
  performanceNow = function performanceNow() {
    return Date.now();
  };
}

module.exports = performanceNow;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var ExecutionEnvironment = __webpack_require__(7);

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */

var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

module.exports = DefaultEventPluginOrder;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(24);
var ReactDOMComponentTree = __webpack_require__(4);
var SyntheticMouseEvent = __webpack_require__(33);

var eventTypes = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {
  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }
};

module.exports = EnterLeaveEventPlugin;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(16);

var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
  Properties: {
    /**
     * Standard Properties
     */
    accept: 0,
    acceptCharset: 0,
    accessKey: 0,
    action: 0,
    allowFullScreen: HAS_BOOLEAN_VALUE,
    allowTransparency: 0,
    alt: 0,
    // specifies target context for links with `preload` type
    as: 0,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: 0,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_BOOLEAN_VALUE,
    cellPadding: 0,
    cellSpacing: 0,
    charSet: 0,
    challenge: 0,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cite: 0,
    classID: 0,
    className: 0,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: 0,
    content: 0,
    contentEditable: 0,
    contextMenu: 0,
    controls: HAS_BOOLEAN_VALUE,
    coords: 0,
    crossOrigin: 0,
    data: 0, // For `<object />` acts as `src`.
    dateTime: 0,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: 0,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: 0,
    encType: 0,
    form: 0,
    formAction: 0,
    formEncType: 0,
    formMethod: 0,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: 0,
    frameBorder: 0,
    headers: 0,
    height: 0,
    hidden: HAS_BOOLEAN_VALUE,
    high: 0,
    href: 0,
    hrefLang: 0,
    htmlFor: 0,
    httpEquiv: 0,
    icon: 0,
    id: 0,
    inputMode: 0,
    integrity: 0,
    is: 0,
    keyParams: 0,
    keyType: 0,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: HAS_BOOLEAN_VALUE,
    low: 0,
    manifest: 0,
    marginHeight: 0,
    marginWidth: 0,
    max: 0,
    maxLength: 0,
    media: 0,
    mediaGroup: 0,
    method: 0,
    min: 0,
    minLength: 0,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: 0,
    nonce: 0,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    playsInline: HAS_BOOLEAN_VALUE,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 0,
    readOnly: HAS_BOOLEAN_VALUE,
    referrerPolicy: 0,
    rel: 0,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: 0,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    sandbox: 0,
    scope: 0,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: 0,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: 0,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    sizes: 0,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: 0,
    src: 0,
    srcDoc: 0,
    srcLang: 0,
    srcSet: 0,
    start: HAS_NUMERIC_VALUE,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 0,
    target: 0,
    title: 0,
    // Setting .type throws on non-<input> tags
    type: 0,
    useMap: 0,
    value: 0,
    width: 0,
    wmode: 0,
    wrap: 0,

    /**
     * RDFa Properties
     */
    about: 0,
    datatype: 0,
    inlist: 0,
    prefix: 0,
    // property is also supported for OpenGraph in meta tags.
    property: 0,
    resource: 0,
    'typeof': 0,
    vocab: 0,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: 0,
    autoCorrect: 0,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: 0,
    // color is for Safari mask-icon link
    color: 0,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: 0,
    itemScope: HAS_BOOLEAN_VALUE,
    itemType: 0,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: 0,
    itemRef: 0,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: 0,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: 0,
    // IE-only attribute that controls focus behavior
    unselectable: 0
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {},
  DOMMutationMethods: {
    value: function value(node, _value) {
      if (_value == null) {
        return node.removeAttribute('value');
      }

      // Number inputs get special treatment due to some edge cases in
      // Chrome. Let everything else assign the value attribute as normal.
      // https://github.com/facebook/react/issues/7253#issuecomment-236074326
      if (node.type !== 'number' || node.hasAttribute('value') === false) {
        node.setAttribute('value', '' + _value);
      } else if (node.validity && !node.validity.badInput && node.ownerDocument.activeElement !== node) {
        // Don't assign an attribute if validation reports bad
        // input. Chrome will clear the value. Additionally, don't
        // operate on inputs that have focus, otherwise Chrome might
        // strip off trailing decimal places and cause the user's
        // cursor position to jump to the beginning of the input.
        //
        // In ReactDOMInput, we have an onBlur event that will trigger
        // this function again when focus is lost.
        node.setAttribute('value', '' + _value);
      }
    }
  }
};

module.exports = HTMLDOMPropertyConfig;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMChildrenOperations = __webpack_require__(46);
var ReactDOMIDOperations = __webpack_require__(142);

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {
  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup
};

module.exports = ReactComponentBrowserEnvironment;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var DOMLazyTree = __webpack_require__(23);
var ExecutionEnvironment = __webpack_require__(7);

var createNodesFromMarkup = __webpack_require__(139);
var emptyFunction = __webpack_require__(10);
var invariant = __webpack_require__(1);

var Danger = {
  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.replaceChildWithTree(oldChild, markup);
    }
  }
};

module.exports = Danger;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

var ExecutionEnvironment = __webpack_require__(7);

var createArrayFromMixed = __webpack_require__(140);
var getMarkupWrap = __webpack_require__(141);
var invariant = __webpack_require__(1);

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = Array.from(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var invariant = __webpack_require__(1);

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/*eslint-disable fb-www/unsafe-html */

var ExecutionEnvironment = __webpack_require__(7);

var invariant = __webpack_require__(1);

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMChildrenOperations = __webpack_require__(46);
var ReactDOMComponentTree = __webpack_require__(4);

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {
  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.processUpdates(node, updates);
  }
};

module.exports = ReactDOMIDOperations;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* global hasOwnProperty:true */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(6);

var AutoFocusUtils = __webpack_require__(144);
var CSSPropertyOperations = __webpack_require__(145);
var DOMLazyTree = __webpack_require__(23);
var DOMNamespaces = __webpack_require__(47);
var DOMProperty = __webpack_require__(16);
var DOMPropertyOperations = __webpack_require__(80);
var EventPluginHub = __webpack_require__(25);
var EventPluginRegistry = __webpack_require__(31);
var ReactBrowserEventEmitter = __webpack_require__(36);
var ReactDOMComponentFlags = __webpack_require__(68);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactDOMInput = __webpack_require__(155);
var ReactDOMOption = __webpack_require__(156);
var ReactDOMSelect = __webpack_require__(82);
var ReactDOMTextarea = __webpack_require__(157);
var ReactInstrumentation = __webpack_require__(11);
var ReactMultiChild = __webpack_require__(158);
var ReactServerRenderingTransaction = __webpack_require__(167);

var emptyFunction = __webpack_require__(10);
var escapeTextContentForBrowser = __webpack_require__(35);
var invariant = __webpack_require__(1);
var isEventSupported = __webpack_require__(44);
var shallowEqual = __webpack_require__(51);
var inputValueTracking = __webpack_require__(74);
var validateDOMNesting = __webpack_require__(55);
var warning = __webpack_require__(2);

var Flags = ReactDOMComponentFlags;
var deleteListener = EventPluginHub.deleteListener;
var getNode = ReactDOMComponentTree.getNodeFromInstance;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = EventPluginRegistry.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { string: true, number: true };

var STYLE = 'style';
var HTML = '__html';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null
};

// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
var DOC_FRAGMENT_TYPE = 11;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

function friendlyStringify(obj) {
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined because undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[component._tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
  }
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
  }
  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
}

function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), "This browser doesn't support the `onScroll` event") : void 0;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.postMountWrapper(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}

function optionPostMount() {
  var inst = this;
  ReactDOMOption.postMountWrapper(inst);
}

var setAndValidateContentChildDev = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
  setAndValidateContentChildDev = function setAndValidateContentChildDev(content) {
    var hasExistingContent = this._contentDebugID != null;
    var debugID = this._debugID;
    // This ID represents the inlined child that has no backing instance:
    var contentDebugID = -debugID;

    if (content == null) {
      if (hasExistingContent) {
        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
      }
      this._contentDebugID = null;
      return;
    }

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trackInputValue() {
  inputValueTracking.track(this);
}

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
  var node = getNode(inst);
  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

  switch (inst._tag) {
    case 'iframe':
    case 'object':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'video':
    case 'audio':
      inst._wrapperState.listeners = [];
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
        }
      }
      break;
    case 'source':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
      break;
    case 'input':
    case 'select':
    case 'textarea':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
      break;
  }
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  area: true,
  base: true,
  br: true,
  col: true,
  embed: true,
  hr: true,
  img: true,
  input: true,
  keygen: true,
  link: true,
  meta: true,
  param: true,
  source: true,
  track: true,
  wbr: true
  // NOTE: menuitem's close tag should be omitted, but that causes problems.
};

var newlineEatingTags = {
  listing: true,
  pre: true,
  textarea: true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  menuitem: true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
    validatedTagCache[tag] = true;
  }
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

var globalIdCounter = 1;

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if (process.env.NODE_ENV !== 'production') {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {
  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?ReactDOMComponent} the parent component instance
   * @param {?object} info about the host container
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
    this._rootNodeID = globalIdCounter++;
    this._domID = hostContainerInfo._idCounter++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, hostParent);
        props = ReactDOMInput.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trackInputValue, this);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, hostParent);
        props = ReactDOMOption.getHostProps(this, props);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, hostParent);
        props = ReactDOMSelect.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, hostParent);
        props = ReactDOMTextarea.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trackInputValue, this);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
    }

    assertValidProps(this, props);

    // We create tags in the namespace of their parent container, except HTML
    // tags get no namespace.
    var namespaceURI;
    var parentTag;
    if (hostParent != null) {
      namespaceURI = hostParent._namespaceURI;
      parentTag = hostParent._tag;
    } else if (hostContainerInfo._tag) {
      namespaceURI = hostContainerInfo._namespaceURI;
      parentTag = hostContainerInfo._tag;
    }
    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
      namespaceURI = DOMNamespaces.html;
    }
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === 'svg') {
        namespaceURI = DOMNamespaces.svg;
      } else if (this._tag === 'math') {
        namespaceURI = DOMNamespaces.mathml;
      }
    }
    this._namespaceURI = namespaceURI;

    if (process.env.NODE_ENV !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo._tag) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(this._tag, null, this, parentInfo);
      }
      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var el;
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'script') {
          // Create the script via .innerHTML so its "parser-inserted" flag is
          // set to true and it does not execute
          var div = ownerDocument.createElement('div');
          var type = this._currentElement.type;
          div.innerHTML = '<' + type + '></' + type + '>';
          el = div.removeChild(div.firstChild);
        } else if (props.is) {
          el = ownerDocument.createElement(this._currentElement.type, props.is);
        } else {
          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
          // See discussion in https://github.com/facebook/react/pull/6896
          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
          el = ownerDocument.createElement(this._currentElement.type);
        }
      } else {
        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
      }
      ReactDOMComponentTree.precacheNode(this, el);
      this._flags |= Flags.hasCachedChildNodes;
      if (!this._hostParent) {
        DOMPropertyOperations.setAttributeForRoot(el);
      }
      this._updateDOMProperties(null, props, transaction);
      var lazyTree = DOMLazyTree(el);
      this._createInitialChildren(transaction, props, context, lazyTree);
      mountImage = lazyTree;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(inputPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'textarea':
        transaction.getReactMountReady().enqueue(textareaPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'select':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'button':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'option':
        transaction.getReactMountReady().enqueue(optionPostMount, this);
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if (process.env.NODE_ENV !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = _assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    if (!this._hostParent) {
      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
    }
    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
    return ret;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
        if (process.env.NODE_ENV !== 'production') {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function _createInitialChildren(transaction, props, context, lazyTree) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      // TODO: Validate that text is allowed as a child of this node
      if (contentToUse != null) {
        // Avoid setting textContent when the text is empty. In IE11 setting
        // textContent on a text area will cause the placeholder to not
        // show within the textarea until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        if (contentToUse !== '') {
          if (process.env.NODE_ENV !== 'production') {
            setAndValidateContentChildDev.call(this, contentToUse);
          }
          DOMLazyTree.queueText(lazyTree, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function receiveComponent(nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'input':
        lastProps = ReactDOMInput.getHostProps(this, lastProps);
        nextProps = ReactDOMInput.getHostProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getHostProps(this, lastProps);
        nextProps = ReactDOMOption.getHostProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
        break;
      case 'textarea':
        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
        break;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    switch (this._tag) {
      case 'input':
        // Update the wrapper around inputs *after* updating props. This has to
        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
        // raise warnings and prevent the new value from being assigned.
        ReactDOMInput.updateWrapper(this);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        break;
      case 'select':
        // <select> value update needs to occur after <option> children
        // reconciliation
        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        break;
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, lastProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if (process.env.NODE_ENV !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = _assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
        if (process.env.NODE_ENV !== 'production') {
          setAndValidateContentChildDev.call(this, nextContent);
        }
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    } else if (nextChildren != null) {
      if (process.env.NODE_ENV !== 'production') {
        setAndValidateContentChildDev.call(this, null);
      }

      this.updateChildren(nextChildren, transaction, context);
    }
  },

  getHostNode: function getHostNode() {
    return getNode(this);
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function unmountComponent(safely) {
    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'input':
      case 'textarea':
        inputValueTracking.stopTracking(this);
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
        break;
    }

    this.unmountChildren(safely);
    ReactDOMComponentTree.uncacheNode(this);
    EventPluginHub.deleteAllListeners(this);
    this._rootNodeID = 0;
    this._domID = 0;
    this._wrapperState = null;

    if (process.env.NODE_ENV !== 'production') {
      setAndValidateContentChildDev.call(this, null);
    }
  },

  getPublicInstance: function getPublicInstance() {
    return getNode(this);
  }
};

_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMComponentTree = __webpack_require__(4);

var focusNode = __webpack_require__(78);

var AutoFocusUtils = {
  focusDOMComponent: function focusDOMComponent() {
    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
  }
};

module.exports = AutoFocusUtils;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var CSSProperty = __webpack_require__(79);
var ExecutionEnvironment = __webpack_require__(7);
var ReactInstrumentation = __webpack_require__(11);

var camelizeStyleName = __webpack_require__(146);
var dangerousStyleValue = __webpack_require__(148);
var hyphenateStyleName = __webpack_require__(149);
var memoizeStringOnly = __webpack_require__(151);
var warning = __webpack_require__(2);

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if (process.env.NODE_ENV !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;

  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
  };

  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
  };

  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value, owner) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, "Style property values shouldn't contain a semicolon.%s " + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
  };

  var warnStyleValueIsNaN = function warnStyleValueIsNaN(name, value, owner) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
  };

  var checkRenderMessage = function checkRenderMessage(owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  };

  /**
   * @param {string} name
   * @param {*} value
   * @param {ReactDOMComponent} component
   */
  var warnValidStyle = function warnValidStyle(name, value, component) {
    var owner;
    if (component) {
      owner = component._currentElement._owner;
    }
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, owner);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, owner);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, owner);
    }

    if (typeof value === 'number' && isNaN(value)) {
      warnStyleValueIsNaN(name, value, owner);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {
  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @param {ReactDOMComponent} component
   * @return {?string}
   */
  createMarkupForStyles: function createMarkupForStyles(styles, component) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var isCustomProperty = styleName.indexOf('--') === 0;
      var styleValue = styles[styleName];
      if (process.env.NODE_ENV !== 'production') {
        if (!isCustomProperty) {
          warnValidStyle(styleName, styleValue, component);
        }
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, component, isCustomProperty) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function setValueForStyles(node, styles, component) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: component._debugID,
        type: 'update styles',
        payload: styles
      });
    }

    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var isCustomProperty = styleName.indexOf('--') === 0;
      if (process.env.NODE_ENV !== 'production') {
        if (!isCustomProperty) {
          warnValidStyle(styleName, styles[styleName], component);
        }
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], component, isCustomProperty);
      if (styleName === 'float' || styleName === 'cssFloat') {
        styleName = styleFloatAccessor;
      }
      if (isCustomProperty) {
        style.setProperty(styleName, styleValue);
      } else if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }
};

module.exports = CSSPropertyOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var camelize = __webpack_require__(147);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var CSSProperty = __webpack_require__(79);
var warning = __webpack_require__(2);

var isUnitlessNumber = CSSProperty.isUnitlessNumber;
var styleWarnings = {};

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @param {ReactDOMComponent} component
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, component, isCustomProperty) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isCustomProperty || isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    if (process.env.NODE_ENV !== 'production') {
      // Allow '0' to pass through without warning. 0 is already special and
      // doesn't require units, so we don't need to warn about it.
      if (component && value !== '0') {
        var owner = component._currentElement._owner;
        var ownerName = owner ? owner.getName() : null;
        if (ownerName && !styleWarnings[ownerName]) {
          styleWarnings[ownerName] = {};
        }
        var warned = false;
        if (ownerName) {
          var warnings = styleWarnings[ownerName];
          warned = warnings[name];
          if (!warned) {
            warnings[name] = true;
          }
        }
        if (!warned) {
          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
        }
      }
    }
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(150);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @typechecks static-only
 */



/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var escapeTextContentForBrowser = __webpack_require__(35);

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(25);

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {
  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(7);

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

module.exports = getVendorPrefixedEventName;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(6);

var DOMPropertyOperations = __webpack_require__(80);
var LinkedValueUtils = __webpack_require__(49);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactUpdates = __webpack_require__(14);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var didWarnValueLink = false;
var didWarnCheckedLink = false;
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function getHostProps(inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var hostProps = _assign({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined,
      // Make sure we set .step before .value (setting .value before .step
      // means .value is rounded on mount, based upon step precision)
      step: undefined,
      // Make sure we set .min & .max before .value (to ensure proper order
      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
      min: undefined,
      max: undefined
    }, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function mountWrapper(inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

      var owner = inst._currentElement._owner;

      if (props.valueLink !== undefined && !didWarnValueLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnCheckedLink = true;
      }
      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnCheckedDefaultChecked = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnValueDefaultValue = true;
      }
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
      initialValue: props.value != null ? props.value : defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      controlled: isControlled(props)
    };
  },

  updateWrapper: function updateWrapper(inst) {
    var props = inst._currentElement.props;

    if (process.env.NODE_ENV !== 'production') {
      var controlled = isControlled(props);
      var owner = inst._currentElement._owner;

      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnUncontrolledToControlled = true;
      }
      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnControlledToUncontrolled = true;
      }
    }

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      if (value === 0 && node.value === '') {
        node.value = '0';
        // Note: IE9 reports a number inputs as 'text', so check props instead.
      } else if (props.type === 'number') {
        // Simulate `input.valueAsNumber`. IE9 does not support it
        var valueAsNumber = parseFloat(node.value, 10) || 0;

        if (
        // eslint-disable-next-line
        value != valueAsNumber ||
        // eslint-disable-next-line
        value == valueAsNumber && node.value != value) {
          // Cast `value` to a string to ensure the value is set correctly. While
          // browsers typically do this as necessary, jsdom doesn't.
          node.value = '' + value;
        }
      } else if (node.value !== '' + value) {
        // Cast `value` to a string to ensure the value is set correctly. While
        // browsers typically do this as necessary, jsdom doesn't.
        node.value = '' + value;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        // In Chrome, assigning defaultValue to certain input types triggers input validation.
        // For number inputs, the display value loses trailing decimal points. For email inputs,
        // Chrome raises "The specified value <x> is not a valid email address".
        //
        // Here we check to see if the defaultValue has actually changed, avoiding these problems
        // when the user is inputting text
        //
        // https://github.com/facebook/react/issues/7253
        if (node.defaultValue !== '' + props.defaultValue) {
          node.defaultValue = '' + props.defaultValue;
        }
      }
      if (props.checked == null && props.defaultChecked != null) {
        node.defaultChecked = !!props.defaultChecked;
      }
    }
  },

  postMountWrapper: function postMountWrapper(inst) {
    var props = inst._currentElement.props;

    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

    // Detach value from defaultValue. We won't do anything if we're working on
    // submit or reset inputs as those values & defaultValues are linked. They
    // are not resetable nodes so this operation doesn't matter and actually
    // removes browser-default values (eg "Submit Query") when no value is
    // provided.

    switch (props.type) {
      case 'submit':
      case 'reset':
        break;
      case 'color':
      case 'date':
      case 'datetime':
      case 'datetime-local':
      case 'month':
      case 'time':
      case 'week':
        // This fixes the no-show issue on iOS Safari and Android Chrome:
        // https://github.com/facebook/react/issues/7233
        node.value = '';
        node.value = node.defaultValue;
        break;
      default:
        node.value = node.value;
        break;
    }

    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
    // this is needed to work around a chrome bug where setting defaultChecked
    // will sometimes influence the value of checked (even after detachment).
    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
    // We need to temporarily unset name to avoid disrupting radio button groups.
    var name = node.name;
    if (name !== '') {
      node.name = '';
    }
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !node.defaultChecked;
    if (name !== '') {
      node.name = name;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var React = __webpack_require__(20);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactDOMSelect = __webpack_require__(82);

var warning = __webpack_require__(2);
var didWarnInvalidOptionChildren = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    } else if (!didWarnInvalidOptionChildren) {
      didWarnInvalidOptionChildren = true;
      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function mountWrapper(inst, props, hostParent) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
    }

    // Look up whether this option is 'selected'
    var selectValue = null;
    if (hostParent != null) {
      var selectParent = hostParent;

      if (selectParent._tag === 'optgroup') {
        selectParent = selectParent._hostParent;
      }

      if (selectParent != null && selectParent._tag === 'select') {
        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
      }
    }

    // If the value is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      var value;
      if (props.value != null) {
        value = props.value + '';
      } else {
        value = flattenChildren(props.children);
      }
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  postMountWrapper: function postMountWrapper(inst) {
    // value="" should make a value attribute (#6219)
    var props = inst._currentElement.props;
    if (props.value != null) {
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      node.setAttribute('value', props.value);
    }
  },

  getHostProps: function getHostProps(inst, props) {
    var hostProps = _assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      hostProps.selected = inst._wrapperState.selected;
    }

    var content = flattenChildren(props.children);

    if (content) {
      hostProps.children = content;
    }

    return hostProps;
  }
};

module.exports = ReactDOMOption;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(6);

var LinkedValueUtils = __webpack_require__(49);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactUpdates = __webpack_require__(14);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var didWarnValueLink = false;
var didWarnValDefaultVal = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getHostProps: function getHostProps(inst, props) {
    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.  We could add a check in setTextContent
    // to only set the value if/when the value differs from the node value (which would
    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
    // The value can be a boolean or object so that's why it's forced to be a string.
    var hostProps = _assign({}, props, {
      value: undefined,
      defaultValue: undefined,
      children: '' + inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function mountWrapper(inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
        didWarnValDefaultVal = true;
      }
    }

    var value = LinkedValueUtils.getValue(props);
    var initialValue = value;

    // Only bother fetching default value if we're going to use it
    if (value == null) {
      var defaultValue = props.defaultValue;
      // TODO (yungsters): Remove support for children content in <textarea>.
      var children = props.children;
      if (children != null) {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
        }
        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
        if (Array.isArray(children)) {
          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
          children = children[0];
        }

        defaultValue = '' + children;
      }
      if (defaultValue == null) {
        defaultValue = '';
      }
      initialValue = defaultValue;
    }

    inst._wrapperState = {
      initialValue: '' + initialValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function updateWrapper(inst) {
    var props = inst._currentElement.props;

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue != null) {
      node.defaultValue = props.defaultValue;
    }
  },

  postMountWrapper: function postMountWrapper(inst) {
    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var textContent = node.textContent;

    // Only set node.value if textContent is equal to the expected
    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
    // will populate textContent as well.
    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
    if (textContent === inst._wrapperState.initialValue) {
      node.value = textContent;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactComponentEnvironment = __webpack_require__(50);
var ReactInstanceMap = __webpack_require__(27);
var ReactInstrumentation = __webpack_require__(11);

var ReactCurrentOwner = __webpack_require__(13);
var ReactReconciler = __webpack_require__(22);
var ReactChildReconciler = __webpack_require__(159);

var emptyFunction = __webpack_require__(10);
var flattenChildren = __webpack_require__(166);
var invariant = __webpack_require__(1);

/**
 * Make an update for markup to be rendered and inserted at a supplied index.
 *
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function makeInsertMarkup(markup, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'INSERT_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for moving an existing element to another index.
 *
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function makeMove(child, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'MOVE_EXISTING',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler.getHostNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for removing an element at an index.
 *
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function makeRemove(child, node) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'REMOVE_NODE',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the markup of a node.
 *
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function makeSetMarkup(markup) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'SET_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the text content.
 *
 * @param {string} textContent Text content to set.
 * @private
 */
function makeTextContent(textContent) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'TEXT_CONTENT',
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Push an update, if any, onto the queue. Creates a new queue if none is
 * passed and always returns the queue. Mutative.
 */
function enqueue(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
  var getDebugID = function getDebugID(inst) {
    if (!inst._debugID) {
      // Check for ART-like instances. TODO: This is silly/gross.
      var internal;
      if (internal = ReactInstanceMap.get(inst)) {
        inst = internal;
      }
    }
    return inst._debugID;
  };
  setChildrenForInstrumentation = function setChildrenForInstrumentation(children) {
    var debugID = getDebugID(this);
    // TODO: React Native empty components are also multichild.
    // This means they still get into this method but don't have _debugID.
    if (debugID !== 0) {
      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
        return children[key]._debugID;
      }) : []);
    }
  };
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {
  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {
    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
      if (process.env.NODE_ENV !== 'production') {
        var selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
      var nextChildren;
      var selfDebugID = 0;
      if (process.env.NODE_ENV !== 'production') {
        selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function mountChildren(nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;

      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var selfDebugID = 0;
          if (process.env.NODE_ENV !== 'production') {
            selfDebugID = getDebugID(this);
          }
          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }

      if (process.env.NODE_ENV !== 'production') {
        setChildrenForInstrumentation.call(this, children);
      }

      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function updateTextContent(nextContent) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      // Set new text content.
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function updateMarkup(nextMarkup) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
      // Hook used by React ART
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },

    /**
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var mountImages = [];
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var nextIndex = 0;
      var lastIndex = 0;
      // `nextMountIndex` will increment for each newly mounted child.
      var nextMountIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
          nextMountIndex++;
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;

      if (process.env.NODE_ENV !== 'production') {
        setChildrenForInstrumentation.call(this, nextChildren);
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted. It does not actually perform any
     * backend operations.
     *
     * @internal
     */
    unmountChildren: function unmountChildren(safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function moveChild(child, afterNode, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function createChild(child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function removeChild(child, node) {
      return makeRemove(child, node);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildAtIndex: function _mountChildAtIndex(child, mountImage, afterNode, index, transaction, context) {
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function _unmountChild(child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }
  }
};

module.exports = ReactMultiChild;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactReconciler = __webpack_require__(22);

var instantiateReactComponent = __webpack_require__(83);
var KeyEscapeUtils = __webpack_require__(53);
var shouldUpdateReactComponent = __webpack_require__(52);
var traverseAllChildren = __webpack_require__(87);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(9);
}

function instantiateChild(childInstances, child, name, selfDebugID) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    if (!ReactComponentTreeHook) {
      ReactComponentTreeHook = __webpack_require__(9);
    }
    if (!keyUnique) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
    }
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context, selfDebugID) // 0 in production and for roots
  {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};

    if (process.env.NODE_ENV !== 'production') {
      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
        return instantiateChild(childInsts, child, name, selfDebugID);
      }, childInstances);
    } else {
      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    }
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) // 0 in production and for roots
  {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, true);
        nextChildren[name] = nextChildInstance;
        // Creating mount image now ensures refs are resolved in right order
        // (see https://github.com/facebook/react/pull/7101 for explanation).
        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
        mountImages.push(nextChildMountImage);
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
    }
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function unmountChildren(renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild, safely);
      }
    }
  }
};

module.exports = ReactChildReconciler;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(6);

var React = __webpack_require__(20);
var ReactComponentEnvironment = __webpack_require__(50);
var ReactCurrentOwner = __webpack_require__(13);
var ReactErrorUtils = __webpack_require__(42);
var ReactInstanceMap = __webpack_require__(27);
var ReactInstrumentation = __webpack_require__(11);
var ReactNodeTypes = __webpack_require__(84);
var ReactReconciler = __webpack_require__(22);

if (process.env.NODE_ENV !== 'production') {
  var checkReactTypeSpec = __webpack_require__(161);
}

var emptyObject = __webpack_require__(30);
var invariant = __webpack_require__(1);
var shallowEqual = __webpack_require__(51);
var shouldUpdateReactComponent = __webpack_require__(52);
var warning = __webpack_require__(2);

var CompositeTypes = {
  ImpureClass: 0,
  PureClass: 1,
  StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};

function warnIfInvalidElement(Component, element) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
  }
}

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

function isPureComponent(Component) {
  return !!(Component.prototype && Component.prototype.isPureReactComponent);
}

// Separated into a function to contain deoptimizations caused by try/finally.
function measureLifeCyclePerf(fn, debugID, timerType) {
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponent = {
  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function construct(element) {
    this._currentElement = element;
    this._rootNodeID = 0;
    this._compositeType = null;
    this._instance = null;
    this._hostParent = null;
    this._hostContainerInfo = null;

    // See ReactUpdateQueue
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;

    // ComponentWillUnmount shall only be called once
    this._calledComponentWillUnmount = false;

    if (process.env.NODE_ENV !== 'production') {
      this._warnedAboutRefsInRender = false;
    }
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} hostParent
   * @param {?object} hostContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
    var _this = this;

    this._context = context;
    this._mountOrder = nextMountID++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var publicProps = this._currentElement.props;
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    var updateQueue = transaction.getUpdateQueue();

    // Initialize the public class
    var doConstruct = shouldConstruct(Component);
    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
    var renderedElement;

    // Support functional components
    if (!doConstruct && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
      inst = new StatelessComponent(Component);
      this._compositeType = CompositeTypes.StatelessFunctional;
    } else {
      if (isPureComponent(Component)) {
        this._compositeType = CompositeTypes.PureClass;
      } else {
        this._compositeType = CompositeTypes.ImpureClass;
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
      }

      var propsMutated = inst.props !== publicProps;
      var componentName = Component.displayName || Component.name || 'Component';

      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + "up the same props that your component's constructor was passed.", componentName, componentName) : void 0;
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = updateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if (process.env.NODE_ENV !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      if (process.env.NODE_ENV !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(function () {
            return inst.componentDidMount();
          }, _this._debugID, 'componentDidMount');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }

    return markup;
  },

  _constructComponent: function _constructComponent(doConstruct, publicProps, publicContext, updateQueue) {
    if (process.env.NODE_ENV !== 'production') {
      ReactCurrentOwner.current = this;
      try {
        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    }
  },

  _constructComponentWithoutOwner: function _constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue) {
    var Component = this._currentElement.type;

    if (doConstruct) {
      if (process.env.NODE_ENV !== 'production') {
        return measureLifeCyclePerf(function () {
          return new Component(publicProps, publicContext, updateQueue);
        }, this._debugID, 'ctor');
      } else {
        return new Component(publicProps, publicContext, updateQueue);
      }
    }

    // This can still be an instance in case of factory components
    // but we'll count this as time spent rendering as the more common case.
    if (process.env.NODE_ENV !== 'production') {
      return measureLifeCyclePerf(function () {
        return Component(publicProps, publicContext, updateQueue);
      }, this._debugID, 'render');
    } else {
      return Component(publicProps, publicContext, updateQueue);
    }
  },

  performInitialMountWithErrorHandling: function performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();

      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);

      // Try again - we've informed the component about the error, so they can render an error message this time.
      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    return markup;
  },

  performInitialMount: function performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var inst = this._instance;

    var debugID = 0;
    if (process.env.NODE_ENV !== 'production') {
      debugID = this._debugID;
    }

    if (inst.componentWillMount) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillMount();
        }, debugID, 'componentWillMount');
      } else {
        inst.componentWillMount();
      }
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    var nodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
    );
    this._renderedComponent = child;

    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

    if (process.env.NODE_ENV !== 'production') {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    return markup;
  },

  getHostNode: function getHostNode() {
    return ReactReconciler.getHostNode(this._renderedComponent);
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function unmountComponent(safely) {
    if (!this._renderedComponent) {
      return;
    }

    var inst = this._instance;

    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;

      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        if (process.env.NODE_ENV !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillUnmount();
          }, this._debugID, 'componentWillUnmount');
        } else {
          inst.componentWillUnmount();
        }
      }
    }

    if (this._renderedComponent) {
      ReactReconciler.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = 0;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function _maskContext(context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function _processContext(context) {
    var maskedContext = this._maskContext(context);
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function _processChildContext(currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext;

    if (inst.getChildContext) {
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
        try {
          childContext = inst.getChildContext();
        } finally {
          ReactInstrumentation.debugTool.onEndProcessingChildContext();
        }
      } else {
        childContext = inst.getChildContext();
      }
    }

    if (childContext) {
      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
      if (process.env.NODE_ENV !== 'production') {
        this._checkContextTypes(Component.childContextTypes, childContext, 'child context');
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
      }
      return _assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Assert that the context types are valid
   *
   * @param {object} typeSpecs Map of context field to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkContextTypes: function _checkContextTypes(typeSpecs, values, location) {
    if (process.env.NODE_ENV !== 'production') {
      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
    }
  },

  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

    var willReceive = false;
    var nextContext;

    // Determine if the context has changed or not
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }

    var prevProps = prevParentElement.props;
    var nextProps = nextParentElement.props;

    // Not a simple state update but a props update
    if (prevParentElement !== nextParentElement) {
      willReceive = true;
    }

    // An update here will schedule an update but immediately set
    // _pendingStateQueue which will ensure that any state updates gets
    // immediately reconciled instead of waiting for the next batch.
    if (willReceive && inst.componentWillReceiveProps) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillReceiveProps(nextProps, nextContext);
        }, this._debugID, 'componentWillReceiveProps');
      } else {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;

    if (!this._pendingForceUpdate) {
      if (inst.shouldComponentUpdate) {
        if (process.env.NODE_ENV !== 'production') {
          shouldUpdate = measureLifeCyclePerf(function () {
            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          }, this._debugID, 'shouldComponentUpdate');
        } else {
          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }
      } else {
        if (this._compositeType === CompositeTypes.PureClass) {
          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
        }
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
    }

    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function _processPendingState(props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var _this2 = this;

    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillUpdate(nextProps, nextState, nextContext);
        }, this._debugID, 'componentWillUpdate');
      } else {
        inst.componentWillUpdate(nextProps, nextState, nextContext);
      }
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
      }
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();

    var debugID = 0;
    if (process.env.NODE_ENV !== 'production') {
      debugID = this._debugID;
    }

    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
      ReactReconciler.unmountComponent(prevComponentInstance, false);

      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
      );
      this._renderedComponent = child;

      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

      if (process.env.NODE_ENV !== 'production') {
        if (debugID !== 0) {
          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
        }
      }

      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
    }
  },

  /**
   * Overridden in shallow rendering.
   *
   * @protected
   */
  _replaceNodeWithMarkup: function _replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
    var inst = this._instance;
    var renderedElement;

    if (process.env.NODE_ENV !== 'production') {
      renderedElement = measureLifeCyclePerf(function () {
        return inst.render();
      }, this._debugID, 'render');
    } else {
      renderedElement = inst.render();
    }

    if (process.env.NODE_ENV !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (renderedElement === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedElement = null;
      }
    }

    return renderedElement;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function _renderValidatedComponent() {
    var renderedElement;
    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
      ReactCurrentOwner.current = this;
      try {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

    return renderedElement;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function attachRef(ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
    var publicComponentInstance = component.getPublicInstance();
    if (process.env.NODE_ENV !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function detachRef(ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function getName() {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function getPublicInstance() {
    var inst = this._instance;
    if (this._compositeType === CompositeTypes.StatelessFunctional) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null
};

module.exports = ReactCompositeComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _prodInvariant = __webpack_require__(3);

var ReactPropTypeLocationNames = __webpack_require__(162);
var ReactPropTypesSecret = __webpack_require__(81);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(9);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(9);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var nextDebugID = 1;

function getNextDebugID() {
  return nextDebugID++;
}

module.exports = getNextDebugID;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var KeyEscapeUtils = __webpack_require__(53);
var traverseAllChildren = __webpack_require__(87);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(9);
}

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 * @param {number=} selfDebugID Optional debugID of the current internal instance.
 */
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  // We found a component instance.
  if (traverseContext && (typeof traverseContext === 'undefined' ? 'undefined' : _typeof(traverseContext)) === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if (process.env.NODE_ENV !== 'production') {
      if (!ReactComponentTreeHook) {
        ReactComponentTreeHook = __webpack_require__(9);
      }
      if (!keyUnique) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
      }
    }
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};

  if (process.env.NODE_ENV !== 'production') {
    traverseAllChildren(children, function (traverseContext, child, name) {
      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
    }, result);
  } else {
    traverseAllChildren(children, flattenSingleChildIntoContext, result);
  }
  return result;
}

module.exports = flattenChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var PooledClass = __webpack_require__(18);
var Transaction = __webpack_require__(32);
var ReactInstrumentation = __webpack_require__(11);
var ReactServerUpdateQueue = __webpack_require__(168);

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [];

if (process.env.NODE_ENV !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

var noopCallbackQueue = {
  enqueue: function enqueue() {}
};

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function getTransactionWrappers() {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function getReactMountReady() {
    return noopCallbackQueue;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function getUpdateQueue() {
    return this.updateQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function destructor() {},

  checkpoint: function checkpoint() {},

  rollback: function rollback() {}
};

_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var ReactUpdateQueue = __webpack_require__(54);

var warning = __webpack_require__(2);

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the update queue used for server rendering.
 * It delegates to ReactUpdateQueue while server rendering is in progress and
 * switches to ReactNoopUpdateQueue after the transaction has completed.
 * @class ReactServerUpdateQueue
 * @param {Transaction} transaction
 */

var ReactServerUpdateQueue = function () {
  function ReactServerUpdateQueue(transaction) {
    _classCallCheck(this, ReactServerUpdateQueue);

    this.transaction = transaction;
  }

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */

  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
    return false;
  };

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */

  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
    }
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */

  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
    } else {
      warnNoop(publicInstance, 'forceUpdate');
    }
  };

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} completeState Next state.
   * @internal
   */

  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
    } else {
      warnNoop(publicInstance, 'replaceState');
    }
  };

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */

  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();

module.exports = ReactServerUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var DOMLazyTree = __webpack_require__(23);
var ReactDOMComponentTree = __webpack_require__(4);

var ReactDOMEmptyComponent = function ReactDOMEmptyComponent(instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
};
_assign(ReactDOMEmptyComponent.prototype, {
  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
    var domID = hostContainerInfo._idCounter++;
    this._domID = domID;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var nodeValue = ' react-empty: ' + this._domID + ' ';
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var node = ownerDocument.createComment(nodeValue);
      ReactDOMComponentTree.precacheNode(this, node);
      return DOMLazyTree(node);
    } else {
      if (transaction.renderToStaticMarkup) {
        // Normally we'd insert a comment node, but since this is a situation
        // where React won't take over (static pages), we can simply return
        // nothing.
        return '';
      }
      return '<!--' + nodeValue + '-->';
    }
  },
  receiveComponent: function receiveComponent() {},
  getHostNode: function getHostNode() {
    return ReactDOMComponentTree.getNodeFromInstance(this);
  },
  unmountComponent: function unmountComponent() {
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMEmptyComponent;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

  return inst._hostParent;
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from && from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to && to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (i = pathTo.length; i-- > 0;) {
    fn(pathTo[i], 'captured', argTo);
  }
}

module.exports = {
  isAncestor: isAncestor,
  getLowestCommonAncestor: getLowestCommonAncestor,
  getParentInstance: getParentInstance,
  traverseTwoPhase: traverseTwoPhase,
  traverseEnterLeave: traverseEnterLeave
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(6);

var DOMChildrenOperations = __webpack_require__(46);
var DOMLazyTree = __webpack_require__(23);
var ReactDOMComponentTree = __webpack_require__(4);

var escapeTextContentForBrowser = __webpack_require__(35);
var invariant = __webpack_require__(1);
var validateDOMNesting = __webpack_require__(55);

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings between comment nodes so that they
 * can undergo the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function ReactDOMTextComponent(text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

_assign(ReactDOMTextComponent.prototype, {
  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
    if (process.env.NODE_ENV !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo != null) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(null, this._stringText, this, parentInfo);
      }
    }

    var domID = hostContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._hostParent = hostParent;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
      if (this._stringText) {
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
      }
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
      ReactDOMComponentTree.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this between comment nodes for the reasons stated
        // above, but since this is a situation where React won't take over
        // (static pages), we can simply return the text as it is.
        return escapedText;
      }

      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function receiveComponent(nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var commentNodes = this.getHostNode();
        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
      }
    }
  },

  getHostNode: function getHostNode() {
    var hostNode = this._commentNodes;
    if (hostNode) {
      return hostNode;
    }
    if (!this._closingComment) {
      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
      var node = openingComment.nextSibling;
      while (true) {
        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
          this._closingComment = node;
          break;
        }
        node = node.nextSibling;
      }
    }
    hostNode = [this._hostNode, this._closingComment];
    this._commentNodes = hostNode;
    return hostNode;
  },

  unmountComponent: function unmountComponent() {
    this._closingComment = null;
    this._commentNodes = null;
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMTextComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var ReactUpdates = __webpack_require__(14);
var Transaction = __webpack_require__(32);

var emptyFunction = __webpack_require__(10);

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function close() {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function getTransactionWrappers() {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var EventListener = __webpack_require__(88);
var ExecutionEnvironment = __webpack_require__(7);
var PooledClass = __webpack_require__(18);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactUpdates = __webpack_require__(14);

var getEventTarget = __webpack_require__(43);
var getUnboundedScrollPosition = __webpack_require__(174);

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findParent(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst._hostParent) {
    inst = inst._hostParent;
  }
  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
  var container = rootNode.parentNode;
  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
_assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function destructor() {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function setEnabled(enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function isEnabled() {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function monitorScrollValue(refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable.Window && scrollable instanceof scrollable.Window) {
    return {
      x: scrollable.pageXOffset || scrollable.document.documentElement.scrollLeft,
      y: scrollable.pageYOffset || scrollable.document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(16);
var EventPluginHub = __webpack_require__(25);
var EventPluginUtils = __webpack_require__(41);
var ReactComponentEnvironment = __webpack_require__(50);
var ReactEmptyComponent = __webpack_require__(85);
var ReactBrowserEventEmitter = __webpack_require__(36);
var ReactHostComponent = __webpack_require__(86);
var ReactUpdates = __webpack_require__(14);

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventPluginUtils: EventPluginUtils.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  HostComponent: ReactHostComponent.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(6);

var CallbackQueue = __webpack_require__(72);
var PooledClass = __webpack_require__(18);
var ReactBrowserEventEmitter = __webpack_require__(36);
var ReactInputSelection = __webpack_require__(89);
var ReactInstrumentation = __webpack_require__(11);
var Transaction = __webpack_require__(32);
var ReactUpdateQueue = __webpack_require__(54);

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function initialize() {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function close(previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function initialize() {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function close() {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

if (process.env.NODE_ENV !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function getTransactionWrappers() {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function getReactMountReady() {
    return this.reactMountReady;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function getUpdateQueue() {
    return ReactUpdateQueue;
  },

  /**
   * Save current transaction state -- if the return value from this method is
   * passed to `rollback`, the transaction will be reset to that state.
   */
  checkpoint: function checkpoint() {
    // reactMountReady is the our only stateful wrapper
    return this.reactMountReady.checkpoint();
  },

  rollback: function rollback(checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function destructor() {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(7);

var getNodeForCharacterOffset = __webpack_require__(178);
var getTextContentAccessor = __webpack_require__(71);

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (offsets.end === undefined) {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var isTextNode = __webpack_require__(180);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var isNode = __webpack_require__(181);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

// We use attributes for everything SVG so let's avoid some duplication and run
// code instead.
// The following are all specified in the HTML config already so we exclude here.
// - class (as className)
// - color
// - height
// - id
// - lang
// - max
// - media
// - method
// - min
// - name
// - style
// - target
// - type
// - width
var ATTRS = {
  accentHeight: 'accent-height',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 'alignment-baseline',
  allowReorder: 'allowReorder',
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 'arabic-form',
  ascent: 0,
  attributeName: 'attributeName',
  attributeType: 'attributeType',
  autoReverse: 'autoReverse',
  azimuth: 0,
  baseFrequency: 'baseFrequency',
  baseProfile: 'baseProfile',
  baselineShift: 'baseline-shift',
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 'calcMode',
  capHeight: 'cap-height',
  clip: 0,
  clipPath: 'clip-path',
  clipRule: 'clip-rule',
  clipPathUnits: 'clipPathUnits',
  colorInterpolation: 'color-interpolation',
  colorInterpolationFilters: 'color-interpolation-filters',
  colorProfile: 'color-profile',
  colorRendering: 'color-rendering',
  contentScriptType: 'contentScriptType',
  contentStyleType: 'contentStyleType',
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 'diffuseConstant',
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 'dominant-baseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 'edgeMode',
  elevation: 0,
  enableBackground: 'enable-background',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 'externalResourcesRequired',
  fill: 0,
  fillOpacity: 'fill-opacity',
  fillRule: 'fill-rule',
  filter: 0,
  filterRes: 'filterRes',
  filterUnits: 'filterUnits',
  floodColor: 'flood-color',
  floodOpacity: 'flood-opacity',
  focusable: 0,
  fontFamily: 'font-family',
  fontSize: 'font-size',
  fontSizeAdjust: 'font-size-adjust',
  fontStretch: 'font-stretch',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 'glyph-name',
  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
  glyphOrientationVertical: 'glyph-orientation-vertical',
  glyphRef: 'glyphRef',
  gradientTransform: 'gradientTransform',
  gradientUnits: 'gradientUnits',
  hanging: 0,
  horizAdvX: 'horiz-adv-x',
  horizOriginX: 'horiz-origin-x',
  ideographic: 0,
  imageRendering: 'image-rendering',
  'in': 0,
  in2: 0,
  intercept: 0,
  k: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  kernelMatrix: 'kernelMatrix',
  kernelUnitLength: 'kernelUnitLength',
  kerning: 0,
  keyPoints: 'keyPoints',
  keySplines: 'keySplines',
  keyTimes: 'keyTimes',
  lengthAdjust: 'lengthAdjust',
  letterSpacing: 'letter-spacing',
  lightingColor: 'lighting-color',
  limitingConeAngle: 'limitingConeAngle',
  local: 0,
  markerEnd: 'marker-end',
  markerMid: 'marker-mid',
  markerStart: 'marker-start',
  markerHeight: 'markerHeight',
  markerUnits: 'markerUnits',
  markerWidth: 'markerWidth',
  mask: 0,
  maskContentUnits: 'maskContentUnits',
  maskUnits: 'maskUnits',
  mathematical: 0,
  mode: 0,
  numOctaves: 'numOctaves',
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 'overline-position',
  overlineThickness: 'overline-thickness',
  paintOrder: 'paint-order',
  panose1: 'panose-1',
  pathLength: 'pathLength',
  patternContentUnits: 'patternContentUnits',
  patternTransform: 'patternTransform',
  patternUnits: 'patternUnits',
  pointerEvents: 'pointer-events',
  points: 0,
  pointsAtX: 'pointsAtX',
  pointsAtY: 'pointsAtY',
  pointsAtZ: 'pointsAtZ',
  preserveAlpha: 'preserveAlpha',
  preserveAspectRatio: 'preserveAspectRatio',
  primitiveUnits: 'primitiveUnits',
  r: 0,
  radius: 0,
  refX: 'refX',
  refY: 'refY',
  renderingIntent: 'rendering-intent',
  repeatCount: 'repeatCount',
  repeatDur: 'repeatDur',
  requiredExtensions: 'requiredExtensions',
  requiredFeatures: 'requiredFeatures',
  restart: 0,
  result: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  seed: 0,
  shapeRendering: 'shape-rendering',
  slope: 0,
  spacing: 0,
  specularConstant: 'specularConstant',
  specularExponent: 'specularExponent',
  speed: 0,
  spreadMethod: 'spreadMethod',
  startOffset: 'startOffset',
  stdDeviation: 'stdDeviation',
  stemh: 0,
  stemv: 0,
  stitchTiles: 'stitchTiles',
  stopColor: 'stop-color',
  stopOpacity: 'stop-opacity',
  strikethroughPosition: 'strikethrough-position',
  strikethroughThickness: 'strikethrough-thickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 'stroke-dasharray',
  strokeDashoffset: 'stroke-dashoffset',
  strokeLinecap: 'stroke-linecap',
  strokeLinejoin: 'stroke-linejoin',
  strokeMiterlimit: 'stroke-miterlimit',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  surfaceScale: 'surfaceScale',
  systemLanguage: 'systemLanguage',
  tableValues: 'tableValues',
  targetX: 'targetX',
  targetY: 'targetY',
  textAnchor: 'text-anchor',
  textDecoration: 'text-decoration',
  textRendering: 'text-rendering',
  textLength: 'textLength',
  to: 0,
  transform: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 'underline-position',
  underlineThickness: 'underline-thickness',
  unicode: 0,
  unicodeBidi: 'unicode-bidi',
  unicodeRange: 'unicode-range',
  unitsPerEm: 'units-per-em',
  vAlphabetic: 'v-alphabetic',
  vHanging: 'v-hanging',
  vIdeographic: 'v-ideographic',
  vMathematical: 'v-mathematical',
  values: 0,
  vectorEffect: 'vector-effect',
  version: 0,
  vertAdvY: 'vert-adv-y',
  vertOriginX: 'vert-origin-x',
  vertOriginY: 'vert-origin-y',
  viewBox: 'viewBox',
  viewTarget: 'viewTarget',
  visibility: 0,
  widths: 0,
  wordSpacing: 'word-spacing',
  writingMode: 'writing-mode',
  x: 0,
  xHeight: 'x-height',
  x1: 0,
  x2: 0,
  xChannelSelector: 'xChannelSelector',
  xlinkActuate: 'xlink:actuate',
  xlinkArcrole: 'xlink:arcrole',
  xlinkHref: 'xlink:href',
  xlinkRole: 'xlink:role',
  xlinkShow: 'xlink:show',
  xlinkTitle: 'xlink:title',
  xlinkType: 'xlink:type',
  xmlBase: 'xml:base',
  xmlns: 0,
  xmlnsXlink: 'xmlns:xlink',
  xmlLang: 'xml:lang',
  xmlSpace: 'xml:space',
  y: 0,
  y1: 0,
  y2: 0,
  yChannelSelector: 'yChannelSelector',
  z: 0,
  zoomAndPan: 'zoomAndPan'
};

var SVGDOMPropertyConfig = {
  Properties: {},
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {}
};

Object.keys(ATTRS).forEach(function (key) {
  SVGDOMPropertyConfig.Properties[key] = 0;
  if (ATTRS[key]) {
    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
  }
});

module.exports = SVGDOMPropertyConfig;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(24);
var ExecutionEnvironment = __webpack_require__(7);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactInputSelection = __webpack_require__(89);
var SyntheticEvent = __webpack_require__(15);

var getActiveElement = __webpack_require__(90);
var isTextInputElement = __webpack_require__(75);
var shallowEqual = __webpack_require__(51);

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement = null;
var activeElementInst = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events. See #3639.
var hasListener = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement = targetNode;
          activeElementInst = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement = null;
        activeElementInst = null;
        lastSelection = null;
        break;
      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);
      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function didPutListener(inst, registrationName, listener) {
    if (registrationName === 'onSelect') {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var EventListener = __webpack_require__(88);
var EventPropagators = __webpack_require__(24);
var ReactDOMComponentTree = __webpack_require__(4);
var SyntheticAnimationEvent = __webpack_require__(185);
var SyntheticClipboardEvent = __webpack_require__(186);
var SyntheticEvent = __webpack_require__(15);
var SyntheticFocusEvent = __webpack_require__(187);
var SyntheticKeyboardEvent = __webpack_require__(188);
var SyntheticMouseEvent = __webpack_require__(33);
var SyntheticDragEvent = __webpack_require__(190);
var SyntheticTouchEvent = __webpack_require__(191);
var SyntheticTransitionEvent = __webpack_require__(192);
var SyntheticUIEvent = __webpack_require__(26);
var SyntheticWheelEvent = __webpack_require__(193);

var emptyFunction = __webpack_require__(10);
var getEventCharCode = __webpack_require__(56);
var invariant = __webpack_require__(1);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

var onClickListeners = {};

function getDictionaryKey(inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

var SimpleEventPlugin = {
  eventTypes: eventTypes,

  extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topAbort':
      case 'topCanPlay':
      case 'topCanPlayThrough':
      case 'topDurationChange':
      case 'topEmptied':
      case 'topEncrypted':
      case 'topEnded':
      case 'topError':
      case 'topInput':
      case 'topInvalid':
      case 'topLoad':
      case 'topLoadedData':
      case 'topLoadedMetadata':
      case 'topLoadStart':
      case 'topPause':
      case 'topPlay':
      case 'topPlaying':
      case 'topProgress':
      case 'topRateChange':
      case 'topReset':
      case 'topSeeked':
      case 'topSeeking':
      case 'topStalled':
      case 'topSubmit':
      case 'topSuspend':
      case 'topTimeUpdate':
      case 'topVolumeChange':
      case 'topWaiting':
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function didPutListener(inst, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      if (!onClickListeners[key]) {
        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function willDeleteListener(inst, registrationName) {
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      onClickListeners[key].remove();
      delete onClickListeners[key];
    }
  }
};

module.exports = SimpleEventPlugin;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(15);

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

module.exports = SyntheticAnimationEvent;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(15);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function clipboardData(event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(26);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(26);

var getEventCharCode = __webpack_require__(56);
var getEventKey = __webpack_require__(189);
var getEventModifierState = __webpack_require__(45);

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function charCode(event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function keyCode(event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function which(event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var getEventCharCode = __webpack_require__(56);

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1',
  113: 'F2',
  114: 'F3',
  115: 'F4',
  116: 'F5',
  117: 'F6',
  118: 'F7',
  119: 'F8',
  120: 'F9',
  121: 'F10',
  122: 'F11',
  123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticMouseEvent = __webpack_require__(33);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(26);

var getEventModifierState = __webpack_require__(45);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(15);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

module.exports = SyntheticTransitionEvent;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticMouseEvent = __webpack_require__(33);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function deltaX(event) {
    return 'deltaX' in event ? event.deltaX : // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function deltaY(event) {
    return 'deltaY' in event ? event.deltaY : // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY : // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var validateDOMNesting = __webpack_require__(55);

var DOC_NODE_TYPE = 9;

function ReactDOMContainerInfo(topLevelWrapper, node) {
  var info = {
    _topLevelWrapper: topLevelWrapper,
    _idCounter: 1,
    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
    _node: node,
    _tag: node ? node.nodeName.toLowerCase() : null,
    _namespaceURI: node ? node.namespaceURI : null
  };
  if (process.env.NODE_ENV !== 'production') {
    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
  }
  return info;
}

module.exports = ReactDOMContainerInfo;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMFeatureFlags = {
  useCreateElement: true,
  useFiber: false
};

module.exports = ReactDOMFeatureFlags;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var adler32 = __webpack_require__(197);

var TAG_END = /\/?>/;
var COMMENT_START = /^<\!\-\-/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function addChecksumToMarkup(markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags, comments and self-closing tags)
    if (COMMENT_START.test(markup)) {
      return markup;
    } else {
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    }
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function canReuseMarkup(markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    var n = Math.min(i + 4096, m);
    for (; i < n; i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.6.1';

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactCurrentOwner = __webpack_require__(13);
var ReactDOMComponentTree = __webpack_require__(4);
var ReactInstanceMap = __webpack_require__(27);

var getHostComponentFromComposite = __webpack_require__(92);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

/**
 * Returns the DOM node rendered by this element.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if (process.env.NODE_ENV !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
  } else {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
  }
}

module.exports = findDOMNode;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactMount = __webpack_require__(91);

module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(16);
var EventPluginRegistry = __webpack_require__(31);
var ReactComponentTreeHook = __webpack_require__(9);

var warning = __webpack_require__(2);

if (process.env.NODE_ENV !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true,

    autoFocus: true,
    defaultValue: true,
    valueLink: true,
    defaultChecked: true,
    checkedLink: true,
    innerHTML: true,
    suppressContentEditableWarning: true,
    onFocusIn: true,
    onFocusOut: true
  };
  var warnedProperties = {};

  var validateProperty = function validateProperty(tagName, name, debugID) {
    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
      return true;
    }
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return true;
    }
    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
      return true;
    }
    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

    if (standardName != null) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else if (registrationName != null) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else {
      // We were unable to guess which prop the user intended.
      // It is likely that the user was just blindly spreading/forwarding props
      // Components should be careful to only render valid props/attributes.
      // Warning will be invoked in warnUnknownProperties to allow grouping.
      return false;
    }
  };
}

var warnUnknownProperties = function warnUnknownProperties(debugID, element) {
  var unknownProps = [];
  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (unknownProps.length === 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (unknownProps.length > 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
};

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }
  warnUnknownProperties(debugID, element);
}

var ReactDOMUnknownPropertyHook = {
  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMUnknownPropertyHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactComponentTreeHook = __webpack_require__(9);

var warning = __webpack_require__(2);

var didWarnValueNull = false;

function handleElement(debugID, element) {
  if (element == null) {
    return;
  }
  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
    return;
  }
  if (element.props != null && element.props.value === null && !didWarnValueNull) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

    didWarnValueNull = true;
  }
}

var ReactDOMNullInputValuePropHook = {
  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMNullInputValuePropHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(16);
var ReactComponentTreeHook = __webpack_require__(9);

var warning = __webpack_require__(2);

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

function validateProperty(tagName, name, debugID) {
  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
    return true;
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(debugID, element) {
  var invalidProps = [];

  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (invalidProps.length > 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
}

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }

  warnInvalidARIAProps(debugID, element);
}

var ReactDOMInvalidARIAHook = {
  onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
    if (process.env.NODE_ENV !== 'production') {
      handleElement(debugID, element);
    }
  },
  onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
    if (process.env.NODE_ENV !== 'production') {
      handleElement(debugID, element);
    }
  }
};

module.exports = ReactDOMInvalidARIAHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createMemoryHistory = __webpack_require__(206);

var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);

var _Router = __webpack_require__(59);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that stores location in memory.
 */

var MemoryRouter = function (_React$Component) {
  _inherits(MemoryRouter, _React$Component);

  function MemoryRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, MemoryRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _createMemoryHistory2.default)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  MemoryRouter.prototype.render = function render() {
    return _react2.default.createElement(_Router2.default, { history: this.history, children: this.props.children });
  };

  return MemoryRouter;
}(_react2.default.Component);

MemoryRouter.propTypes = {
  initialEntries: _propTypes2.default.array,
  initialIndex: _propTypes2.default.number,
  getUserConfirmation: _propTypes2.default.func,
  keyLength: _propTypes2.default.number,
  children: _propTypes2.default.node
};

exports.default = MemoryRouter;

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



var emptyFunction = __webpack_require__(10);
var invariant = __webpack_require__(1);
var ReactPropTypesSecret = __webpack_require__(40);

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _warning = __webpack_require__(19);

var _warning2 = _interopRequireDefault(_warning);

var _PathUtils = __webpack_require__(28);

var _LocationUtils = __webpack_require__(57);

var _createTransitionManager = __webpack_require__(58);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createMemoryHistory;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isAbsolute = function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
};

// About 1.5x faster than the two-arg version of Array#splice()
var spliceOne = function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }list.pop();
};

// This implementation is based heavily on node's url.parse
var resolvePathname = function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
};

module.exports = resolvePathname;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var valueEqual = function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
    return valueEqual(item, b[index]);
  });

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
};

exports.default = valueEqual;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for prompting the user before navigating away
 * from a screen with a component.
 */

var Prompt = function (_React$Component) {
  _inherits(Prompt, _React$Component);

  function Prompt() {
    _classCallCheck(this, Prompt);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Prompt.prototype.enable = function enable(message) {
    if (this.unblock) this.unblock();

    this.unblock = this.context.router.history.block(message);
  };

  Prompt.prototype.disable = function disable() {
    if (this.unblock) {
      this.unblock();
      this.unblock = null;
    }
  };

  Prompt.prototype.componentWillMount = function componentWillMount() {
    if (this.props.when) this.enable(this.props.message);
  };

  Prompt.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    if (nextProps.when) {
      if (!this.props.when || this.props.message !== nextProps.message) this.enable(nextProps.message);
    } else {
      this.disable();
    }
  };

  Prompt.prototype.componentWillUnmount = function componentWillUnmount() {
    this.disable();
  };

  Prompt.prototype.render = function render() {
    return null;
  };

  return Prompt;
}(_react2.default.Component);

Prompt.propTypes = {
  when: _propTypes2.default.bool,
  message: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired
};
Prompt.defaultProps = {
  when: true
};
Prompt.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      block: _propTypes2.default.func.isRequired
    }).isRequired
  }).isRequired
};

exports.default = Prompt;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for updating the location programatically
 * with a component.
 */

var Redirect = function (_React$Component) {
  _inherits(Redirect, _React$Component);

  function Redirect() {
    _classCallCheck(this, Redirect);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Redirect.prototype.isStatic = function isStatic() {
    return this.context.router && this.context.router.staticContext;
  };

  Redirect.prototype.componentWillMount = function componentWillMount() {
    if (this.isStatic()) this.perform();
  };

  Redirect.prototype.componentDidMount = function componentDidMount() {
    if (!this.isStatic()) this.perform();
  };

  Redirect.prototype.perform = function perform() {
    var history = this.context.router.history;
    var _props = this.props,
        push = _props.push,
        to = _props.to;

    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  Redirect.prototype.render = function render() {
    return null;
  };

  return Redirect;
}(_react2.default.Component);

Redirect.propTypes = {
  push: _propTypes2.default.bool,
  from: _propTypes2.default.string,
  to: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
};
Redirect.defaultProps = {
  push: false
};
Redirect.contextTypes = {
  router: _propTypes2.default.shape({
    history: _propTypes2.default.shape({
      push: _propTypes2.default.func.isRequired,
      replace: _propTypes2.default.func.isRequired
    }).isRequired,
    staticContext: _propTypes2.default.object
  }).isRequired
};

exports.default = Redirect;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isarray = __webpack_require__(212);

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;
module.exports.parse = parse;
module.exports.compile = compile;
module.exports.tokensToFunction = tokensToFunction;
module.exports.tokensToRegExp = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won't transform.
'(\\\\.)',
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
// "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
// "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
'([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var defaultDelimiter = options && options.delimiter || '/';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var partial = prefix != null && next != null && next !== prefix;
    var repeat = modifier === '+' || modifier === '*';
    var optional = modifier === '?' || modifier === '*';
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?'
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (_typeof(tokens[i]) === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
    }
  }

  return function (obj, opts) {
    var path = '';
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined');
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`');
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty');
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`');
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"');
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1');
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = '(?:' + token.pattern + ')';

      keys.push(token);

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = prefix + '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || '/');
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (isarray(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _invariant = __webpack_require__(37);

var _invariant2 = _interopRequireDefault(_invariant);

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _PathUtils = __webpack_require__(28);

var _Router = __webpack_require__(59);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

var normalizeLocation = function normalizeLocation(object) {
  var _object$pathname = object.pathname,
      pathname = _object$pathname === undefined ? '/' : _object$pathname,
      _object$search = object.search,
      search = _object$search === undefined ? '' : _object$search,
      _object$hash = object.hash,
      hash = _object$hash === undefined ? '' : _object$hash;

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var addBasename = function addBasename(basename, location) {
  if (!basename) return location;

  return _extends({}, location, {
    pathname: (0, _PathUtils.addLeadingSlash)(basename) + location.pathname
  });
};

var stripBasename = function stripBasename(basename, location) {
  if (!basename) return location;

  var base = (0, _PathUtils.addLeadingSlash)(basename);

  if (location.pathname.indexOf(base) !== 0) return location;

  return _extends({}, location, {
    pathname: location.pathname.substr(base.length)
  });
};

var createLocation = function createLocation(location) {
  return typeof location === 'string' ? (0, _PathUtils.parsePath)(location) : normalizeLocation(location);
};

var createURL = function createURL(location) {
  return typeof location === 'string' ? location : (0, _PathUtils.createPath)(location);
};

var staticHandler = function staticHandler(methodName) {
  return function () {
    (0, _invariant2.default)(false, 'You cannot %s with <StaticRouter>', methodName);
  };
};

var noop = function noop() {};

/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */

var StaticRouter = function (_React$Component) {
  _inherits(StaticRouter, _React$Component);

  function StaticRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, StaticRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.createHref = function (path) {
      return (0, _PathUtils.addLeadingSlash)(_this.props.basename + createURL(path));
    }, _this.handlePush = function (location) {
      var _this$props = _this.props,
          basename = _this$props.basename,
          context = _this$props.context;

      context.action = 'PUSH';
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleReplace = function (location) {
      var _this$props2 = _this.props,
          basename = _this$props2.basename,
          context = _this$props2.context;

      context.action = 'REPLACE';
      context.location = addBasename(basename, createLocation(location));
      context.url = createURL(context.location);
    }, _this.handleListen = function () {
      return noop;
    }, _this.handleBlock = function () {
      return noop;
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  StaticRouter.prototype.getChildContext = function getChildContext() {
    return {
      router: {
        staticContext: this.props.context
      }
    };
  };

  StaticRouter.prototype.render = function render() {
    var _props = this.props,
        basename = _props.basename,
        context = _props.context,
        location = _props.location,
        props = _objectWithoutProperties(_props, ['basename', 'context', 'location']);

    var history = {
      createHref: this.createHref,
      action: 'POP',
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler('go'),
      goBack: staticHandler('goBack'),
      goForward: staticHandler('goForward'),
      listen: this.handleListen,
      block: this.handleBlock
    };

    return _react2.default.createElement(_Router2.default, _extends({}, props, { history: history }));
  };

  return StaticRouter;
}(_react2.default.Component);

StaticRouter.propTypes = {
  basename: _propTypes2.default.string,
  context: _propTypes2.default.object.isRequired,
  location: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
};
StaticRouter.defaultProps = {
  basename: '',
  location: '/'
};
StaticRouter.childContextTypes = {
  router: _propTypes2.default.object.isRequired
};

exports.default = StaticRouter;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _warning = __webpack_require__(19);

var _warning2 = _interopRequireDefault(_warning);

var _matchPath = __webpack_require__(60);

var _matchPath2 = _interopRequireDefault(_matchPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for rendering the first <Route> that matches.
 */

var Switch = function (_React$Component) {
  _inherits(Switch, _React$Component);

  function Switch() {
    _classCallCheck(this, Switch);

    return _possibleConstructorReturn(this, _React$Component.apply(this, arguments));
  }

  Switch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    (0, _warning2.default)(!(nextProps.location && !this.props.location), '<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.');

    (0, _warning2.default)(!(!nextProps.location && this.props.location), '<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.');
  };

  Switch.prototype.render = function render() {
    var route = this.context.router.route;
    var children = this.props.children;

    var location = this.props.location || route.location;

    var match = void 0,
        child = void 0;
    _react2.default.Children.forEach(children, function (element) {
      if (!_react2.default.isValidElement(element)) return;

      var _element$props = element.props,
          pathProp = _element$props.path,
          exact = _element$props.exact,
          strict = _element$props.strict,
          from = _element$props.from;

      var path = pathProp || from;

      if (match == null) {
        child = element;
        match = path ? (0, _matchPath2.default)(location.pathname, { path: path, exact: exact, strict: strict }) : route.match;
      }
    });

    return match ? _react2.default.cloneElement(child, { location: location, computedMatch: match }) : null;
  };

  return Switch;
}(_react2.default.Component);

Switch.contextTypes = {
  router: _propTypes2.default.shape({
    route: _propTypes2.default.object.isRequired
  }).isRequired
};
Switch.propTypes = {
  children: _propTypes2.default.node,
  location: _propTypes2.default.object
};

exports.default = Switch;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _hoistNonReactStatics = __webpack_require__(216);

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _Route = __webpack_require__(93);

var _Route2 = _interopRequireDefault(_Route);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

/**
 * A public higher-order component to access the imperative API
 */
var withRouter = function withRouter(Component) {
  var C = function C(props) {
    var wrappedComponentRef = props.wrappedComponentRef,
        remainingProps = _objectWithoutProperties(props, ['wrappedComponentRef']);

    return _react2.default.createElement(_Route2.default, { render: function render(routeComponentProps) {
        return _react2.default.createElement(Component, _extends({}, remainingProps, routeComponentProps, { ref: wrappedComponentRef }));
      } });
  };

  C.displayName = 'withRouter(' + (Component.displayName || Component.name) + ')';
  C.WrappedComponent = Component;
  C.propTypes = {
    wrappedComponentRef: _propTypes2.default.func
  };

  return (0, _hoistNonReactStatics2.default)(C, Component);
};

exports.default = withRouter;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */


var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    arguments: true,
    arity: true
};

var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
    if (typeof sourceComponent !== 'string') {
        // don't hoist over string (html) components
        var keys = Object.getOwnPropertyNames(sourceComponent);

        /* istanbul ignore else */
        if (isGetOwnPropertySymbolsAvailable) {
            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
                try {
                    targetComponent[keys[i]] = sourceComponent[keys[i]];
                } catch (error) {}
            }
        }
    }

    return targetComponent;
};

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var constants = {
  EXPERIENCE_ID: 'Birds Need a Home'
};

exports.default = constants;

/***/ }),
/* 218 */
/***/ (function(module, exports) {

module.exports = {"experienceId":"Birds Need A Home"}

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _reactRouter = __webpack_require__(8);

var _MetaTag = __webpack_require__(220);

var _MetaTag2 = _interopRequireDefault(_MetaTag);

var _Navigation = __webpack_require__(221);

var _Navigation2 = _interopRequireDefault(_Navigation);

var _Presentation = __webpack_require__(235);

var _Presentation2 = _interopRequireDefault(_Presentation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Home = function (_React$Component) {
  _inherits(Home, _React$Component);

  function Home(props) {
    _classCallCheck(this, Home);

    var _this = _possibleConstructorReturn(this, (Home.__proto__ || Object.getPrototypeOf(Home)).call(this, props));

    _this.state = {
      mounted: false
    };
    return _this;
  }

  _createClass(Home, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        mounted: true
      });
      var title = document.querySelector('title');
      if (title) {
        title.innerText = this.props.content.title;
      } else {
        var _title = document.createElement('title');
        _title.innerText = this.props.content.title;
        document.querySelector('head').prepend(_title);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.setState({
        mounted: false
      });
    }
  }, {
    key: 'render',
    value: function render() {
      console.log(this.props);
      return _react2.default.createElement(
        'div',
        { className: [this.props.constants.EXPERIENCE_ID.toLowerCase()].join(' ') },
        _react2.default.createElement(_MetaTag2.default, { tags: this.props.content.metadata }),
        _react2.default.createElement(_Navigation2.default, null),
        _react2.default.createElement(_Presentation2.default, { title: this.props.content.title, galleries: this.props.content.galleries, houses: this.props.content.houses, pics: this.props.content.pics })
      );
    }
  }]);

  return Home;
}(_react2.default.Component);

exports.default = (0, _reactRouter.withRouter)(Home);

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MetaTag = function (_React$Component) {
  _inherits(MetaTag, _React$Component);

  function MetaTag(props) {
    _classCallCheck(this, MetaTag);

    var _this = _possibleConstructorReturn(this, (MetaTag.__proto__ || Object.getPrototypeOf(MetaTag)).call(this, props));

    _this.state = {
      mounted: false
    };
    return _this;
  }

  _createClass(MetaTag, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        mounted: true
      });
      var head = document.querySelector('head');
      this.props.tags.forEach(function (tag) {
        var metatag = document.createElement('meta');
        for (var key in tag) {
          metatag.setAttribute(key, tag[key]);
        }
        head.prepend(metatag);
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.setState({
        mounted: false
      });
    }
  }, {
    key: 'render',
    value: function render() {
      return null;
    }
  }]);

  return MetaTag;
}(_react2.default.Component);

exports.default = MetaTag;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(97);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Navigation = function (_React$Component) {
  _inherits(Navigation, _React$Component);

  function Navigation() {
    _classCallCheck(this, Navigation);

    return _possibleConstructorReturn(this, (Navigation.__proto__ || Object.getPrototypeOf(Navigation)).apply(this, arguments));
  }

  _createClass(Navigation, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: ['navigation'].join(' ') },
        _react2.default.createElement(
          'div',
          { className: 'header' },
          _react2.default.createElement(
            'h1',
            { className: 'branding' },
            'CoDesign'
          )
        ),
        _react2.default.createElement('nav', { role: 'navigation' })
      );
    }
  }]);

  return Navigation;
}(_react2.default.Component);

exports.default = Navigation;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createBrowserHistory = __webpack_require__(94);

var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);

var _reactRouter = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that uses HTML5 history.
 */

var BrowserRouter = function (_React$Component) {
  _inherits(BrowserRouter, _React$Component);

  function BrowserRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, BrowserRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _createBrowserHistory2.default)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  BrowserRouter.prototype.render = function render() {
    return _react2.default.createElement(_reactRouter.Router, { history: this.history, children: this.props.children });
  };

  return BrowserRouter;
}(_react2.default.Component);

BrowserRouter.propTypes = {
  basename: _propTypes2.default.string,
  forceRefresh: _propTypes2.default.bool,
  getUserConfirmation: _propTypes2.default.func,
  keyLength: _propTypes2.default.number,
  children: _propTypes2.default.node
};

exports.default = BrowserRouter;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _createHashHistory = __webpack_require__(224);

var _createHashHistory2 = _interopRequireDefault(_createHashHistory);

var _reactRouter = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

/**
 * The public API for a <Router> that uses window.location.hash.
 */

var HashRouter = function (_React$Component) {
  _inherits(HashRouter, _React$Component);

  function HashRouter() {
    var _temp, _this, _ret;

    _classCallCheck(this, HashRouter);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.history = (0, _createHashHistory2.default)(_this.props), _temp), _possibleConstructorReturn(_this, _ret);
  }

  HashRouter.prototype.render = function render() {
    return _react2.default.createElement(_reactRouter.Router, { history: this.history, children: this.props.children });
  };

  return HashRouter;
}(_react2.default.Component);

HashRouter.propTypes = {
  basename: _propTypes2.default.string,
  getUserConfirmation: _propTypes2.default.func,
  hashType: _propTypes2.default.oneOf(['hashbang', 'noslash', 'slash']),
  children: _propTypes2.default.node
};

exports.default = HashRouter;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.__esModule = true;

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _warning = __webpack_require__(19);

var _warning2 = _interopRequireDefault(_warning);

var _invariant = __webpack_require__(37);

var _invariant2 = _interopRequireDefault(_invariant);

var _LocationUtils = __webpack_require__(57);

var _PathUtils = __webpack_require__(28);

var _createTransitionManager = __webpack_require__(58);

var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);

var _DOMUtils = __webpack_require__(95);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + (0, _PathUtils.stripLeadingSlash)(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils.stripLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  },
  slash: {
    encodePath: _PathUtils.addLeadingSlash,
    decodePath: _PathUtils.addLeadingSlash
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;

  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = (0, _PathUtils.stripBasename)(path, basename);

    return (0, _LocationUtils.createLocation)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        (0, _warning2.default)(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf((0, _PathUtils.createPath)(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    (0, _warning2.default)(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

exports.default = createHashHistory;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRouter = __webpack_require__(8);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _reactRouter.MemoryRouter;
  }
});

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(12);

var _propTypes2 = _interopRequireDefault(_propTypes);

var _reactRouter = __webpack_require__(8);

var _Link = __webpack_require__(98);

var _Link2 = _interopRequireDefault(_Link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}

/**
 * A <Link> wrapper that knows if it's "active" or not.
 */
var NavLink = function NavLink(_ref) {
  var to = _ref.to,
      exact = _ref.exact,
      strict = _ref.strict,
      location = _ref.location,
      activeClassName = _ref.activeClassName,
      className = _ref.className,
      activeStyle = _ref.activeStyle,
      style = _ref.style,
      getIsActive = _ref.isActive,
      rest = _objectWithoutProperties(_ref, ['to', 'exact', 'strict', 'location', 'activeClassName', 'className', 'activeStyle', 'style', 'isActive']);

  return _react2.default.createElement(_reactRouter.Route, {
    path: (typeof to === 'undefined' ? 'undefined' : _typeof(to)) === 'object' ? to.pathname : to,
    exact: exact,
    strict: strict,
    location: location,
    children: function children(_ref2) {
      var location = _ref2.location,
          match = _ref2.match;

      var isActive = !!(getIsActive ? getIsActive(match, location) : match);

      return _react2.default.createElement(_Link2.default, _extends({
        to: to,
        className: isActive ? [activeClassName, className].filter(function (i) {
          return i;
        }).join(' ') : className,
        style: isActive ? _extends({}, style, activeStyle) : style
      }, rest));
    }
  });
};

NavLink.propTypes = {
  to: _Link2.default.propTypes.to,
  exact: _propTypes2.default.bool,
  strict: _propTypes2.default.bool,
  location: _propTypes2.default.object,
  activeClassName: _propTypes2.default.string,
  className: _propTypes2.default.string,
  activeStyle: _propTypes2.default.object,
  style: _propTypes2.default.object,
  isActive: _propTypes2.default.func
};

NavLink.defaultProps = {
  activeClassName: 'active'
};

exports.default = NavLink;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRouter = __webpack_require__(8);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _reactRouter.Prompt;
  }
});

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRouter = __webpack_require__(8);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _reactRouter.Redirect;
  }
});

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRouter = __webpack_require__(8);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _reactRouter.Route;
  }
});

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRouter = __webpack_require__(8);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _reactRouter.Router;
  }
});

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRouter = __webpack_require__(8);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _reactRouter.StaticRouter;
  }
});

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRouter = __webpack_require__(8);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _reactRouter.Switch;
  }
});

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRouter = __webpack_require__(8);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _reactRouter.matchPath;
  }
});

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reactRouter = __webpack_require__(8);

Object.defineProperty(exports, 'default', {
  enumerable: true,
  get: function get() {
    return _reactRouter.withRouter;
  }
});

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

var _reactRouterDom = __webpack_require__(97);

var _ContentServices = __webpack_require__(236);

var _ContentServices2 = _interopRequireDefault(_ContentServices);

var _Header = __webpack_require__(237);

var _Header2 = _interopRequireDefault(_Header);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var contentServices = new _ContentServices2.default();

var Presentation = function (_React$Component) {
  _inherits(Presentation, _React$Component);

  function Presentation() {
    _classCallCheck(this, Presentation);

    return _possibleConstructorReturn(this, (Presentation.__proto__ || Object.getPrototypeOf(Presentation)).apply(this, arguments));
  }

  _createClass(Presentation, [{
    key: 'render',
    value: function render() {
      var galleries = this.props.galleries.map(function (gallery, idx) {
        return _react2.default.createElement(
          'li',
          { key: idx },
          _react2.default.createElement(
            _reactRouterDom.Link,
            { to: '/gallery/' + gallery.id },
            _react2.default.createElement(
              'h2',
              null,
              gallery.title
            ),
            _react2.default.createElement(
              'p',
              null,
              gallery.desc
            ),
            _react2.default.createElement('img', { src: contentServices.getPicFor('G', gallery.id).src, alt: '' })
          )
        );
      });
      return _react2.default.createElement(
        'div',
        { className: ['presentation'].join(' ') },
        _react2.default.createElement(_Header2.default, { type: '1', text: this.props.title }),
        _react2.default.createElement(
          'ul',
          null,
          galleries
        )
      );
    }
  }]);

  return Presentation;
}(_react2.default.Component);

exports.default = Presentation;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _content = __webpack_require__(96);

var _content2 = _interopRequireDefault(_content);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ContentServices = function () {
  function ContentServices() {
    _classCallCheck(this, ContentServices);

    this.galleries = _content2.default.galleries;
    this.houses = _content2.default.houses;
    this.pics = _content2.default.pics;
  }

  _createClass(ContentServices, [{
    key: 'getGallery',
    value: function getGallery(id) {
      return this.galleries.filter(function (gallery) {
        return gallery.id === id;
      })[0];
    }
  }, {
    key: 'getHouse',
    value: function getHouse(id) {
      return this.houses.filter(function (house) {
        return house.id === id;
      })[0];
    }
  }, {
    key: 'getPic',
    value: function getPic(id) {
      return this.pics.filter(function (pic) {
        return pic.id === id;
      })[0];
    }
  }, {
    key: 'getPicFor',
    value: function getPicFor(type, id) {
      return this.pics.filter(function (pic) {
        return pic.type === type && pic.xid === id;
      })[0];
    }
  }]);

  return ContentServices;
}();

exports.default = ContentServices;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(5);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Header = function (_React$Component) {
  _inherits(Header, _React$Component);

  function Header(props) {
    _classCallCheck(this, Header);

    var _this = _possibleConstructorReturn(this, (Header.__proto__ || Object.getPrototypeOf(Header)).call(this, props));

    _this.state = {
      mounted: false
    };
    return _this;
  }

  _createClass(Header, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.setState({
        mounted: true
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.setState({
        mounted: false
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      var HeaderTag = 'h' + this.props.type;
      return _react2.default.createElement(
        HeaderTag,
        {
          className: ["header"].join(' '),
          ref: function ref(component) {
            _this2.header = component;
          }
        },
        this.props.text
      );
    }
  }]);

  return Header;
}(_react2.default.Component);

exports.default = Header;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(239);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(247)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../node_modules/css-loader/index.js!../node_modules/less-loader/dist/cjs.js??ref--1-2!./main.less", function() {
			var newContent = require("!!../node_modules/css-loader/index.js!../node_modules/less-loader/dist/cjs.js??ref--1-2!./main.less");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(99)(undefined);
// imports
exports.i(__webpack_require__(240), "");

// module
exports.push([module.i, "html,\nbody {\n  border: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\nbody {\n  background: orange;\n}\n.boilerplate {\n  color: green;\n}\n@font-face {\n  font-family: 'LegoIcons';\n  src: url(" + __webpack_require__(100) + ");\n  src: url(" + __webpack_require__(100) + "?#iefix) format('embedded-opentype'), url(" + __webpack_require__(241) + ") format('woff'), url(" + __webpack_require__(242) + ") format('truetype'), url(" + __webpack_require__(243) + "#LegoIcons) format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n@font-face {\n  font-family: 'LovedbytheKing';\n  src: url(" + __webpack_require__(101) + ");\n  src: url(" + __webpack_require__(101) + "?#iefix) format('embedded-opentype'), url(" + __webpack_require__(244) + ") format('woff'), url(" + __webpack_require__(245) + ") format('truetype'), url(" + __webpack_require__(246) + "#LovedbytheKing) format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n@font-face {\n  font-family: 'Ubuntu-Regular';\n  src: url('/fonts/Ubuntu-Regular.eot');\n  src: url('/fonts/Ubuntu-Regular.woff2') format('woff2'), url('/fonts/Ubuntu-Regular.eot?#iefix') format('embedded-opentype');\n  font-weight: normal;\n  font-style: normal;\n}\n@font-face {\n  font-family: 'Ubuntu';\n  src: url('/fonts/Ubuntu.woff') format('woff'), url('/fonts/Ubuntu.ttf') format('truetype'), url('/fonts/Ubuntu.svg#Ubuntu') format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n.codesign {\n  display: flex;\n  flex-direction: row;\n  align-items: flex-start;\n  justify-content: flex-start;\n}\n.codesign > * {\n  min-height: 100vh;\n}\n.navigation {\n  width: 25%;\n  padding: 2%;\n  background-color: #ddd;\n}\n.navigation .header {\n  display: flex;\n  flex-direction: row;\n  align-items: flex-start;\n}\n.navigation .logo {\n  width: 30px;\n  margin-right: 10px;\n}\n.navigation h1 {\n  font-family: 'Ubuntu', Arial, sans-serif;\n  font-size: 1em;\n}\n.navigation nav ul {\n  list-style-type: none;\n  padding: 0;\n}\n", ""]);

// exports


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(99)(undefined);
// imports


// module
exports.push([module.i, "/*! normalize.css v7.0.0 | MIT License | github.com/necolas/normalize.css */\n\n/* Document\n   ========================================================================== */\n\n/**\n * 1. Correct the line height in all browsers.\n * 2. Prevent adjustments of font size after orientation changes in\n *    IE on Windows Phone and in iOS.\n */\n\nhtml {\n  line-height: 1.15; /* 1 */\n  -ms-text-size-adjust: 100%; /* 2 */\n  -webkit-text-size-adjust: 100%; /* 2 */\n}\n\n/* Sections\n   ========================================================================== */\n\n/**\n * Remove the margin in all browsers (opinionated).\n */\n\nbody {\n  margin: 0;\n}\n\n/**\n * Add the correct display in IE 9-.\n */\n\narticle,\naside,\nfooter,\nheader,\nnav,\nsection {\n  display: block;\n}\n\n/**\n * Correct the font size and margin on `h1` elements within `section` and\n * `article` contexts in Chrome, Firefox, and Safari.\n */\n\nh1 {\n  font-size: 2em;\n  margin: 0.67em 0;\n}\n\n/* Grouping content\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n * 1. Add the correct display in IE.\n */\n\nfigcaption,\nfigure,\nmain { /* 1 */\n  display: block;\n}\n\n/**\n * Add the correct margin in IE 8.\n */\n\nfigure {\n  margin: 1em 40px;\n}\n\n/**\n * 1. Add the correct box sizing in Firefox.\n * 2. Show the overflow in Edge and IE.\n */\n\nhr {\n  box-sizing: content-box; /* 1 */\n  height: 0; /* 1 */\n  overflow: visible; /* 2 */\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\npre {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/* Text-level semantics\n   ========================================================================== */\n\n/**\n * 1. Remove the gray background on active links in IE 10.\n * 2. Remove gaps in links underline in iOS 8+ and Safari 8+.\n */\n\na {\n  background-color: transparent; /* 1 */\n  -webkit-text-decoration-skip: objects; /* 2 */\n}\n\n/**\n * 1. Remove the bottom border in Chrome 57- and Firefox 39-.\n * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.\n */\n\nabbr[title] {\n  border-bottom: none; /* 1 */\n  text-decoration: underline; /* 2 */\n  text-decoration: underline dotted; /* 2 */\n}\n\n/**\n * Prevent the duplicate application of `bolder` by the next rule in Safari 6.\n */\n\nb,\nstrong {\n  font-weight: inherit;\n}\n\n/**\n * Add the correct font weight in Chrome, Edge, and Safari.\n */\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/**\n * 1. Correct the inheritance and scaling of font size in all browsers.\n * 2. Correct the odd `em` font sizing in all browsers.\n */\n\ncode,\nkbd,\nsamp {\n  font-family: monospace, monospace; /* 1 */\n  font-size: 1em; /* 2 */\n}\n\n/**\n * Add the correct font style in Android 4.3-.\n */\n\ndfn {\n  font-style: italic;\n}\n\n/**\n * Add the correct background and color in IE 9-.\n */\n\nmark {\n  background-color: #ff0;\n  color: #000;\n}\n\n/**\n * Add the correct font size in all browsers.\n */\n\nsmall {\n  font-size: 80%;\n}\n\n/**\n * Prevent `sub` and `sup` elements from affecting the line height in\n * all browsers.\n */\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/* Embedded content\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n */\n\naudio,\nvideo {\n  display: inline-block;\n}\n\n/**\n * Add the correct display in iOS 4-7.\n */\n\naudio:not([controls]) {\n  display: none;\n  height: 0;\n}\n\n/**\n * Remove the border on images inside links in IE 10-.\n */\n\nimg {\n  border-style: none;\n}\n\n/**\n * Hide the overflow in IE.\n */\n\nsvg:not(:root) {\n  overflow: hidden;\n}\n\n/* Forms\n   ========================================================================== */\n\n/**\n * 1. Change the font styles in all browsers (opinionated).\n * 2. Remove the margin in Firefox and Safari.\n */\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: sans-serif; /* 1 */\n  font-size: 100%; /* 1 */\n  line-height: 1.15; /* 1 */\n  margin: 0; /* 2 */\n}\n\n/**\n * Show the overflow in IE.\n * 1. Show the overflow in Edge.\n */\n\nbutton,\ninput { /* 1 */\n  overflow: visible;\n}\n\n/**\n * Remove the inheritance of text transform in Edge, Firefox, and IE.\n * 1. Remove the inheritance of text transform in Firefox.\n */\n\nbutton,\nselect { /* 1 */\n  text-transform: none;\n}\n\n/**\n * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video`\n *    controls in Android 4.\n * 2. Correct the inability to style clickable types in iOS and Safari.\n */\n\nbutton,\nhtml [type=\"button\"], /* 1 */\n[type=\"reset\"],\n[type=\"submit\"] {\n  -webkit-appearance: button; /* 2 */\n}\n\n/**\n * Remove the inner border and padding in Firefox.\n */\n\nbutton::-moz-focus-inner,\n[type=\"button\"]::-moz-focus-inner,\n[type=\"reset\"]::-moz-focus-inner,\n[type=\"submit\"]::-moz-focus-inner {\n  border-style: none;\n  padding: 0;\n}\n\n/**\n * Restore the focus styles unset by the previous rule.\n */\n\nbutton:-moz-focusring,\n[type=\"button\"]:-moz-focusring,\n[type=\"reset\"]:-moz-focusring,\n[type=\"submit\"]:-moz-focusring {\n  outline: 1px dotted ButtonText;\n}\n\n/**\n * Correct the padding in Firefox.\n */\n\nfieldset {\n  padding: 0.35em 0.75em 0.625em;\n}\n\n/**\n * 1. Correct the text wrapping in Edge and IE.\n * 2. Correct the color inheritance from `fieldset` elements in IE.\n * 3. Remove the padding so developers are not caught out when they zero out\n *    `fieldset` elements in all browsers.\n */\n\nlegend {\n  box-sizing: border-box; /* 1 */\n  color: inherit; /* 2 */\n  display: table; /* 1 */\n  max-width: 100%; /* 1 */\n  padding: 0; /* 3 */\n  white-space: normal; /* 1 */\n}\n\n/**\n * 1. Add the correct display in IE 9-.\n * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera.\n */\n\nprogress {\n  display: inline-block; /* 1 */\n  vertical-align: baseline; /* 2 */\n}\n\n/**\n * Remove the default vertical scrollbar in IE.\n */\n\ntextarea {\n  overflow: auto;\n}\n\n/**\n * 1. Add the correct box sizing in IE 10-.\n * 2. Remove the padding in IE 10-.\n */\n\n[type=\"checkbox\"],\n[type=\"radio\"] {\n  box-sizing: border-box; /* 1 */\n  padding: 0; /* 2 */\n}\n\n/**\n * Correct the cursor style of increment and decrement buttons in Chrome.\n */\n\n[type=\"number\"]::-webkit-inner-spin-button,\n[type=\"number\"]::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/**\n * 1. Correct the odd appearance in Chrome and Safari.\n * 2. Correct the outline style in Safari.\n */\n\n[type=\"search\"] {\n  -webkit-appearance: textfield; /* 1 */\n  outline-offset: -2px; /* 2 */\n}\n\n/**\n * Remove the inner padding and cancel buttons in Chrome and Safari on macOS.\n */\n\n[type=\"search\"]::-webkit-search-cancel-button,\n[type=\"search\"]::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/**\n * 1. Correct the inability to style clickable types in iOS and Safari.\n * 2. Change font properties to `inherit` in Safari.\n */\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button; /* 1 */\n  font: inherit; /* 2 */\n}\n\n/* Interactive\n   ========================================================================== */\n\n/*\n * Add the correct display in IE 9-.\n * 1. Add the correct display in Edge, IE, and Firefox.\n */\n\ndetails, /* 1 */\nmenu {\n  display: block;\n}\n\n/*\n * Add the correct display in all browsers.\n */\n\nsummary {\n  display: list-item;\n}\n\n/* Scripting\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 9-.\n */\n\ncanvas {\n  display: inline-block;\n}\n\n/**\n * Add the correct display in IE.\n */\n\ntemplate {\n  display: none;\n}\n\n/* Hidden\n   ========================================================================== */\n\n/**\n * Add the correct display in IE 10-.\n */\n\n[hidden] {\n  display: none;\n}\n", ""]);

// exports


/***/ }),
/* 241 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff;base64,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"

/***/ }),
/* 242 */
/***/ (function(module, exports) {

module.exports = "data:application/octet-stream;base64,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"

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/lego-icons.svg";

/***/ }),
/* 244 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff;base64,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"

/***/ }),
/* 245 */
/***/ (function(module, exports) {

module.exports = "data:application/octet-stream;base64,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AEwAbf/WAE0Ab//WAE4AcP/VAE8Acv/VAFAAc//UAFEAdf/UAFIAdv/TAFMAd//TAFQAef/SAFUAev/RAFYAfP/RAFcAff/QAFgAf//QAFkAgP/PAFoAgv/PAFsAg//OAFwAhP/OAF0Ahv/NAF4Ah//NAF8Aif/MAGAAiv/LAGEAjP/LAGIAjf/KAGMAjv/KAGQAkP/JAGUAkf/JAGYAk//IAGcAlP/IAGgAlv/HAGkAl//HAGoAmP/GAGsAmv/GAGwAm//FAG0Anf/EAG4Anv/EAG8AoP/DAHAAof/DAHEAov/CAHIApP/CAHMApf/BAHQAp//BAHUAqP/AAHYAqv/AAHcAq/+/AHgArf++AHkArv++AHoAr/+9AHsAsf+9AHwAsv+8AH0AtP+8AH4Atf+7AH8At/+7AIAAuP+6AIEAuf+6AIIAu/+5AIMAvP+4AIQAvv+4AIUAv/+3AIYAwf+3AIcAwv+2AIgAw/+2AIkAxf+1AIoAxv+1AIsAyP+0AIwAyf+0AI0Ay/+zAI4AzP+zAI8Azv+yAJAAz/+xAJEA0P+xAJIA0v+wAJMA0/+wAJQA1f+vAJUA1v+vAJYA2P+uAJcA2f+uAJgA2v+tAJkA3P+tAJoA3f+sAJsA3/+rAJwA4P+rAJ0A4v+qAJ4A4/+qAJ8A5P+pAKAA5v+pAKEA5/+oAKIA6f+oAKMA6v+nAKQA7P+nAKUA7f+mAKYA7v+mAKcA8P+lAKgA8f+kAKkA8/+kAKoA9P+jAKsA9v+jAKwA9/+iAK0A+f+iAK4A+v+hAK8A+/+hALAA/f+gALEA/v+gALIBAP+fALMBAf+eALQBA/+eALUBBP+dALYBBf+dALcBB/+cALgBCP+cALkBCv+bALoBC/+bALsBDf+aALwBDv+aAL0BD/+ZAL4BEf+ZAL8BEv+YAMABFP+XAMEBFf+XAMIBF/+WAMMBGP+WAMQBGf+VAMUBG/+VAMYBHP+UAMcBHv+UAMgBH/+TAMkBIf+TAMoBIv+SAMsBJP+RAMwBJf+RAM0BJv+QAM4BKP+QAM8BKf+PANABK/+PANEBLP+OANIBLv+OANMBL/+NANQBMP+NANUBMv+MANYBM/+MANcBNf+LANgBNv+KANkBOP+KANoBOf+JANsBOv+JANwBPP+IAN0BPf+IAN4BP/+HAN8BQP+HAOABQv+GAOEBQ/+GAOIBRP+FAOMBRv+EAOQBR/+EAOUBSf+DAOYBSv+DAOcBTP+CAOgBTf+CAOkBT/+BAOoBUP+BAOsBUf+AAOwBU/+AAO0BVP9/AO4BVv9/AO8BV/9+APABWf99APEBWv99APIBW/98APMBXf98APQBXv97APUBYP97APYBYf96APcBY/96APgBZP95APkBZf95APoBZ/94APsBaP93APwBav93AP0Ba/92AP4Bbf92AP8Bbv91AAAAFwAAAWQJDw4GBgUHBQMDBgQKBQQFAwcEBgUGBgcIBgMFBQQLBQcLCAYDAwcFBwQDBgMHCgkFBgUEBAcEBwYHBwQDBgMIDAcDBwMEAwUDBwMEAwMJBwYEBQMFBAQDBgMEBAMCBAUJDwQEBwMEBAYFDw8HBgsDAwYGBAYJBQoHBQMCBQMMBgcGCAgICAgPCAYDAwMDAwMDAwMDCQQEBAQEBAQEBAQHAwMDAwMDBQMDAwMDAwMDAwYFBQUFBQUDAwMDAwMFCwsHAwcDBgMDBwoJAwcKBQQICwQGCAoKBAMKBggKBgcDBQcGBQcGBgcDCAgIDAcHBwcHBwcHBwcHBwcHBwcDAwMDAwYHBwcHBwkJCQgICAgHBwcICAgIBwcHBwcHBwcKCgoKBwkHCQcHBwoGBgYGCgYGBgYGBgcHBwcHBwMDAwMEBwMFAwYGBgYGBQUFBQYGBgUFBQUHBAYGBgYGBgkJCQkHBwcHAAoRDwcHBQgGBAMHBQsGBAYECAUHBQYHBwgHBAYGBAwGBwwIBwQECAYIBQQHBAgLCgUGBQUECAQIBwgIBQMHBAkNCAQIAwUDBgQIAwQEAwoHBgQFAwYEBAMGBAQEAwMEBgoRBAQIAwUEBwYREQcHDAQEBwcEBwoGDAgGAwMFAw4GBwcICAgICBEIBwQEBAQEBAQEBAQKBAQEBAQEBAQEBAgEBAQEBAQGAwMDAwMDAwMDBwYGBgYGBgMDAwMEBAYMDAcDCAQHBAQHDAoDCAsGBQkMBAcJCwsEAwsHCQsGCAQGCAYGCAcHCAMICAgOCAgICAgICAgICAgICAgICAQEBAQEBgcICAgICgoKCQkJCQcHBwkJCQkICAgICAgICAwMDAwICggKBwcHDAcHBwcLBwcHBwcHBwcHBwgIAwMDAwQIAwUDBwcHBwcGBgYGBgYGBgYGBggEBgYGBgYGCgoKCgcHCAgACxIRCAgFCQYEBAcFDAYFBgQIBggFBwcICQcEBgYFDQYIDQkIBAQJBgkFBAcECAwLBgcGBQUIBAkHCQkFBAcECg8IBAgEBQQGBAgDBQQDCwgHBAUDBgUEAwcEBQQEAwQHCxIFBQgDBQQHBxISCAcNBAQICAUICwYNCQYEAwYEDwcICAkJCQkJEgkIBAQEBAQEBAQEBAsFBQUFBQUEBAQECQQEBAQEBAYEBAQEBAMDAwMHBgYGBgYGAwMDAwQEBg0NCAMJBAgEBAgNCwQJDAYFCg0FBwoMDAUDDQcJDAcIBAYJBwYJCAcIBAkJCQ8JCQkJCQkJCQkJCQkJCQkJBAQEBAQHCAgICAgLCwsJCQkJCAgICQkJCQgICQkJCQkJDQ0NDQkLCQsICAgNCAgICAwICAgICAgICAgICAgDAwMDBQkDBgMIBwcHBwYGBgYHBwcGBgYGCQUHBwcHBwcLCwsLCAgJCQAMFBIJCAYKBwUECAYNBwUHBQkGCAUICAgJCAUHBwUOBwgOCgkFBQkHCgUECAQJDQwGCAYFBQkFCggKCgYECAQLEAkECQQFBAcECQQFBQQMCAcEBQQHBQUDBwQFBQQDBQcMFAUFCQQGBQgHFBQJCA4FBQkJBQkMBw4KBwQDBgQQCAkICgoKCgoUCggFBQUFBQQEBAQEDAUFBQUFBQUFBQUKBAQEBAQEBwQEBAQEBAQEBAgHBwcHBwcEBAQEBAQHDg8JBAoFCQQECQ4MBAoNBwUKDgUICw0NBQQOCAoNBwkFBwkIBwkICAkECgoKEQkJCQkJCQkJCQkKCQoKCgoEBAQEBAgJCQkJCQwMDAoKCgoJCQkKCgoKCQkJCQkJCQkODg4OCgwKDAkJCQ4ICAgIDQgICAgICAkJCQkJCQQEBAQFCQQGBAgICAgIBwcHBwcHBwcHBwcKBQcHBwcHBwwMDAwJCQoKAA0WFAkJBwoHBQQIBg4HBgcFCQYJBggJCQoJBQcHBg8ICg8LCgUFCggLBQUIBQoODQYIBwYGCgUKCAsKBgQJBAwRCgUKBAUEBwUKBAYFBA0JCAUGBAcFBQQIBQUFBAMFCA4WBgYKBAYFCQgWFgkJDwUFCQkGCQ0HDwoHBAQHBBIICQkLCwsLCxYLCQUFBQUFBQUFBQUNBgYGBgYGBQUFBQoFBQUFBQUHBAQEBAQEBAQECQgICAgICAQEBAQFBQcPEAoECgUJBQUKDw0ECw4HBgsPBgkLDg4GBA8JCw4ICgUHCggHCgkJCgQLCwsSCgoKCgoKCgoKCgsKCwsLCwUFBQUFCAoKCgoKDQ0NCwsLCwoKCgsLCwsKCgoKCgoKCg8PDw8KDQoNCgoKDwkJCQkOCQkJCQkJCgoKCgoKBAQEBAYKBAcECQkJCQkICAgICAgIBwcHBwoFCAgICAgIDQ0NDQkJCwsADxkXCwoHDAgGBQoHEAgHCAYLBwoGCQoKDAoGCAgHEgkLEQ0LBgYMCQwGBQkGCxAPBwsHBgYLBgwJDAwHBQoFDhQLBgwFBgUIBgsFBwYFDwoJBQYFCAYFBAgFBgYFBAUJEBkGBgsFBwYKCRkZCwoSBgYLCwYLDggRDAgFBAgFFAoLCw0NDQ0NGQ0KBgYGBgYFBQUFBQ8GBgYGBgYGBgYGDAYGBgYGBgkFBQUFBQUFBQUKCQkJCQkJBQUFBQUFCBISCwUMBgsGBgsRDwUMEAgHDRIHCg0REQcFEQoNEAoLBggNCQkMCgoLBQ0NDRUMDAwMDAwMDAwMDAwMDAwMBQUFBQUJCwsLCwsPDw8NDQ0NCwsLDQ0NDQsLDAwMDAwMEREREQwPDA8LCwsRCgoKChAKCgoKCgoLCwsLCwsFBQUFBwwFCAUKCgoKCgkJCQkJCQkICAgIDAYJCQkJCQkPDw8PCwsMDAAQGxgLCwgNCQYFCggSCQcJBgsICwcKCwoNCwYJCQcTCQsSDQwGBgwJDQYGCgYMERAICwgHBwwGDQoNDQgFCwUPFQwGDAUGBQkGDAUHBgUQCwkFBwUJBwYFCQYGBwUEBgoRGwcHDAUIBwsKGxsMCxMGBgsLBwsPCRMNCQUECAUWCgwLDQ0NDQ0bDQsGBgYGBgYGBgYGEAcHBwcHBwYGBgYNBgYGBgYGCQUFBQUFBQUFBQsJCQkJCQkFBQUFBgYJExMMBQ0GCwYGDBMQBQ0RCQcOEwcLDhISBwUSCw4SCgwGCQ0KCQwLCwwFDQ0NFgwMDAwMDAwMDAwNDA0NDQ0GBgYGBgoMDAwMDBAQEA4ODg4MDAwODg4ODAwNDQ0NDQ0SEhISDRANEAwMDBILCwsLEQsLCwsLCwwMDAwMDAUFBQUHDAUIBQsLCwsLCQkJCQoKCgkJCQkNBwoKCgoKChAQEBAMDA0NABEcGgwMCA4KBgYLCBMJBwkGDQgM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GAwKEgsWHx0NEw4LDBYLFxEYFw4KFAkbJhYLFQoKChALFgkNCwkcFBIJCgkQDAoIDgoLDAoICRIeMAwNFgkODBMRMDAVEyILCxUVDBUaECIXEAoIDwonExUVGBgYGBgwGBQLCwsLCwoKCgoKHQwMDAwMDAsLCwsXCwsLCwsLEQoKCgoKCQkJCRQREREREREJCQkJCwsQIiIVCRcLFQsLFiIeChgfEA0ZIg0TGSAgDQkhExkgEhYLEBcSDxcUExYKGBgYKBYWFhYWFhcXFxcYFxgYGBgKCgoKChIVFhYWFh0dHRkZGRkVFRUZGRkZFhYXFxcXFxchISEhFxwXHBYWFiEUFBQUHxQUFBQUFBUVFRUWFgkJCQkNFgkPCRQUFBQUERERERISEhAQEBAXDBISEhISEh0dHR0VFRgYACA1MRcWEBoSDAsTDyMSDhIMFw8WDBQVFhoVDBISDiUTFyQbGQwMGRMbDQsUDBghIA4VDwwOGA0ZExsaEAsWCh4qGAwXCwsLEgwZCg4MCh8VEwoMChINCgkQCwwNCwgLEyE1Dg4YChANFRM1NRcVJgwMFxcOFx0SJRoSCwkRCysUFxcbGxsbGzUbFgwMDAwMCwsLCwwgDg4ODg4ODQ0NDRoMDAwMDAwSCwsLCwsKCgoKFhMTExMTEwoKCgoMDBIlJRgKGgwXDAwYJSELGiMSDhwmDhUcJCQOCiUVGyMUGAwSGhQRGRYVGAsbGxssGRkZGRkZGRkZGRsZGxsbGgsLCwsLFBgYGBgYICAgGxsbGxgYGBsbGxsYGBkZGRkZGSUlJSUaHxofGBgYJRYWFhYiFhYWFhYWGBgYGBgYCgoKCg4ZChAKFhYWFhYTExMTFBQUEhISEhoNFBQUFBQUICAgIBcXGhoAITcyFxcQGhMNCxMQJBIOEgwYDxcMFRYWGhYMEhIOJxMYJhwaDQ0aExsNDBQMGSIhDhUQDQ4ZDRoTGxoQCxYLHywZDBgLDAsSDBkKDw0KIBYUCwwKEw4KCRAMDA0LCQsUIjcODhkKEA0WFDc3GBYnDQ0XFw4YHhMmGhILCRELLRUYFxwcHBwcNxwXDQ0NDQ0MDAwMDSEODg4ODg4NDQ0NGgwMDAwMDBMLCwsLCwoKCgoWExMTExMTCgoKCgwMEicmGAobDRcMDBkmIgsbJBIPHScOFh0lJQ4KJhYcJBQZDBIaFREaFxYZCxwcHC4aGhoaGhoaGhoaGxobGxsbDAwMDAwVGBkZGRkhISEcHBwcGBgYHBwcHBkZGhoaGhoaJiYmJhogGiAZGRkmFxcXFyMXFxcXFxcYGBgYGRkKCgoKDxoKEQoXFhYWFhMTExMUFBQTExMTGg4UFBQUFBQhISEhGBgbGwAlPjgaGhIdFQ4MFxIoFRAVDhsSGg4XGRgdGA4VFRArFhoqHx0ODh0WHw8NGA4cJyUQGRIOEBwOHRUfHhINGQwjMRwOGg0NDRUOHAsQDgskGRULDgsVDwsLEw0NDwwKDRYmPhAQHAsSDxkWPj4bGSsODhoaEBohFSseFQ0KEwwyGBsaHx8fHx8+HxoODg4ODg0NDQ0OJRAQEBAQEA4ODg4eDg4ODg4OFQ0NDQ0NCwsLCxkWFhYWFhYLCwsLDQ0VKysbCx4OGg4OHCsmDB4oFREgLBAYICkpEAsqGCAoFhwOFR4XEx0aGBwNHx8fMx0dHR0dHR0dHR0fHR8fHx4NDQ0NDRcbHBwcHCUlJSAgICAbGxsgICAgHBwdHR0dHR0rKysrHiQeJBsbGysZGRkZKBoZGRkZGRsbGxscHAsLCwsQHQsTCxkZGRkZFhYWFhcXFxUVFRUdDxcXFxcXFyYmJiYbGx4eACpGQB4dFCEYEA4ZFC4XEhcQHxQdEBocHCAcEBcXEjEZHS8jIRAQIRgjEQ8bECArKhIbFQ8SIBAhGCMiFQ4cDSc3IBAeDg8OFxAgDRMQDSgcGQwPDRgRDAwWDw8RDgsOGSxGEhIgDRURHBlGRh8cMRAQHh4SHiYYMSIXDgsWDjkbHx4jIyMjI0YjHRAQEBAQDw8PDxAqEhISEhISEBAQECIQEBAQEBAYDg4ODg4NDQ0NHBkZGRkZGQ0NDQ0PDxcxMR8NIhAeEBAfMSsOIi0XEyUyEhwlLy8SDTAcJC4ZIBAXIhoWIR0cIA4jIyM6ISEhISEhISEhISMhIyMjIg8PDw8PGh8gICAgKioqJCQkJB8fHyQkJCQgICEhISEhITAwMDAiKSIpHx8fMB0dHR0tHR0dHR0dHx8fHyAgDQ0NDRMhDRUNHRwcHBwZGRkZGhoaGBgYGCERGhoaGhoaKysrKx8fIiIALk1GISAVJRoSDxwWMhoUGhEhFSARHR8fJB4RGhoUNhshNCYkEhIkGyYSEB0RIzAuFB8WERQjEiQaJiUWEB8PKz0jESAQEBAaESQOFBIOLB8aDRAOGhMODRgQERMPDA8cME0UFCMOFhMfHE1NIR82EhIhIRQhKRo1JRoQDBgPPh0iISYmJiYmTSYgEhISEhIQEBAQES4UFBQUFBQSEhISJRERERERERsQEBAQEA4ODg4fGxsbGxsbDg4ODhERGjY2Ig4lEiERESI1Lw8mMhoVKDYUHigzMxQONR4nMhwjERolHRgkIB4jECYmJkAkJCQkJCQkJCQkJiQmJiYmEBAQEBAdIiMjIyMuLi4nJycnIiIiJycnJyMjJCQkJCQkNTU1NSUtJS0iIiI1ICAgIDEgICAgICAiIiIiIyMODg4OFCQOFw4fHx8fHxsbGxscHBwaGhoaJRMcHBwcHBwvLy8vISEmJgAyU0wjIxgoHBMRHhg3HBYcEyQYIhMfIiEoIRMcHBY6HSQ5KigTEycdKhQSHxImNDIVIRkSFSYUKB4pKBgRIhAvQiYTJBESERwSJg8WEw8wIR0QEg8cFQ8OGRISFBENER40UxUWJg8YFCEeU1MkITsTEyMjFSQtHDooHBEOGhFEICQjKioqKipTKiMTExMTExISEhIUMhUVFRUVFRQUFBQoExMTExMTHRERERERDw8PDyIdHR0dHR0PDw8PEhIcOjslECgTIxISJTozECk2HBYsOxYhLDg4Fg85ISs3HyYTHCgfGycjISYRKioqRScnJycnJycnJycqJyoqKikSEhISEh8lJiYmJjIyMisrKyslJSUrKysrJiYnJycnJyc6Ojo6KDEoMSUlJToiIiIiNiIiIiIiIiUlJSUmJg8PDw8WJw8ZDyIiIiIiHR0dHR8fHxwcHBwoFR8fHx8fHzMzMzMkJCkpADZaUiYmGiseFRIgGjseGB4UKBolFCIkJCokFB4eGD8gJj0tKxUVKh8tFhMiFCk5NhcjGxQXKRUrIC0rGhMlETNHKRQnExMTHhQpEBgVETQlIBETER4WEBAbExQWEg4SIThaFxcpERoWJCBaWickPxUVJiYXJzAePyseEw8cEkkiJyYtLS0tLVotJRUVFRUVExMTExU2FxcXFxcXFRUVFSsUFBQUFBQfExMTExMQEBAQJSAgICAgIBEREREUFB4/PygRLBUmFBQoPzgSLDoeGC9AGCMvPDwXED4jLjshKRQeKyIdKiYjKRItLS1LKioqKioqKioqKi0q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CEsCJgA0AAAABwBe/6f/b///ADb/6wLoBrsCJgA0AAAABwBp/yf/rf//ADr/ogOCCcwCJgA4AAAABwBqAKACnP//AAf/WQK5BoICJgBAAAAABgA/jwAAAP//AFL/WQK5BzACJgBAAAAABwBqAIAAAP//AFL/WQLrBycCJgBAAAAABwBe/+X+S////37/WQN/B2sCJgBAAAAABwBr/u8AAP//AFL/WQK5BeECJgBAAAAABwBp/wf+0///AFL/WQK5BgsCJgBAAAAABwCF/mX+Df//AFL/WQROBPAAJgBAAAAABwBEAdIACv//ABX89AKFBR4CJgBCAAAABwBs/0kAAP///+v/6wJ8BoICJgBEAAAABwA//3MAAP//ABX/6wJ8BzACJgBEAAAABgBqZAAAAP//ABX/6wKvB48CJgBEAAAABwBe/6n+s///ABX/6wJ8BgsCJgBEAAAABwBp/tX+/QAD/z7/9gH4BoIADAAVACIAbbgACiu6AAMACgANK0EbAAYAAwAWAAMAJgADADYAAwBGAAMAVgADAGYAAwB2AAMAhgADAJYAAwCmAAMAtgADAMYAAwANXUEFANUAAwDlAAMAAl24AAMQuAAZ0LgAChC4ACDQALgABy+4AB0vMDETFwYREhMVByMiAxAzATc2AR8BBgAHARcGERITFQcjIgMQM7IuPAhSLixGJFr+qhoyAfBcInD+SCABAi48CFIuLEYkWgPyPD7+9P7k/vIeLgLCAToCXBIi/rIcMkIBLA7+MDw+/vT+5P7yHi4CwgE6AAAC/yz/9gIKBo4ADAAVAFm4AAorugADAAoADStBGwAGAAMAFgADACYAAwA2AAMARgADAFYAAwBmAAMAdgADAIYAAwCWAAMApgADALYAAwDGAAMADV1BBQDVAAMA5QADAAJdALgABy8wMRMXBhESExUHIyIDEDMBJgAnPwEAHwGyLjwIUi4sRiRaAQAi/jB2JGACCjYaA/I8Pv70/uT+8h4uAsIBOgH0DP76OiwYASQeEAAAAAAC/6r/9gIIBtIADAAcAGe4AAorugADAAoADStBGwAGAAMAFgADACYAAwA2AAMARgADAFYAAwBmAAMAdgADAIYAAwCWAAMApgADALYAAwDGAAMADV1BBQDVAAMA5QADAAJdALgABy+4AA0vugARAAcADRESOTAxExcGERITFQcj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COwCJgAgAAAABwDUAej/if//ABb/cgMiCd4CJgAgAAAABwDjAJoECv//ABb/cgU6C6IAJgAgAAAAJwAkAloACgAHAGoCqgRy//8AKP/mAzQKcgImACIAAAAHAGoBIgNC//8AKP/mA4QLpgImACIAAAAHAF4AfgLK//8AKP/mA60LBgImACIAAAAHAF//YwIi//8AKP/mAzQJmAImACIAAAAHAL8BxgK6//8ACP+wA0ELJgImACMAAAAHAF/+QwJC////y/+wA0EIAgImACMAAAAHAOP/W/7T//8ALv/aAuAKTgImACQAAAAHAL7/0wGS//8ALv/aAuALrgImACQAAAAHAF/+dQLK//8ALv/aAuAJqAImACQAAAAHAL8BCALK//8ALv/aAuAJPgImACQAAAAHAOMAHANq//8AJv+4A24J5gImACYAAAAHAL4ATAEq//8ALv6gAuAILAImACQAAAAHANQA1gAo//8AJv+4A24LpgImACYAAAAHAF7/1QLK//8AJv3kA24IGAImACYAAAAHAOUAsAAA//8AJv+4A24JqAImACYAAAAHAL8BIgLK////9f+XA0wLpgImACcAAAAHAF7/zQLK//8ANP/uAnoKBgImACgAAAAHAL4AAgFK//8ANP/uAboJsAImACgAAAAHAL8AvgLS////4f5xAboHnAImACgAAAAGANSp+QAA//8ANP/uArgIpgImACgAAAAHAOMAVALS//8ANP/uA0EJyAImACgAAABHAGv/6QMYLuk5tP//ACAAAAOYCZ4CJgApAAAABwBeAJIAwv//ACP95AMvByUCJgAqAAAABwDlAIAAAP//AEz/6gLCCfoCJgArAAAABwBqAEYCyv//AEz/6gLCCCYCJgArAAAABwBtAYQBOv//AEz95ALCB7YCJgArAAAABwDlAIgAAP//AEz/6gLCB7YCJgArAAAABwDcAUgAAP//ADr/0gO+CfoCJgAtAAAABwBqAMgCyv//ADr/0gO+C64CJgAtAAAABwBf/usCyv//ADr95AO+CEICJgAtAAAABwDlAQoAAP//AC8AAAM7CHcCJgAuAAAABgC+SrsAAP//AC8AAAM7CXICJgAuAAAABwDAADwBqv//AC8AAAM7CNoCJgAuAAAAJgAONAAABwBqACIBqgAA//8ALwAAAzsHtgImAC4AAAAHAOMAJAHi//8AF/8kAvYIsgImADEAAAAHAGoATAGC//8AF/8kAvYJDgImADEAAAAHAF/+PwAq//8AF/3kAvYGpAImADEAAAAGAOV+AAAA//8ASP7pBFMKcgImADIAAAAHAGoBYgNC//8ARfwFBFMIowImADIAAAAHAGz/Uf8R//8ASP7pBHYLpgImADIAAAAHAF4BcALK//8ASPy1BFMIowImADIAAAAHAOUBHv7R/////gAAA+oItwImADMAAAAHAF/+6//T/////v3kA+oFvgImADMAAAAHAOUAigAA//8ANv/rAugH9wImADQAAAAHAL4ALP87//8ANv/rAugGrgImADQAAAAHAOMATgDa//8ANv/rAugIsgImADQAAAAHAMAAEgDq//8ANv/rAugHuQImADQAAAAHAIX+Zf+7//8ANv54AugFiwImADQAAAAGANReAAAA////4v/rA+MH9QImADQAAAAHAGv/UwCK//8AT/+1BFoIggImADYAAAAHAGoA+gFS//8AT/+1BFoJvgImADYAAAAHAF4AlgDi//8AT/+1BFoHuAImADYAAAAHAGn/uwCq//8AT/+1BFoJTAImADYAAAAHAD8AugLK//8AOv+iA5ILDgImADgAAAAHAF4AjAIy//8AKwAAA74HmgImADkAAAAHAGoAuABq//8AOv+iA4IJTAImADgAAAAHAD8ABgLK//8AKwAAA74HAAImADkAAAAHAL8BIgAi//8AUv9ZArkGZQImAEAAAAAHAL7/9/2p//8AUv9ZArkF1AImAEAAAAAGAOMSAAAA//8AUv6IAyAEnwImAEAAAAAHANQBhgAQ//8AUv9ZBE4HMAAmAEAAAAAnAEQB0gAKAAcAagESAAD//wAV/+cCfAcwAiYAQgAAAAYAaiIAAAD//wAV/+cCjwjkAiYAQgAAAAcAX/5FAAD//wAV/+cCjwjcAiYAQgAAAAYAXokAAAD//wAV/+cCfAbeAiYAQgAAAAcAvwDYAAD//wA//9IDzAbsACYAQwAAAAcAbQLCAAD//wA//9ID4gZ5AiYAQwAAAAcADACyAaD//wAV/+sCggbtAiYARAAAAAcAvgAK/jH//wAV/+sCfAedAiYARAAAAAcAX/4t/rn//wAV/+sCfAbeAiYARAAAAAcAvwDYAAD//wAV/+sCfAXUAiYARAAAAAYA4/cAAAD//wAV/ngCfATmAiYARAAAAAcA1ADiAAD//wAa/BwCzAaFAiYARgAAAAcAvgBE/cn//wAa/BwDYgetAiYARgAAAAcAXgBc/tH//wAa/BwCzAc+AiYARgAAAAcAbgF8AFL//wAa/BwCzAbeAiYARgAAAAcAvwDyAAD///+t/8YC2gb6AiYARwAAAAcA4/89/yn//wAK/8YDrge1AiYARwAAAAcAXgCo/tkAAv/I//YB3gYkAAwAEwBnuAAKK7oAAwAKAA0rQRsABgADABYAAwAmAAMANgADAEYAAwBWAAMAZgADAHYAAwCGAAMAlgADAKYAAwC2AAMAxgADAA1dQQUA1QADAOUAAwACXQC4AAcvuAARL7oAEgAHABEREjkwMRMXBhESExUHIyIDEDMDNx4BNxcAsi48CFIuLEYkWswqiICiQv78A/I8Pv70/uT+8h4uAsIBOgHoLsIG5Ar9tAAAAAL/ov/2AZYF1AAMABIAZbgACiu6AAMACgANK0EbAAYAAwAWAAMAJgADADYAAwBGAAMAVgADAGYAAwB2AAMAhgADAJYAAwCmAAMAtgADAMYAAwANXUEFANUAAwDlAAMAAl0AuAASL7gABy+6AA4AEQANKzAxExcGERITFQcjIgMQMxM3FyYFN7IuPAhSLixGJFrSLATM/tgGA/I8Pv70/uT+8h4uAsIBOgHQBnImEGj//wAj/pgBhQV4AiYASAAAAAYA1OsgAAAAAv6a//YCnAdqAAwAIQBduAAKK7oAAwAKAA0rQRsABgADABYAAwAmAAMANgADAEYAAwBWAAMAZgADAHYAAwCGAAMAlgADAKYAAwC2AAMAxgADAA1dQQUA1QADAOUAAwACXQC4AAcvuAAZLzAxExcGERITFQcjIgMQMwEGLwEmLwEmDwEnNjcXEh8BFjcfAbIuPAhSLixGJFoCAsbQeMocDGBCCFIq5Cy2ehakvhYKA/I8Pv70/uT+8h4uAsIBOgKM/DpI7AgEGqAyCv4eGP7yIgYuvgYOAAAAAv9Q+6oCKgbEABMAIwAjuAAKK7oABAAQAA0ruAAQELgAAdAAuAAUL7oADgAHAA0rMDETFwcSERUQISY9ATMfATMyEQIDNhMzMhMXIicCJyMGDwEjNRLILA5o/qimHmoOHvAsahZmHj7gFJYUdCIQWmo8DtYEGizE/Nj/AEz89FaaWtIOAwwC4gHOSgKq/dY2ngEIBl7sLEoB4AD//wAM/eQC+gZRAiYASgAAAAcA5QCSAAD////b/+YBYwmAAiYASwAAAAcAav9jAlD//wBM/+YBvAhkACYASwAAAAcAbQCyAXj//wAV/eQBKQfeAiYASwAAAAYA5aUAAAD//wBM/+YCNgfeACYASwAAAAcA3AE6AAD//wAo/7QCgAcwAiYATQAAAAYAah4AAAD//wAR/+wCaQdUAiYATek4AAcA5f/ZB8r//wAo/7QCiwf1AiYATQAAAAcAX/5B/xH//wAo/eQCgAUmAiYATQAAAAYA5WAAAAD//wAb/9YCMgalAiYATgAAAAcAvv+5/en//wAH/9YCVQfIAiYATgAAAAYAwJ8AAAD//wAz/9YCMgXUAiYATgAAAAYA48MAAAD//wAI/wgCMgcwAiYATgAAACcADv+D/wEABgBq8QAAAP//ACIABAJNBzACJgBRAAAABgBqAAAAAP//AA0ABAJrCOQCJgBRAAAABwBf/iEAAP//ACL95AJNBKUCJgBRAAAABgDlQAAAAP///77/1gIWBzACJgBSAAAABgBq5wAAAP///7789AJHBOACJgBSAAAABwBs/wsAAP///77/1gJRCNwCJgBSAAAABwBe/0sAAP///7795AIWBOACJgBSAAAABgDlJgAAAP///8j//AK0BwAAJgBTAAAABwBtAaoAAP///8j95AG6BwACJgBTAAAABgDl3QAAAP//ACf/7wJSCLwCJgBUAAAABgC+zwAAAP//ABX/7wJjB8gCJgBUAAAABgDArQAAAP//ACf/7wJSBdQCJgBUAAAABgDj0wAAAP//ACf+eAJSBFQCJgBUAAAABwDUALgAAP//ACf/7wJSB/4CJgBUAAAABwCF/i8AAP///zz/7wM9B2sCJgBUAAAABwBr/q0AAP//ACsAAAO+BzACJgBWAAAABwBqAMoAAP//ACsAAAO+CNwCJgBWAAAABgBeMAAAAP//ACsAAAO+Bw4CJgBWAAAABgBpnQAAAP//ACsAAAO+BoICJgBWAAAABgA/cgAAAP//AC78igKlCNwCJgBYAAAABgBenwAAAP//AC78igKkBoICJgBYAAAABgA/4QAAAP//ACj/1gMHBzACJgBZAAAABgBqZgAAAP//ACj/1gMHBt4CJgBZAAAABwC/ARoAAAAAAAAAMAC0AUYBggIGAiQCVAKEAuADGAM4A1IDbAOMA/IEIARYBOIFIgVkBboGDgZiBroG5gciB0oHcgeaCAAIrgjuCXgJtAnwCjgKfArCC0oLdAuyC/oMMAyuDRgNWA3KDi4OhA7EDwgPQg90D/AQMBB6ELQQ4BEEEUQRbhGUEaoR9hJIEnoS0BMaE2ITtBQaFHAUthUGFTwVpBXuFlgWzhdSF5QXxBgkGGYYmhj0GSwZghnAGhQaThqqGqoa0Br2GwIbDhsaGyYbMhtCG24bwBv4HBwcNBxgHIYcpBzCHPIdIh0uHTod8B38HggeFB4gHpIenh6qHrYezB7gHvYfAh8OHxofJh8yHz4fnh+qH7Yfwh/OH9of5h/yH/4gCiAWICIggCCMIJggpCCwILwgyCDUIOAg7CD4IQQhECEcISghNCFAIUwhWCFkIXAhfCGIIZQhoCIYInIi2CM4I0QjUCNcI2gjdCOAI4wjmCOkI7AjvCPII9Qj/iQsJHoklCSwJNwk+iUqJTYlQiWYJdQmSiZ4JrgnAidIJ1QnfifEJ9gn9igYKHQo1Cj8KUYpaCmGKfAqUiqoKuIq9isEK44r3CxELJAs1CzyLRQtLi06LUYtUi1iLW4tei2GLZItni2qLbYtwi3OLdot5i3yLf4uCi4WLiIuLi46LkYuUi5gLmwueC6ELpAunC6oLrQuwC7MLtgu5C70LwAvDC8YLyQvMC88L0gvVC9gL2wveC+EL5AvnC+oL7QvwC/ML9gv5C/wL/wwCDAUMCAwLDA4MEgwVDBgMGwweDCEMJAwnDCoMLQwwDDMMNgw5DDwMPwxCDEUMXAxyDHUMkAyjjKaMqYysjK+Msoy1jLiMu4y+jMGMxIzHjMuMzozRjNSM14zajN2M4IzjjOaM6YzsjO+M8oz1jPiM+4z+jQGNBI0HjQqNDY0QgAAADACRgABAAAAAAAAADwAAAABAAAAAAABABEAPAABAAAAAAACAAcATQABAAAAAAADAB4AVAABAAAAAAAEABEAcgABAAAAAAAFABIAgwABAAAAAAAGAA4AlQABAAAAAAAIABAAowABAAAAAAAJABAAswABAAAAAAAKADwAwwABAAAAAAAMABoA/wABAAAAAAANAIUBGQADAAEEAwACAAwBngADAAEEBQACABABqgADAAEEBgACAAwBugADAAEEBwACABABxgADAAEECAACABAB1gADAAEECQAAAHgB5gADAAEECQABACICXgADAAEECQACAA4CgAADAAEECQADADwCjgADAAEECQAEACICygADAAEECQAFACQC7AADAAEECQAGABwDEAADAAEECQAIACADLAADAAEECQAJACADTAADAAEECQAKAHgDbAADAAEECQAMADQD5AADAAEECQANAQoEGAADAAEECgACAAwFIgADAAEECwACABAFLgADAAEEDAACAAwFPgADAAEEDgACAAwFSgADAAEEEAACAA4FVgADAAEEEwACABIFZAADAAEEFAACAAwFdgADAAEEFQACABAFggADAAEEFgACAAwFkgADAAEEGQACAA4FngADAAEEGwACABAFrAADAAEEHQACAAwFvAADAAEEHwACAAwFyAADAAEEJAACAA4F1AADAAEELQACAA4F4gADAAEICgACAAwF8AADAAEIFgACAAwF/AADAAEMCgACAAwGCAADAAEMDAACAAwGFENvcHlyaWdodCAoYykgMjAwNiBieSBLaW1iZXJseSBHZXN3ZWluLiBBbGwgcmlnaHRzIHJlc2VydmVkLkxvdmVkIGJ5IHRoZSBLaW5nUmVndWxhckxvdmVkIGJ5IHRoZSBLaW5nOlZlcnNpb24gMS4wMExvdmVkIGJ5IHRoZSBLaW5nVmVyc2lvbiAxLjAwMiAyMDA2TG92ZWRieXRoZUtpbmdLaW1iZXJseSBHZXN3ZWluS2ltYmVybHkgR2Vzd2VpbkNvcHlyaWdodCAoYykgMjAwNiBieSBLaW1iZXJseSBHZXN3ZWluLiBBbGwgcmlnaHRzIHJlc2VydmVkLmh0dHA6Ly9raW1iZXJseWdlc3dlaW4uY29tRnJlZSBmb3IgcGVyc29uYWwgdXNlLiAgRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgbWFrZSBhIG9uZS10aW1lIFVTJDUgcGF5bWVudCB0byBnZXN3ZWluZmFtaWx5QGdtYWlsLmNvbSB2aWEgcGF5cGFsLmNvbSAgVGhhbmsgeW91IQBOAG8AcgBtAGEAbABvAGIAeQENAGUAagBuAOkAbgBvAHIAbQBhAGwAUwB0AGEAbgBkAGEAcgBkA5oDsQO9A78DvQO5A7oDrABDAG8AcAB5AHIAaQBnAGgAdAAgACgAYwApACAAMgAwADAANgAgAGIAeQAgAEsAaQBtAGIAZQByAGwAeQAgAEcAZQBzAHcAZQBpAG4ALgAgAEEAbABsACAAcgBpAGcAaAB0AHMAIAByAGUAcwBlAHIAdgBlAGQALgBMAG8AdgBlAGQAIABiAHkAIAB0AGgAZQAgAEsAaQBuAGcAUgBlAGcAdQBsAGEAcgBMAG8AdgBlAGQAIABiAHkAIAB0AGgAZQAgAEsAaQBuAGcAOgBWAGUAcgBzAGkAbwBuACAAMQAuADAAMABMAG8AdgBlAGQAIABiAHkAIAB0AGgAZQAgAEsAaQBuAGcAVgBlAHIAcwBpAG8AbgAgADEALgAwADAAMgAgADIAMAAwADYATABvAHYAZQBkAGIAeQB0AGgAZQBLAGkAbgBnAEsAaQBtAGIAZQByAGwAeQAgAEcAZQBzAHcAZQBpAG4ASwBpAG0AYgBlAHIAbAB5ACAARwBlAHMAdwBlAGkAbgBDAG8AcAB5AHIAaQBnAGgAdAAgACgAYwApACAAMgAwADAANgAgAGIAeQAgAEsAaQBtAGIAZQByAGwAeQAgAEcAZQBzAHcAZQBpAG4ALgAgAEEAbABsACAAcgBpAGcAaAB0AHMAIAByAGUAcwBlAHIAdgBlAGQALgBoAHQAdABwADoALwAvAGsAaQBtAGIAZQByAGwAeQBnAGUAcwB3AGUAaQBuAC4AYwBvAG0ARgByAGUAZQAgAGYAbwByACAAcABlAHIAcwBvAG4AYQBsACAAdQBzAGUALgAgACAARgBvAHIAIABjAG8AbQBtAGUAcgBjAGkAYQBsACAAdQBzAGUALAAgAHAAbABlAGEAcwBlACAAbQBhAGsAZQAgAGEAIABvAG4AZQAtAHQAaQBtAGUAIABVAFMAJAA1ACAAcABhAHkAbQBlAG4AdAAgAHQAbwAgAGcAZQBzAHcAZQBpAG4AZgBhAG0AaQBsAHkAQABnAG0AYQBpAGwALgBjAG8AbQAgAHYAaQBhACAAcABhAHkAcABhAGwALgBjAG8AbQAgACAAVABoAGEAbgBrACAAeQBvAHUAIQBOAG8AcgBtAGEAbABOAG8AcgBtAGEAYQBsAGkATgBvAHIAbQBhAGwATgBvAHIAbQDhAGwATgBvAHIAbQBhAGwAZQBTAHQAYQBuAGQAYQBhAHIAZABOAG8AcgBtAGEAbABOAG8AcgBtAGEAbABuAHkATgBvAHIAbQBhAGwEHgQxBEsERwQ9BEsEOQBOAG8AcgBtAOEAbABuAGUATgBvAHIAbQBhAGwATgBvAHIAbQBhAGwATgBhAHYAYQBkAG4AbwBBAHIAcgB1AG4AdABhAE4AbwByAG0AYQBsAE4AbwByAG0AYQBsAE4AbwByAG0AYQBsAE4AbwByAG0AYQBsAAAAAgAAAAAAAP8mAJYAAAAAAAAAAAAAAAAAAAAAAAAAAAFhAAAABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAAMA2ADhAMAAwQDiAOMA5gDnAGEBAgCrAI4AjQDZAN4AtwC2ALQAtQDkALAAjADlALEAuwCjAIQA8gDzAPEA9QD0APYAogCtAMkAxwCuAGIA3QBjAJAAZADLAGUAyADKAM8AzADNAM4A6QBmANMA0ADRAK8AZwCRANYA1ADVAGgA6wBqAGkAawBtAGwAbgCgAG8AcQBwAHIAcwB1AHQAdgB3AHgAegB5AHsAfQB8AKEAfwB+AIAAgQDsALoABAC/AKoA2wDcAN8AxADFAJ4AgwCWAIUAvQDoAIYAiwCmAJ0AvgCpAIcAsgCzAIIAwgDgANcApADvAIoAkwCXAIgBAwC4AIkA7QDuAOoA8AEEALwBBQEGAQcBCAEJAP0BCgD/AQsBDAENAQ4BDwEQAREA+AESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAD7AS0BLgEvATABMQEyATMBNAE1ATYBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIA/gEAAUMBRAFFAUYBRwFIAUkBSgFLAPkBTAFNAU4BTwFQAVEBUgFTAVQBVQFWAVcBWAFZAVoBWwFcAV0BXgFfAWABYQFiAWMBZAFlAWYA/AFnAWgBaQFqAWsBbAFtAW4BbwFwAXEBcgFzAXQBdQF2AXcBeARFdXJvDnBlcmlvZGNlbnRlcmVkBm1hY3Jvbgtjb21tYWFjY2VudAZBYnJldmUHQW9nb25lawdBbWFjcm9uB0FFYWN1dGULQ2NpcmN1bWZsZXgKQ2RvdGFjY2VudAZEY2Fyb24GRGNyb2F0BkVicmV2ZQZFY2Fyb24KRWRvdGFjY2VudAdFbWFjcm9uB0VvZ29uZWsLR2NpcmN1bWZsZXgMR2NvbW1hYWNjZW50Ckdkb3RhY2NlbnQLSGNpcmN1bWZsZXgGSWJyZXZlCklkb3RhY2NlbnQHSW9nb25lawdJbWFjcm9uBkl0aWxkZQtKY2lyY3VtZmxleAxLY29tbWFhY2NlbnQGTGFjdXRlBkxjYXJvbgxMY29tbWFhY2NlbnQETGRvdAZOYWN1dGUGTmNhcm9uDE5jb21tYWFjY2VudAZPYnJldmUNT2h1bmdhcnVtbGF1dAtPc2xhc2hhY3V0ZQdPbWFjcm9uBlJhY3V0ZQZSY2Fyb24MUmNvbW1hYWNjZW50BlNhY3V0ZQtTY2lyY3VtZmxleAxTY29tbWFhY2NlbnQGVGNhcm9uDFRjb21tYWFjY2VudAZVYnJldmUHVW1hY3Jvbg1VaHVuZ2FydW1sYXV0BVVyaW5nB1VvZ29uZWsGVXRpbGRlBldhY3V0ZQtXY2lyY3VtZmxleAlXZGllcmVzaXMGV2dyYXZlC1ljaXJjdW1mbGV4BlphY3V0ZQZZZ3JhdmUKWmRvdGFjY2VudAZhYnJldmUHYW1hY3Jvbgdhb2dvbmVrB2FlYWN1dGULY2NpcmN1bWZsZXgKY2RvdGFjY2VudAZkY2Fyb24GZGNyb2F0BmVicmV2ZQZlY2Fyb24KZWRvdGFjY2VudAdlbWFjcm9uB2VvZ29uZWsLZ2NpcmN1bWZsZXgMZ2NvbW1hYWNjZW50Cmdkb3RhY2NlbnQEaGJhcgtoY2lyY3VtZmxleAZpYnJldmUHaW1hY3Jvbgdpb2dvbmVrBml0aWxkZQtqY2lyY3VtZmxleAxrY29tbWFhY2NlbnQGbGFjdXRlBmxjYXJvbgxsY29tbWFhY2NlbnQEbGRvdAZuYWN1dGULbmFwb3N0cm9waGUGbmNhcm9uDG5jb21tYWFjY2VudAZvYnJldmUNb2h1bmdhcnVtbGF1dAdvbWFjcm9uC29zbGFzaGFjdXRlBnJhY3V0ZQZyY2Fyb24McmNvbW1hYWNjZW50BnNhY3V0ZQtzY2lyY3VtZmxleAxzY29tbWFhY2NlbnQGdGNhcm9uDHRjb21tYWFjY2VudAZ1YnJldmUNdWh1bmdhcnVtbGF1dAd1bWFjcm9uB3VvZ29uZWsFdXJpbmcGdXRpbGRlBndhY3V0ZQt3Y2lyY3VtZmxleAl3ZGllcmVzaXMGd2dyYXZlC3ljaXJjdW1mbGV4BnlncmF2ZQZ6YWN1dGUKemRvdGFjY2VudAAAAAAB//8AAg=="

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "assets/LovedbytheKing.svg";

/***/ }),
/* 247 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0;

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
}

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function createStyleElement() {
	var styleElement = document.createElement("style");
	var head = getHeadElement();
	styleElement.type = "text/css";
	head.appendChild(styleElement);
	return styleElement;
}

function createLinkElement() {
	var linkElement = document.createElement("link");
	var head = getHeadElement();
	linkElement.rel = "stylesheet";
	head.appendChild(linkElement);
	return linkElement;
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement());
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement();
		update = updateLink.bind(null, styleElement);
		remove = function() {
			styleElement.parentNode.removeChild(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement();
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			styleElement.parentNode.removeChild(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;
	var sourceMap = obj.sourceMap;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, obj) {
	var css = obj.css;
	var media = obj.media;
	var sourceMap = obj.sourceMap;

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMTgyMjE2ZWYxODE2NGFiZmExN2EiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5zdHJ1bWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1Bvb2xlZENsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NTGF6eVRyZWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRXZlbnRQcm9wYWdhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpbkh1Yi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5zdGFuY2VNYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvUGF0aFV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luUmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljTW91c2VFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9zZXRJbm5lckhUTUwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW52YXJpYW50L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvbG93UHJpb3JpdHlXYXJuaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRFdmVudFRhcmdldC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01DaGlsZHJlbk9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NTmFtZXNwYWNlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0xpbmtlZFZhbHVlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0tleUVzY2FwZVV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvTG9jYXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0QmFzZUNsYXNzZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudEZsYWdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2ZvckVhY2hBY2N1bXVsYXRlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRUZXh0Q29udGVudEFjY2Vzc29yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NhbGxiYWNrUXVldWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RGZWF0dXJlRmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvaW5wdXRWYWx1ZVRyYWNraW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2lzVGV4dElucHV0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9WaWV3cG9ydE1ldHJpY3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9DU1NQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE5vZGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5wdXRTZWxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RNb3VudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1JvdXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvY29udGVudC5qc29uIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL3N0eWxlcy9mb250cy9sZWdvLWljb25zLmVvdCIsIndlYnBhY2s6Ly8vLi9zdHlsZXMvZm9udHMvTG92ZWRieXRoZUtpbmcuZW90Iiwid2VicGFjazovLy8uL3NjcmlwdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvS2V5RXNjYXBlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2NoZWNrUmVhY3RUeXBlU3BlYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2NyZWF0ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jcmVhdGUtcmVhY3QtY2xhc3MvZmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3JlYXRlLXJlYWN0LWNsYXNzL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET00uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0FSSUFET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9CZWZvcmVJbnB1dEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RSZWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEludmFsaWRTZXRTdGF0ZVdhcm5pbmdIb29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0hUTUxET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9EYW5nZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01JRE9wZXJhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQXV0b0ZvY3VzVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHlPcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL21lbW9pemVTdHJpbmdPbmx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01JbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0TXVsdGlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENoaWxkUmVjb25jaWxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9nZXROZXh0RGVidWdJRC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEVsZW1lbnRTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbmplY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TZWxlY3RFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNBbmltYXRpb25FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNGb2N1c0V2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRLZXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljRHJhZ0V2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NRmVhdHVyZUZsYWdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZmluZERPTU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUludmFsaWRBUklBSG9vay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9SZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGF0aC10by1yZWdleHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3RhdGljUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvU3dpdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9jb25maWcuanNvbiIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2V4cGVyaWVuY2VzL0hvbWUuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9jb21wb25lbnRzL01ldGFUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9jb21wb25lbnRzL05hdmlnYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9IYXNoUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL01lbW9yeVJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9OYXZMaW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1Byb21wdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9SZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Sb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvU3RhdGljUm91dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N3aXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9tYXRjaFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvd2l0aFJvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2NvbXBvbmVudHMvUHJlc2VudGF0aW9uLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvc2VydmljZXMvQ29udGVudFNlcnZpY2VzLmpzIiwid2VicGFjazovLy8uL3NjcmlwdHMvY29tcG9uZW50cy9IZWFkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzL21haW4ubGVzcz85ODc3Iiwid2VicGFjazovLy8uL3N0eWxlcy9tYWluLmxlc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzcyIsIndlYnBhY2s6Ly8vLi9zdHlsZXMvZm9udHMvbGVnby1pY29ucy53b2ZmIiwid2VicGFjazovLy8uL3N0eWxlcy9mb250cy9sZWdvLWljb25zLnR0ZiIsIndlYnBhY2s6Ly8vLi9zdHlsZXMvZm9udHMvbGVnby1pY29ucy5zdmciLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzL2ZvbnRzL0xvdmVkYnl0aGVLaW5nLndvZmYiLCJ3ZWJwYWNrOi8vLy4vc3R5bGVzL2ZvbnRzL0xvdmVkYnl0aGVLaW5nLnR0ZiIsIndlYnBhY2s6Ly8vLi9zdHlsZXMvZm9udHMvTG92ZWRieXRoZUtpbmcuc3ZnIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwidmFsaWRhdGVGb3JtYXQiLCJmb3JtYXQiLCJOT0RFX0VOViIsInVuZGVmaW5lZCIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImEiLCJiIiwiYyIsImQiLCJmIiwiZXJyb3IiLCJhcmdJbmRleCIsInJlcGxhY2UiLCJmcmFtZXNUb1BvcCIsImVtcHR5RnVuY3Rpb24iLCJyZXF1aXJlIiwid2FybmluZyIsInByaW50V2FybmluZyIsIl9sZW4iLCJfa2V5IiwibWVzc2FnZSIsImNvbnNvbGUiLCJ4IiwiaW5kZXhPZiIsIl9sZW4yIiwiX2tleTIiLCJyZWFjdFByb2RJbnZhcmlhbnQiLCJjb2RlIiwiYXJnQ291bnQiLCJhcmdJZHgiLCJlbmNvZGVVUklDb21wb25lbnQiLCJfcHJvZEludmFyaWFudCIsIkRPTVByb3BlcnR5IiwiUmVhY3RET01Db21wb25lbnRGbGFncyIsIkFUVFJfTkFNRSIsIklEX0FUVFJJQlVURV9OQU1FIiwiRmxhZ3MiLCJpbnRlcm5hbEluc3RhbmNlS2V5IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJzaG91bGRQcmVjYWNoZU5vZGUiLCJub2RlIiwibm9kZUlEIiwibm9kZVR5cGUiLCJnZXRBdHRyaWJ1dGUiLCJTdHJpbmciLCJub2RlVmFsdWUiLCJnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50IiwiY29tcG9uZW50IiwicmVuZGVyZWQiLCJfcmVuZGVyZWRDb21wb25lbnQiLCJwcmVjYWNoZU5vZGUiLCJpbnN0IiwiaG9zdEluc3QiLCJfaG9zdE5vZGUiLCJ1bmNhY2hlTm9kZSIsInByZWNhY2hlQ2hpbGROb2RlcyIsIl9mbGFncyIsImhhc0NhY2hlZENoaWxkTm9kZXMiLCJjaGlsZHJlbiIsIl9yZW5kZXJlZENoaWxkcmVuIiwiY2hpbGROb2RlIiwiZmlyc3RDaGlsZCIsIm91dGVyIiwiaGFzT3duUHJvcGVydHkiLCJjaGlsZEluc3QiLCJjaGlsZElEIiwiX2RvbUlEIiwibmV4dFNpYmxpbmciLCJnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSIsInBhcmVudHMiLCJwYXJlbnROb2RlIiwiY2xvc2VzdCIsInBvcCIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwiX2hvc3RQYXJlbnQiLCJSZWFjdERPTUNvbXBvbmVudFRyZWUiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJPYmplY3QiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsImFzc2lnbiIsInRlc3QxIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibWFwIiwibiIsImpvaW4iLCJ0ZXN0MyIsInNwbGl0IiwiZm9yRWFjaCIsImxldHRlciIsImtleXMiLCJlcnIiLCJ0YXJnZXQiLCJzb3VyY2UiLCJmcm9tIiwidG8iLCJzeW1ib2xzIiwicyIsImtleSIsImNhblVzZURPTSIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIkV4ZWN1dGlvbkVudmlyb25tZW50IiwiY2FuVXNlV29ya2VycyIsIldvcmtlciIsImNhblVzZUV2ZW50TGlzdGVuZXJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwiY2FuVXNlVmlld3BvcnQiLCJzY3JlZW4iLCJpc0luV29ya2VyIiwiTWVtb3J5Um91dGVyIiwiUHJvbXB0IiwiUmVkaXJlY3QiLCJSb3V0ZSIsIlJvdXRlciIsIlN0YXRpY1JvdXRlciIsIlN3aXRjaCIsIm1hdGNoUGF0aCIsIndpdGhSb3V0ZXIiLCJSZWFjdEN1cnJlbnRPd25lciIsImlzTmF0aXZlIiwiZm4iLCJmdW5jVG9TdHJpbmciLCJGdW5jdGlvbiIsInJlSXNOYXRpdmUiLCJSZWdFeHAiLCJ0ZXN0IiwiY2FuVXNlQ29sbGVjdGlvbnMiLCJNYXAiLCJTZXQiLCJzZXRJdGVtIiwiZ2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJnZXRJdGVtSURzIiwiYWRkUm9vdCIsInJlbW92ZVJvb3QiLCJnZXRSb290SURzIiwiaXRlbU1hcCIsInJvb3RJRFNldCIsImlkIiwiaXRlbSIsInNldCIsImdldCIsImFkZCIsIml0ZW1CeUtleSIsInJvb3RCeUtleSIsImdldEtleUZyb21JRCIsImdldElERnJvbUtleSIsInBhcnNlSW50Iiwic3Vic3RyIiwidW5tb3VudGVkSURzIiwicHVyZ2VEZWVwIiwiY2hpbGRJRHMiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZ2V0RGlzcGxheU5hbWUiLCJlbGVtZW50IiwidHlwZSIsImRpc3BsYXlOYW1lIiwiZGVzY3JpYmVJRCIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJnZXRFbGVtZW50Iiwib3duZXJJRCIsImdldE93bmVySUQiLCJfc291cmNlIiwib25TZXRDaGlsZHJlbiIsIm5leHRDaGlsZElEcyIsIm5leHRDaGlsZElEIiwibmV4dENoaWxkIiwiaXNNb3VudGVkIiwicGFyZW50SUQiLCJvbkJlZm9yZU1vdW50Q29tcG9uZW50IiwidGV4dCIsInVwZGF0ZUNvdW50Iiwib25CZWZvcmVVcGRhdGVDb21wb25lbnQiLCJvbk1vdW50Q29tcG9uZW50IiwiaXNSb290Iiwib25VcGRhdGVDb21wb25lbnQiLCJvblVubW91bnRDb21wb25lbnQiLCJwdXJnZVVubW91bnRlZENvbXBvbmVudHMiLCJfcHJldmVudFB1cmdpbmciLCJnZXRDdXJyZW50U3RhY2tBZGRlbmR1bSIsInRvcEVsZW1lbnQiLCJpbmZvIiwib3duZXIiLCJfb3duZXIiLCJnZXROYW1lIiwiY3VycmVudE93bmVyIiwiY3VycmVudCIsIl9kZWJ1Z0lEIiwiZ2V0U3RhY2tBZGRlbmR1bUJ5SUQiLCJnZXRQYXJlbnRJRCIsImdldENoaWxkSURzIiwiZ2V0U291cmNlIiwiZ2V0VGV4dCIsImdldFVwZGF0ZUNvdW50IiwiZ2V0UmVnaXN0ZXJlZElEcyIsInB1c2hOb25TdGFuZGFyZFdhcm5pbmdTdGFjayIsImlzQ3JlYXRpbmdFbGVtZW50IiwiY3VycmVudFNvdXJjZSIsInJlYWN0U3RhY2siLCJzdGFjayIsInBvcE5vblN0YW5kYXJkV2FybmluZ1N0YWNrIiwicmVhY3RTdGFja0VuZCIsIm1ha2VFbXB0eUZ1bmN0aW9uIiwiYXJnIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNOdWxsIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsImRlYnVnVG9vbCIsIlJlYWN0RGVidWdUb29sIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiaXNWYWxpZEVsZW1lbnQiLCJvYmplY3QiLCIkJHR5cGVvZiIsInRocm93T25EaXJlY3RBY2Nlc3MiLCJfYXNzaWduIiwiQ2FsbGJhY2tRdWV1ZSIsIlBvb2xlZENsYXNzIiwiUmVhY3RGZWF0dXJlRmxhZ3MiLCJSZWFjdFJlY29uY2lsZXIiLCJUcmFuc2FjdGlvbiIsImRpcnR5Q29tcG9uZW50cyIsInVwZGF0ZUJhdGNoTnVtYmVyIiwiYXNhcENhbGxiYWNrUXVldWUiLCJnZXRQb29sZWQiLCJhc2FwRW5xdWV1ZWQiLCJiYXRjaGluZ1N0cmF0ZWd5IiwiZW5zdXJlSW5qZWN0ZWQiLCJSZWFjdFVwZGF0ZXMiLCJSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiTkVTVEVEX1VQREFURVMiLCJpbml0aWFsaXplIiwiZGlydHlDb21wb25lbnRzTGVuZ3RoIiwiY2xvc2UiLCJzcGxpY2UiLCJmbHVzaEJhdGNoZWRVcGRhdGVzIiwiVVBEQVRFX1FVRVVFSU5HIiwiY2FsbGJhY2tRdWV1ZSIsInJlc2V0Iiwibm90aWZ5QWxsIiwiVFJBTlNBQ1RJT05fV1JBUFBFUlMiLCJSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uIiwicmVpbml0aWFsaXplVHJhbnNhY3Rpb24iLCJyZWNvbmNpbGVUcmFuc2FjdGlvbiIsImdldFRyYW5zYWN0aW9uV3JhcHBlcnMiLCJkZXN0cnVjdG9yIiwicmVsZWFzZSIsInBlcmZvcm0iLCJtZXRob2QiLCJzY29wZSIsImFkZFBvb2xpbmdUbyIsImJhdGNoZWRVcGRhdGVzIiwiY2FsbGJhY2siLCJtb3VudE9yZGVyQ29tcGFyYXRvciIsImMxIiwiYzIiLCJfbW91bnRPcmRlciIsInJ1bkJhdGNoZWRVcGRhdGVzIiwidHJhbnNhY3Rpb24iLCJzb3J0IiwiY2FsbGJhY2tzIiwiX3BlbmRpbmdDYWxsYmFja3MiLCJtYXJrZXJOYW1lIiwibG9nVG9wTGV2ZWxSZW5kZXJzIiwibmFtZWRDb21wb25lbnQiLCJfY3VycmVudEVsZW1lbnQiLCJpc1JlYWN0VG9wTGV2ZWxXcmFwcGVyIiwidGltZSIsInBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSIsInRpbWVFbmQiLCJqIiwiZW5xdWV1ZSIsImdldFB1YmxpY0luc3RhbmNlIiwiZW5xdWV1ZVVwZGF0ZSIsImlzQmF0Y2hpbmdVcGRhdGVzIiwiX3VwZGF0ZUJhdGNoTnVtYmVyIiwiYXNhcCIsImNvbnRleHQiLCJSZWFjdFVwZGF0ZXNJbmplY3Rpb24iLCJpbmplY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiIsIlJlY29uY2lsZVRyYW5zYWN0aW9uIiwiaW5qZWN0QmF0Y2hpbmdTdHJhdGVneSIsIl9iYXRjaGluZ1N0cmF0ZWd5IiwiaW5qZWN0aW9uIiwiZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkiLCJpc1Byb3h5U3VwcG9ydGVkIiwiUHJveHkiLCJzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyIsIkV2ZW50SW50ZXJmYWNlIiwiY3VycmVudFRhcmdldCIsImV2ZW50UGhhc2UiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInRpbWVTdGFtcCIsImV2ZW50IiwiRGF0ZSIsIm5vdyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpc1RydXN0ZWQiLCJTeW50aGV0aWNFdmVudCIsImRpc3BhdGNoQ29uZmlnIiwidGFyZ2V0SW5zdCIsIm5hdGl2ZUV2ZW50IiwibmF0aXZlRXZlbnRUYXJnZXQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsIl90YXJnZXRJbnN0IiwiSW50ZXJmYWNlIiwiY29uc3RydWN0b3IiLCJwcm9wTmFtZSIsIm5vcm1hbGl6ZSIsInJldHVyblZhbHVlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiaXNQZXJzaXN0ZW50IiwiZGVmaW5lUHJvcGVydHkiLCJnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uIiwiY29uc3RydWN0IiwiY3JlYXRlIiwidGhhdCIsInByb3AiLCJ2YWx1ZSIsImF1Z21lbnRDbGFzcyIsIkNsYXNzIiwiU3VwZXIiLCJFIiwiZm91ckFyZ3VtZW50UG9vbGVyIiwiZ2V0VmFsIiwiaXNGdW5jdGlvbiIsImNvbmZpZ3VyYWJsZSIsImFjdGlvbiIsIndhcm4iLCJyZXN1bHQiLCJ3YXJuaW5nQ29uZGl0aW9uIiwiY2hlY2tNYXNrIiwiYml0bWFzayIsIkRPTVByb3BlcnR5SW5qZWN0aW9uIiwiTVVTVF9VU0VfUFJPUEVSVFkiLCJIQVNfQk9PTEVBTl9WQUxVRSIsIkhBU19OVU1FUklDX1ZBTFVFIiwiSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUiLCJIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFIiwiaW5qZWN0RE9NUHJvcGVydHlDb25maWciLCJkb21Qcm9wZXJ0eUNvbmZpZyIsIkluamVjdGlvbiIsIlByb3BlcnRpZXMiLCJET01BdHRyaWJ1dGVOYW1lc3BhY2VzIiwiRE9NQXR0cmlidXRlTmFtZXMiLCJET01Qcm9wZXJ0eU5hbWVzIiwiRE9NTXV0YXRpb25NZXRob2RzIiwiaXNDdXN0b21BdHRyaWJ1dGUiLCJfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMiLCJwcm9wZXJ0aWVzIiwibG93ZXJDYXNlZCIsInRvTG93ZXJDYXNlIiwicHJvcENvbmZpZyIsInByb3BlcnR5SW5mbyIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJwcm9wZXJ0eU5hbWUiLCJtdXRhdGlvbk1ldGhvZCIsIm11c3RVc2VQcm9wZXJ0eSIsImhhc0Jvb2xlYW5WYWx1ZSIsImhhc051bWVyaWNWYWx1ZSIsImhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlIiwiaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSIsImdldFBvc3NpYmxlU3RhbmRhcmROYW1lIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIlJPT1RfQVRUUklCVVRFX05BTUUiLCJBVFRSSUJVVEVfTkFNRV9DSEFSIiwiYXV0b2ZvY3VzIiwiaXNDdXN0b21BdHRyaWJ1dGVGbiIsImNhbkRlZmluZVByb3BlcnR5IiwiUkVTRVJWRURfUFJPUFMiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJoYXNWYWxpZFJlZiIsImNvbmZpZyIsImdldHRlciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzUmVhY3RXYXJuaW5nIiwiaGFzVmFsaWRLZXkiLCJkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlciIsInByb3BzIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJzZWxmIiwiX3N0b3JlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwidmFsaWRhdGVkIiwiX3NlbGYiLCJmcmVlemUiLCJjaGlsZHJlbkxlbmd0aCIsImNoaWxkQXJyYXkiLCJkZWZhdWx0UHJvcHMiLCJjcmVhdGVGYWN0b3J5IiwiZmFjdG9yeSIsImJpbmQiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsImNsb25lRWxlbWVudCIsIm9uZUFyZ3VtZW50UG9vbGVyIiwiY29weUZpZWxkc0Zyb20iLCJLbGFzcyIsImluc3RhbmNlUG9vbCIsImluc3RhbmNlIiwidHdvQXJndW1lbnRQb29sZXIiLCJhMSIsImEyIiwidGhyZWVBcmd1bWVudFBvb2xlciIsImEzIiwiYTQiLCJzdGFuZGFyZFJlbGVhc2VyIiwicG9vbFNpemUiLCJERUZBVUxUX1BPT0xfU0laRSIsIkRFRkFVTFRfUE9PTEVSIiwiQ29weUNvbnN0cnVjdG9yIiwicG9vbGVyIiwiTmV3S2xhc3MiLCJSZWFjdEJhc2VDbGFzc2VzIiwiUmVhY3RDaGlsZHJlbiIsIlJlYWN0RE9NRmFjdG9yaWVzIiwiUmVhY3RQcm9wVHlwZXMiLCJSZWFjdFZlcnNpb24iLCJjcmVhdGVSZWFjdENsYXNzIiwib25seUNoaWxkIiwibG93UHJpb3JpdHlXYXJuaW5nIiwiUmVhY3RFbGVtZW50VmFsaWRhdG9yIiwiZGlkV2FyblByb3BUeXBlc0RlcHJlY2F0ZWQiLCJfX3NwcmVhZCIsImNyZWF0ZU1peGluIiwibWl4aW4iLCJ3YXJuZWRGb3JTcHJlYWQiLCJ3YXJuZWRGb3JDcmVhdGVNaXhpbiIsIlJlYWN0IiwiQ2hpbGRyZW4iLCJjb3VudCIsInRvQXJyYXkiLCJvbmx5IiwiQ29tcG9uZW50IiwiUHVyZUNvbXBvbmVudCIsIlByb3BUeXBlcyIsImNyZWF0ZUNsYXNzIiwiRE9NIiwid2FybmVkRm9yQ3JlYXRlQ2xhc3MiLCJ3YXJuZWRGb3JGYWN0b3JpZXMiLCJSZWFjdFJlZiIsIlJlYWN0SW5zdHJ1bWVudGF0aW9uIiwiYXR0YWNoUmVmcyIsIm1vdW50Q29tcG9uZW50IiwiaW50ZXJuYWxJbnN0YW5jZSIsImhvc3RQYXJlbnQiLCJob3N0Q29udGFpbmVySW5mbyIsInBhcmVudERlYnVnSUQiLCJtYXJrdXAiLCJnZXRSZWFjdE1vdW50UmVhZHkiLCJnZXRIb3N0Tm9kZSIsInVubW91bnRDb21wb25lbnQiLCJzYWZlbHkiLCJvbkJlZm9yZVVubW91bnRDb21wb25lbnQiLCJkZXRhY2hSZWZzIiwicmVjZWl2ZUNvbXBvbmVudCIsIm5leHRFbGVtZW50IiwicHJldkVsZW1lbnQiLCJfY29udGV4dCIsInJlZnNDaGFuZ2VkIiwic2hvdWxkVXBkYXRlUmVmcyIsIkRPTU5hbWVzcGFjZXMiLCJzZXRJbm5lckhUTUwiLCJjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uIiwic2V0VGV4dENvbnRlbnQiLCJFTEVNRU5UX05PREVfVFlQRSIsIkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSIsImVuYWJsZUxhenkiLCJkb2N1bWVudE1vZGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbnNlcnRUcmVlQ2hpbGRyZW4iLCJ0cmVlIiwiaW5zZXJ0VHJlZUJlZm9yZSIsImh0bWwiLCJyZWZlcmVuY2VOb2RlIiwibm9kZU5hbWUiLCJuYW1lc3BhY2VVUkkiLCJpbnNlcnRCZWZvcmUiLCJyZXBsYWNlQ2hpbGRXaXRoVHJlZSIsIm9sZE5vZGUiLCJuZXdUcmVlIiwicmVwbGFjZUNoaWxkIiwicXVldWVDaGlsZCIsInBhcmVudFRyZWUiLCJjaGlsZFRyZWUiLCJhcHBlbmRDaGlsZCIsInF1ZXVlSFRNTCIsInF1ZXVlVGV4dCIsIkRPTUxhenlUcmVlIiwiRXZlbnRQbHVnaW5IdWIiLCJFdmVudFBsdWdpblV0aWxzIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJnZXRMaXN0ZW5lciIsImxpc3RlbmVyQXRQaGFzZSIsInByb3BhZ2F0aW9uUGhhc2UiLCJyZWdpc3RyYXRpb25OYW1lIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMiLCJhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzIiwicGhhc2UiLCJsaXN0ZW5lciIsIl9kaXNwYXRjaExpc3RlbmVycyIsIl9kaXNwYXRjaEluc3RhbmNlcyIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUiLCJ0cmF2ZXJzZVR3b1BoYXNlIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQiLCJwYXJlbnRJbnN0IiwiZ2V0UGFyZW50SW5zdGFuY2UiLCJhY2N1bXVsYXRlRGlzcGF0Y2hlcyIsImlnbm9yZWREaXJlY3Rpb24iLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMiLCJldmVudHMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCIsImFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyIsImxlYXZlIiwiZW50ZXIiLCJ0cmF2ZXJzZUVudGVyTGVhdmUiLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyIsIkV2ZW50UHJvcGFnYXRvcnMiLCJFdmVudFBsdWdpblJlZ2lzdHJ5IiwiUmVhY3RFcnJvclV0aWxzIiwibGlzdGVuZXJCYW5rIiwiZXZlbnRRdWV1ZSIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSIsInNpbXVsYXRlZCIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlciIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsIiwiZ2V0RGljdGlvbmFyeUtleSIsIl9yb290Tm9kZUlEIiwiaXNJbnRlcmFjdGl2ZSIsInRhZyIsInNob3VsZFByZXZlbnRNb3VzZUV2ZW50IiwiZGlzYWJsZWQiLCJpbmplY3RFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lIiwicHV0TGlzdGVuZXIiLCJiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSIsIlBsdWdpbk1vZHVsZSIsInJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzIiwiZGlkUHV0TGlzdGVuZXIiLCJkZWxldGVMaXN0ZW5lciIsIndpbGxEZWxldGVMaXN0ZW5lciIsImRlbGV0ZUFsbExpc3RlbmVycyIsImV4dHJhY3RFdmVudHMiLCJ0b3BMZXZlbFR5cGUiLCJwbHVnaW5zIiwicG9zc2libGVQbHVnaW4iLCJleHRyYWN0ZWRFdmVudHMiLCJlbnF1ZXVlRXZlbnRzIiwicHJvY2Vzc0V2ZW50UXVldWUiLCJwcm9jZXNzaW5nRXZlbnRRdWV1ZSIsInJldGhyb3dDYXVnaHRFcnJvciIsIl9fcHVyZ2UiLCJfX2dldExpc3RlbmVyQmFuayIsImdldEV2ZW50VGFyZ2V0IiwiVUlFdmVudEludGVyZmFjZSIsInZpZXciLCJkb2MiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJkZXRhaWwiLCJTeW50aGV0aWNVSUV2ZW50IiwiZGlzcGF0Y2hNYXJrZXIiLCJSZWFjdEluc3RhbmNlTWFwIiwicmVtb3ZlIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImhhcyIsIl9fZXNNb2R1bGUiLCJhZGRMZWFkaW5nU2xhc2giLCJwYXRoIiwiY2hhckF0Iiwic3RyaXBMZWFkaW5nU2xhc2giLCJoYXNCYXNlbmFtZSIsInByZWZpeCIsInN0cmlwQmFzZW5hbWUiLCJzdHJpcFRyYWlsaW5nU2xhc2giLCJwYXJzZVBhdGgiLCJwYXRobmFtZSIsInNlYXJjaCIsImhhc2giLCJoYXNoSW5kZXgiLCJzZWFyY2hJbmRleCIsImNyZWF0ZVBhdGgiLCJsb2NhdGlvbiIsImVtcHR5T2JqZWN0IiwiZXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luTW9kdWxlIiwicGx1Z2luSW5kZXgiLCJwdWJsaXNoZWRFdmVudHMiLCJldmVudFR5cGVzIiwiZXZlbnROYW1lIiwicHVibGlzaEV2ZW50Rm9yUGx1Z2luIiwiZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzIiwicGhhc2VOYW1lIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZSIsInB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsImxvd2VyQ2FzZWROYW1lIiwicG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyIsIm9uZGJsY2xpY2siLCJpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RlZE5hbWVzVG9QbHVnaW5zIiwiaXNPcmRlcmluZ0RpcnR5IiwiZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQiLCJfcmVzZXRFdmVudFBsdWdpbnMiLCJPQlNFUlZFRF9FUlJPUiIsIlRyYW5zYWN0aW9uSW1wbCIsInRyYW5zYWN0aW9uV3JhcHBlcnMiLCJ3cmFwcGVySW5pdERhdGEiLCJfaXNJblRyYW5zYWN0aW9uIiwiaXNJblRyYW5zYWN0aW9uIiwiZXJyb3JUaHJvd24iLCJyZXQiLCJpbml0aWFsaXplQWxsIiwiY2xvc2VBbGwiLCJzdGFydEluZGV4Iiwid3JhcHBlciIsImluaXREYXRhIiwiVmlld3BvcnRNZXRyaWNzIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiTW91c2VFdmVudEludGVyZmFjZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiZ2V0TW9kaWZpZXJTdGF0ZSIsImJ1dHRvbiIsImJ1dHRvbnMiLCJyZWxhdGVkVGFyZ2V0IiwiZnJvbUVsZW1lbnQiLCJzcmNFbGVtZW50IiwidG9FbGVtZW50IiwicGFnZVgiLCJjdXJyZW50U2Nyb2xsTGVmdCIsInBhZ2VZIiwiY3VycmVudFNjcm9sbFRvcCIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJXSElURVNQQUNFX1RFU1QiLCJOT05WSVNJQkxFX1RFU1QiLCJyZXVzYWJsZVNWR0NvbnRhaW5lciIsInN2ZyIsImlubmVySFRNTCIsInN2Z05vZGUiLCJ0ZXN0RWxlbWVudCIsInRleHROb2RlIiwiZGF0YSIsInJlbW92ZUNoaWxkIiwiZGVsZXRlRGF0YSIsIm1hdGNoSHRtbFJlZ0V4cCIsImVzY2FwZUh0bWwiLCJzdHJpbmciLCJzdHIiLCJtYXRjaCIsImV4ZWMiLCJlc2NhcGUiLCJpbmRleCIsImxhc3RJbmRleCIsImNoYXJDb2RlQXQiLCJzdWJzdHJpbmciLCJlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIiLCJSZWFjdEV2ZW50RW1pdHRlck1peGluIiwiZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUiLCJpc0V2ZW50U3VwcG9ydGVkIiwiaGFzRXZlbnRQYWdlWFkiLCJhbHJlYWR5TGlzdGVuaW5nVG8iLCJpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSIsInJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciIsInRvcEV2ZW50TWFwcGluZyIsInRvcEFib3J0IiwidG9wQW5pbWF0aW9uRW5kIiwidG9wQW5pbWF0aW9uSXRlcmF0aW9uIiwidG9wQW5pbWF0aW9uU3RhcnQiLCJ0b3BCbHVyIiwidG9wQ2FuUGxheSIsInRvcENhblBsYXlUaHJvdWdoIiwidG9wQ2hhbmdlIiwidG9wQ2xpY2siLCJ0b3BDb21wb3NpdGlvbkVuZCIsInRvcENvbXBvc2l0aW9uU3RhcnQiLCJ0b3BDb21wb3NpdGlvblVwZGF0ZSIsInRvcENvbnRleHRNZW51IiwidG9wQ29weSIsInRvcEN1dCIsInRvcERvdWJsZUNsaWNrIiwidG9wRHJhZyIsInRvcERyYWdFbmQiLCJ0b3BEcmFnRW50ZXIiLCJ0b3BEcmFnRXhpdCIsInRvcERyYWdMZWF2ZSIsInRvcERyYWdPdmVyIiwidG9wRHJhZ1N0YXJ0IiwidG9wRHJvcCIsInRvcER1cmF0aW9uQ2hhbmdlIiwidG9wRW1wdGllZCIsInRvcEVuY3J5cHRlZCIsInRvcEVuZGVkIiwidG9wRXJyb3IiLCJ0b3BGb2N1cyIsInRvcElucHV0IiwidG9wS2V5RG93biIsInRvcEtleVByZXNzIiwidG9wS2V5VXAiLCJ0b3BMb2FkZWREYXRhIiwidG9wTG9hZGVkTWV0YWRhdGEiLCJ0b3BMb2FkU3RhcnQiLCJ0b3BNb3VzZURvd24iLCJ0b3BNb3VzZU1vdmUiLCJ0b3BNb3VzZU91dCIsInRvcE1vdXNlT3ZlciIsInRvcE1vdXNlVXAiLCJ0b3BQYXN0ZSIsInRvcFBhdXNlIiwidG9wUGxheSIsInRvcFBsYXlpbmciLCJ0b3BQcm9ncmVzcyIsInRvcFJhdGVDaGFuZ2UiLCJ0b3BTY3JvbGwiLCJ0b3BTZWVrZWQiLCJ0b3BTZWVraW5nIiwidG9wU2VsZWN0aW9uQ2hhbmdlIiwidG9wU3RhbGxlZCIsInRvcFN1c3BlbmQiLCJ0b3BUZXh0SW5wdXQiLCJ0b3BUaW1lVXBkYXRlIiwidG9wVG91Y2hDYW5jZWwiLCJ0b3BUb3VjaEVuZCIsInRvcFRvdWNoTW92ZSIsInRvcFRvdWNoU3RhcnQiLCJ0b3BUcmFuc2l0aW9uRW5kIiwidG9wVm9sdW1lQ2hhbmdlIiwidG9wV2FpdGluZyIsInRvcFdoZWVsIiwidG9wTGlzdGVuZXJzSURLZXkiLCJnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudCIsIm1vdW50QXQiLCJSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIiLCJSZWFjdEV2ZW50TGlzdGVuZXIiLCJpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIiLCJzZXRIYW5kbGVUb3BMZXZlbCIsImhhbmRsZVRvcExldmVsIiwic2V0RW5hYmxlZCIsImVuYWJsZWQiLCJpc0VuYWJsZWQiLCJsaXN0ZW5UbyIsImNvbnRlbnREb2N1bWVudEhhbmRsZSIsImlzTGlzdGVuaW5nIiwiZGVwZW5kZW5jeSIsInRyYXBCdWJibGVkRXZlbnQiLCJ0cmFwQ2FwdHVyZWRFdmVudCIsIldJTkRPV19IQU5ETEUiLCJoYW5kbGVyQmFzZU5hbWUiLCJoYW5kbGUiLCJzdXBwb3J0c0V2ZW50UGFnZVhZIiwiY3JlYXRlRXZlbnQiLCJldiIsImVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZyIsInJlZnJlc2giLCJyZWZyZXNoU2Nyb2xsVmFsdWVzIiwibW9uaXRvclNjcm9sbFZhbHVlIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJDb21wb25lbnRUcmVlIiwiVHJlZVRyYXZlcnNhbCIsImluamVjdENvbXBvbmVudFRyZWUiLCJJbmplY3RlZCIsImluamVjdFRyZWVUcmF2ZXJzYWwiLCJpc0FuY2VzdG9yIiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpc0VuZGlzaCIsImlzTW92ZWlzaCIsImlzU3RhcnRpc2giLCJ2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyIsImRpc3BhdGNoTGlzdGVuZXJzIiwiZGlzcGF0Y2hJbnN0YW5jZXMiLCJsaXN0ZW5lcnNJc0FyciIsImlzQXJyYXkiLCJsaXN0ZW5lcnNMZW4iLCJpbnN0YW5jZXNJc0FyciIsImluc3RhbmNlc0xlbiIsImV4ZWN1dGVEaXNwYXRjaCIsImludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSIsImV4ZWN1dGVEaXJlY3REaXNwYXRjaCIsImRpc3BhdGNoTGlzdGVuZXIiLCJkaXNwYXRjaEluc3RhbmNlIiwicmVzIiwiaGFzRGlzcGF0Y2hlcyIsImFyZ0Zyb20iLCJhcmdUbyIsImNhdWdodEVycm9yIiwiZnVuYyIsImRpc3BhdGNoRXZlbnQiLCJmYWtlTm9kZSIsImJvdW5kRnVuYyIsImV2dFR5cGUiLCJldnQiLCJpbml0RXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQiLCJ1c2VIYXNGZWF0dXJlIiwiaW1wbGVtZW50YXRpb24iLCJoYXNGZWF0dXJlIiwiZXZlbnROYW1lU3VmZml4IiwiY2FwdHVyZSIsImlzU3VwcG9ydGVkIiwic2V0QXR0cmlidXRlIiwibW9kaWZpZXJLZXlUb1Byb3AiLCJBbHQiLCJDb250cm9sIiwiTWV0YSIsIlNoaWZ0IiwibW9kaWZpZXJTdGF0ZUdldHRlciIsImtleUFyZyIsInN5bnRoZXRpY0V2ZW50Iiwia2V5UHJvcCIsIkRhbmdlciIsImdldE5vZGVBZnRlciIsImluc2VydENoaWxkQXQiLCJpbnNlcnRMYXp5VHJlZUNoaWxkQXQiLCJtb3ZlQ2hpbGQiLCJtb3ZlRGVsaW1pdGVkVGV4dCIsImNsb3NpbmdDb21tZW50IiwicmVtb3ZlRGVsaW1pdGVkVGV4dCIsIm9wZW5pbmdDb21tZW50IiwibmV4dE5vZGUiLCJzdGFydE5vZGUiLCJyZXBsYWNlRGVsaW1pdGVkVGV4dCIsInN0cmluZ1RleHQiLCJub2RlQWZ0ZXJDb21tZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJvbkhvc3RPcGVyYXRpb24iLCJpbnN0YW5jZUlEIiwicGF5bG9hZCIsImRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwIiwib2xkQ2hpbGQiLCJwcmV2SW5zdGFuY2UiLCJuZXh0SW5zdGFuY2UiLCJET01DaGlsZHJlbk9wZXJhdGlvbnMiLCJwcm9jZXNzVXBkYXRlcyIsInVwZGF0ZXMiLCJwYXJlbnROb2RlRGVidWdJRCIsImsiLCJ1cGRhdGUiLCJjb250ZW50IiwiYWZ0ZXJOb2RlIiwidG9JbmRleCIsImZyb21Ob2RlIiwiZnJvbUluZGV4IiwibWF0aG1sIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJwcm9wVHlwZXNGYWN0b3J5IiwiaGFzUmVhZE9ubHlWYWx1ZSIsImNoZWNrYm94IiwiaW1hZ2UiLCJoaWRkZW4iLCJyYWRpbyIsInN1Ym1pdCIsIl9hc3NlcnRTaW5nbGVMaW5rIiwiaW5wdXRQcm9wcyIsImNoZWNrZWRMaW5rIiwidmFsdWVMaW5rIiwiX2Fzc2VydFZhbHVlTGluayIsIm9uQ2hhbmdlIiwiX2Fzc2VydENoZWNrZWRMaW5rIiwiY2hlY2tlZCIsInByb3BUeXBlcyIsImNvbXBvbmVudE5hbWUiLCJyZWFkT25seSIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsImdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSIsIkxpbmtlZFZhbHVlVXRpbHMiLCJjaGVja1Byb3BUeXBlcyIsInRhZ05hbWUiLCJhZGRlbmR1bSIsImdldFZhbHVlIiwiZ2V0Q2hlY2tlZCIsImV4ZWN1dGVPbkNoYW5nZSIsInJlcXVlc3RDaGFuZ2UiLCJpbmplY3RlZCIsIlJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQiLCJyZXBsYWNlTm9kZVdpdGhNYXJrdXAiLCJwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwiaW5qZWN0RW52aXJvbm1lbnQiLCJlbnZpcm9ubWVudCIsImlzIiwieSIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsInNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50IiwicHJldkVtcHR5IiwibmV4dEVtcHR5IiwicHJldlR5cGUiLCJuZXh0VHlwZSIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJ1bmVzY2FwZSIsInVuZXNjYXBlUmVnZXgiLCJ1bmVzY2FwZXJMb29rdXAiLCJrZXlTdWJzdHJpbmciLCJLZXlFc2NhcGVVdGlscyIsImZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudCIsImdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZSIsInB1YmxpY0luc3RhbmNlIiwiY2FsbGVyTmFtZSIsImN0b3IiLCJSZWFjdFVwZGF0ZVF1ZXVlIiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiZW5xdWV1ZUNhbGxiYWNrIiwidmFsaWRhdGVDYWxsYmFjayIsImVucXVldWVDYWxsYmFja0ludGVybmFsIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiX3BlbmRpbmdGb3JjZVVwZGF0ZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJjb21wbGV0ZVN0YXRlIiwiX3BlbmRpbmdTdGF0ZVF1ZXVlIiwiX3BlbmRpbmdSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlU2V0U3RhdGUiLCJwYXJ0aWFsU3RhdGUiLCJvblNldFN0YXRlIiwiZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbCIsIm5leHRDb250ZXh0IiwiX3BlbmRpbmdFbGVtZW50IiwidmFsaWRhdGVET01OZXN0aW5nIiwic3BlY2lhbFRhZ3MiLCJpblNjb3BlVGFncyIsImJ1dHRvblNjb3BlVGFncyIsImltcGxpZWRFbmRUYWdzIiwiZW1wdHlBbmNlc3RvckluZm8iLCJmb3JtVGFnIiwiYVRhZ0luU2NvcGUiLCJidXR0b25UYWdJblNjb3BlIiwibm9iclRhZ0luU2NvcGUiLCJwVGFnSW5CdXR0b25TY29wZSIsImxpc3RJdGVtVGFnQXV0b2Nsb3NpbmciLCJkbEl0ZW1UYWdBdXRvY2xvc2luZyIsInVwZGF0ZWRBbmNlc3RvckluZm8iLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJwYXJlbnRUYWciLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZmluZE93bmVyU3RhY2siLCJyZXZlcnNlIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRUZXh0IiwiY2hpbGRJbnN0YW5jZSIsInBhcmVudEluZm8iLCJpbnZhbGlkUGFyZW50IiwiaW52YWxpZEFuY2VzdG9yIiwicHJvYmxlbWF0aWMiLCJhbmNlc3RvclRhZyIsImFuY2VzdG9ySW5zdGFuY2UiLCJjaGlsZE93bmVyIiwiYW5jZXN0b3JPd25lciIsImNoaWxkT3duZXJzIiwiYW5jZXN0b3JPd25lcnMiLCJtaW5TdGFja0xlbiIsIm1pbiIsImRlZXBlc3RDb21tb24iLCJVTktOT1dOIiwiY2hpbGRPd25lck5hbWVzIiwiYW5jZXN0b3JPd25lck5hbWVzIiwib3duZXJJbmZvIiwid2FybktleSIsInRhZ0Rpc3BsYXlOYW1lIiwid2hpdGVzcGFjZUluZm8iLCJpc1RhZ1ZhbGlkSW5Db250ZXh0IiwiZ2V0RXZlbnRDaGFyQ29kZSIsImNoYXJDb2RlIiwia2V5Q29kZSIsImxvY2F0aW9uc0FyZUVxdWFsIiwiY3JlYXRlTG9jYXRpb24iLCJfZXh0ZW5kcyIsIl9yZXNvbHZlUGF0aG5hbWUiLCJfcmVzb2x2ZVBhdGhuYW1lMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfdmFsdWVFcXVhbCIsIl92YWx1ZUVxdWFsMiIsIl9QYXRoVXRpbHMiLCJvYmoiLCJkZWZhdWx0Iiwic3RhdGUiLCJjdXJyZW50TG9jYXRpb24iLCJkZWNvZGVVUkkiLCJVUklFcnJvciIsIl93YXJuaW5nIiwiX3dhcm5pbmcyIiwiY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIiLCJwcm9tcHQiLCJzZXRQcm9tcHQiLCJuZXh0UHJvbXB0IiwiY29uZmlybVRyYW5zaXRpb25UbyIsImdldFVzZXJDb25maXJtYXRpb24iLCJhcHBlbmRMaXN0ZW5lciIsImlzQWN0aXZlIiwiZmlsdGVyIiwibm90aWZ5TGlzdGVuZXJzIiwiX2NsYXNzQ2FsbENoZWNrIiwiQ29uc3RydWN0b3IiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIlJlZmVyZW5jZUVycm9yIiwiX2luaGVyaXRzIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJfUmVhY3QkQ29tcG9uZW50IiwiX3RlbXAiLCJfdGhpcyIsIl9yZXQiLCJjb21wdXRlTWF0Y2giLCJoaXN0b3J5IiwiZ2V0Q2hpbGRDb250ZXh0Iiwicm91dGVyIiwicm91dGUiLCJ1cmwiLCJwYXJhbXMiLCJpc0V4YWN0IiwiY29tcG9uZW50V2lsbE1vdW50IiwiX3RoaXMyIiwiX3Byb3BzIiwidW5saXN0ZW4iLCJsaXN0ZW4iLCJzZXRTdGF0ZSIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJuZXh0UHJvcHMiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInJlbmRlciIsImlzUmVxdWlyZWQiLCJjb250ZXh0VHlwZXMiLCJjaGlsZENvbnRleHRUeXBlcyIsInBhdHRlcm5DYWNoZSIsImNhY2hlTGltaXQiLCJjYWNoZUNvdW50IiwiY29tcGlsZVBhdGgiLCJwYXR0ZXJuIiwib3B0aW9ucyIsImNhY2hlS2V5IiwiZW5kIiwic3RyaWN0IiwiY2FjaGUiLCJyZSIsImNvbXBpbGVkUGF0dGVybiIsIl9vcHRpb25zIiwiX29wdGlvbnMkcGF0aCIsIl9vcHRpb25zJGV4YWN0IiwiZXhhY3QiLCJfb3B0aW9ucyRzdHJpY3QiLCJfY29tcGlsZVBhdGgiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJtZW1vIiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJSZWFjdENvbXBvbmVudCIsInVwZGF0ZXIiLCJyZWZzIiwiaXNSZWFjdENvbXBvbmVudCIsImZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJtZXRob2ROYW1lIiwiZm5OYW1lIiwiUmVhY3RQdXJlQ29tcG9uZW50IiwiQ29tcG9uZW50RHVtbXkiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIndhcm5Ob29wIiwiSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwiaXRlcmF0b3JGbiIsImNoZWNrUmVhY3RUeXBlU3BlYyIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZWxlbWVudFByb3BzIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudFR5cGUiLCJwYXJlbnROYW1lIiwidmFsaWRhdGVFeHBsaWNpdEtleSIsIm1lbW9pemVyIiwidW5pcXVlS2V5IiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInZhbGlkYXRlQ2hpbGRLZXlzIiwiY2hpbGQiLCJlbnRyaWVzIiwic3RlcCIsIm5leHQiLCJkb25lIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJjb21wb25lbnRDbGFzcyIsImdldERlZmF1bHRQcm9wcyIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwidmFsaWRUeXBlIiwic291cmNlSW5mbyIsInZhbGlkYXRlZEZhY3RvcnkiLCJBTk9OWU1PVVMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJvb2wiLCJudW1iZXIiLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwic2hhcGUiLCJjcmVhdGVTaGFwZVR5cGVDaGVja2VyIiwiUHJvcFR5cGVFcnJvciIsImNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyIiwidmFsaWRhdGUiLCJtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSIsIm1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IiwiY2hlY2tUeXBlIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY2hhaW5lZENoZWNrVHlwZSIsImV4cGVjdGVkVHlwZSIsInByb3BWYWx1ZSIsInByb3BUeXBlIiwiZ2V0UHJvcFR5cGUiLCJwcmVjaXNlVHlwZSIsImdldFByZWNpc2VUeXBlIiwidHlwZUNoZWNrZXIiLCJleHBlY3RlZENsYXNzIiwiZXhwZWN0ZWRDbGFzc05hbWUiLCJhY3R1YWxDbGFzc05hbWUiLCJnZXRDbGFzc05hbWUiLCJleHBlY3RlZFZhbHVlcyIsInZhbHVlc1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsImlzTm9kZSIsInNoYXBlVHlwZXMiLCJldmVyeSIsImVudHJ5IiwiaXNTeW1ib2wiLCJhcnIiLCJjYiIsImNvbnRlbnRLZXkiLCJnZXRUZXh0Q29udGVudEFjY2Vzc29yIiwiZG9jdW1lbnRFbGVtZW50IiwiX2NhbGxiYWNrcyIsIl9jb250ZXh0cyIsIl9hcmciLCJjb250ZXh0cyIsImNoZWNrcG9pbnQiLCJyb2xsYmFjayIsImlzQ2hlY2thYmxlIiwiZWxlbSIsImdldFRyYWNrZXIiLCJfd3JhcHBlclN0YXRlIiwidmFsdWVUcmFja2VyIiwiYXR0YWNoVHJhY2tlciIsInRyYWNrZXIiLCJkZXRhY2hUcmFja2VyIiwiZ2V0VmFsdWVGcm9tTm9kZSIsImlucHV0VmFsdWVUcmFja2luZyIsIl9nZXRUcmFja2VyRnJvbU5vZGUiLCJ0cmFjayIsInZhbHVlRmllbGQiLCJkZXNjcmlwdG9yIiwiY3VycmVudFZhbHVlIiwic2V0VmFsdWUiLCJzdG9wVHJhY2tpbmciLCJ1cGRhdGVWYWx1ZUlmQ2hhbmdlZCIsImxhc3RWYWx1ZSIsIm5leHRWYWx1ZSIsInN1cHBvcnRlZElucHV0VHlwZXMiLCJjb2xvciIsImRhdGUiLCJkYXRldGltZSIsImVtYWlsIiwibW9udGgiLCJwYXNzd29yZCIsInJhbmdlIiwidGVsIiwid2VlayIsImlzVGV4dElucHV0RWxlbWVudCIsInNjcm9sbFBvc2l0aW9uIiwibGFzdENoaWxkIiwidGV4dENvbnRlbnQiLCJmb2N1c05vZGUiLCJmb2N1cyIsImlzVW5pdGxlc3NOdW1iZXIiLCJhbmltYXRpb25JdGVyYXRpb25Db3VudCIsImJvcmRlckltYWdlT3V0c2V0IiwiYm9yZGVySW1hZ2VTbGljZSIsImJvcmRlckltYWdlV2lkdGgiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsInRvVXBwZXJDYXNlIiwicHJlZml4ZXMiLCJzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnMiLCJiYWNrZ3JvdW5kIiwiYmFja2dyb3VuZEF0dGFjaG1lbnQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJiYWNrZ3JvdW5kSW1hZ2UiLCJiYWNrZ3JvdW5kUG9zaXRpb25YIiwiYmFja2dyb3VuZFBvc2l0aW9uWSIsImJhY2tncm91bmRSZXBlYXQiLCJiYWNrZ3JvdW5kUG9zaXRpb24iLCJib3JkZXIiLCJib3JkZXJXaWR0aCIsImJvcmRlclN0eWxlIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJCb3R0b20iLCJib3JkZXJCb3R0b21XaWR0aCIsImJvcmRlckJvdHRvbVN0eWxlIiwiYm9yZGVyQm90dG9tQ29sb3IiLCJib3JkZXJMZWZ0IiwiYm9yZGVyTGVmdFdpZHRoIiwiYm9yZGVyTGVmdFN0eWxlIiwiYm9yZGVyTGVmdENvbG9yIiwiYm9yZGVyUmlnaHQiLCJib3JkZXJSaWdodFdpZHRoIiwiYm9yZGVyUmlnaHRTdHlsZSIsImJvcmRlclJpZ2h0Q29sb3IiLCJib3JkZXJUb3AiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlclRvcFN0eWxlIiwiYm9yZGVyVG9wQ29sb3IiLCJmb250IiwiZm9udFN0eWxlIiwiZm9udFZhcmlhbnQiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJvdXRsaW5lIiwib3V0bGluZVdpZHRoIiwib3V0bGluZVN0eWxlIiwib3V0bGluZUNvbG9yIiwiQ1NTUHJvcGVydHkiLCJxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlciIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJzaG91bGRJZ25vcmVWYWx1ZSIsImlzTmFOIiwiRE9NUHJvcGVydHlPcGVyYXRpb25zIiwiY3JlYXRlTWFya3VwRm9ySUQiLCJzZXRBdHRyaWJ1dGVGb3JJRCIsImNyZWF0ZU1hcmt1cEZvclJvb3QiLCJzZXRBdHRyaWJ1dGVGb3JSb290IiwiY3JlYXRlTWFya3VwRm9yUHJvcGVydHkiLCJjcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5IiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm5hbWVzcGFjZSIsInNldEF0dHJpYnV0ZU5TIiwic2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZSIsImRpZFdhcm5WYWx1ZUxpbmsiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUiLCJ1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCIsInBlbmRpbmdVcGRhdGUiLCJ1cGRhdGVPcHRpb25zIiwiQm9vbGVhbiIsIm11bHRpcGxlIiwidmFsdWVQcm9wTmFtZXMiLCJjaGVja1NlbGVjdFByb3BUeXBlcyIsInNlbGVjdGVkVmFsdWUiLCJzZWxlY3RlZCIsIlJlYWN0RE9NU2VsZWN0IiwiZ2V0SG9zdFByb3BzIiwibW91bnRXcmFwcGVyIiwiaW5pdGlhbFZhbHVlIiwiZGVmYXVsdFZhbHVlIiwiX2hhbmRsZUNoYW5nZSIsIndhc011bHRpcGxlIiwiZ2V0U2VsZWN0VmFsdWVDb250ZXh0IiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCIsIlJlYWN0RW1wdHlDb21wb25lbnQiLCJSZWFjdEhvc3RDb21wb25lbnQiLCJnZXROZXh0RGVidWdJRCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciIsImlzSW50ZXJuYWxDb21wb25lbnRUeXBlIiwiaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCIsInNob3VsZEhhdmVEZWJ1Z0lEIiwiY3JlYXRlSW50ZXJuYWxDb21wb25lbnQiLCJnZXROYXRpdmVOb2RlIiwiY3JlYXRlSW5zdGFuY2VGb3JUZXh0IiwiX21vdW50SW5kZXgiLCJfbW91bnRJbWFnZSIsInByZXZlbnRFeHRlbnNpb25zIiwiX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQiLCJSZWFjdE5vZGVUeXBlcyIsIkhPU1QiLCJDT01QT1NJVEUiLCJFTVBUWSIsImdldFR5cGUiLCJlbXB0eUNvbXBvbmVudEZhY3RvcnkiLCJSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uIiwiaW5qZWN0RW1wdHlDb21wb25lbnRGYWN0b3J5IiwiaW5zdGFudGlhdGUiLCJnZW5lcmljQ29tcG9uZW50Q2xhc3MiLCJ0ZXh0Q29tcG9uZW50Q2xhc3MiLCJSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb24iLCJpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MiLCJpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MiLCJpc1RleHRDb21wb25lbnQiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZ2V0Q29tcG9uZW50S2V5IiwidHJhdmVyc2VBbGxDaGlsZHJlbkltcGwiLCJuYW1lU29GYXIiLCJ0cmF2ZXJzZUNvbnRleHQiLCJuZXh0TmFtZSIsInN1YnRyZWVDb3VudCIsIm5leHROYW1lUHJlZml4IiwiaWkiLCJtYXBzQXNDaGlsZHJlbkFkZGVuZHVtIiwibWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUiLCJfaXNSZWFjdEVsZW1lbnQiLCJjaGlsZHJlblN0cmluZyIsInRyYXZlcnNlQWxsQ2hpbGRyZW4iLCJFdmVudExpc3RlbmVyIiwiZXZlbnRUeXBlIiwiZGV0YWNoRXZlbnQiLCJyZWdpc3RlckRlZmF1bHQiLCJSZWFjdERPTVNlbGVjdGlvbiIsImNvbnRhaW5zTm9kZSIsImdldEFjdGl2ZUVsZW1lbnQiLCJpc0luRG9jdW1lbnQiLCJSZWFjdElucHV0U2VsZWN0aW9uIiwiaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzIiwiY29udGVudEVkaXRhYmxlIiwiZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24iLCJmb2N1c2VkRWxlbSIsInNlbGVjdGlvblJhbmdlIiwiZ2V0U2VsZWN0aW9uIiwicmVzdG9yZVNlbGVjdGlvbiIsInByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24iLCJjdXJGb2N1c2VkRWxlbSIsInByaW9yRm9jdXNlZEVsZW0iLCJwcmlvclNlbGVjdGlvblJhbmdlIiwic2V0U2VsZWN0aW9uIiwiaW5wdXQiLCJzZWxlY3Rpb24iLCJzdGFydCIsInNlbGVjdGlvblN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwiY3JlYXRlUmFuZ2UiLCJwYXJlbnRFbGVtZW50IiwibW92ZVN0YXJ0IiwibW92ZUVuZCIsImdldE9mZnNldHMiLCJvZmZzZXRzIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJzZWxlY3QiLCJzZXRPZmZzZXRzIiwiYWN0aXZlRWxlbWVudCIsImJvZHkiLCJSZWFjdERPTUNvbnRhaW5lckluZm8iLCJSZWFjdERPTUZlYXR1cmVGbGFncyIsIlJlYWN0TWFya3VwQ2hlY2tzdW0iLCJST09UX0FUVFJfTkFNRSIsIkRPQ19OT0RFX1RZUEUiLCJpbnN0YW5jZXNCeVJlYWN0Um9vdElEIiwiZmlyc3REaWZmZXJlbmNlSW5kZXgiLCJzdHJpbmcxIiwic3RyaW5nMiIsIm1pbkxlbiIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsImNvbnRhaW5lciIsImludGVybmFsR2V0SUQiLCJtb3VudENvbXBvbmVudEludG9Ob2RlIiwid3JhcHBlckluc3RhbmNlIiwic2hvdWxkUmV1c2VNYXJrdXAiLCJ3cmFwcGVkRWxlbWVudCIsIl90b3BMZXZlbFdyYXBwZXIiLCJSZWFjdE1vdW50IiwiX21vdW50SW1hZ2VJbnRvTm9kZSIsImJhdGNoZWRNb3VudENvbXBvbmVudEludG9Ob2RlIiwiY29tcG9uZW50SW5zdGFuY2UiLCJ1c2VDcmVhdGVFbGVtZW50IiwidW5tb3VudENvbXBvbmVudEZyb21Ob2RlIiwib25CZWdpbkZsdXNoIiwib25FbmRGbHVzaCIsImhhc05vblJvb3RSZWFjdENoaWxkIiwicm9vdEVsIiwibm9kZUlzUmVuZGVyZWRCeU90aGVySW5zdGFuY2UiLCJpc1JlYWN0Tm9kZSIsImlzVmFsaWRDb250YWluZXIiLCJoYXNBdHRyaWJ1dGUiLCJnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIiLCJwcmV2SG9zdEluc3RhbmNlIiwiZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIiLCJyb290IiwiX2hvc3RDb250YWluZXJJbmZvIiwidG9wTGV2ZWxSb290Q291bnRlciIsIlRvcExldmVsV3JhcHBlciIsInJvb3RJRCIsIl9pbnN0YW5jZXNCeVJlYWN0Um9vdElEIiwic2Nyb2xsTW9uaXRvciIsInJlbmRlckNhbGxiYWNrIiwiX3VwZGF0ZVJvb3RDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50IiwiX3JlbmRlck5ld1Jvb3RDb21wb25lbnQiLCJ3cmFwcGVySUQiLCJfaW5zdGFuY2UiLCJyZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsInBhcmVudENvbXBvbmVudCIsIl9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsIm5leHRXcmFwcGVkRWxlbWVudCIsIl9wcm9jZXNzQ2hpbGRDb250ZXh0IiwicHJldldyYXBwZWRFbGVtZW50IiwicHVibGljSW5zdCIsInVwZGF0ZWRDYWxsYmFjayIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJyZWFjdFJvb3RFbGVtZW50IiwiY29udGFpbmVySGFzUmVhY3RNYXJrdXAiLCJjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCIsInJvb3RFbGVtZW50U2libGluZyIsImlzQ29udGFpbmVyUmVhY3RSb290Iiwicm9vdEVsZW1lbnQiLCJjYW5SZXVzZU1hcmt1cCIsImNoZWNrc3VtIiwiQ0hFQ0tTVU1fQVRUUl9OQU1FIiwicm9vdE1hcmt1cCIsIm91dGVySFRNTCIsIm5vcm1hbGl6ZWRNYXJrdXAiLCJub3JtYWxpemVyIiwiY29udGVudERvY3VtZW50Iiwid3JpdGUiLCJkaWZmSW5kZXgiLCJkaWZmZXJlbmNlIiwiaG9zdE5vZGUiLCJnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZSIsIl9yZW5kZXJlZE5vZGVUeXBlIiwiX3JlZiIsIl9yZWYyIiwiY29tcHV0ZWRNYXRjaCIsIl9wcm9wczIiLCJfY29udGV4dCRyb3V0ZXIiLCJzdGF0aWNDb250ZXh0IiwiX3R5cGVvZiIsIl9pbnZhcmlhbnQiLCJfaW52YXJpYW50MiIsIl9Mb2NhdGlvblV0aWxzIiwiX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIiwiX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiIsIl9ET01VdGlscyIsIlBvcFN0YXRlRXZlbnQiLCJIYXNoQ2hhbmdlRXZlbnQiLCJnZXRIaXN0b3J5U3RhdGUiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsImdsb2JhbEhpc3RvcnkiLCJjYW5Vc2VIaXN0b3J5Iiwic3VwcG9ydHNIaXN0b3J5IiwibmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIiLCJzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlIiwiX3Byb3BzJGZvcmNlUmVmcmVzaCIsImZvcmNlUmVmcmVzaCIsIl9wcm9wcyRnZXRVc2VyQ29uZmlybSIsImdldENvbmZpcm1hdGlvbiIsIl9wcm9wcyRrZXlMZW5ndGgiLCJrZXlMZW5ndGgiLCJiYXNlbmFtZSIsImdldERPTUxvY2F0aW9uIiwiaGlzdG9yeVN0YXRlIiwiX3dpbmRvdyRsb2NhdGlvbiIsImNyZWF0ZUtleSIsInRyYW5zaXRpb25NYW5hZ2VyIiwibmV4dFN0YXRlIiwiaGFuZGxlUG9wU3RhdGUiLCJpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50IiwiaGFuZGxlUG9wIiwiaGFuZGxlSGFzaENoYW5nZSIsImZvcmNlTmV4dFBvcCIsIm9rIiwicmV2ZXJ0UG9wIiwiZnJvbUxvY2F0aW9uIiwidG9Mb2NhdGlvbiIsImFsbEtleXMiLCJkZWx0YSIsImdvIiwiaW5pdGlhbExvY2F0aW9uIiwiY3JlYXRlSHJlZiIsImhyZWYiLCJwdXNoU3RhdGUiLCJwcmV2SW5kZXgiLCJuZXh0S2V5cyIsImdvQmFjayIsImdvRm9yd2FyZCIsImxpc3RlbmVyQ291bnQiLCJjaGVja0RPTUxpc3RlbmVycyIsImlzQmxvY2tlZCIsImJsb2NrIiwidW5ibG9jayIsImNvbmZpcm0iLCJ1YSIsInN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoIiwiQnJvd3NlclJvdXRlciIsIkhhc2hSb3V0ZXIiLCJMaW5rIiwiTmF2TGluayIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImlzTW9kaWZpZWRFdmVudCIsImhhbmRsZUNsaWNrIiwib25DbGljayIsIl90aGlzJHByb3BzIiwidXNlU291cmNlTWFwIiwibGlzdCIsImNzc1dpdGhNYXBwaW5nVG9TdHJpbmciLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZVJvb3QiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJjdXN0b21IaXN0b3J5IiwiYXBwIiwiZ2V0RWxlbWVudEJ5SWQiLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCIsImVzY2FwZVVzZXJQcm92aWRlZEtleSIsIkZvckVhY2hCb29rS2VlcGluZyIsImZvckVhY2hGdW5jdGlvbiIsImZvckVhY2hDb250ZXh0IiwiZm9yRWFjaFNpbmdsZUNoaWxkIiwiYm9va0tlZXBpbmciLCJmb3JFYWNoQ2hpbGRyZW4iLCJmb3JFYWNoRnVuYyIsIk1hcEJvb2tLZWVwaW5nIiwibWFwUmVzdWx0Iiwia2V5UHJlZml4IiwibWFwRnVuY3Rpb24iLCJtYXBDb250ZXh0IiwibWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsImNoaWxkS2V5IiwibWFwcGVkQ2hpbGQiLCJtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsIiwiZXNjYXBlZFByZWZpeCIsIm1hcENoaWxkcmVuIiwiZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkiLCJjb3VudENoaWxkcmVuIiwiY3JlYXRlRE9NRmFjdG9yeSIsImFiYnIiLCJhZGRyZXNzIiwiYXJlYSIsImFydGljbGUiLCJhc2lkZSIsImF1ZGlvIiwiYmFzZSIsImJkaSIsImJkbyIsImJpZyIsImJsb2NrcXVvdGUiLCJiciIsImNhbnZhcyIsImNhcHRpb24iLCJjaXRlIiwiY29sIiwiY29sZ3JvdXAiLCJkYXRhbGlzdCIsImRkIiwiZGVsIiwiZGV0YWlscyIsImRmbiIsImRpYWxvZyIsImRpdiIsImRsIiwiZHQiLCJlbSIsImVtYmVkIiwiZmllbGRzZXQiLCJmaWdjYXB0aW9uIiwiZmlndXJlIiwiZm9vdGVyIiwiZm9ybSIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImhlYWQiLCJoZWFkZXIiLCJoZ3JvdXAiLCJociIsImlmcmFtZSIsImltZyIsImlucyIsImtiZCIsImtleWdlbiIsImxhYmVsIiwibGVnZW5kIiwibGkiLCJsaW5rIiwibWFpbiIsIm1hcmsiLCJtZW51IiwibWVudWl0ZW0iLCJtZXRhIiwibWV0ZXIiLCJuYXYiLCJub3NjcmlwdCIsIm9sIiwib3B0Z3JvdXAiLCJvcHRpb24iLCJvdXRwdXQiLCJwIiwicGFyYW0iLCJwaWN0dXJlIiwicHJlIiwicHJvZ3Jlc3MiLCJxIiwicnAiLCJydCIsInJ1YnkiLCJzYW1wIiwic2NyaXB0Iiwic2VjdGlvbiIsInNtYWxsIiwic3BhbiIsInN0cm9uZyIsInN0eWxlIiwic3ViIiwic3VtbWFyeSIsInN1cCIsInRhYmxlIiwidGJvZHkiLCJ0ZCIsInRleHRhcmVhIiwidGZvb3QiLCJ0aCIsInRoZWFkIiwidHIiLCJ1IiwidWwiLCJ2aWRlbyIsIndiciIsImNpcmNsZSIsImNsaXBQYXRoIiwiZGVmcyIsImVsbGlwc2UiLCJnIiwibGluZSIsImxpbmVhckdyYWRpZW50IiwibWFzayIsInBvbHlnb24iLCJwb2x5bGluZSIsInJhZGlhbEdyYWRpZW50IiwicmVjdCIsInN0b3AiLCJ0c3BhbiIsIlJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzIiwidHlwZVNwZWNzIiwiZGVidWdJRCIsInR5cGVTcGVjTmFtZSIsImV4IiwiY29tcG9uZW50U3RhY2tJbmZvIiwiY2hpbGRDb250ZXh0IiwiX3JlcXVpcmUiLCJnZXRTdGFjayIsIl9yZXF1aXJlMiIsIk1JWElOU19LRVkiLCJpZGVudGl0eSIsImluamVjdGVkTWl4aW5zIiwiUmVhY3RDbGFzc0ludGVyZmFjZSIsIm1peGlucyIsInN0YXRpY3MiLCJnZXRJbml0aWFsU3RhdGUiLCJjb21wb25lbnREaWRNb3VudCIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJ1cGRhdGVDb21wb25lbnQiLCJSRVNFUlZFRF9TUEVDX0tFWVMiLCJtaXhTcGVjSW50b0NvbXBvbmVudCIsInZhbGlkYXRlVHlwZURlZiIsImNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uIiwibWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQiLCJhdXRvYmluZCIsInR5cGVEZWYiLCJ2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlIiwiaXNBbHJlYWR5RGVmaW5lZCIsInNwZWNQb2xpY3kiLCJSZWFjdENsYXNzTWl4aW4iLCJzcGVjIiwidHlwZW9mU3BlYyIsImlzTWl4aW5WYWxpZCIsInByb3RvIiwiYXV0b0JpbmRQYWlycyIsIl9fcmVhY3RBdXRvQmluZFBhaXJzIiwicHJvcGVydHkiLCJpc1JlYWN0Q2xhc3NNZXRob2QiLCJzaG91bGRBdXRvQmluZCIsImNyZWF0ZUNoYWluZWRGdW5jdGlvbiIsImlzUmVzZXJ2ZWQiLCJpc0luaGVyaXRlZCIsIm1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMiLCJvbmUiLCJ0d28iLCJtZXJnZWRSZXN1bHQiLCJjaGFpbmVkRnVuY3Rpb24iLCJiaW5kQXV0b0JpbmRNZXRob2QiLCJib3VuZE1ldGhvZCIsIl9fcmVhY3RCb3VuZENvbnRleHQiLCJfX3JlYWN0Qm91bmRNZXRob2QiLCJfX3JlYWN0Qm91bmRBcmd1bWVudHMiLCJfYmluZCIsIm5ld1RoaXMiLCJyZWJvdW5kTWV0aG9kIiwiYmluZEF1dG9CaW5kTWV0aG9kcyIsInBhaXJzIiwiYXV0b0JpbmRLZXkiLCJJc01vdW50ZWRQcmVNaXhpbiIsIl9faXNNb3VudGVkIiwiSXNNb3VudGVkUG9zdE1peGluIiwibmV3U3RhdGUiLCJfX2RpZFdhcm5Jc01vdW50ZWQiLCJSZWFjdENsYXNzQ29tcG9uZW50IiwiaW5pdGlhbFN0YXRlIiwiX2lzTW9ja0Z1bmN0aW9uIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsIlJlYWN0RGVmYXVsdEluamVjdGlvbiIsImZpbmRET01Ob2RlIiwiaW5qZWN0IiwiUmVhY3RET00iLCJ1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyIsInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiTW91bnQiLCJSZWNvbmNpbGVyIiwidG9wIiwic2hvd0ZpbGVVcmxNZXNzYWdlIiwicHJvdG9jb2wiLCJkZWJ1ZyIsInRlc3RGdW5jIiwidGVzdEZuIiwiaWVDb21wYXRpYmlsaXR5TW9kZSIsImV4cGVjdGVkRmVhdHVyZXMiLCJ0cmltIiwiUmVhY3RET01Vbmtub3duUHJvcGVydHlIb29rIiwiUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rIiwiUmVhY3RET01JbnZhbGlkQVJJQUhvb2siLCJhZGRIb29rIiwiQVJJQURPTVByb3BlcnR5Q29uZmlnIiwiQmVmb3JlSW5wdXRFdmVudFBsdWdpbiIsIkNoYW5nZUV2ZW50UGx1Z2luIiwiRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXIiLCJFbnRlckxlYXZlRXZlbnRQbHVnaW4iLCJIVE1MRE9NUHJvcGVydHlDb25maWciLCJSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCIsIlJlYWN0RE9NQ29tcG9uZW50IiwiUmVhY3RET01FbXB0eUNvbXBvbmVudCIsIlJlYWN0RE9NVHJlZVRyYXZlcnNhbCIsIlJlYWN0RE9NVGV4dENvbXBvbmVudCIsIlJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kiLCJSZWFjdEluamVjdGlvbiIsIlNWR0RPTVByb3BlcnR5Q29uZmlnIiwiU2VsZWN0RXZlbnRQbHVnaW4iLCJTaW1wbGVFdmVudFBsdWdpbiIsImFscmVhZHlJbmplY3RlZCIsIkV2ZW50RW1pdHRlciIsIkhvc3RDb21wb25lbnQiLCJFbXB0eUNvbXBvbmVudCIsIlVwZGF0ZXMiLCJGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUiLCJTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50IiwiU3ludGhldGljSW5wdXRFdmVudCIsIkVORF9LRVlDT0RFUyIsIlNUQVJUX0tFWUNPREUiLCJjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IiwiY2FuVXNlVGV4dElucHV0RXZlbnQiLCJpc1ByZXN0byIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwib3BlcmEiLCJTUEFDRUJBUl9DT0RFIiwiU1BBQ0VCQVJfQ0hBUiIsImJlZm9yZUlucHV0IiwiYnViYmxlZCIsImNhcHR1cmVkIiwiY29tcG9zaXRpb25FbmQiLCJjb21wb3NpdGlvblN0YXJ0IiwiY29tcG9zaXRpb25VcGRhdGUiLCJoYXNTcGFjZUtleXByZXNzIiwiaXNLZXlwcmVzc0NvbW1hbmQiLCJnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0IiwiaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kIiwiZ2V0RGF0YUZyb21DdXN0b21FdmVudCIsImN1cnJlbnRDb21wb3NpdGlvbiIsImV4dHJhY3RDb21wb3NpdGlvbkV2ZW50IiwiZmFsbGJhY2tEYXRhIiwiZ2V0RGF0YSIsImN1c3RvbURhdGEiLCJnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzIiwid2hpY2giLCJjaGFycyIsImdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyIsImV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50IiwiX3Jvb3QiLCJfc3RhcnRUZXh0IiwiX2ZhbGxiYWNrVGV4dCIsInN0YXJ0VmFsdWUiLCJzdGFydExlbmd0aCIsImVuZFZhbHVlIiwiZW5kTGVuZ3RoIiwibWluRW5kIiwic2xpY2VUYWlsIiwiQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSIsIklucHV0RXZlbnRJbnRlcmZhY2UiLCJjaGFuZ2UiLCJjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQiLCJhY3RpdmVFbGVtZW50SW5zdCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwiZG9lc0NoYW5nZUV2ZW50QnViYmxlIiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsInN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCIsInN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4IiwiZ2V0SW5zdElmVmFsdWVDaGFuZ2VkIiwidXBkYXRlZCIsIl9hbGxvd1NpbXVsYXRlZFBhc3NUaHJvdWdoIiwiZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50IiwiaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsIiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQiLCJoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyIiwiY29udHJvbGxlZCIsIl9pc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJ0YXJnZXROb2RlIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJSZWFjdE93bmVyIiwiYXR0YWNoUmVmIiwiYWRkQ29tcG9uZW50QXNSZWZUbyIsImRldGFjaFJlZiIsInJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbSIsInByZXZSZWYiLCJwcmV2T3duZXIiLCJuZXh0UmVmIiwibmV4dE93bmVyIiwiaXNWYWxpZE93bmVyIiwib3duZXJQdWJsaWNJbnN0YW5jZSIsIlJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2siLCJSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayIsInBlcmZvcm1hbmNlTm93IiwiaG9va3MiLCJkaWRIb29rVGhyb3dGb3JFdmVudCIsImNhbGxIb29rIiwiYXJnNCIsImFyZzUiLCJlbWl0RXZlbnQiLCJob29rIiwiaXNQcm9maWxpbmciLCJmbHVzaEhpc3RvcnkiLCJsaWZlQ3ljbGVUaW1lclN0YWNrIiwiY3VycmVudEZsdXNoTmVzdGluZyIsImN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyIsImN1cnJlbnRGbHVzaFN0YXJ0VGltZSIsImN1cnJlbnRUaW1lckRlYnVnSUQiLCJjdXJyZW50VGltZXJTdGFydFRpbWUiLCJjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uIiwiY3VycmVudFRpbWVyVHlwZSIsImxpZmVDeWNsZVRpbWVySGFzV2FybmVkIiwiY2xlYXJIaXN0b3J5IiwiZ2V0VHJlZVNuYXBzaG90IiwicmVnaXN0ZXJlZElEcyIsInJlc2V0TWVhc3VyZW1lbnRzIiwicHJldmlvdXNTdGFydFRpbWUiLCJwcmV2aW91c01lYXN1cmVtZW50cyIsInByZXZpb3VzT3BlcmF0aW9ucyIsImdldEhpc3RvcnkiLCJkdXJhdGlvbiIsIm1lYXN1cmVtZW50cyIsIm9wZXJhdGlvbnMiLCJ0cmVlU25hcHNob3QiLCJjaGVja0RlYnVnSUQiLCJhbGxvd1Jvb3QiLCJiZWdpbkxpZmVDeWNsZVRpbWVyIiwidGltZXJUeXBlIiwiZW5kTGlmZUN5Y2xlVGltZXIiLCJwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lciIsImN1cnJlbnRUaW1lciIsInN0YXJ0VGltZSIsIm5lc3RlZEZsdXNoU3RhcnRUaW1lIiwicmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyIiwiX2xpZmVDeWNsZVRpbWVyU3RhY2skIiwibmVzdGVkRmx1c2hEdXJhdGlvbiIsImxhc3RNYXJrVGltZVN0YW1wIiwiY2FuVXNlUGVyZm9ybWFuY2VNZWFzdXJlIiwicGVyZm9ybWFuY2UiLCJjbGVhck1hcmtzIiwibWVhc3VyZSIsImNsZWFyTWVhc3VyZXMiLCJzaG91bGRNYXJrIiwiaXNIb3N0RWxlbWVudCIsIm1hcmtCZWdpbiIsIm1hcmtUeXBlIiwibWFya05hbWUiLCJtYXJrRW5kIiwibWVhc3VyZW1lbnROYW1lIiwicmVtb3ZlSG9vayIsImJlZ2luUHJvZmlsaW5nIiwiZW5kUHJvZmlsaW5nIiwiZ2V0Rmx1c2hIaXN0b3J5Iiwib25CZWdpbkxpZmVDeWNsZVRpbWVyIiwib25FbmRMaWZlQ3ljbGVUaW1lciIsIm9uQmVnaW5Qcm9jZXNzaW5nQ2hpbGRDb250ZXh0Iiwib25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0Iiwib3BlcmF0aW9uIiwiY2hpbGREZWJ1Z0lEcyIsIm9uVGVzdEV2ZW50IiwiYWRkRGV2dG9vbCIsInJlbW92ZURldnRvb2wiLCJwcm9jZXNzaW5nQ2hpbGRDb250ZXh0Iiwid2FybkludmFsaWRTZXRTdGF0ZSIsIl9wcmV2ZW50Q2xlYXJpbmciLCJtc1BlcmZvcm1hbmNlIiwid2Via2l0UGVyZm9ybWFuY2UiLCJtb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsIndpbiIsInJlbGF0ZWQiLCJ0b05vZGUiLCJhY2NlcHQiLCJhY2NlcHRDaGFyc2V0IiwiYWNjZXNzS2V5IiwiYWxsb3dGdWxsU2NyZWVuIiwiYWxsb3dUcmFuc3BhcmVuY3kiLCJhbHQiLCJhcyIsImFzeW5jIiwiYXV0b0NvbXBsZXRlIiwiYXV0b1BsYXkiLCJjZWxsUGFkZGluZyIsImNlbGxTcGFjaW5nIiwiY2hhclNldCIsImNoYWxsZW5nZSIsImNsYXNzSUQiLCJjbGFzc05hbWUiLCJjb2xzIiwiY29sU3BhbiIsImNvbnRleHRNZW51IiwiY29udHJvbHMiLCJjb29yZHMiLCJjcm9zc09yaWdpbiIsImRhdGVUaW1lIiwiZGVmZXIiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY1R5cGUiLCJmb3JtQWN0aW9uIiwiZm9ybUVuY1R5cGUiLCJmb3JtTWV0aG9kIiwiZm9ybU5vVmFsaWRhdGUiLCJmb3JtVGFyZ2V0IiwiZnJhbWVCb3JkZXIiLCJoZWFkZXJzIiwiaGVpZ2h0IiwiaGlnaCIsImhyZWZMYW5nIiwiaHRtbEZvciIsImh0dHBFcXVpdiIsImljb24iLCJpbnB1dE1vZGUiLCJpbnRlZ3JpdHkiLCJrZXlQYXJhbXMiLCJrZXlUeXBlIiwia2luZCIsImxhbmciLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW5IZWlnaHQiLCJtYXJnaW5XaWR0aCIsIm1heCIsIm1heExlbmd0aCIsIm1lZGlhIiwibWVkaWFHcm91cCIsIm1pbkxlbmd0aCIsIm11dGVkIiwibm9uY2UiLCJub1ZhbGlkYXRlIiwib3BlbiIsIm9wdGltdW0iLCJwbGFjZWhvbGRlciIsInBsYXlzSW5saW5lIiwicG9zdGVyIiwicHJlbG9hZCIsInByb2ZpbGUiLCJyYWRpb0dyb3VwIiwicmVmZXJyZXJQb2xpY3kiLCJyZWwiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm9sZSIsInJvd3MiLCJyb3dTcGFuIiwic2FuZGJveCIsInNjb3BlZCIsInNjcm9sbGluZyIsInNlYW1sZXNzIiwic2l6ZSIsInNpemVzIiwic3BlbGxDaGVjayIsInNyYyIsInNyY0RvYyIsInNyY0xhbmciLCJzcmNTZXQiLCJ0YWJJbmRleCIsInVzZU1hcCIsIndpZHRoIiwid21vZGUiLCJ3cmFwIiwiYWJvdXQiLCJkYXRhdHlwZSIsImlubGlzdCIsInJlc291cmNlIiwidm9jYWIiLCJhdXRvQ2FwaXRhbGl6ZSIsImF1dG9Db3JyZWN0IiwiYXV0b1NhdmUiLCJpdGVtUHJvcCIsIml0ZW1TY29wZSIsIml0ZW1UeXBlIiwiaXRlbUlEIiwiaXRlbVJlZiIsInJlc3VsdHMiLCJzZWN1cml0eSIsInVuc2VsZWN0YWJsZSIsInZhbGlkaXR5IiwiYmFkSW5wdXQiLCJSZWFjdERPTUlET3BlcmF0aW9ucyIsImRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyIsImNyZWF0ZU5vZGVzRnJvbU1hcmt1cCIsIm5ld0NoaWxkIiwiY3JlYXRlQXJyYXlGcm9tTWl4ZWQiLCJnZXRNYXJrdXBXcmFwIiwiZHVtbXlOb2RlIiwibm9kZU5hbWVQYXR0ZXJuIiwiZ2V0Tm9kZU5hbWUiLCJub2RlTmFtZU1hdGNoIiwiaGFuZGxlU2NyaXB0Iiwid3JhcERlcHRoIiwic2NyaXB0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibm9kZXMiLCJjaGlsZE5vZGVzIiwiY2FsbGVlIiwiaGFzQXJyYXlOYXR1cmUiLCJzaG91bGRXcmFwIiwic2VsZWN0V3JhcCIsInRhYmxlV3JhcCIsInRyV3JhcCIsInN2Z1dyYXAiLCJtYXJrdXBXcmFwIiwic3ZnRWxlbWVudHMiLCJBdXRvRm9jdXNVdGlscyIsIkNTU1Byb3BlcnR5T3BlcmF0aW9ucyIsIlJlYWN0RE9NSW5wdXQiLCJSZWFjdERPTU9wdGlvbiIsIlJlYWN0RE9NVGV4dGFyZWEiLCJSZWFjdE11bHRpQ2hpbGQiLCJSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uIiwiZ2V0Tm9kZSIsIkNPTlRFTlRfVFlQRVMiLCJTVFlMRSIsIkhUTUwiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyIsIkRPQ19GUkFHTUVOVF9UWVBFIiwiZnJpZW5kbHlTdHJpbmdpZnkiLCJrZXlFc2NhcGVkIiwic3R5bGVNdXRhdGlvbldhcm5pbmciLCJjaGVja0FuZFdhcm5Gb3JNdXRhdGVkU3R5bGUiLCJzdHlsZTEiLCJzdHlsZTIiLCJfdGFnIiwiYXNzZXJ0VmFsaWRQcm9wcyIsInZvaWRFbGVtZW50VGFncyIsIm9uRm9jdXNJbiIsIm9uRm9jdXNPdXQiLCJlbnF1ZXVlUHV0TGlzdGVuZXIiLCJjb250YWluZXJJbmZvIiwiaXNEb2N1bWVudEZyYWdtZW50IiwiX25vZGUiLCJfb3duZXJEb2N1bWVudCIsImxpc3RlbmVyVG9QdXQiLCJpbnB1dFBvc3RNb3VudCIsInBvc3RNb3VudFdyYXBwZXIiLCJ0ZXh0YXJlYVBvc3RNb3VudCIsIm9wdGlvblBvc3RNb3VudCIsInNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2IiwiaGFzRXhpc3RpbmdDb250ZW50IiwiX2NvbnRlbnREZWJ1Z0lEIiwiY29udGVudERlYnVnSUQiLCJfYW5jZXN0b3JJbmZvIiwibWVkaWFFdmVudHMiLCJ0cmFja0lucHV0VmFsdWUiLCJ0cmFwQnViYmxlZEV2ZW50c0xvY2FsIiwicG9zdFVwZGF0ZVNlbGVjdFdyYXBwZXIiLCJvbWl0dGVkQ2xvc2VUYWdzIiwibmV3bGluZUVhdGluZ1RhZ3MiLCJsaXN0aW5nIiwiVkFMSURfVEFHX1JFR0VYIiwidmFsaWRhdGVkVGFnQ2FjaGUiLCJ2YWxpZGF0ZURhbmdlcm91c1RhZyIsImlzQ3VzdG9tQ29tcG9uZW50IiwiZ2xvYmFsSWRDb3VudGVyIiwiX25hbWVzcGFjZVVSSSIsIl9wcmV2aW91c1N0eWxlIiwiX3ByZXZpb3VzU3R5bGVDb3B5IiwiTWl4aW4iLCJfaWRDb3VudGVyIiwibW91bnRJbWFnZSIsImVsIiwiY3JlYXRlRWxlbWVudE5TIiwiX3VwZGF0ZURPTVByb3BlcnRpZXMiLCJsYXp5VHJlZSIsIl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4iLCJ0YWdPcGVuIiwiX2NyZWF0ZU9wZW5UYWdNYXJrdXBBbmRQdXRMaXN0ZW5lcnMiLCJ0YWdDb250ZW50IiwiX2NyZWF0ZUNvbnRlbnRNYXJrdXAiLCJhdXRvRm9jdXMiLCJmb2N1c0RPTUNvbXBvbmVudCIsInByb3BLZXkiLCJjcmVhdGVNYXJrdXBGb3JTdHlsZXMiLCJyZW5kZXJUb1N0YXRpY01hcmt1cCIsIl9faHRtbCIsImNvbnRlbnRUb1VzZSIsImNoaWxkcmVuVG9Vc2UiLCJtb3VudEltYWdlcyIsIm1vdW50Q2hpbGRyZW4iLCJsYXN0UHJvcHMiLCJfdXBkYXRlRE9NQ2hpbGRyZW4iLCJ1cGRhdGVXcmFwcGVyIiwic3R5bGVOYW1lIiwic3R5bGVVcGRhdGVzIiwibGFzdFN0eWxlIiwibmV4dFByb3AiLCJsYXN0UHJvcCIsInNldFZhbHVlRm9yU3R5bGVzIiwibGFzdENvbnRlbnQiLCJuZXh0Q29udGVudCIsImxhc3RIdG1sIiwibmV4dEh0bWwiLCJsYXN0Q2hpbGRyZW4iLCJuZXh0Q2hpbGRyZW4iLCJsYXN0SGFzQ29udGVudE9ySHRtbCIsIm5leHRIYXNDb250ZW50T3JIdG1sIiwidXBkYXRlQ2hpbGRyZW4iLCJ1cGRhdGVUZXh0Q29udGVudCIsInVwZGF0ZU1hcmt1cCIsInVubW91bnRDaGlsZHJlbiIsImNhbWVsaXplU3R5bGVOYW1lIiwiZGFuZ2Vyb3VzU3R5bGVWYWx1ZSIsImh5cGhlbmF0ZVN0eWxlTmFtZSIsIm1lbW9pemVTdHJpbmdPbmx5IiwicHJvY2Vzc1N0eWxlTmFtZSIsImhhc1Nob3J0aGFuZFByb3BlcnR5QnVnIiwic3R5bGVGbG9hdEFjY2Vzc29yIiwidGVtcFN0eWxlIiwiY3NzRmxvYXQiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwiY2hlY2tSZW5kZXJNZXNzYWdlIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwid2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uIiwid2FyblN0eWxlVmFsdWVJc05hTiIsIndhcm5WYWxpZFN0eWxlIiwic3R5bGVzIiwic2VyaWFsaXplZCIsImlzQ3VzdG9tUHJvcGVydHkiLCJzdHlsZVZhbHVlIiwic2V0UHJvcGVydHkiLCJleHBhbnNpb24iLCJpbmRpdmlkdWFsU3R5bGVOYW1lIiwiY2FtZWxpemUiLCJtc1BhdHRlcm4iLCJfaHlwaGVuUGF0dGVybiIsIl8iLCJjaGFyYWN0ZXIiLCJzdHlsZVdhcm5pbmdzIiwiaXNFbXB0eSIsImlzTm9uTnVtZXJpYyIsIndhcm5lZCIsIndhcm5pbmdzIiwiaHlwaGVuYXRlIiwiX3VwcGVyY2FzZVBhdHRlcm4iLCJydW5FdmVudFF1ZXVlSW5CYXRjaCIsIm1ha2VQcmVmaXhNYXAiLCJzdHlsZVByb3AiLCJ2ZW5kb3JQcmVmaXhlcyIsImFuaW1hdGlvbmVuZCIsImFuaW1hdGlvbml0ZXJhdGlvbiIsImFuaW1hdGlvbnN0YXJ0IiwidHJhbnNpdGlvbmVuZCIsInByZWZpeGVkRXZlbnROYW1lcyIsImFuaW1hdGlvbiIsInRyYW5zaXRpb24iLCJwcmVmaXhNYXAiLCJkaWRXYXJuQ2hlY2tlZExpbmsiLCJkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkIiwiZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCIsImRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQiLCJmb3JjZVVwZGF0ZUlmTW91bnRlZCIsImlzQ29udHJvbGxlZCIsInVzZXNDaGVja2VkIiwiaG9zdFByb3BzIiwiZGVmYXVsdENoZWNrZWQiLCJpbml0aWFsQ2hlY2tlZCIsInZhbHVlQXNOdW1iZXIiLCJwYXJzZUZsb2F0Iiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJncm91cCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvdGhlck5vZGUiLCJvdGhlckluc3RhbmNlIiwiZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiIsImZsYXR0ZW5DaGlsZHJlbiIsInNlbGVjdFZhbHVlIiwic2VsZWN0UGFyZW50IiwiZGlkV2FyblZhbERlZmF1bHRWYWwiLCJuZXdWYWx1ZSIsIlJlYWN0Q2hpbGRSZWNvbmNpbGVyIiwibWFrZUluc2VydE1hcmt1cCIsIm1ha2VNb3ZlIiwibWFrZVJlbW92ZSIsIm1ha2VTZXRNYXJrdXAiLCJtYWtlVGV4dENvbnRlbnQiLCJwcm9jZXNzUXVldWUiLCJ1cGRhdGVRdWV1ZSIsInNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uIiwiZ2V0RGVidWdJRCIsImludGVybmFsIiwiX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuIiwibmVzdGVkQ2hpbGRyZW4iLCJzZWxmRGVidWdJRCIsImluc3RhbnRpYXRlQ2hpbGRyZW4iLCJfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuIiwicHJldkNoaWxkcmVuIiwibmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMiLCJyZW1vdmVkTm9kZXMiLCJuZXh0TWFya3VwIiwiX3VwZGF0ZUNoaWxkcmVuIiwibmV4dEluZGV4IiwibmV4dE1vdW50SW5kZXgiLCJsYXN0UGxhY2VkTm9kZSIsInByZXZDaGlsZCIsIl9tb3VudENoaWxkQXRJbmRleCIsIl91bm1vdW50Q2hpbGQiLCJyZW5kZXJlZENoaWxkcmVuIiwiY3JlYXRlQ2hpbGQiLCJpbnN0YW50aWF0ZUNoaWxkIiwiY2hpbGRJbnN0YW5jZXMiLCJrZXlVbmlxdWUiLCJuZXN0ZWRDaGlsZE5vZGVzIiwiY2hpbGRJbnN0cyIsIm5leHRDaGlsZEluc3RhbmNlIiwibmV4dENoaWxkTW91bnRJbWFnZSIsInJlbmRlcmVkQ2hpbGQiLCJDb21wb3NpdGVUeXBlcyIsIkltcHVyZUNsYXNzIiwiUHVyZUNsYXNzIiwiU3RhdGVsZXNzRnVuY3Rpb25hbCIsIlN0YXRlbGVzc0NvbXBvbmVudCIsIndhcm5JZkludmFsaWRFbGVtZW50Iiwic2hvdWxkQ29uc3RydWN0IiwiaXNQdXJlQ29tcG9uZW50IiwibWVhc3VyZUxpZmVDeWNsZVBlcmYiLCJuZXh0TW91bnRJRCIsIl9jb21wb3NpdGVUeXBlIiwiX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50IiwicHVibGljUHJvcHMiLCJwdWJsaWNDb250ZXh0IiwiX3Byb2Nlc3NDb250ZXh0IiwiZ2V0VXBkYXRlUXVldWUiLCJkb0NvbnN0cnVjdCIsIl9jb25zdHJ1Y3RDb21wb25lbnQiLCJyZW5kZXJlZEVsZW1lbnQiLCJwcm9wc011dGF0ZWQiLCJjb21wb25lbnREaWRVbm1vdW50IiwidW5zdGFibGVfaGFuZGxlRXJyb3IiLCJwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmciLCJwZXJmb3JtSW5pdGlhbE1vdW50IiwiX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lciIsIl9wcm9jZXNzUGVuZGluZ1N0YXRlIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCIsIl9tYXNrQ29udGV4dCIsIm1hc2tlZENvbnRleHQiLCJjb250ZXh0TmFtZSIsIl9jaGVja0NvbnRleHRUeXBlcyIsImN1cnJlbnRDb250ZXh0IiwicHJldkNvbnRleHQiLCJwcmV2UGFyZW50RWxlbWVudCIsIm5leHRQYXJlbnRFbGVtZW50IiwicHJldlVubWFza2VkQ29udGV4dCIsIm5leHRVbm1hc2tlZENvbnRleHQiLCJ3aWxsUmVjZWl2ZSIsInByZXZQcm9wcyIsInNob3VsZFVwZGF0ZSIsIl9wZXJmb3JtQ29tcG9uZW50VXBkYXRlIiwicGFydGlhbCIsInVubWFza2VkQ29udGV4dCIsImhhc0NvbXBvbmVudERpZFVwZGF0ZSIsInByZXZTdGF0ZSIsIl91cGRhdGVSZW5kZXJlZENvbXBvbmVudCIsInByZXZDb21wb25lbnRJbnN0YW5jZSIsInByZXZSZW5kZXJlZEVsZW1lbnQiLCJuZXh0UmVuZGVyZWRFbGVtZW50Iiwib2xkSG9zdE5vZGUiLCJfcmVwbGFjZU5vZGVXaXRoTWFya3VwIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCIsInB1YmxpY0NvbXBvbmVudEluc3RhbmNlIiwibmV4dERlYnVnSUQiLCJmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCIsIlJlYWN0U2VydmVyVXBkYXRlUXVldWUiLCJub29wQ2FsbGJhY2tRdWV1ZSIsImRvbUlEIiwiY3JlYXRlQ29tbWVudCIsImluc3RBIiwiaW5zdEIiLCJkZXB0aEEiLCJ0ZW1wQSIsImRlcHRoQiIsInRlbXBCIiwiZGVwdGgiLCJjb21tb24iLCJwYXRoRnJvbSIsInBhdGhUbyIsIl9zdHJpbmdUZXh0IiwiX2Nsb3NpbmdDb21tZW50IiwiX2NvbW1lbnROb2RlcyIsIm9wZW5pbmdWYWx1ZSIsImNsb3NpbmdWYWx1ZSIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJlc2NhcGVkVGV4dCIsIm5leHRUZXh0IiwibmV4dFN0cmluZ1RleHQiLCJjb21tZW50Tm9kZXMiLCJSRVNFVF9CQVRDSEVEX1VQREFURVMiLCJGTFVTSF9CQVRDSEVEX1VQREFURVMiLCJSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24iLCJhbHJlYWR5QmF0Y2hpbmdVcGRhdGVzIiwiZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24iLCJmaW5kUGFyZW50IiwiVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiYW5jZXN0b3JzIiwiaGFuZGxlVG9wTGV2ZWxJbXBsIiwiYW5jZXN0b3IiLCJfaGFuZGxlVG9wTGV2ZWwiLCJzY3JvbGxWYWx1ZU1vbml0b3IiLCJfZW5hYmxlZCIsInNjcm9sbGFibGUiLCJXaW5kb3ciLCJwYWdlWE9mZnNldCIsInNjcm9sbExlZnQiLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsIlNFTEVDVElPTl9SRVNUT1JBVElPTiIsIkVWRU5UX1NVUFBSRVNTSU9OIiwiY3VycmVudGx5RW5hYmxlZCIsInByZXZpb3VzbHlFbmFibGVkIiwiT05fRE9NX1JFQURZX1FVRVVFSU5HIiwicmVhY3RNb3VudFJlYWR5IiwiZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCIsImlzQ29sbGFwc2VkIiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzT2Zmc2V0IiwiZ2V0SUVPZmZzZXRzIiwic2VsZWN0ZWRSYW5nZSIsInNlbGVjdGVkTGVuZ3RoIiwiZnJvbVN0YXJ0IiwiZHVwbGljYXRlIiwibW92ZVRvRWxlbWVudFRleHQiLCJzZXRFbmRQb2ludCIsInN0YXJ0T2Zmc2V0IiwiZW5kT2Zmc2V0IiwiZ2V0TW9kZXJuT2Zmc2V0cyIsInJhbmdlQ291bnQiLCJjdXJyZW50UmFuZ2UiLCJnZXRSYW5nZUF0Iiwic3RhcnRDb250YWluZXIiLCJlbmRDb250YWluZXIiLCJpc1NlbGVjdGlvbkNvbGxhcHNlZCIsInJhbmdlTGVuZ3RoIiwidGVtcFJhbmdlIiwiY2xvbmVSYW5nZSIsInNlbGVjdE5vZGVDb250ZW50cyIsInNldEVuZCIsImlzVGVtcFJhbmdlQ29sbGFwc2VkIiwiZGV0ZWN0aW9uUmFuZ2UiLCJzZXRTdGFydCIsImlzQmFja3dhcmQiLCJjb2xsYXBzZWQiLCJzZXRJRU9mZnNldHMiLCJzZXRNb2Rlcm5PZmZzZXRzIiwiZXh0ZW5kIiwidGVtcCIsInN0YXJ0TWFya2VyIiwiZW5kTWFya2VyIiwib2Zmc2V0IiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJ1c2VJRU9mZnNldHMiLCJnZXRMZWFmTm9kZSIsImdldFNpYmxpbmdOb2RlIiwibm9kZVN0YXJ0Iiwibm9kZUVuZCIsImlzVGV4dE5vZGUiLCJvdXRlck5vZGUiLCJpbm5lck5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiTm9kZSIsIk5TIiwieGxpbmsiLCJ4bWwiLCJBVFRSUyIsImFjY2VudEhlaWdodCIsImFjY3VtdWxhdGUiLCJhZGRpdGl2ZSIsImFsaWdubWVudEJhc2VsaW5lIiwiYWxsb3dSZW9yZGVyIiwiYWxwaGFiZXRpYyIsImFtcGxpdHVkZSIsImFyYWJpY0Zvcm0iLCJhc2NlbnQiLCJhdHRyaWJ1dGVUeXBlIiwiYXV0b1JldmVyc2UiLCJhemltdXRoIiwiYmFzZUZyZXF1ZW5jeSIsImJhc2VQcm9maWxlIiwiYmFzZWxpbmVTaGlmdCIsImJib3giLCJiZWdpbiIsImJpYXMiLCJieSIsImNhbGNNb2RlIiwiY2FwSGVpZ2h0IiwiY2xpcCIsImNsaXBSdWxlIiwiY2xpcFBhdGhVbml0cyIsImNvbG9ySW50ZXJwb2xhdGlvbiIsImNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMiLCJjb2xvclByb2ZpbGUiLCJjb2xvclJlbmRlcmluZyIsImNvbnRlbnRTY3JpcHRUeXBlIiwiY29udGVudFN0eWxlVHlwZSIsImN1cnNvciIsImN4IiwiY3kiLCJkZWNlbGVyYXRlIiwiZGVzY2VudCIsImRpZmZ1c2VDb25zdGFudCIsImRpcmVjdGlvbiIsImRpc3BsYXkiLCJkaXZpc29yIiwiZG9taW5hbnRCYXNlbGluZSIsImR1ciIsImR4IiwiZHkiLCJlZGdlTW9kZSIsImVsZXZhdGlvbiIsImVuYWJsZUJhY2tncm91bmQiLCJleHBvbmVudCIsImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQiLCJmaWxsIiwiZmlsbFJ1bGUiLCJmaWx0ZXJSZXMiLCJmaWx0ZXJVbml0cyIsImZsb29kQ29sb3IiLCJmb2N1c2FibGUiLCJmb250U2l6ZUFkanVzdCIsImZvbnRTdHJldGNoIiwiZngiLCJmeSIsImcxIiwiZzIiLCJnbHlwaE5hbWUiLCJnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCIsImdseXBoT3JpZW50YXRpb25WZXJ0aWNhbCIsImdseXBoUmVmIiwiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudFVuaXRzIiwiaGFuZ2luZyIsImhvcml6QWR2WCIsImhvcml6T3JpZ2luWCIsImlkZW9ncmFwaGljIiwiaW1hZ2VSZW5kZXJpbmciLCJpbjIiLCJpbnRlcmNlcHQiLCJrMSIsImsyIiwiazMiLCJrNCIsImtlcm5lbE1hdHJpeCIsImtlcm5lbFVuaXRMZW5ndGgiLCJrZXJuaW5nIiwia2V5UG9pbnRzIiwia2V5U3BsaW5lcyIsImtleVRpbWVzIiwibGVuZ3RoQWRqdXN0IiwibGV0dGVyU3BhY2luZyIsImxpZ2h0aW5nQ29sb3IiLCJsaW1pdGluZ0NvbmVBbmdsZSIsImxvY2FsIiwibWFya2VyRW5kIiwibWFya2VyTWlkIiwibWFya2VyU3RhcnQiLCJtYXJrZXJIZWlnaHQiLCJtYXJrZXJVbml0cyIsIm1hcmtlcldpZHRoIiwibWFza0NvbnRlbnRVbml0cyIsIm1hc2tVbml0cyIsIm1hdGhlbWF0aWNhbCIsIm1vZGUiLCJudW1PY3RhdmVzIiwib3BlcmF0b3IiLCJvcmllbnQiLCJvcmllbnRhdGlvbiIsIm9yaWdpbiIsIm92ZXJmbG93Iiwib3ZlcmxpbmVQb3NpdGlvbiIsIm92ZXJsaW5lVGhpY2tuZXNzIiwicGFpbnRPcmRlciIsInBhbm9zZTEiLCJwYXRoTGVuZ3RoIiwicGF0dGVybkNvbnRlbnRVbml0cyIsInBhdHRlcm5UcmFuc2Zvcm0iLCJwYXR0ZXJuVW5pdHMiLCJwb2ludGVyRXZlbnRzIiwicG9pbnRzIiwicG9pbnRzQXRYIiwicG9pbnRzQXRZIiwicG9pbnRzQXRaIiwicHJlc2VydmVBbHBoYSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJwcmltaXRpdmVVbml0cyIsInIiLCJyYWRpdXMiLCJyZWZYIiwicmVmWSIsInJlbmRlcmluZ0ludGVudCIsInJlcGVhdENvdW50IiwicmVwZWF0RHVyIiwicmVxdWlyZWRFeHRlbnNpb25zIiwicmVxdWlyZWRGZWF0dXJlcyIsInJlc3RhcnQiLCJyb3RhdGUiLCJyeCIsInJ5Iiwic2NhbGUiLCJzZWVkIiwic2hhcGVSZW5kZXJpbmciLCJzbG9wZSIsInNwYWNpbmciLCJzcGVjdWxhckNvbnN0YW50Iiwic3BlY3VsYXJFeHBvbmVudCIsInNwZWVkIiwic3ByZWFkTWV0aG9kIiwic3RkRGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaFRpbGVzIiwic3RvcENvbG9yIiwic3RyaWtldGhyb3VnaFBvc2l0aW9uIiwic3RyaWtldGhyb3VnaFRoaWNrbmVzcyIsInN0cm9rZSIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN1cmZhY2VTY2FsZSIsInN5c3RlbUxhbmd1YWdlIiwidGFibGVWYWx1ZXMiLCJ0YXJnZXRYIiwidGFyZ2V0WSIsInRleHRBbmNob3IiLCJ0ZXh0RGVjb3JhdGlvbiIsInRleHRSZW5kZXJpbmciLCJ0ZXh0TGVuZ3RoIiwidHJhbnNmb3JtIiwidTEiLCJ1MiIsInVuZGVybGluZVBvc2l0aW9uIiwidW5kZXJsaW5lVGhpY2tuZXNzIiwidW5pY29kZSIsInVuaWNvZGVCaWRpIiwidW5pY29kZVJhbmdlIiwidW5pdHNQZXJFbSIsInZBbHBoYWJldGljIiwidkhhbmdpbmciLCJ2SWRlb2dyYXBoaWMiLCJ2TWF0aGVtYXRpY2FsIiwidmVjdG9yRWZmZWN0IiwidmVydEFkdlkiLCJ2ZXJ0T3JpZ2luWCIsInZlcnRPcmlnaW5ZIiwidmlld0JveCIsInZpZXdUYXJnZXQiLCJ2aXNpYmlsaXR5Iiwid2lkdGhzIiwid29yZFNwYWNpbmciLCJ3cml0aW5nTW9kZSIsInhIZWlnaHQiLCJ4MSIsIngyIiwieENoYW5uZWxTZWxlY3RvciIsInhsaW5rQWN0dWF0ZSIsInhsaW5rQXJjcm9sZSIsInhsaW5rSHJlZiIsInhsaW5rUm9sZSIsInhsaW5rU2hvdyIsInhsaW5rVGl0bGUiLCJ4bGlua1R5cGUiLCJ4bWxCYXNlIiwieG1sbnMiLCJ4bWxuc1hsaW5rIiwieG1sTGFuZyIsInhtbFNwYWNlIiwieTEiLCJ5MiIsInlDaGFubmVsU2VsZWN0b3IiLCJ6Iiwiem9vbUFuZFBhbiIsInNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCIsImxhc3RTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJoYXNMaXN0ZW5lciIsImJvdW5kaW5nVG9wIiwibGVmdCIsImJvdW5kaW5nTGVmdCIsImNvbnN0cnVjdFNlbGVjdEV2ZW50IiwiY3VycmVudFNlbGVjdGlvbiIsIlN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJTeW50aGV0aWNGb2N1c0V2ZW50IiwiU3ludGhldGljS2V5Ym9hcmRFdmVudCIsIlN5bnRoZXRpY0RyYWdFdmVudCIsIlN5bnRoZXRpY1RvdWNoRXZlbnQiLCJTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQiLCJTeW50aGV0aWNXaGVlbEV2ZW50IiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiY2FwaXRhbGl6ZWRFdmVudCIsIm9uRXZlbnQiLCJ0b3BFdmVudCIsIm9uQ2xpY2tMaXN0ZW5lcnMiLCJFdmVudENvbnN0cnVjdG9yIiwiQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UiLCJhbmltYXRpb25OYW1lIiwiZWxhcHNlZFRpbWUiLCJwc2V1ZG9FbGVtZW50IiwiQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UiLCJjbGlwYm9hcmREYXRhIiwiRm9jdXNFdmVudEludGVyZmFjZSIsImdldEV2ZW50S2V5IiwiS2V5Ym9hcmRFdmVudEludGVyZmFjZSIsInJlcGVhdCIsImxvY2FsZSIsIm5vcm1hbGl6ZUtleSIsIkVzYyIsIlNwYWNlYmFyIiwiTGVmdCIsIlVwIiwiUmlnaHQiLCJEb3duIiwiRGVsIiwiV2luIiwiTWVudSIsIkFwcHMiLCJTY3JvbGwiLCJNb3pQcmludGFibGVLZXkiLCJ0cmFuc2xhdGVUb0tleSIsIkRyYWdFdmVudEludGVyZmFjZSIsImRhdGFUcmFuc2ZlciIsIlRvdWNoRXZlbnRJbnRlcmZhY2UiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwiVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlIiwiV2hlZWxFdmVudEludGVyZmFjZSIsImRlbHRhWCIsIndoZWVsRGVsdGFYIiwiZGVsdGFZIiwid2hlZWxEZWx0YVkiLCJ3aGVlbERlbHRhIiwiZGVsdGFaIiwiZGVsdGFNb2RlIiwidG9wTGV2ZWxXcmFwcGVyIiwidXNlRmliZXIiLCJhZGxlcjMyIiwiVEFHX0VORCIsIkNPTU1FTlRfU1RBUlQiLCJhZGRDaGVja3N1bVRvTWFya3VwIiwiZXhpc3RpbmdDaGVja3N1bSIsIm1hcmt1cENoZWNrc3VtIiwiTU9EIiwibCIsIm0iLCJjb21wb25lbnRPckVsZW1lbnQiLCJyZWFjdFByb3BzIiwid2FybmVkUHJvcGVydGllcyIsInZhbGlkYXRlUHJvcGVydHkiLCJzdGFuZGFyZE5hbWUiLCJ3YXJuVW5rbm93blByb3BlcnRpZXMiLCJ1bmtub3duUHJvcHMiLCJpc1ZhbGlkIiwidW5rbm93blByb3BTdHJpbmciLCJoYW5kbGVFbGVtZW50IiwiZGlkV2FyblZhbHVlTnVsbCIsInJBUklBIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiLCJpbml0aWFsRW50cmllcyIsImluaXRpYWxJbmRleCIsInNoaW0iLCJnZXRTaGltIiwiY2xhbXAiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJfcHJvcHMkaW5pdGlhbEVudHJpZXMiLCJfcHJvcHMkaW5pdGlhbEluZGV4IiwibmV4dEVudHJpZXMiLCJjYW5HbyIsImlzQWJzb2x1dGUiLCJzcGxpY2VPbmUiLCJyZXNvbHZlUGF0aG5hbWUiLCJ0b1BhcnRzIiwiZnJvbVBhcnRzIiwiaXNUb0FicyIsImlzRnJvbUFicyIsIm11c3RFbmRBYnMiLCJoYXNUcmFpbGluZ1NsYXNoIiwibGFzdCIsInVwIiwicGFydCIsInVuc2hpZnQiLCJ2YWx1ZUVxdWFsIiwiYVR5cGUiLCJiVHlwZSIsImFWYWx1ZSIsInZhbHVlT2YiLCJiVmFsdWUiLCJhS2V5cyIsImJLZXlzIiwiZW5hYmxlIiwiZGlzYWJsZSIsIndoZW4iLCJpc1N0YXRpYyIsImlzYXJyYXkiLCJwYXRoVG9SZWdleHAiLCJwYXJzZSIsImNvbXBpbGUiLCJ0b2tlbnNUb0Z1bmN0aW9uIiwidG9rZW5zVG9SZWdFeHAiLCJQQVRIX1JFR0VYUCIsInRva2VucyIsImRlZmF1bHREZWxpbWl0ZXIiLCJkZWxpbWl0ZXIiLCJlc2NhcGVkIiwibW9kaWZpZXIiLCJhc3RlcmlzayIsIm9wdGlvbmFsIiwiZXNjYXBlR3JvdXAiLCJlc2NhcGVTdHJpbmciLCJlbmNvZGVVUklDb21wb25lbnRQcmV0dHkiLCJlbmNvZGVVUkkiLCJlbmNvZGVBc3RlcmlzayIsIm1hdGNoZXMiLCJvcHRzIiwiZW5jb2RlIiwicHJldHR5IiwidG9rZW4iLCJzZWdtZW50IiwiYXR0YWNoS2V5cyIsImZsYWdzIiwic2Vuc2l0aXZlIiwicmVnZXhwVG9SZWdleHAiLCJncm91cHMiLCJhcnJheVRvUmVnZXhwIiwicGFydHMiLCJyZWdleHAiLCJzdHJpbmdUb1JlZ2V4cCIsImVuZHNXaXRoRGVsaW1pdGVyIiwibm9ybWFsaXplTG9jYXRpb24iLCJfb2JqZWN0JHBhdGhuYW1lIiwiX29iamVjdCRzZWFyY2giLCJfb2JqZWN0JGhhc2giLCJhZGRCYXNlbmFtZSIsImNyZWF0ZVVSTCIsInN0YXRpY0hhbmRsZXIiLCJoYW5kbGVQdXNoIiwiaGFuZGxlUmVwbGFjZSIsIl90aGlzJHByb3BzMiIsImhhbmRsZUxpc3RlbiIsImhhbmRsZUJsb2NrIiwiX2VsZW1lbnQkcHJvcHMiLCJwYXRoUHJvcCIsIkMiLCJ3cmFwcGVkQ29tcG9uZW50UmVmIiwicmVtYWluaW5nUHJvcHMiLCJyb3V0ZUNvbXBvbmVudFByb3BzIiwiV3JhcHBlZENvbXBvbmVudCIsIlJFQUNUX1NUQVRJQ1MiLCJLTk9XTl9TVEFUSUNTIiwiY2FsbGVyIiwiYXJpdHkiLCJpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSIsImhvaXN0Tm9uUmVhY3RTdGF0aWNzIiwidGFyZ2V0Q29tcG9uZW50Iiwic291cmNlQ29tcG9uZW50IiwiY3VzdG9tU3RhdGljcyIsImNvbnN0YW50cyIsIkVYUEVSSUVOQ0VfSUQiLCJIb21lIiwibW91bnRlZCIsInF1ZXJ5U2VsZWN0b3IiLCJpbm5lclRleHQiLCJwcmVwZW5kIiwibG9nIiwibWV0YWRhdGEiLCJnYWxsZXJpZXMiLCJob3VzZXMiLCJwaWNzIiwiTWV0YVRhZyIsInRhZ3MiLCJtZXRhdGFnIiwiTmF2aWdhdGlvbiIsImhhc2hUeXBlIiwiSGFzaFBhdGhDb2RlcnMiLCJoYXNoYmFuZyIsImVuY29kZVBhdGgiLCJkZWNvZGVQYXRoIiwibm9zbGFzaCIsInNsYXNoIiwiZ2V0SGFzaFBhdGgiLCJwdXNoSGFzaFBhdGgiLCJyZXBsYWNlSGFzaFBhdGgiLCJjcmVhdGVIYXNoSGlzdG9yeSIsImNhbkdvV2l0aG91dFJlbG9hZCIsIl9wcm9wcyRoYXNoVHlwZSIsIl9IYXNoUGF0aENvZGVycyRoYXNoVCIsImlnbm9yZVBhdGgiLCJlbmNvZGVkUGF0aCIsInByZXZMb2NhdGlvbiIsImFsbFBhdGhzIiwibGFzdEluZGV4T2YiLCJoYXNoQ2hhbmdlZCIsIm5leHRQYXRocyIsImFjdGl2ZUNsYXNzTmFtZSIsImFjdGl2ZVN0eWxlIiwiZ2V0SXNBY3RpdmUiLCJyZXN0IiwiY29udGVudFNlcnZpY2VzIiwiUHJlc2VudGF0aW9uIiwiZ2FsbGVyeSIsImlkeCIsImRlc2MiLCJnZXRQaWNGb3IiLCJDb250ZW50U2VydmljZXMiLCJob3VzZSIsInBpYyIsInhpZCIsIkhlYWRlciIsIkhlYWRlclRhZyJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7O0FDN0RBO0FBQ0EsSUFBSUEsVUFBVUMsT0FBT0MsT0FBUCxHQUFpQixFQUEvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJQyxnQkFBSjtBQUNBLElBQUlDLGtCQUFKOztBQUVBLFNBQVNDLGdCQUFULEdBQTRCO0FBQ3hCLFVBQU0sSUFBSUMsS0FBSixDQUFVLGlDQUFWLENBQU47QUFDSDtBQUNELFNBQVNDLG1CQUFULEdBQWdDO0FBQzVCLFVBQU0sSUFBSUQsS0FBSixDQUFVLG1DQUFWLENBQU47QUFDSDtBQUNBLGFBQVk7QUFDVCxRQUFJO0FBQ0EsWUFBSSxPQUFPRSxVQUFQLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ2xDTCwrQkFBbUJLLFVBQW5CO0FBQ0gsU0FGRCxNQUVPO0FBQ0hMLCtCQUFtQkUsZ0JBQW5CO0FBQ0g7QUFDSixLQU5ELENBTUUsT0FBT0ksQ0FBUCxFQUFVO0FBQ1JOLDJCQUFtQkUsZ0JBQW5CO0FBQ0g7QUFDRCxRQUFJO0FBQ0EsWUFBSSxPQUFPSyxZQUFQLEtBQXdCLFVBQTVCLEVBQXdDO0FBQ3BDTixpQ0FBcUJNLFlBQXJCO0FBQ0gsU0FGRCxNQUVPO0FBQ0hOLGlDQUFxQkcsbUJBQXJCO0FBQ0g7QUFDSixLQU5ELENBTUUsT0FBT0UsQ0FBUCxFQUFVO0FBQ1JMLDZCQUFxQkcsbUJBQXJCO0FBQ0g7QUFDSixDQW5CQSxHQUFEO0FBb0JBLFNBQVNJLFVBQVQsQ0FBb0JDLEdBQXBCLEVBQXlCO0FBQ3JCLFFBQUlULHFCQUFxQkssVUFBekIsRUFBcUM7QUFDakM7QUFDQSxlQUFPQSxXQUFXSSxHQUFYLEVBQWdCLENBQWhCLENBQVA7QUFDSDtBQUNEO0FBQ0EsUUFBSSxDQUFDVCxxQkFBcUJFLGdCQUFyQixJQUF5QyxDQUFDRixnQkFBM0MsS0FBZ0VLLFVBQXBFLEVBQWdGO0FBQzVFTCwyQkFBbUJLLFVBQW5CO0FBQ0EsZUFBT0EsV0FBV0ksR0FBWCxFQUFnQixDQUFoQixDQUFQO0FBQ0g7QUFDRCxRQUFJO0FBQ0E7QUFDQSxlQUFPVCxpQkFBaUJTLEdBQWpCLEVBQXNCLENBQXRCLENBQVA7QUFDSCxLQUhELENBR0UsT0FBTUgsQ0FBTixFQUFRO0FBQ04sWUFBSTtBQUNBO0FBQ0EsbUJBQU9OLGlCQUFpQlUsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEJELEdBQTVCLEVBQWlDLENBQWpDLENBQVA7QUFDSCxTQUhELENBR0UsT0FBTUgsQ0FBTixFQUFRO0FBQ047QUFDQSxtQkFBT04saUJBQWlCVSxJQUFqQixDQUFzQixJQUF0QixFQUE0QkQsR0FBNUIsRUFBaUMsQ0FBakMsQ0FBUDtBQUNIO0FBQ0o7QUFHSjtBQUNELFNBQVNFLGVBQVQsQ0FBeUJDLE1BQXpCLEVBQWlDO0FBQzdCLFFBQUlYLHVCQUF1Qk0sWUFBM0IsRUFBeUM7QUFDckM7QUFDQSxlQUFPQSxhQUFhSyxNQUFiLENBQVA7QUFDSDtBQUNEO0FBQ0EsUUFBSSxDQUFDWCx1QkFBdUJHLG1CQUF2QixJQUE4QyxDQUFDSCxrQkFBaEQsS0FBdUVNLFlBQTNFLEVBQXlGO0FBQ3JGTiw2QkFBcUJNLFlBQXJCO0FBQ0EsZUFBT0EsYUFBYUssTUFBYixDQUFQO0FBQ0g7QUFDRCxRQUFJO0FBQ0E7QUFDQSxlQUFPWCxtQkFBbUJXLE1BQW5CLENBQVA7QUFDSCxLQUhELENBR0UsT0FBT04sQ0FBUCxFQUFTO0FBQ1AsWUFBSTtBQUNBO0FBQ0EsbUJBQU9MLG1CQUFtQlMsSUFBbkIsQ0FBd0IsSUFBeEIsRUFBOEJFLE1BQTlCLENBQVA7QUFDSCxTQUhELENBR0UsT0FBT04sQ0FBUCxFQUFTO0FBQ1A7QUFDQTtBQUNBLG1CQUFPTCxtQkFBbUJTLElBQW5CLENBQXdCLElBQXhCLEVBQThCRSxNQUE5QixDQUFQO0FBQ0g7QUFDSjtBQUlKO0FBQ0QsSUFBSUMsUUFBUSxFQUFaO0FBQ0EsSUFBSUMsV0FBVyxLQUFmO0FBQ0EsSUFBSUMsWUFBSjtBQUNBLElBQUlDLGFBQWEsQ0FBQyxDQUFsQjs7QUFFQSxTQUFTQyxlQUFULEdBQTJCO0FBQ3ZCLFFBQUksQ0FBQ0gsUUFBRCxJQUFhLENBQUNDLFlBQWxCLEVBQWdDO0FBQzVCO0FBQ0g7QUFDREQsZUFBVyxLQUFYO0FBQ0EsUUFBSUMsYUFBYUcsTUFBakIsRUFBeUI7QUFDckJMLGdCQUFRRSxhQUFhSSxNQUFiLENBQW9CTixLQUFwQixDQUFSO0FBQ0gsS0FGRCxNQUVPO0FBQ0hHLHFCQUFhLENBQUMsQ0FBZDtBQUNIO0FBQ0QsUUFBSUgsTUFBTUssTUFBVixFQUFrQjtBQUNkRTtBQUNIO0FBQ0o7O0FBRUQsU0FBU0EsVUFBVCxHQUFzQjtBQUNsQixRQUFJTixRQUFKLEVBQWM7QUFDVjtBQUNIO0FBQ0QsUUFBSU8sVUFBVWIsV0FBV1MsZUFBWCxDQUFkO0FBQ0FILGVBQVcsSUFBWDs7QUFFQSxRQUFJUSxNQUFNVCxNQUFNSyxNQUFoQjtBQUNBLFdBQU1JLEdBQU4sRUFBVztBQUNQUCx1QkFBZUYsS0FBZjtBQUNBQSxnQkFBUSxFQUFSO0FBQ0EsZUFBTyxFQUFFRyxVQUFGLEdBQWVNLEdBQXRCLEVBQTJCO0FBQ3ZCLGdCQUFJUCxZQUFKLEVBQWtCO0FBQ2RBLDZCQUFhQyxVQUFiLEVBQXlCTyxHQUF6QjtBQUNIO0FBQ0o7QUFDRFAscUJBQWEsQ0FBQyxDQUFkO0FBQ0FNLGNBQU1ULE1BQU1LLE1BQVo7QUFDSDtBQUNESCxtQkFBZSxJQUFmO0FBQ0FELGVBQVcsS0FBWDtBQUNBSCxvQkFBZ0JVLE9BQWhCO0FBQ0g7O0FBRUR4QixRQUFRMkIsUUFBUixHQUFtQixVQUFVZixHQUFWLEVBQWU7QUFDOUIsUUFBSWdCLE9BQU8sSUFBSUMsS0FBSixDQUFVQyxVQUFVVCxNQUFWLEdBQW1CLENBQTdCLENBQVg7QUFDQSxRQUFJUyxVQUFVVCxNQUFWLEdBQW1CLENBQXZCLEVBQTBCO0FBQ3RCLGFBQUssSUFBSVUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxVQUFVVCxNQUE5QixFQUFzQ1UsR0FBdEMsRUFBMkM7QUFDdkNILGlCQUFLRyxJQUFJLENBQVQsSUFBY0QsVUFBVUMsQ0FBVixDQUFkO0FBQ0g7QUFDSjtBQUNEZixVQUFNZ0IsSUFBTixDQUFXLElBQUlDLElBQUosQ0FBU3JCLEdBQVQsRUFBY2dCLElBQWQsQ0FBWDtBQUNBLFFBQUlaLE1BQU1LLE1BQU4sS0FBaUIsQ0FBakIsSUFBc0IsQ0FBQ0osUUFBM0IsRUFBcUM7QUFDakNOLG1CQUFXWSxVQUFYO0FBQ0g7QUFDSixDQVhEOztBQWFBO0FBQ0EsU0FBU1UsSUFBVCxDQUFjckIsR0FBZCxFQUFtQnNCLEtBQW5CLEVBQTBCO0FBQ3RCLFNBQUt0QixHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLc0IsS0FBTCxHQUFhQSxLQUFiO0FBQ0g7QUFDREQsS0FBS0UsU0FBTCxDQUFlVCxHQUFmLEdBQXFCLFlBQVk7QUFDN0IsU0FBS2QsR0FBTCxDQUFTd0IsS0FBVCxDQUFlLElBQWYsRUFBcUIsS0FBS0YsS0FBMUI7QUFDSCxDQUZEO0FBR0FsQyxRQUFRcUMsS0FBUixHQUFnQixTQUFoQjtBQUNBckMsUUFBUXNDLE9BQVIsR0FBa0IsSUFBbEI7QUFDQXRDLFFBQVF1QyxHQUFSLEdBQWMsRUFBZDtBQUNBdkMsUUFBUXdDLElBQVIsR0FBZSxFQUFmO0FBQ0F4QyxRQUFReUMsT0FBUixHQUFrQixFQUFsQixDLENBQXNCO0FBQ3RCekMsUUFBUTBDLFFBQVIsR0FBbUIsRUFBbkI7O0FBRUEsU0FBU0MsSUFBVCxHQUFnQixDQUFFOztBQUVsQjNDLFFBQVE0QyxFQUFSLEdBQWFELElBQWI7QUFDQTNDLFFBQVE2QyxXQUFSLEdBQXNCRixJQUF0QjtBQUNBM0MsUUFBUThDLElBQVIsR0FBZUgsSUFBZjtBQUNBM0MsUUFBUStDLEdBQVIsR0FBY0osSUFBZDtBQUNBM0MsUUFBUWdELGNBQVIsR0FBeUJMLElBQXpCO0FBQ0EzQyxRQUFRaUQsa0JBQVIsR0FBNkJOLElBQTdCO0FBQ0EzQyxRQUFRa0QsSUFBUixHQUFlUCxJQUFmO0FBQ0EzQyxRQUFRbUQsZUFBUixHQUEwQlIsSUFBMUI7QUFDQTNDLFFBQVFvRCxtQkFBUixHQUE4QlQsSUFBOUI7O0FBRUEzQyxRQUFRcUQsU0FBUixHQUFvQixVQUFVQyxJQUFWLEVBQWdCO0FBQUUsV0FBTyxFQUFQO0FBQVcsQ0FBakQ7O0FBRUF0RCxRQUFRdUQsT0FBUixHQUFrQixVQUFVRCxJQUFWLEVBQWdCO0FBQzlCLFVBQU0sSUFBSWhELEtBQUosQ0FBVSxrQ0FBVixDQUFOO0FBQ0gsQ0FGRDs7QUFJQU4sUUFBUXdELEdBQVIsR0FBYyxZQUFZO0FBQUUsV0FBTyxHQUFQO0FBQVksQ0FBeEM7QUFDQXhELFFBQVF5RCxLQUFSLEdBQWdCLFVBQVVDLEdBQVYsRUFBZTtBQUMzQixVQUFNLElBQUlwRCxLQUFKLENBQVUsZ0NBQVYsQ0FBTjtBQUNILENBRkQ7QUFHQU4sUUFBUTJELEtBQVIsR0FBZ0IsWUFBVztBQUFFLFdBQU8sQ0FBUDtBQUFXLENBQXhDLEM7Ozs7Ozs7QUN2TEE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxJQUFJQyxpQkFBaUIsU0FBU0EsY0FBVCxDQUF3QkMsTUFBeEIsRUFBZ0MsQ0FBRSxDQUF2RDs7QUFFQSxJQUFJN0QsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNGLG1CQUFpQixTQUFTQSxjQUFULENBQXdCQyxNQUF4QixFQUFnQztBQUMvQyxRQUFJQSxXQUFXRSxTQUFmLEVBQTBCO0FBQ3hCLFlBQU0sSUFBSXpELEtBQUosQ0FBVSw4Q0FBVixDQUFOO0FBQ0Q7QUFDRixHQUpEO0FBS0Q7O0FBRUQsU0FBUzBELFNBQVQsQ0FBbUJDLFNBQW5CLEVBQThCSixNQUE5QixFQUFzQ0ssQ0FBdEMsRUFBeUNDLENBQXpDLEVBQTRDQyxDQUE1QyxFQUErQ0MsQ0FBL0MsRUFBa0Q1RCxDQUFsRCxFQUFxRDZELENBQXJELEVBQXdEO0FBQ3REVixpQkFBZUMsTUFBZjs7QUFFQSxNQUFJLENBQUNJLFNBQUwsRUFBZ0I7QUFDZCxRQUFJTSxLQUFKO0FBQ0EsUUFBSVYsV0FBV0UsU0FBZixFQUEwQjtBQUN4QlEsY0FBUSxJQUFJakUsS0FBSixDQUFVLHVFQUF1RSw2REFBakYsQ0FBUjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUlzQixPQUFPLENBQUNzQyxDQUFELEVBQUlDLENBQUosRUFBT0MsQ0FBUCxFQUFVQyxDQUFWLEVBQWE1RCxDQUFiLEVBQWdCNkQsQ0FBaEIsQ0FBWDtBQUNBLFVBQUlFLFdBQVcsQ0FBZjtBQUNBRCxjQUFRLElBQUlqRSxLQUFKLENBQVV1RCxPQUFPWSxPQUFQLENBQWUsS0FBZixFQUFzQixZQUFZO0FBQ2xELGVBQU83QyxLQUFLNEMsVUFBTCxDQUFQO0FBQ0QsT0FGaUIsQ0FBVixDQUFSO0FBR0FELFlBQU1qQixJQUFOLEdBQWEscUJBQWI7QUFDRDs7QUFFRGlCLFVBQU1HLFdBQU4sR0FBb0IsQ0FBcEIsQ0FiYyxDQWFTO0FBQ3ZCLFVBQU1ILEtBQU47QUFDRDtBQUNGOztBQUVEdEUsT0FBT0MsT0FBUCxHQUFpQjhELFNBQWpCLEM7Ozs7Ozs7O0FDdERBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSVcsZ0JBQWdCLG1CQUFBQyxDQUFRLEVBQVIsQ0FBcEI7O0FBRUE7Ozs7Ozs7QUFPQSxJQUFJQyxVQUFVRixhQUFkOztBQUVBLElBQUkzRSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJZ0IsZUFBZSxTQUFTQSxZQUFULENBQXNCakIsTUFBdEIsRUFBOEI7QUFDL0MsU0FBSyxJQUFJa0IsT0FBT2pELFVBQVVULE1BQXJCLEVBQTZCTyxPQUFPQyxNQUFNa0QsT0FBTyxDQUFQLEdBQVdBLE9BQU8sQ0FBbEIsR0FBc0IsQ0FBNUIsQ0FBcEMsRUFBb0VDLE9BQU8sQ0FBaEYsRUFBbUZBLE9BQU9ELElBQTFGLEVBQWdHQyxNQUFoRyxFQUF3RztBQUN0R3BELFdBQUtvRCxPQUFPLENBQVosSUFBaUJsRCxVQUFVa0QsSUFBVixDQUFqQjtBQUNEOztBQUVELFFBQUlSLFdBQVcsQ0FBZjtBQUNBLFFBQUlTLFVBQVUsY0FBY3BCLE9BQU9ZLE9BQVAsQ0FBZSxLQUFmLEVBQXNCLFlBQVk7QUFDNUQsYUFBTzdDLEtBQUs0QyxVQUFMLENBQVA7QUFDRCxLQUYyQixDQUE1QjtBQUdBLFFBQUksT0FBT1UsT0FBUCxLQUFtQixXQUF2QixFQUFvQztBQUNsQ0EsY0FBUVgsS0FBUixDQUFjVSxPQUFkO0FBQ0Q7QUFDRCxRQUFJO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsWUFBTSxJQUFJM0UsS0FBSixDQUFVMkUsT0FBVixDQUFOO0FBQ0QsS0FMRCxDQUtFLE9BQU9FLENBQVAsRUFBVSxDQUFFO0FBQ2YsR0FsQkQ7O0FBb0JBTixZQUFVLFNBQVNBLE9BQVQsQ0FBaUJaLFNBQWpCLEVBQTRCSixNQUE1QixFQUFvQztBQUM1QyxRQUFJQSxXQUFXRSxTQUFmLEVBQTBCO0FBQ3hCLFlBQU0sSUFBSXpELEtBQUosQ0FBVSw4REFBOEQsa0JBQXhFLENBQU47QUFDRDs7QUFFRCxRQUFJdUQsT0FBT3VCLE9BQVAsQ0FBZSw2QkFBZixNQUFrRCxDQUF0RCxFQUF5RDtBQUN2RCxhQUR1RCxDQUMvQztBQUNUOztBQUVELFFBQUksQ0FBQ25CLFNBQUwsRUFBZ0I7QUFDZCxXQUFLLElBQUlvQixRQUFRdkQsVUFBVVQsTUFBdEIsRUFBOEJPLE9BQU9DLE1BQU13RCxRQUFRLENBQVIsR0FBWUEsUUFBUSxDQUFwQixHQUF3QixDQUE5QixDQUFyQyxFQUF1RUMsUUFBUSxDQUFwRixFQUF1RkEsUUFBUUQsS0FBL0YsRUFBc0dDLE9BQXRHLEVBQStHO0FBQzdHMUQsYUFBSzBELFFBQVEsQ0FBYixJQUFrQnhELFVBQVV3RCxLQUFWLENBQWxCO0FBQ0Q7O0FBRURSLG1CQUFhMUMsS0FBYixDQUFtQjJCLFNBQW5CLEVBQThCLENBQUNGLE1BQUQsRUFBU3ZDLE1BQVQsQ0FBZ0JNLElBQWhCLENBQTlCO0FBQ0Q7QUFDRixHQWhCRDtBQWlCRDs7QUFFRDNCLE9BQU9DLE9BQVAsR0FBaUIyRSxPQUFqQixDOzs7Ozs7OztBQy9EQTs7Ozs7Ozs7OztBQVVBOztBQUVBOzs7Ozs7O0FBT0EsU0FBU1Usa0JBQVQsQ0FBNEJDLElBQTVCLEVBQWtDO0FBQ2hDLE1BQUlDLFdBQVczRCxVQUFVVCxNQUFWLEdBQW1CLENBQWxDOztBQUVBLE1BQUk0RCxVQUFVLDJCQUEyQk8sSUFBM0IsR0FBa0MsVUFBbEMsR0FBK0Msb0VBQS9DLEdBQXNIQSxJQUFwSTs7QUFFQSxPQUFLLElBQUlFLFNBQVMsQ0FBbEIsRUFBcUJBLFNBQVNELFFBQTlCLEVBQXdDQyxRQUF4QyxFQUFrRDtBQUNoRFQsZUFBVyxhQUFhVSxtQkFBbUI3RCxVQUFVNEQsU0FBUyxDQUFuQixDQUFuQixDQUF4QjtBQUNEOztBQUVEVCxhQUFXLGtFQUFrRSxtREFBN0U7O0FBRUEsTUFBSVYsUUFBUSxJQUFJakUsS0FBSixDQUFVMkUsT0FBVixDQUFaO0FBQ0FWLFFBQU1qQixJQUFOLEdBQWEscUJBQWI7QUFDQWlCLFFBQU1HLFdBQU4sR0FBb0IsQ0FBcEIsQ0FiZ0MsQ0FhVDs7QUFFdkIsUUFBTUgsS0FBTjtBQUNEOztBQUVEdEUsT0FBT0MsT0FBUCxHQUFpQnFGLGtCQUFqQixDOzs7Ozs7O0FDckNBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSUssaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCOztBQUVBLElBQUlpQixjQUFjLG1CQUFBakIsQ0FBUSxFQUFSLENBQWxCO0FBQ0EsSUFBSWtCLHlCQUF5QixtQkFBQWxCLENBQVEsRUFBUixDQUE3Qjs7QUFFQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7O0FBRUEsSUFBSW1CLFlBQVlGLFlBQVlHLGlCQUE1QjtBQUNBLElBQUlDLFFBQVFILHNCQUFaOztBQUVBLElBQUlJLHNCQUFzQiw2QkFBNkJDLEtBQUtDLE1BQUwsR0FBY0MsUUFBZCxDQUF1QixFQUF2QixFQUEyQkMsS0FBM0IsQ0FBaUMsQ0FBakMsQ0FBdkQ7O0FBRUE7OztBQUdBLFNBQVNDLGtCQUFULENBQTRCQyxJQUE1QixFQUFrQ0MsTUFBbEMsRUFBMEM7QUFDeEMsU0FBT0QsS0FBS0UsUUFBTCxLQUFrQixDQUFsQixJQUF1QkYsS0FBS0csWUFBTCxDQUFrQlosU0FBbEIsTUFBaUNhLE9BQU9ILE1BQVAsQ0FBeEQsSUFBMEVELEtBQUtFLFFBQUwsS0FBa0IsQ0FBbEIsSUFBdUJGLEtBQUtLLFNBQUwsS0FBbUIsa0JBQWtCSixNQUFsQixHQUEyQixHQUEvSSxJQUFzSkQsS0FBS0UsUUFBTCxLQUFrQixDQUFsQixJQUF1QkYsS0FBS0ssU0FBTCxLQUFtQixtQkFBbUJKLE1BQW5CLEdBQTRCLEdBQW5PO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTSyxrQ0FBVCxDQUE0Q0MsU0FBNUMsRUFBdUQ7QUFDckQsTUFBSUMsUUFBSjtBQUNBLFNBQU9BLFdBQVdELFVBQVVFLGtCQUE1QixFQUFnRDtBQUM5Q0YsZ0JBQVlDLFFBQVo7QUFDRDtBQUNELFNBQU9ELFNBQVA7QUFDRDs7QUFFRDs7OztBQUlBLFNBQVNHLFlBQVQsQ0FBc0JDLElBQXRCLEVBQTRCWCxJQUE1QixFQUFrQztBQUNoQyxNQUFJWSxXQUFXTixtQ0FBbUNLLElBQW5DLENBQWY7QUFDQUMsV0FBU0MsU0FBVCxHQUFxQmIsSUFBckI7QUFDQUEsT0FBS04sbUJBQUwsSUFBNEJrQixRQUE1QjtBQUNEOztBQUVELFNBQVNFLFdBQVQsQ0FBcUJILElBQXJCLEVBQTJCO0FBQ3pCLE1BQUlYLE9BQU9XLEtBQUtFLFNBQWhCO0FBQ0EsTUFBSWIsSUFBSixFQUFVO0FBQ1IsV0FBT0EsS0FBS04sbUJBQUwsQ0FBUDtBQUNBaUIsU0FBS0UsU0FBTCxHQUFpQixJQUFqQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FBY0EsU0FBU0Usa0JBQVQsQ0FBNEJKLElBQTVCLEVBQWtDWCxJQUFsQyxFQUF3QztBQUN0QyxNQUFJVyxLQUFLSyxNQUFMLEdBQWN2QixNQUFNd0IsbUJBQXhCLEVBQTZDO0FBQzNDO0FBQ0Q7QUFDRCxNQUFJQyxXQUFXUCxLQUFLUSxpQkFBcEI7QUFDQSxNQUFJQyxZQUFZcEIsS0FBS3FCLFVBQXJCO0FBQ0FDLFNBQU8sS0FBSyxJQUFJeEUsSUFBVCxJQUFpQm9FLFFBQWpCLEVBQTJCO0FBQ2hDLFFBQUksQ0FBQ0EsU0FBU0ssY0FBVCxDQUF3QnpFLElBQXhCLENBQUwsRUFBb0M7QUFDbEM7QUFDRDtBQUNELFFBQUkwRSxZQUFZTixTQUFTcEUsSUFBVCxDQUFoQjtBQUNBLFFBQUkyRSxVQUFVbkIsbUNBQW1Da0IsU0FBbkMsRUFBOENFLE1BQTVEO0FBQ0EsUUFBSUQsWUFBWSxDQUFoQixFQUFtQjtBQUNqQjtBQUNBO0FBQ0Q7QUFDRDtBQUNBLFdBQU9MLGNBQWMsSUFBckIsRUFBMkJBLFlBQVlBLFVBQVVPLFdBQWpELEVBQThEO0FBQzVELFVBQUk1QixtQkFBbUJxQixTQUFuQixFQUE4QkssT0FBOUIsQ0FBSixFQUE0QztBQUMxQ2YscUJBQWFjLFNBQWIsRUFBd0JKLFNBQXhCO0FBQ0EsaUJBQVNFLEtBQVQ7QUFDRDtBQUNGO0FBQ0Q7QUFDQSxZQUFTOUgsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixvQ0FBakIsRUFBdURpRSxPQUF2RCxDQUF4QyxHQUEwR3JDLGVBQWUsSUFBZixFQUFxQnFDLE9BQXJCLENBQW5ILEdBQW1KLEtBQUssQ0FBeEo7QUFDRDtBQUNEZCxPQUFLSyxNQUFMLElBQWV2QixNQUFNd0IsbUJBQXJCO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxTQUFTVywwQkFBVCxDQUFvQzVCLElBQXBDLEVBQTBDO0FBQ3hDLE1BQUlBLEtBQUtOLG1CQUFMLENBQUosRUFBK0I7QUFDN0IsV0FBT00sS0FBS04sbUJBQUwsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsTUFBSW1DLFVBQVUsRUFBZDtBQUNBLFNBQU8sQ0FBQzdCLEtBQUtOLG1CQUFMLENBQVIsRUFBbUM7QUFDakNtQyxZQUFRckcsSUFBUixDQUFhd0UsSUFBYjtBQUNBLFFBQUlBLEtBQUs4QixVQUFULEVBQXFCO0FBQ25COUIsYUFBT0EsS0FBSzhCLFVBQVo7QUFDRCxLQUZELE1BRU87QUFDTDtBQUNBO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJQyxPQUFKO0FBQ0EsTUFBSXBCLElBQUo7QUFDQSxTQUFPWCxTQUFTVyxPQUFPWCxLQUFLTixtQkFBTCxDQUFoQixDQUFQLEVBQW1ETSxPQUFPNkIsUUFBUUcsR0FBUixFQUExRCxFQUF5RTtBQUN2RUQsY0FBVXBCLElBQVY7QUFDQSxRQUFJa0IsUUFBUWhILE1BQVosRUFBb0I7QUFDbEJrRyx5QkFBbUJKLElBQW5CLEVBQXlCWCxJQUF6QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTytCLE9BQVA7QUFDRDs7QUFFRDs7OztBQUlBLFNBQVNFLG1CQUFULENBQTZCakMsSUFBN0IsRUFBbUM7QUFDakMsTUFBSVcsT0FBT2lCLDJCQUEyQjVCLElBQTNCLENBQVg7QUFDQSxNQUFJVyxRQUFRLElBQVIsSUFBZ0JBLEtBQUtFLFNBQUwsS0FBbUJiLElBQXZDLEVBQTZDO0FBQzNDLFdBQU9XLElBQVA7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPLElBQVA7QUFDRDtBQUNGOztBQUVEOzs7O0FBSUEsU0FBU3VCLG1CQUFULENBQTZCdkIsSUFBN0IsRUFBbUM7QUFDakM7QUFDQTtBQUNBLElBQUVBLEtBQUtFLFNBQUwsS0FBbUJ0RCxTQUFyQixJQUFrQy9ELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsd0NBQWpCLENBQXhDLEdBQXFHNEIsZUFBZSxJQUFmLENBQXZJLEdBQThKLEtBQUssQ0FBbks7O0FBRUEsTUFBSXVCLEtBQUtFLFNBQVQsRUFBb0I7QUFDbEIsV0FBT0YsS0FBS0UsU0FBWjtBQUNEOztBQUVEO0FBQ0EsTUFBSWdCLFVBQVUsRUFBZDtBQUNBLFNBQU8sQ0FBQ2xCLEtBQUtFLFNBQWIsRUFBd0I7QUFDdEJnQixZQUFRckcsSUFBUixDQUFhbUYsSUFBYjtBQUNBLEtBQUNBLEtBQUt3QixXQUFOLEdBQW9CM0ksUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiwwREFBakIsQ0FBeEMsR0FBdUg0QixlQUFlLElBQWYsQ0FBM0ksR0FBa0ssS0FBSyxDQUF2SztBQUNBdUIsV0FBT0EsS0FBS3dCLFdBQVo7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsU0FBT04sUUFBUWhILE1BQWYsRUFBdUI4RixPQUFPa0IsUUFBUUcsR0FBUixFQUE5QixFQUE2QztBQUMzQ2pCLHVCQUFtQkosSUFBbkIsRUFBeUJBLEtBQUtFLFNBQTlCO0FBQ0Q7O0FBRUQsU0FBT0YsS0FBS0UsU0FBWjtBQUNEOztBQUVELElBQUl1Qix3QkFBd0I7QUFDMUJSLDhCQUE0QkEsMEJBREY7QUFFMUJLLHVCQUFxQkEsbUJBRks7QUFHMUJDLHVCQUFxQkEsbUJBSEs7QUFJMUJuQixzQkFBb0JBLGtCQUpNO0FBSzFCTCxnQkFBY0EsWUFMWTtBQU0xQkksZUFBYUE7QUFOYSxDQUE1Qjs7QUFTQXJILE9BQU9DLE9BQVAsR0FBaUIwSSxxQkFBakIsQzs7Ozs7Ozs7QUNqTUE7O0FBRUEzSSxPQUFPQyxPQUFQLEdBQWlCLG1CQUFBMEUsQ0FBUSxFQUFSLENBQWpCLEM7Ozs7Ozs7QUNGQTs7Ozs7O0FBTUE7QUFDQTs7QUFDQSxJQUFJaUUsd0JBQXdCQyxPQUFPRCxxQkFBbkM7QUFDQSxJQUFJZCxpQkFBaUJlLE9BQU8zRyxTQUFQLENBQWlCNEYsY0FBdEM7QUFDQSxJQUFJZ0IsbUJBQW1CRCxPQUFPM0csU0FBUCxDQUFpQjZHLG9CQUF4Qzs7QUFFQSxTQUFTQyxRQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUN0QixLQUFJQSxRQUFRLElBQVIsSUFBZ0JBLFFBQVFuRixTQUE1QixFQUF1QztBQUN0QyxRQUFNLElBQUlvRixTQUFKLENBQWMsdURBQWQsQ0FBTjtBQUNBOztBQUVELFFBQU9MLE9BQU9JLEdBQVAsQ0FBUDtBQUNBOztBQUVELFNBQVNFLGVBQVQsR0FBMkI7QUFDMUIsS0FBSTtBQUNILE1BQUksQ0FBQ04sT0FBT08sTUFBWixFQUFvQjtBQUNuQixVQUFPLEtBQVA7QUFDQTs7QUFFRDs7QUFFQTtBQUNBLE1BQUlDLFFBQVEsSUFBSTFDLE1BQUosQ0FBVyxLQUFYLENBQVosQ0FSRyxDQVE2QjtBQUNoQzBDLFFBQU0sQ0FBTixJQUFXLElBQVg7QUFDQSxNQUFJUixPQUFPUyxtQkFBUCxDQUEyQkQsS0FBM0IsRUFBa0MsQ0FBbEMsTUFBeUMsR0FBN0MsRUFBa0Q7QUFDakQsVUFBTyxLQUFQO0FBQ0E7O0FBRUQ7QUFDQSxNQUFJRSxRQUFRLEVBQVo7QUFDQSxPQUFLLElBQUl6SCxJQUFJLENBQWIsRUFBZ0JBLElBQUksRUFBcEIsRUFBd0JBLEdBQXhCLEVBQTZCO0FBQzVCeUgsU0FBTSxNQUFNNUMsT0FBTzZDLFlBQVAsQ0FBb0IxSCxDQUFwQixDQUFaLElBQXNDQSxDQUF0QztBQUNBO0FBQ0QsTUFBSTJILFNBQVNaLE9BQU9TLG1CQUFQLENBQTJCQyxLQUEzQixFQUFrQ0csR0FBbEMsQ0FBc0MsVUFBVUMsQ0FBVixFQUFhO0FBQy9ELFVBQU9KLE1BQU1JLENBQU4sQ0FBUDtBQUNBLEdBRlksQ0FBYjtBQUdBLE1BQUlGLE9BQU9HLElBQVAsQ0FBWSxFQUFaLE1BQW9CLFlBQXhCLEVBQXNDO0FBQ3JDLFVBQU8sS0FBUDtBQUNBOztBQUVEO0FBQ0EsTUFBSUMsUUFBUSxFQUFaO0FBQ0EseUJBQXVCQyxLQUF2QixDQUE2QixFQUE3QixFQUFpQ0MsT0FBakMsQ0FBeUMsVUFBVUMsTUFBVixFQUFrQjtBQUMxREgsU0FBTUcsTUFBTixJQUFnQkEsTUFBaEI7QUFDQSxHQUZEO0FBR0EsTUFBSW5CLE9BQU9vQixJQUFQLENBQVlwQixPQUFPTyxNQUFQLENBQWMsRUFBZCxFQUFrQlMsS0FBbEIsQ0FBWixFQUFzQ0QsSUFBdEMsQ0FBMkMsRUFBM0MsTUFDRixzQkFERixFQUMwQjtBQUN6QixVQUFPLEtBQVA7QUFDQTs7QUFFRCxTQUFPLElBQVA7QUFDQSxFQXJDRCxDQXFDRSxPQUFPTSxHQUFQLEVBQVk7QUFDYjtBQUNBLFNBQU8sS0FBUDtBQUNBO0FBQ0Q7O0FBRURsSyxPQUFPQyxPQUFQLEdBQWlCa0osb0JBQW9CTixPQUFPTyxNQUEzQixHQUFvQyxVQUFVZSxNQUFWLEVBQWtCQyxNQUFsQixFQUEwQjtBQUM5RSxLQUFJQyxJQUFKO0FBQ0EsS0FBSUMsS0FBS3RCLFNBQVNtQixNQUFULENBQVQ7QUFDQSxLQUFJSSxPQUFKOztBQUVBLE1BQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJM0ksVUFBVVQsTUFBOUIsRUFBc0NvSixHQUF0QyxFQUEyQztBQUMxQ0gsU0FBT3hCLE9BQU9oSCxVQUFVMkksQ0FBVixDQUFQLENBQVA7O0FBRUEsT0FBSyxJQUFJQyxHQUFULElBQWdCSixJQUFoQixFQUFzQjtBQUNyQixPQUFJdkMsZUFBZWxILElBQWYsQ0FBb0J5SixJQUFwQixFQUEwQkksR0FBMUIsQ0FBSixFQUFvQztBQUNuQ0gsT0FBR0csR0FBSCxJQUFVSixLQUFLSSxHQUFMLENBQVY7QUFDQTtBQUNEOztBQUVELE1BQUk3QixxQkFBSixFQUEyQjtBQUMxQjJCLGFBQVUzQixzQkFBc0J5QixJQUF0QixDQUFWO0FBQ0EsUUFBSyxJQUFJdkksSUFBSSxDQUFiLEVBQWdCQSxJQUFJeUksUUFBUW5KLE1BQTVCLEVBQW9DVSxHQUFwQyxFQUF5QztBQUN4QyxRQUFJZ0gsaUJBQWlCbEksSUFBakIsQ0FBc0J5SixJQUF0QixFQUE0QkUsUUFBUXpJLENBQVIsQ0FBNUIsQ0FBSixFQUE2QztBQUM1Q3dJLFFBQUdDLFFBQVF6SSxDQUFSLENBQUgsSUFBaUJ1SSxLQUFLRSxRQUFRekksQ0FBUixDQUFMLENBQWpCO0FBQ0E7QUFDRDtBQUNEO0FBQ0Q7O0FBRUQsUUFBT3dJLEVBQVA7QUFDQSxDQXpCRCxDOzs7Ozs7O0FDaEVBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSUksWUFBWSxDQUFDLEVBQUUsT0FBT0MsTUFBUCxLQUFrQixXQUFsQixJQUFpQ0EsT0FBT0MsUUFBeEMsSUFBb0RELE9BQU9DLFFBQVAsQ0FBZ0JDLGFBQXRFLENBQWpCOztBQUVBOzs7Ozs7QUFNQSxJQUFJQyx1QkFBdUI7O0FBRXpCSixhQUFXQSxTQUZjOztBQUl6QkssaUJBQWUsT0FBT0MsTUFBUCxLQUFrQixXQUpSOztBQU16QkMsd0JBQXNCUCxhQUFhLENBQUMsRUFBRUMsT0FBT08sZ0JBQVAsSUFBMkJQLE9BQU9RLFdBQXBDLENBTlg7O0FBUXpCQyxrQkFBZ0JWLGFBQWEsQ0FBQyxDQUFDQyxPQUFPVSxNQVJiOztBQVV6QkMsY0FBWSxDQUFDWixTQVZZLENBVUY7O0FBVkUsQ0FBM0I7O0FBY0ExSyxPQUFPQyxPQUFQLEdBQWlCNkssb0JBQWpCLEM7Ozs7Ozs7Ozs7Ozs7O0FDbENBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUVBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUVBOzs7O0FBRUE7Ozs7QUFFQTs7Ozs7O1FBZjBCUyxZO1FBRU5DLE07UUFFRUMsUTtRQUVIQyxLO1FBRUNDLE07UUFFTUMsWTtRQUVOQyxNO1FBRUdDLFM7UUFFQ0MsVTs7Ozs7OztBQ2pCeEI7Ozs7Ozs7Ozs7O0FBV0E7Ozs7QUFFQSxJQUFJcEcsaUJBQWlCLG1CQUFBaEIsQ0FBUSxFQUFSLENBQXJCOztBQUVBLElBQUlxSCxvQkFBb0IsbUJBQUFySCxDQUFRLEVBQVIsQ0FBeEI7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCO0FBQ0EsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUEsU0FBU3NILFFBQVQsQ0FBa0JDLEVBQWxCLEVBQXNCO0FBQ3BCO0FBQ0EsTUFBSUMsZUFBZUMsU0FBU2xLLFNBQVQsQ0FBbUJrRSxRQUF0QztBQUNBLE1BQUkwQixpQkFBaUJlLE9BQU8zRyxTQUFQLENBQWlCNEYsY0FBdEM7QUFDQSxNQUFJdUUsYUFBYUMsT0FBTyxNQUFNSDtBQUM5QjtBQUQ4QixHQUU3QnZMLElBRjZCLENBRXhCa0g7QUFDTjtBQUg4QixJQUk1QnRELE9BSjRCLENBSXBCLHFCQUpvQixFQUlHO0FBQ2pDO0FBTDhCLElBTTVCQSxPQU40QixDQU1wQix3REFOb0IsRUFNc0MsT0FOdEMsQ0FBTixHQU11RCxHQU45RCxDQUFqQjtBQU9BLE1BQUk7QUFDRixRQUFJNEYsU0FBUytCLGFBQWF2TCxJQUFiLENBQWtCc0wsRUFBbEIsQ0FBYjtBQUNBLFdBQU9HLFdBQVdFLElBQVgsQ0FBZ0JuQyxNQUFoQixDQUFQO0FBQ0QsR0FIRCxDQUdFLE9BQU9GLEdBQVAsRUFBWTtBQUNaLFdBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsSUFBSXNDO0FBQ0o7QUFDQSxPQUFPNUssTUFBTXlJLElBQWIsS0FBc0IsVUFBdEI7QUFDQTtBQUNBLE9BQU9vQyxHQUFQLEtBQWUsVUFGZixJQUU2QlIsU0FBU1EsR0FBVCxDQUY3QjtBQUdBO0FBQ0FBLElBQUl2SyxTQUFKLElBQWlCLElBSmpCLElBSXlCLE9BQU91SyxJQUFJdkssU0FBSixDQUFjK0gsSUFBckIsS0FBOEIsVUFKdkQsSUFJcUVnQyxTQUFTUSxJQUFJdkssU0FBSixDQUFjK0gsSUFBdkIsQ0FKckU7QUFLQTtBQUNBLE9BQU95QyxHQUFQLEtBQWUsVUFOZixJQU02QlQsU0FBU1MsR0FBVCxDQU43QjtBQU9BO0FBQ0FBLElBQUl4SyxTQUFKLElBQWlCLElBUmpCLElBUXlCLE9BQU93SyxJQUFJeEssU0FBSixDQUFjK0gsSUFBckIsS0FBOEIsVUFSdkQsSUFRcUVnQyxTQUFTUyxJQUFJeEssU0FBSixDQUFjK0gsSUFBdkIsQ0FWckU7O0FBWUEsSUFBSTBDLE9BQUo7QUFDQSxJQUFJQyxPQUFKO0FBQ0EsSUFBSUMsVUFBSjtBQUNBLElBQUlDLFVBQUo7QUFDQSxJQUFJQyxPQUFKO0FBQ0EsSUFBSUMsVUFBSjtBQUNBLElBQUlDLFVBQUo7O0FBRUEsSUFBSVQsaUJBQUosRUFBdUI7QUFDckIsTUFBSVUsVUFBVSxJQUFJVCxHQUFKLEVBQWQ7QUFDQSxNQUFJVSxZQUFZLElBQUlULEdBQUosRUFBaEI7O0FBRUFDLFlBQVUsaUJBQVVTLEVBQVYsRUFBY0MsSUFBZCxFQUFvQjtBQUM1QkgsWUFBUUksR0FBUixDQUFZRixFQUFaLEVBQWdCQyxJQUFoQjtBQUNELEdBRkQ7QUFHQVQsWUFBVSxpQkFBVVEsRUFBVixFQUFjO0FBQ3RCLFdBQU9GLFFBQVFLLEdBQVIsQ0FBWUgsRUFBWixDQUFQO0FBQ0QsR0FGRDtBQUdBUCxlQUFhLG9CQUFVTyxFQUFWLEVBQWM7QUFDekJGLFlBQVEsUUFBUixFQUFrQkUsRUFBbEI7QUFDRCxHQUZEO0FBR0FOLGVBQWEsc0JBQVk7QUFDdkIsV0FBT2xMLE1BQU15SSxJQUFOLENBQVc2QyxRQUFRakQsSUFBUixFQUFYLENBQVA7QUFDRCxHQUZEOztBQUlBOEMsWUFBVSxpQkFBVUssRUFBVixFQUFjO0FBQ3RCRCxjQUFVSyxHQUFWLENBQWNKLEVBQWQ7QUFDRCxHQUZEO0FBR0FKLGVBQWEsb0JBQVVJLEVBQVYsRUFBYztBQUN6QkQsY0FBVSxRQUFWLEVBQW9CQyxFQUFwQjtBQUNELEdBRkQ7QUFHQUgsZUFBYSxzQkFBWTtBQUN2QixXQUFPckwsTUFBTXlJLElBQU4sQ0FBVzhDLFVBQVVsRCxJQUFWLEVBQVgsQ0FBUDtBQUNELEdBRkQ7QUFHRCxDQTFCRCxNQTBCTztBQUNMLE1BQUl3RCxZQUFZLEVBQWhCO0FBQ0EsTUFBSUMsWUFBWSxFQUFoQjs7QUFFQTtBQUNBO0FBQ0EsTUFBSUMsZUFBZSxTQUFmQSxZQUFlLENBQVVQLEVBQVYsRUFBYztBQUMvQixXQUFPLE1BQU1BLEVBQWI7QUFDRCxHQUZEO0FBR0EsTUFBSVEsZUFBZSxTQUFmQSxZQUFlLENBQVVuRCxHQUFWLEVBQWU7QUFDaEMsV0FBT29ELFNBQVNwRCxJQUFJcUQsTUFBSixDQUFXLENBQVgsQ0FBVCxFQUF3QixFQUF4QixDQUFQO0FBQ0QsR0FGRDs7QUFJQW5CLFlBQVUsaUJBQVVTLEVBQVYsRUFBY0MsSUFBZCxFQUFvQjtBQUM1QixRQUFJNUMsTUFBTWtELGFBQWFQLEVBQWIsQ0FBVjtBQUNBSyxjQUFVaEQsR0FBVixJQUFpQjRDLElBQWpCO0FBQ0QsR0FIRDtBQUlBVCxZQUFVLGlCQUFVUSxFQUFWLEVBQWM7QUFDdEIsUUFBSTNDLE1BQU1rRCxhQUFhUCxFQUFiLENBQVY7QUFDQSxXQUFPSyxVQUFVaEQsR0FBVixDQUFQO0FBQ0QsR0FIRDtBQUlBb0MsZUFBYSxvQkFBVU8sRUFBVixFQUFjO0FBQ3pCLFFBQUkzQyxNQUFNa0QsYUFBYVAsRUFBYixDQUFWO0FBQ0EsV0FBT0ssVUFBVWhELEdBQVYsQ0FBUDtBQUNELEdBSEQ7QUFJQXFDLGVBQWEsc0JBQVk7QUFDdkIsV0FBT2pFLE9BQU9vQixJQUFQLENBQVl3RCxTQUFaLEVBQXVCL0QsR0FBdkIsQ0FBMkJrRSxZQUEzQixDQUFQO0FBQ0QsR0FGRDs7QUFJQWIsWUFBVSxpQkFBVUssRUFBVixFQUFjO0FBQ3RCLFFBQUkzQyxNQUFNa0QsYUFBYVAsRUFBYixDQUFWO0FBQ0FNLGNBQVVqRCxHQUFWLElBQWlCLElBQWpCO0FBQ0QsR0FIRDtBQUlBdUMsZUFBYSxvQkFBVUksRUFBVixFQUFjO0FBQ3pCLFFBQUkzQyxNQUFNa0QsYUFBYVAsRUFBYixDQUFWO0FBQ0EsV0FBT00sVUFBVWpELEdBQVYsQ0FBUDtBQUNELEdBSEQ7QUFJQXdDLGVBQWEsc0JBQVk7QUFDdkIsV0FBT3BFLE9BQU9vQixJQUFQLENBQVl5RCxTQUFaLEVBQXVCaEUsR0FBdkIsQ0FBMkJrRSxZQUEzQixDQUFQO0FBQ0QsR0FGRDtBQUdEOztBQUVELElBQUlHLGVBQWUsRUFBbkI7O0FBRUEsU0FBU0MsU0FBVCxDQUFtQlosRUFBbkIsRUFBdUI7QUFDckIsTUFBSUMsT0FBT1QsUUFBUVEsRUFBUixDQUFYO0FBQ0EsTUFBSUMsSUFBSixFQUFVO0FBQ1IsUUFBSVksV0FBV1osS0FBS1ksUUFBcEI7O0FBRUFwQixlQUFXTyxFQUFYO0FBQ0FhLGFBQVNsRSxPQUFULENBQWlCaUUsU0FBakI7QUFDRDtBQUNGOztBQUVELFNBQVNFLHNCQUFULENBQWdDN0ssSUFBaEMsRUFBc0MrRyxNQUF0QyxFQUE4QytELFNBQTlDLEVBQXlEO0FBQ3ZELFNBQU8sZUFBZTlLLFFBQVEsU0FBdkIsS0FBcUMrRyxTQUFTLFVBQVVBLE9BQU9nRSxRQUFQLENBQWdCNUosT0FBaEIsQ0FBd0IsV0FBeEIsRUFBcUMsRUFBckMsQ0FBVixHQUFxRCxHQUFyRCxHQUEyRDRGLE9BQU9pRSxVQUFsRSxHQUErRSxHQUF4RixHQUE4RkYsWUFBWSxrQkFBa0JBLFNBQWxCLEdBQThCLEdBQTFDLEdBQWdELEVBQW5MLENBQVA7QUFDRDs7QUFFRCxTQUFTRyxlQUFULENBQXdCQyxPQUF4QixFQUFpQztBQUMvQixNQUFJQSxXQUFXLElBQWYsRUFBcUI7QUFDbkIsV0FBTyxRQUFQO0FBQ0QsR0FGRCxNQUVPLElBQUksT0FBT0EsT0FBUCxLQUFtQixRQUFuQixJQUErQixPQUFPQSxPQUFQLEtBQW1CLFFBQXRELEVBQWdFO0FBQ3JFLFdBQU8sT0FBUDtBQUNELEdBRk0sTUFFQSxJQUFJLE9BQU9BLFFBQVFDLElBQWYsS0FBd0IsUUFBNUIsRUFBc0M7QUFDM0MsV0FBT0QsUUFBUUMsSUFBZjtBQUNELEdBRk0sTUFFQTtBQUNMLFdBQU9ELFFBQVFDLElBQVIsQ0FBYUMsV0FBYixJQUE0QkYsUUFBUUMsSUFBUixDQUFhbkwsSUFBekMsSUFBaUQsU0FBeEQ7QUFDRDtBQUNGOztBQUVELFNBQVNxTCxVQUFULENBQW9CdEIsRUFBcEIsRUFBd0I7QUFDdEIsTUFBSS9KLE9BQU9zTCx1QkFBdUJMLGNBQXZCLENBQXNDbEIsRUFBdEMsQ0FBWDtBQUNBLE1BQUltQixVQUFVSSx1QkFBdUJDLFVBQXZCLENBQWtDeEIsRUFBbEMsQ0FBZDtBQUNBLE1BQUl5QixVQUFVRix1QkFBdUJHLFVBQXZCLENBQWtDMUIsRUFBbEMsQ0FBZDtBQUNBLE1BQUllLFNBQUo7QUFDQSxNQUFJVSxPQUFKLEVBQWE7QUFDWFYsZ0JBQVlRLHVCQUF1QkwsY0FBdkIsQ0FBc0NPLE9BQXRDLENBQVo7QUFDRDtBQUNEOU8sVUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEySixPQUFSLEVBQWlCLHVFQUF1RSxnQkFBeEYsRUFBMEduQixFQUExRyxDQUF4QyxHQUF3SixLQUFLLENBQTdKO0FBQ0EsU0FBT2MsdUJBQXVCN0ssSUFBdkIsRUFBNkJrTCxXQUFXQSxRQUFRUSxPQUFoRCxFQUF5RFosU0FBekQsQ0FBUDtBQUNEOztBQUVELElBQUlRLHlCQUF5QjtBQUMzQkssaUJBQWUsdUJBQVU1QixFQUFWLEVBQWM2QixZQUFkLEVBQTRCO0FBQ3pDLFFBQUk1QixPQUFPVCxRQUFRUSxFQUFSLENBQVg7QUFDQSxLQUFDQyxJQUFELEdBQVF0TixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHlCQUFqQixDQUF4QyxHQUFzRjRCLGVBQWUsS0FBZixDQUE5RixHQUFzSCxLQUFLLENBQTNIO0FBQ0EwSCxTQUFLWSxRQUFMLEdBQWdCZ0IsWUFBaEI7O0FBRUEsU0FBSyxJQUFJbk4sSUFBSSxDQUFiLEVBQWdCQSxJQUFJbU4sYUFBYTdOLE1BQWpDLEVBQXlDVSxHQUF6QyxFQUE4QztBQUM1QyxVQUFJb04sY0FBY0QsYUFBYW5OLENBQWIsQ0FBbEI7QUFDQSxVQUFJcU4sWUFBWXZDLFFBQVFzQyxXQUFSLENBQWhCO0FBQ0EsT0FBQ0MsU0FBRCxHQUFhcFAsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiw4RkFBakIsQ0FBeEMsR0FBMko0QixlQUFlLEtBQWYsQ0FBeEssR0FBZ00sS0FBSyxDQUFyTTtBQUNBLFFBQUV3SixVQUFVbEIsUUFBVixJQUFzQixJQUF0QixJQUE4QixRQUFPa0IsVUFBVVosT0FBakIsTUFBNkIsUUFBM0QsSUFBdUVZLFVBQVVaLE9BQVYsSUFBcUIsSUFBOUYsSUFBc0d4TyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLDBHQUFqQixDQUF4QyxHQUF1SzRCLGVBQWUsS0FBZixDQUE3USxHQUFxUyxLQUFLLENBQTFTO0FBQ0EsT0FBQ3dKLFVBQVVDLFNBQVgsR0FBdUJyUCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHFHQUFqQixDQUF4QyxHQUFrSzRCLGVBQWUsSUFBZixDQUF6TCxHQUFnTixLQUFLLENBQXJOO0FBQ0EsVUFBSXdKLFVBQVVFLFFBQVYsSUFBc0IsSUFBMUIsRUFBZ0M7QUFDOUJGLGtCQUFVRSxRQUFWLEdBQXFCakMsRUFBckI7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNELFFBQUUrQixVQUFVRSxRQUFWLEtBQXVCakMsRUFBekIsSUFBK0JyTixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLDJHQUFqQixFQUE4SG1MLFdBQTlILEVBQTJJQyxVQUFVRSxRQUFySixFQUErSmpDLEVBQS9KLENBQXhDLEdBQTZNekgsZUFBZSxLQUFmLEVBQXNCdUosV0FBdEIsRUFBbUNDLFVBQVVFLFFBQTdDLEVBQXVEakMsRUFBdkQsQ0FBNU8sR0FBeVMsS0FBSyxDQUE5UztBQUNEO0FBQ0YsR0FwQjBCO0FBcUIzQmtDLDBCQUF3QixnQ0FBVWxDLEVBQVYsRUFBY21CLE9BQWQsRUFBdUJjLFFBQXZCLEVBQWlDO0FBQ3ZELFFBQUloQyxPQUFPO0FBQ1RrQixlQUFTQSxPQURBO0FBRVRjLGdCQUFVQSxRQUZEO0FBR1RFLFlBQU0sSUFIRztBQUlUdEIsZ0JBQVUsRUFKRDtBQUtUbUIsaUJBQVcsS0FMRjtBQU1USSxtQkFBYTtBQU5KLEtBQVg7QUFRQTdDLFlBQVFTLEVBQVIsRUFBWUMsSUFBWjtBQUNELEdBL0IwQjtBQWdDM0JvQywyQkFBeUIsaUNBQVVyQyxFQUFWLEVBQWNtQixPQUFkLEVBQXVCO0FBQzlDLFFBQUlsQixPQUFPVCxRQUFRUSxFQUFSLENBQVg7QUFDQSxRQUFJLENBQUNDLElBQUQsSUFBUyxDQUFDQSxLQUFLK0IsU0FBbkIsRUFBOEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0Q7QUFDRC9CLFNBQUtrQixPQUFMLEdBQWVBLE9BQWY7QUFDRCxHQXhDMEI7QUF5QzNCbUIsb0JBQWtCLDBCQUFVdEMsRUFBVixFQUFjO0FBQzlCLFFBQUlDLE9BQU9ULFFBQVFRLEVBQVIsQ0FBWDtBQUNBLEtBQUNDLElBQUQsR0FBUXROLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIseUJBQWpCLENBQXhDLEdBQXNGNEIsZUFBZSxLQUFmLENBQTlGLEdBQXNILEtBQUssQ0FBM0g7QUFDQTBILFNBQUsrQixTQUFMLEdBQWlCLElBQWpCO0FBQ0EsUUFBSU8sU0FBU3RDLEtBQUtnQyxRQUFMLEtBQWtCLENBQS9CO0FBQ0EsUUFBSU0sTUFBSixFQUFZO0FBQ1Y1QyxjQUFRSyxFQUFSO0FBQ0Q7QUFDRixHQWpEMEI7QUFrRDNCd0MscUJBQW1CLDJCQUFVeEMsRUFBVixFQUFjO0FBQy9CLFFBQUlDLE9BQU9ULFFBQVFRLEVBQVIsQ0FBWDtBQUNBLFFBQUksQ0FBQ0MsSUFBRCxJQUFTLENBQUNBLEtBQUsrQixTQUFuQixFQUE4QjtBQUM1QjtBQUNBO0FBQ0E7QUFDRDtBQUNEL0IsU0FBS21DLFdBQUw7QUFDRCxHQTFEMEI7QUEyRDNCSyxzQkFBb0IsNEJBQVV6QyxFQUFWLEVBQWM7QUFDaEMsUUFBSUMsT0FBT1QsUUFBUVEsRUFBUixDQUFYO0FBQ0EsUUFBSUMsSUFBSixFQUFVO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxXQUFLK0IsU0FBTCxHQUFpQixLQUFqQjtBQUNBLFVBQUlPLFNBQVN0QyxLQUFLZ0MsUUFBTCxLQUFrQixDQUEvQjtBQUNBLFVBQUlNLE1BQUosRUFBWTtBQUNWM0MsbUJBQVdJLEVBQVg7QUFDRDtBQUNGO0FBQ0RXLGlCQUFhaE0sSUFBYixDQUFrQnFMLEVBQWxCO0FBQ0QsR0ExRTBCO0FBMkUzQjBDLDRCQUEwQixvQ0FBWTtBQUNwQyxRQUFJbkIsdUJBQXVCb0IsZUFBM0IsRUFBNEM7QUFDMUM7QUFDQTtBQUNEOztBQUVELFNBQUssSUFBSWpPLElBQUksQ0FBYixFQUFnQkEsSUFBSWlNLGFBQWEzTSxNQUFqQyxFQUF5Q1UsR0FBekMsRUFBOEM7QUFDNUMsVUFBSXNMLEtBQUtXLGFBQWFqTSxDQUFiLENBQVQ7QUFDQWtNLGdCQUFVWixFQUFWO0FBQ0Q7QUFDRFcsaUJBQWEzTSxNQUFiLEdBQXNCLENBQXRCO0FBQ0QsR0F0RjBCO0FBdUYzQmdPLGFBQVcsbUJBQVVoQyxFQUFWLEVBQWM7QUFDdkIsUUFBSUMsT0FBT1QsUUFBUVEsRUFBUixDQUFYO0FBQ0EsV0FBT0MsT0FBT0EsS0FBSytCLFNBQVosR0FBd0IsS0FBL0I7QUFDRCxHQTFGMEI7QUEyRjNCWSwyQkFBeUIsaUNBQVVDLFVBQVYsRUFBc0I7QUFDN0MsUUFBSUMsT0FBTyxFQUFYO0FBQ0EsUUFBSUQsVUFBSixFQUFnQjtBQUNkLFVBQUk1TSxPQUFPaUwsZ0JBQWUyQixVQUFmLENBQVg7QUFDQSxVQUFJRSxRQUFRRixXQUFXRyxNQUF2QjtBQUNBRixjQUFRaEMsdUJBQXVCN0ssSUFBdkIsRUFBNkI0TSxXQUFXbEIsT0FBeEMsRUFBaURvQixTQUFTQSxNQUFNRSxPQUFOLEVBQTFELENBQVI7QUFDRDs7QUFFRCxRQUFJQyxlQUFldEUsa0JBQWtCdUUsT0FBckM7QUFDQSxRQUFJbkQsS0FBS2tELGdCQUFnQkEsYUFBYUUsUUFBdEM7O0FBRUFOLFlBQVF2Qix1QkFBdUI4QixvQkFBdkIsQ0FBNENyRCxFQUE1QyxDQUFSO0FBQ0EsV0FBTzhDLElBQVA7QUFDRCxHQXhHMEI7QUF5RzNCTyx3QkFBc0IsOEJBQVVyRCxFQUFWLEVBQWM7QUFDbEMsUUFBSThDLE9BQU8sRUFBWDtBQUNBLFdBQU85QyxFQUFQLEVBQVc7QUFDVDhDLGNBQVF4QixXQUFXdEIsRUFBWCxDQUFSO0FBQ0FBLFdBQUt1Qix1QkFBdUIrQixXQUF2QixDQUFtQ3RELEVBQW5DLENBQUw7QUFDRDtBQUNELFdBQU84QyxJQUFQO0FBQ0QsR0FoSDBCO0FBaUgzQlMsZUFBYSxxQkFBVXZELEVBQVYsRUFBYztBQUN6QixRQUFJQyxPQUFPVCxRQUFRUSxFQUFSLENBQVg7QUFDQSxXQUFPQyxPQUFPQSxLQUFLWSxRQUFaLEdBQXVCLEVBQTlCO0FBQ0QsR0FwSDBCO0FBcUgzQkssa0JBQWdCLHdCQUFVbEIsRUFBVixFQUFjO0FBQzVCLFFBQUltQixVQUFVSSx1QkFBdUJDLFVBQXZCLENBQWtDeEIsRUFBbEMsQ0FBZDtBQUNBLFFBQUksQ0FBQ21CLE9BQUwsRUFBYztBQUNaLGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBT0QsZ0JBQWVDLE9BQWYsQ0FBUDtBQUNELEdBM0gwQjtBQTRIM0JLLGNBQVksb0JBQVV4QixFQUFWLEVBQWM7QUFDeEIsUUFBSUMsT0FBT1QsUUFBUVEsRUFBUixDQUFYO0FBQ0EsV0FBT0MsT0FBT0EsS0FBS2tCLE9BQVosR0FBc0IsSUFBN0I7QUFDRCxHQS9IMEI7QUFnSTNCTyxjQUFZLG9CQUFVMUIsRUFBVixFQUFjO0FBQ3hCLFFBQUltQixVQUFVSSx1QkFBdUJDLFVBQXZCLENBQWtDeEIsRUFBbEMsQ0FBZDtBQUNBLFFBQUksQ0FBQ21CLE9BQUQsSUFBWSxDQUFDQSxRQUFRNkIsTUFBekIsRUFBaUM7QUFDL0IsYUFBTyxJQUFQO0FBQ0Q7QUFDRCxXQUFPN0IsUUFBUTZCLE1BQVIsQ0FBZUksUUFBdEI7QUFDRCxHQXRJMEI7QUF1STNCRSxlQUFhLHFCQUFVdEQsRUFBVixFQUFjO0FBQ3pCLFFBQUlDLE9BQU9ULFFBQVFRLEVBQVIsQ0FBWDtBQUNBLFdBQU9DLE9BQU9BLEtBQUtnQyxRQUFaLEdBQXVCLElBQTlCO0FBQ0QsR0ExSTBCO0FBMkkzQnVCLGFBQVcsbUJBQVV4RCxFQUFWLEVBQWM7QUFDdkIsUUFBSUMsT0FBT1QsUUFBUVEsRUFBUixDQUFYO0FBQ0EsUUFBSW1CLFVBQVVsQixPQUFPQSxLQUFLa0IsT0FBWixHQUFzQixJQUFwQztBQUNBLFFBQUluRSxTQUFTbUUsV0FBVyxJQUFYLEdBQWtCQSxRQUFRUSxPQUExQixHQUFvQyxJQUFqRDtBQUNBLFdBQU8zRSxNQUFQO0FBQ0QsR0FoSjBCO0FBaUozQnlHLFdBQVMsaUJBQVV6RCxFQUFWLEVBQWM7QUFDckIsUUFBSW1CLFVBQVVJLHVCQUF1QkMsVUFBdkIsQ0FBa0N4QixFQUFsQyxDQUFkO0FBQ0EsUUFBSSxPQUFPbUIsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQixhQUFPQSxPQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUksT0FBT0EsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUN0QyxhQUFPLEtBQUtBLE9BQVo7QUFDRCxLQUZNLE1BRUE7QUFDTCxhQUFPLElBQVA7QUFDRDtBQUNGLEdBMUowQjtBQTJKM0J1QyxrQkFBZ0Isd0JBQVUxRCxFQUFWLEVBQWM7QUFDNUIsUUFBSUMsT0FBT1QsUUFBUVEsRUFBUixDQUFYO0FBQ0EsV0FBT0MsT0FBT0EsS0FBS21DLFdBQVosR0FBMEIsQ0FBakM7QUFDRCxHQTlKMEI7O0FBaUszQnZDLGNBQVlBLFVBaktlO0FBa0szQjhELG9CQUFrQmpFLFVBbEtTOztBQW9LM0JrRSwrQkFBNkIscUNBQVVDLGlCQUFWLEVBQTZCQyxhQUE3QixFQUE0QztBQUN2RSxRQUFJLE9BQU9qTSxRQUFRa00sVUFBZixLQUE4QixVQUFsQyxFQUE4QztBQUM1QztBQUNEOztBQUVELFFBQUlDLFFBQVEsRUFBWjtBQUNBLFFBQUlkLGVBQWV0RSxrQkFBa0J1RSxPQUFyQztBQUNBLFFBQUluRCxLQUFLa0QsZ0JBQWdCQSxhQUFhRSxRQUF0Qzs7QUFFQSxRQUFJO0FBQ0YsVUFBSVMsaUJBQUosRUFBdUI7QUFDckJHLGNBQU1yUCxJQUFOLENBQVc7QUFDVHNCLGdCQUFNK0osS0FBS3VCLHVCQUF1QkwsY0FBdkIsQ0FBc0NsQixFQUF0QyxDQUFMLEdBQWlELElBRDlDO0FBRVRnQixvQkFBVThDLGdCQUFnQkEsY0FBYzlDLFFBQTlCLEdBQXlDLElBRjFDO0FBR1RDLHNCQUFZNkMsZ0JBQWdCQSxjQUFjN0MsVUFBOUIsR0FBMkM7QUFIOUMsU0FBWDtBQUtEOztBQUVELGFBQU9qQixFQUFQLEVBQVc7QUFDVCxZQUFJbUIsVUFBVUksdUJBQXVCQyxVQUF2QixDQUFrQ3hCLEVBQWxDLENBQWQ7QUFDQSxZQUFJaUMsV0FBV1YsdUJBQXVCK0IsV0FBdkIsQ0FBbUN0RCxFQUFuQyxDQUFmO0FBQ0EsWUFBSXlCLFVBQVVGLHVCQUF1QkcsVUFBdkIsQ0FBa0MxQixFQUFsQyxDQUFkO0FBQ0EsWUFBSWUsWUFBWVUsVUFBVUYsdUJBQXVCTCxjQUF2QixDQUFzQ08sT0FBdEMsQ0FBVixHQUEyRCxJQUEzRTtBQUNBLFlBQUl6RSxTQUFTbUUsV0FBV0EsUUFBUVEsT0FBaEM7QUFDQXFDLGNBQU1yUCxJQUFOLENBQVc7QUFDVHNCLGdCQUFNOEssU0FERztBQUVUQyxvQkFBVWhFLFNBQVNBLE9BQU9nRSxRQUFoQixHQUEyQixJQUY1QjtBQUdUQyxzQkFBWWpFLFNBQVNBLE9BQU9pRSxVQUFoQixHQUE2QjtBQUhoQyxTQUFYO0FBS0FqQixhQUFLaUMsUUFBTDtBQUNEO0FBQ0YsS0F0QkQsQ0FzQkUsT0FBT25GLEdBQVAsRUFBWTtBQUNaO0FBQ0E7QUFDRDs7QUFFRGpGLFlBQVFrTSxVQUFSLENBQW1CQyxLQUFuQjtBQUNELEdBek0wQjtBQTBNM0JDLDhCQUE0QixzQ0FBWTtBQUN0QyxRQUFJLE9BQU9wTSxRQUFRcU0sYUFBZixLQUFpQyxVQUFyQyxFQUFpRDtBQUMvQztBQUNEO0FBQ0RyTSxZQUFRcU0sYUFBUjtBQUNEO0FBL00wQixDQUE3Qjs7QUFrTkF0UixPQUFPQyxPQUFQLEdBQWlCME8sc0JBQWpCLEM7Ozs7Ozs7O0FDelhBOztBQUVBOzs7Ozs7Ozs7OztBQVdBLFNBQVM0QyxpQkFBVCxDQUEyQkMsR0FBM0IsRUFBZ0M7QUFDOUIsU0FBTyxZQUFZO0FBQ2pCLFdBQU9BLEdBQVA7QUFDRCxHQUZEO0FBR0Q7O0FBRUQ7Ozs7O0FBS0EsSUFBSTlNLGdCQUFnQixTQUFTQSxhQUFULEdBQXlCLENBQUUsQ0FBL0M7O0FBRUFBLGNBQWMrTSxXQUFkLEdBQTRCRixpQkFBNUI7QUFDQTdNLGNBQWNnTixnQkFBZCxHQUFpQ0gsa0JBQWtCLEtBQWxCLENBQWpDO0FBQ0E3TSxjQUFjaU4sZUFBZCxHQUFnQ0osa0JBQWtCLElBQWxCLENBQWhDO0FBQ0E3TSxjQUFja04sZUFBZCxHQUFnQ0wsa0JBQWtCLElBQWxCLENBQWhDO0FBQ0E3TSxjQUFjbU4sZUFBZCxHQUFnQyxZQUFZO0FBQzFDLFNBQU8sSUFBUDtBQUNELENBRkQ7QUFHQW5OLGNBQWNvTixtQkFBZCxHQUFvQyxVQUFVTixHQUFWLEVBQWU7QUFDakQsU0FBT0EsR0FBUDtBQUNELENBRkQ7O0FBSUF4UixPQUFPQyxPQUFQLEdBQWlCeUUsYUFBakIsQzs7Ozs7OztBQ3JDQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQTs7QUFFQSxJQUFJcU4sWUFBWSxJQUFoQjs7QUFFQSxJQUFJaFMsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSW1PLGlCQUFpQixtQkFBQXJOLENBQVEsR0FBUixDQUFyQjtBQUNBb04sY0FBWUMsY0FBWjtBQUNEOztBQUVEaFMsT0FBT0MsT0FBUCxHQUFpQixFQUFFOFIsV0FBV0EsU0FBYixFQUFqQixDOzs7Ozs7Ozs7Ozs7QUN0QkE7Ozs7Ozs7OztBQVNBLElBQUloUyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJb08scUJBQXNCLE9BQU9DLE1BQVAsS0FBa0IsVUFBbEIsSUFDeEJBLE9BQU9DLEdBRGlCLElBRXhCRCxPQUFPQyxHQUFQLENBQVcsZUFBWCxDQUZ1QixJQUd2QixNQUhGOztBQUtBLE1BQUlDLGlCQUFpQixTQUFqQkEsY0FBaUIsQ0FBU0MsTUFBVCxFQUFpQjtBQUNwQyxXQUFPLFFBQU9BLE1BQVAseUNBQU9BLE1BQVAsT0FBa0IsUUFBbEIsSUFDTEEsV0FBVyxJQUROLElBRUxBLE9BQU9DLFFBQVAsS0FBb0JMLGtCQUZ0QjtBQUdELEdBSkQ7O0FBTUE7QUFDQTtBQUNBLE1BQUlNLHNCQUFzQixJQUExQjtBQUNBdlMsU0FBT0MsT0FBUCxHQUFpQixtQkFBQTBFLENBQVEsRUFBUixFQUFxQ3lOLGNBQXJDLEVBQXFERyxtQkFBckQsQ0FBakI7QUFDRCxDQWhCRCxNQWdCTztBQUNMO0FBQ0E7QUFDQXZTLFNBQU9DLE9BQVAsR0FBaUIsbUJBQUEwRSxDQUFRLEdBQVIsR0FBakI7QUFDRCxDOzs7Ozs7OztBQzdCRDs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQTs7Ozs7OztBQU1BLElBQUlxSCxvQkFBb0I7QUFDdEI7Ozs7QUFJQXVFLFdBQVM7QUFMYSxDQUF4Qjs7QUFRQXZRLE9BQU9DLE9BQVAsR0FBaUIrTCxpQkFBakIsQzs7Ozs7OztBQzNCQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlyRyxpQkFBaUIsbUJBQUFoQixDQUFRLENBQVIsQ0FBckI7QUFBQSxJQUNJNk4sVUFBVSxtQkFBQTdOLENBQVEsQ0FBUixDQURkOztBQUdBLElBQUk4TixnQkFBZ0IsbUJBQUE5TixDQUFRLEVBQVIsQ0FBcEI7QUFDQSxJQUFJK04sY0FBYyxtQkFBQS9OLENBQVEsRUFBUixDQUFsQjtBQUNBLElBQUlnTyxvQkFBb0IsbUJBQUFoTyxDQUFRLEVBQVIsQ0FBeEI7QUFDQSxJQUFJaU8sa0JBQWtCLG1CQUFBak8sQ0FBUSxFQUFSLENBQXRCO0FBQ0EsSUFBSWtPLGNBQWMsbUJBQUFsTyxDQUFRLEVBQVIsQ0FBbEI7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCOztBQUVBLElBQUltTyxrQkFBa0IsRUFBdEI7QUFDQSxJQUFJQyxvQkFBb0IsQ0FBeEI7QUFDQSxJQUFJQyxvQkFBb0JQLGNBQWNRLFNBQWQsRUFBeEI7QUFDQSxJQUFJQyxlQUFlLEtBQW5COztBQUVBLElBQUlDLG1CQUFtQixJQUF2Qjs7QUFFQSxTQUFTQyxjQUFULEdBQTBCO0FBQ3hCLElBQUVDLGFBQWFDLHlCQUFiLElBQTBDSCxnQkFBNUMsSUFBZ0VwVCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLCtFQUFqQixDQUF4QyxHQUE0STRCLGVBQWUsS0FBZixDQUE1TSxHQUFvTyxLQUFLLENBQXpPO0FBQ0Q7O0FBRUQsSUFBSTROLGlCQUFpQjtBQUNuQkMsY0FBWSxzQkFBWTtBQUN0QixTQUFLQyxxQkFBTCxHQUE2QlgsZ0JBQWdCMVIsTUFBN0M7QUFDRCxHQUhrQjtBQUluQnNTLFNBQU8saUJBQVk7QUFDakIsUUFBSSxLQUFLRCxxQkFBTCxLQUErQlgsZ0JBQWdCMVIsTUFBbkQsRUFBMkQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBMFIsc0JBQWdCYSxNQUFoQixDQUF1QixDQUF2QixFQUEwQixLQUFLRixxQkFBL0I7QUFDQUc7QUFDRCxLQVJELE1BUU87QUFDTGQsc0JBQWdCMVIsTUFBaEIsR0FBeUIsQ0FBekI7QUFDRDtBQUNGO0FBaEJrQixDQUFyQjs7QUFtQkEsSUFBSXlTLGtCQUFrQjtBQUNwQkwsY0FBWSxzQkFBWTtBQUN0QixTQUFLTSxhQUFMLENBQW1CQyxLQUFuQjtBQUNELEdBSG1CO0FBSXBCTCxTQUFPLGlCQUFZO0FBQ2pCLFNBQUtJLGFBQUwsQ0FBbUJFLFNBQW5CO0FBQ0Q7QUFObUIsQ0FBdEI7O0FBU0EsSUFBSUMsdUJBQXVCLENBQUNWLGNBQUQsRUFBaUJNLGVBQWpCLENBQTNCOztBQUVBLFNBQVNLLDRCQUFULEdBQXdDO0FBQ3RDLE9BQUtDLHVCQUFMO0FBQ0EsT0FBS1YscUJBQUwsR0FBNkIsSUFBN0I7QUFDQSxPQUFLSyxhQUFMLEdBQXFCckIsY0FBY1EsU0FBZCxFQUFyQjtBQUNBLE9BQUttQixvQkFBTCxHQUE0QmYsYUFBYUMseUJBQWIsQ0FBdUNMLFNBQXZDO0FBQzVCLHdCQUFzQixJQURNLENBQTVCO0FBRUQ7O0FBRURULFFBQVEwQiw2QkFBNkJoUyxTQUFyQyxFQUFnRDJRLFdBQWhELEVBQTZEO0FBQzNEd0IsMEJBQXdCLGtDQUFZO0FBQ2xDLFdBQU9KLG9CQUFQO0FBQ0QsR0FIMEQ7O0FBSzNESyxjQUFZLHNCQUFZO0FBQ3RCLFNBQUtiLHFCQUFMLEdBQTZCLElBQTdCO0FBQ0FoQixrQkFBYzhCLE9BQWQsQ0FBc0IsS0FBS1QsYUFBM0I7QUFDQSxTQUFLQSxhQUFMLEdBQXFCLElBQXJCO0FBQ0FULGlCQUFhQyx5QkFBYixDQUF1Q2lCLE9BQXZDLENBQStDLEtBQUtILG9CQUFwRDtBQUNBLFNBQUtBLG9CQUFMLEdBQTRCLElBQTVCO0FBQ0QsR0FYMEQ7O0FBYTNESSxXQUFTLGlCQUFVQyxNQUFWLEVBQWtCQyxLQUFsQixFQUF5QnpRLENBQXpCLEVBQTRCO0FBQ25DO0FBQ0E7QUFDQSxXQUFPNE8sWUFBWTJCLE9BQVosQ0FBb0I1VCxJQUFwQixDQUF5QixJQUF6QixFQUErQixLQUFLd1Qsb0JBQUwsQ0FBMEJJLE9BQXpELEVBQWtFLEtBQUtKLG9CQUF2RSxFQUE2RkssTUFBN0YsRUFBcUdDLEtBQXJHLEVBQTRHelEsQ0FBNUcsQ0FBUDtBQUNEO0FBakIwRCxDQUE3RDs7QUFvQkF5TyxZQUFZaUMsWUFBWixDQUF5QlQsNEJBQXpCOztBQUVBLFNBQVNVLGNBQVQsQ0FBd0JDLFFBQXhCLEVBQWtDNVEsQ0FBbEMsRUFBcUNDLENBQXJDLEVBQXdDQyxDQUF4QyxFQUEyQ0MsQ0FBM0MsRUFBOEM1RCxDQUE5QyxFQUFpRDtBQUMvQzRTO0FBQ0EsU0FBT0QsaUJBQWlCeUIsY0FBakIsQ0FBZ0NDLFFBQWhDLEVBQTBDNVEsQ0FBMUMsRUFBNkNDLENBQTdDLEVBQWdEQyxDQUFoRCxFQUFtREMsQ0FBbkQsRUFBc0Q1RCxDQUF0RCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTc1Usb0JBQVQsQ0FBOEJDLEVBQTlCLEVBQWtDQyxFQUFsQyxFQUFzQztBQUNwQyxTQUFPRCxHQUFHRSxXQUFILEdBQWlCRCxHQUFHQyxXQUEzQjtBQUNEOztBQUVELFNBQVNDLGlCQUFULENBQTJCQyxXQUEzQixFQUF3QztBQUN0QyxNQUFJM1QsTUFBTTJULFlBQVkxQixxQkFBdEI7QUFDQSxJQUFFalMsUUFBUXNSLGdCQUFnQjFSLE1BQTFCLElBQW9DckIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixnSEFBakIsRUFBbUl2QyxHQUFuSSxFQUF3SXNSLGdCQUFnQjFSLE1BQXhKLENBQXhDLEdBQTBNdUUsZUFBZSxLQUFmLEVBQXNCbkUsR0FBdEIsRUFBMkJzUixnQkFBZ0IxUixNQUEzQyxDQUE5TyxHQUFtUyxLQUFLLENBQXhTOztBQUVBO0FBQ0E7QUFDQTtBQUNBMFIsa0JBQWdCc0MsSUFBaEIsQ0FBcUJOLG9CQUFyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EvQjs7QUFFQSxPQUFLLElBQUlqUixJQUFJLENBQWIsRUFBZ0JBLElBQUlOLEdBQXBCLEVBQXlCTSxHQUF6QixFQUE4QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxRQUFJZ0YsWUFBWWdNLGdCQUFnQmhSLENBQWhCLENBQWhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQUl1VCxZQUFZdk8sVUFBVXdPLGlCQUExQjtBQUNBeE8sY0FBVXdPLGlCQUFWLEdBQThCLElBQTlCOztBQUVBLFFBQUlDLFVBQUo7QUFDQSxRQUFJNUMsa0JBQWtCNkMsa0JBQXRCLEVBQTBDO0FBQ3hDLFVBQUlDLGlCQUFpQjNPLFNBQXJCO0FBQ0E7QUFDQSxVQUFJQSxVQUFVNE8sZUFBVixDQUEwQmxILElBQTFCLENBQStCbUgsc0JBQW5DLEVBQTJEO0FBQ3pERix5QkFBaUIzTyxVQUFVRSxrQkFBM0I7QUFDRDtBQUNEdU8sbUJBQWEsbUJBQW1CRSxlQUFlcEYsT0FBZixFQUFoQztBQUNBcEwsY0FBUTJRLElBQVIsQ0FBYUwsVUFBYjtBQUNEOztBQUVEM0Msb0JBQWdCaUQsd0JBQWhCLENBQXlDL08sU0FBekMsRUFBb0RxTyxZQUFZZixvQkFBaEUsRUFBc0ZyQixpQkFBdEY7O0FBRUEsUUFBSXdDLFVBQUosRUFBZ0I7QUFDZHRRLGNBQVE2USxPQUFSLENBQWdCUCxVQUFoQjtBQUNEOztBQUVELFFBQUlGLFNBQUosRUFBZTtBQUNiLFdBQUssSUFBSVUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJVixVQUFValUsTUFBOUIsRUFBc0MyVSxHQUF0QyxFQUEyQztBQUN6Q1osb0JBQVlyQixhQUFaLENBQTBCa0MsT0FBMUIsQ0FBa0NYLFVBQVVVLENBQVYsQ0FBbEMsRUFBZ0RqUCxVQUFVbVAsaUJBQVYsRUFBaEQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxJQUFJckMsc0JBQXNCLFNBQXRCQSxtQkFBc0IsR0FBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQU9kLGdCQUFnQjFSLE1BQWhCLElBQTBCOFIsWUFBakMsRUFBK0M7QUFDN0MsUUFBSUosZ0JBQWdCMVIsTUFBcEIsRUFBNEI7QUFDMUIsVUFBSStULGNBQWNqQiw2QkFBNkJqQixTQUE3QixFQUFsQjtBQUNBa0Msa0JBQVlYLE9BQVosQ0FBb0JVLGlCQUFwQixFQUF1QyxJQUF2QyxFQUE2Q0MsV0FBN0M7QUFDQWpCLG1DQUE2QkssT0FBN0IsQ0FBcUNZLFdBQXJDO0FBQ0Q7O0FBRUQsUUFBSWpDLFlBQUosRUFBa0I7QUFDaEJBLHFCQUFlLEtBQWY7QUFDQSxVQUFJblMsUUFBUWlTLGlCQUFaO0FBQ0FBLDBCQUFvQlAsY0FBY1EsU0FBZCxFQUFwQjtBQUNBbFMsWUFBTWlULFNBQU47QUFDQXZCLG9CQUFjOEIsT0FBZCxDQUFzQnhULEtBQXRCO0FBQ0Q7QUFDRjtBQUNGLENBcEJEOztBQXNCQTs7OztBQUlBLFNBQVNtVixhQUFULENBQXVCcFAsU0FBdkIsRUFBa0M7QUFDaENzTTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUksQ0FBQ0QsaUJBQWlCZ0QsaUJBQXRCLEVBQXlDO0FBQ3ZDaEQscUJBQWlCeUIsY0FBakIsQ0FBZ0NzQixhQUFoQyxFQUErQ3BQLFNBQS9DO0FBQ0E7QUFDRDs7QUFFRGdNLGtCQUFnQi9RLElBQWhCLENBQXFCK0UsU0FBckI7QUFDQSxNQUFJQSxVQUFVc1Asa0JBQVYsSUFBZ0MsSUFBcEMsRUFBMEM7QUFDeEN0UCxjQUFVc1Asa0JBQVYsR0FBK0JyRCxvQkFBb0IsQ0FBbkQ7QUFDRDtBQUNGOztBQUVEOzs7O0FBSUEsU0FBU3NELElBQVQsQ0FBY3hCLFFBQWQsRUFBd0J5QixPQUF4QixFQUFpQztBQUMvQixHQUFDbkQsaUJBQWlCZ0QsaUJBQWxCLEdBQXNDcFcsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixxR0FBakIsQ0FBeEMsR0FBa0s0QixlQUFlLEtBQWYsQ0FBeE0sR0FBZ08sS0FBSyxDQUFyTztBQUNBcU4sb0JBQWtCZ0QsT0FBbEIsQ0FBMEJuQixRQUExQixFQUFvQ3lCLE9BQXBDO0FBQ0FwRCxpQkFBZSxJQUFmO0FBQ0Q7O0FBRUQsSUFBSXFELHdCQUF3QjtBQUMxQkMsOEJBQTRCLG9DQUFVQyxvQkFBVixFQUFnQztBQUMxRCxLQUFDQSxvQkFBRCxHQUF3QjFXLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsMERBQWpCLENBQXhDLEdBQXVINEIsZUFBZSxLQUFmLENBQS9JLEdBQXVLLEtBQUssQ0FBNUs7QUFDQTBOLGlCQUFhQyx5QkFBYixHQUF5Q21ELG9CQUF6QztBQUNELEdBSnlCOztBQU0xQkMsMEJBQXdCLGdDQUFVQyxpQkFBVixFQUE2QjtBQUNuRCxLQUFDQSxpQkFBRCxHQUFxQjVXLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsZ0RBQWpCLENBQXhDLEdBQTZHNEIsZUFBZSxLQUFmLENBQWxJLEdBQTBKLEtBQUssQ0FBL0o7QUFDQSxNQUFFLE9BQU9nUixrQkFBa0IvQixjQUF6QixLQUE0QyxVQUE5QyxJQUE0RDdVLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsd0RBQWpCLENBQXhDLEdBQXFINEIsZUFBZSxLQUFmLENBQWpMLEdBQXlNLEtBQUssQ0FBOU07QUFDQSxNQUFFLE9BQU9nUixrQkFBa0JSLGlCQUF6QixLQUErQyxTQUFqRCxJQUE4RHBXLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsbUVBQWpCLENBQXhDLEdBQWdJNEIsZUFBZSxLQUFmLENBQTlMLEdBQXNOLEtBQUssQ0FBM047QUFDQXdOLHVCQUFtQndELGlCQUFuQjtBQUNEO0FBWHlCLENBQTVCOztBQWNBLElBQUl0RCxlQUFlO0FBQ2pCOzs7Ozs7QUFNQUMsNkJBQTJCLElBUFY7O0FBU2pCc0Isa0JBQWdCQSxjQVRDO0FBVWpCc0IsaUJBQWVBLGFBVkU7QUFXakJ0Qyx1QkFBcUJBLG1CQVhKO0FBWWpCZ0QsYUFBV0wscUJBWk07QUFhakJGLFFBQU1BO0FBYlcsQ0FBbkI7O0FBZ0JBclcsT0FBT0MsT0FBUCxHQUFpQm9ULFlBQWpCLEM7Ozs7Ozs7O0FDelBBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSWIsVUFBVSxtQkFBQTdOLENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUkrTixjQUFjLG1CQUFBL04sQ0FBUSxFQUFSLENBQWxCOztBQUVBLElBQUlELGdCQUFnQixtQkFBQUMsQ0FBUSxFQUFSLENBQXBCO0FBQ0EsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUEsSUFBSWtTLDZCQUE2QixLQUFqQztBQUNBLElBQUlDLG1CQUFtQixPQUFPQyxLQUFQLEtBQWlCLFVBQXhDOztBQUVBLElBQUlDLDZCQUE2QixDQUFDLGdCQUFELEVBQW1CLGFBQW5CLEVBQWtDLGFBQWxDLEVBQWlELG9CQUFqRCxFQUF1RSxzQkFBdkUsRUFBK0Ysb0JBQS9GLEVBQXFILG9CQUFySCxDQUFqQzs7QUFFQTs7OztBQUlBLElBQUlDLGlCQUFpQjtBQUNuQnpJLFFBQU0sSUFEYTtBQUVuQnJFLFVBQVEsSUFGVztBQUduQjtBQUNBK00saUJBQWV4UyxjQUFja04sZUFKVjtBQUtuQnVGLGNBQVksSUFMTztBQU1uQkMsV0FBUyxJQU5VO0FBT25CQyxjQUFZLElBUE87QUFRbkJDLGFBQVcsbUJBQVVDLEtBQVYsRUFBaUI7QUFDMUIsV0FBT0EsTUFBTUQsU0FBTixJQUFtQkUsS0FBS0MsR0FBTCxFQUExQjtBQUNELEdBVmtCO0FBV25CQyxvQkFBa0IsSUFYQztBQVluQkMsYUFBVztBQVpRLENBQXJCOztBQWVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkEsU0FBU0MsY0FBVCxDQUF3QkMsY0FBeEIsRUFBd0NDLFVBQXhDLEVBQW9EQyxXQUFwRCxFQUFpRUMsaUJBQWpFLEVBQW9GO0FBQ2xGLE1BQUlqWSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QztBQUNBLFdBQU8sS0FBS2tVLFdBQVo7QUFDQSxXQUFPLEtBQUtFLGNBQVo7QUFDQSxXQUFPLEtBQUtDLGVBQVo7QUFDRDs7QUFFRCxPQUFLTCxjQUFMLEdBQXNCQSxjQUF0QjtBQUNBLE9BQUtNLFdBQUwsR0FBbUJMLFVBQW5CO0FBQ0EsT0FBS0MsV0FBTCxHQUFtQkEsV0FBbkI7O0FBRUEsTUFBSUssWUFBWSxLQUFLQyxXQUFMLENBQWlCRCxTQUFqQztBQUNBLE9BQUssSUFBSUUsUUFBVCxJQUFxQkYsU0FBckIsRUFBZ0M7QUFDOUIsUUFBSSxDQUFDQSxVQUFVdFEsY0FBVixDQUF5QndRLFFBQXpCLENBQUwsRUFBeUM7QUFDdkM7QUFDRDtBQUNELFFBQUl2WSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxhQUFPLEtBQUt5VSxRQUFMLENBQVAsQ0FEeUMsQ0FDbEI7QUFDeEI7QUFDRCxRQUFJQyxZQUFZSCxVQUFVRSxRQUFWLENBQWhCO0FBQ0EsUUFBSUMsU0FBSixFQUFlO0FBQ2IsV0FBS0QsUUFBTCxJQUFpQkMsVUFBVVIsV0FBVixDQUFqQjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUlPLGFBQWEsUUFBakIsRUFBMkI7QUFDekIsYUFBS25PLE1BQUwsR0FBYzZOLGlCQUFkO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsYUFBS00sUUFBTCxJQUFpQlAsWUFBWU8sUUFBWixDQUFqQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxNQUFJWixtQkFBbUJLLFlBQVlMLGdCQUFaLElBQWdDLElBQWhDLEdBQXVDSyxZQUFZTCxnQkFBbkQsR0FBc0VLLFlBQVlTLFdBQVosS0FBNEIsS0FBekg7QUFDQSxNQUFJZCxnQkFBSixFQUFzQjtBQUNwQixTQUFLZSxrQkFBTCxHQUEwQi9ULGNBQWNpTixlQUF4QztBQUNELEdBRkQsTUFFTztBQUNMLFNBQUs4RyxrQkFBTCxHQUEwQi9ULGNBQWNnTixnQkFBeEM7QUFDRDtBQUNELE9BQUtnSCxvQkFBTCxHQUE0QmhVLGNBQWNnTixnQkFBMUM7QUFDQSxTQUFPLElBQVA7QUFDRDs7QUFFRGMsUUFBUW9GLGVBQWUxVixTQUF2QixFQUFrQztBQUNoQytWLGtCQUFnQiwwQkFBWTtBQUMxQixTQUFLUCxnQkFBTCxHQUF3QixJQUF4QjtBQUNBLFFBQUlILFFBQVEsS0FBS1EsV0FBakI7QUFDQSxRQUFJLENBQUNSLEtBQUwsRUFBWTtBQUNWO0FBQ0Q7O0FBRUQsUUFBSUEsTUFBTVUsY0FBVixFQUEwQjtBQUN4QlYsWUFBTVUsY0FBTjtBQUNBO0FBQ0QsS0FIRCxNQUdPLElBQUksT0FBT1YsTUFBTWlCLFdBQWIsS0FBNkIsU0FBakMsRUFBNEM7QUFDakRqQixZQUFNaUIsV0FBTixHQUFvQixLQUFwQjtBQUNEO0FBQ0QsU0FBS0Msa0JBQUwsR0FBMEIvVCxjQUFjaU4sZUFBeEM7QUFDRCxHQWYrQjs7QUFpQmhDdUcsbUJBQWlCLDJCQUFZO0FBQzNCLFFBQUlYLFFBQVEsS0FBS1EsV0FBakI7QUFDQSxRQUFJLENBQUNSLEtBQUwsRUFBWTtBQUNWO0FBQ0Q7O0FBRUQsUUFBSUEsTUFBTVcsZUFBVixFQUEyQjtBQUN6QlgsWUFBTVcsZUFBTjtBQUNBO0FBQ0QsS0FIRCxNQUdPLElBQUksT0FBT1gsTUFBTW9CLFlBQWIsS0FBOEIsU0FBbEMsRUFBNkM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBcEIsWUFBTW9CLFlBQU4sR0FBcUIsSUFBckI7QUFDRDs7QUFFRCxTQUFLRCxvQkFBTCxHQUE0QmhVLGNBQWNpTixlQUExQztBQUNELEdBcEMrQjs7QUFzQ2hDOzs7OztBQUtBaUgsV0FBUyxtQkFBWTtBQUNuQixTQUFLQyxZQUFMLEdBQW9CblUsY0FBY2lOLGVBQWxDO0FBQ0QsR0E3QytCOztBQStDaEM7Ozs7O0FBS0FrSCxnQkFBY25VLGNBQWNnTixnQkFwREk7O0FBc0RoQzs7O0FBR0E0QyxjQUFZLHNCQUFZO0FBQ3RCLFFBQUk4RCxZQUFZLEtBQUtDLFdBQUwsQ0FBaUJELFNBQWpDO0FBQ0EsU0FBSyxJQUFJRSxRQUFULElBQXFCRixTQUFyQixFQUFnQztBQUM5QixVQUFJclksUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNnRixlQUFPaVEsY0FBUCxDQUFzQixJQUF0QixFQUE0QlIsUUFBNUIsRUFBc0NTLG1DQUFtQ1QsUUFBbkMsRUFBNkNGLFVBQVVFLFFBQVYsQ0FBN0MsQ0FBdEM7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFLQSxRQUFMLElBQWlCLElBQWpCO0FBQ0Q7QUFDRjtBQUNELFNBQUssSUFBSXhXLElBQUksQ0FBYixFQUFnQkEsSUFBSWtWLDJCQUEyQjVWLE1BQS9DLEVBQXVEVSxHQUF2RCxFQUE0RDtBQUMxRCxXQUFLa1YsMkJBQTJCbFYsQ0FBM0IsQ0FBTCxJQUFzQyxJQUF0QztBQUNEO0FBQ0QsUUFBSS9CLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDZ0YsYUFBT2lRLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsYUFBNUIsRUFBMkNDLG1DQUFtQyxhQUFuQyxFQUFrRCxJQUFsRCxDQUEzQztBQUNBbFEsYUFBT2lRLGNBQVAsQ0FBc0IsSUFBdEIsRUFBNEIsZ0JBQTVCLEVBQThDQyxtQ0FBbUMsZ0JBQW5DLEVBQXFEclUsYUFBckQsQ0FBOUM7QUFDQW1FLGFBQU9pUSxjQUFQLENBQXNCLElBQXRCLEVBQTRCLGlCQUE1QixFQUErQ0MsbUNBQW1DLGlCQUFuQyxFQUFzRHJVLGFBQXRELENBQS9DO0FBQ0Q7QUFDRjtBQTFFK0IsQ0FBbEM7O0FBNkVBa1QsZUFBZVEsU0FBZixHQUEyQm5CLGNBQTNCOztBQUVBLElBQUlsWCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJaVQsZ0JBQUosRUFBc0I7QUFDcEI7QUFDQWMscUJBQWlCLElBQUliLEtBQUosQ0FBVWEsY0FBVixFQUEwQjtBQUN6Q29CLGlCQUFXLG1CQUFVN08sTUFBVixFQUFrQnhJLElBQWxCLEVBQXdCO0FBQ2pDLGVBQU8sS0FBS1EsS0FBTCxDQUFXZ0ksTUFBWCxFQUFtQnRCLE9BQU9vUSxNQUFQLENBQWM5TyxPQUFPakksU0FBckIsQ0FBbkIsRUFBb0RQLElBQXBELENBQVA7QUFDRCxPQUh3QztBQUl6Q1EsYUFBTyxlQUFVa1csV0FBVixFQUF1QmEsSUFBdkIsRUFBNkJ2WCxJQUE3QixFQUFtQztBQUN4QyxlQUFPLElBQUlvVixLQUFKLENBQVVzQixZQUFZbFcsS0FBWixDQUFrQitXLElBQWxCLEVBQXdCdlgsSUFBeEIsQ0FBVixFQUF5QztBQUM5QzJMLGVBQUssYUFBVW5ELE1BQVYsRUFBa0JnUCxJQUFsQixFQUF3QkMsS0FBeEIsRUFBK0I7QUFDbEMsZ0JBQUlELFNBQVMsY0FBVCxJQUEyQixDQUFDaFAsT0FBT2tPLFdBQVAsQ0FBbUJELFNBQW5CLENBQTZCdFEsY0FBN0IsQ0FBNENxUixJQUE1QyxDQUE1QixJQUFpRm5DLDJCQUEyQjdSLE9BQTNCLENBQW1DZ1UsSUFBbkMsTUFBNkMsQ0FBQyxDQUFuSSxFQUFzSTtBQUNwSXBaLHNCQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUWlTLDhCQUE4QjFNLE9BQU8wTyxZQUFQLEVBQXRDLEVBQTZELHVFQUF1RSwyRUFBdkUsR0FBcUosc0NBQXJKLEdBQThMLHlEQUEzUCxDQUF4QyxHQUFnVyxLQUFLLENBQXJXO0FBQ0FoQywyQ0FBNkIsSUFBN0I7QUFDRDtBQUNEMU0sbUJBQU9nUCxJQUFQLElBQWVDLEtBQWY7QUFDQSxtQkFBTyxJQUFQO0FBQ0Q7QUFSNkMsU0FBekMsQ0FBUDtBQVVEO0FBZndDLEtBQTFCLENBQWpCO0FBaUJBO0FBQ0Q7QUFDRjtBQUNEOzs7Ozs7QUFNQXhCLGVBQWV5QixZQUFmLEdBQThCLFVBQVVDLEtBQVYsRUFBaUJsQixTQUFqQixFQUE0QjtBQUN4RCxNQUFJbUIsUUFBUSxJQUFaOztBQUVBLE1BQUlDLElBQUksU0FBSkEsQ0FBSSxHQUFZLENBQUUsQ0FBdEI7QUFDQUEsSUFBRXRYLFNBQUYsR0FBY3FYLE1BQU1yWCxTQUFwQjtBQUNBLE1BQUlBLFlBQVksSUFBSXNYLENBQUosRUFBaEI7O0FBRUFoSCxVQUFRdFEsU0FBUixFQUFtQm9YLE1BQU1wWCxTQUF6QjtBQUNBb1gsUUFBTXBYLFNBQU4sR0FBa0JBLFNBQWxCO0FBQ0FvWCxRQUFNcFgsU0FBTixDQUFnQm1XLFdBQWhCLEdBQThCaUIsS0FBOUI7O0FBRUFBLFFBQU1sQixTQUFOLEdBQWtCNUYsUUFBUSxFQUFSLEVBQVkrRyxNQUFNbkIsU0FBbEIsRUFBNkJBLFNBQTdCLENBQWxCO0FBQ0FrQixRQUFNRCxZQUFOLEdBQXFCRSxNQUFNRixZQUEzQjs7QUFFQTNHLGNBQVlpQyxZQUFaLENBQXlCMkUsS0FBekIsRUFBZ0M1RyxZQUFZK0csa0JBQTVDO0FBQ0QsQ0FmRDs7QUFpQkEvRyxZQUFZaUMsWUFBWixDQUF5QmlELGNBQXpCLEVBQXlDbEYsWUFBWStHLGtCQUFyRDs7QUFFQXpaLE9BQU9DLE9BQVAsR0FBaUIyWCxjQUFqQjs7QUFFQTs7Ozs7OztBQU9BLFNBQVNtQixrQ0FBVCxDQUE0Q1QsUUFBNUMsRUFBc0RvQixNQUF0RCxFQUE4RDtBQUM1RCxNQUFJQyxhQUFhLE9BQU9ELE1BQVAsS0FBa0IsVUFBbkM7QUFDQSxTQUFPO0FBQ0xFLGtCQUFjLElBRFQ7QUFFTHRNLFNBQUtBLEdBRkE7QUFHTEMsU0FBS0E7QUFIQSxHQUFQOztBQU1BLFdBQVNELEdBQVQsQ0FBYXJFLEdBQWIsRUFBa0I7QUFDaEIsUUFBSTRRLFNBQVNGLGFBQWEsb0JBQWIsR0FBb0Msc0JBQWpEO0FBQ0FHLFNBQUtELE1BQUwsRUFBYSw2QkFBYjtBQUNBLFdBQU81USxHQUFQO0FBQ0Q7O0FBRUQsV0FBU3NFLEdBQVQsR0FBZTtBQUNiLFFBQUlzTSxTQUFTRixhQUFhLHNCQUFiLEdBQXNDLHdCQUFuRDtBQUNBLFFBQUlJLFNBQVNKLGFBQWEsMEJBQWIsR0FBMEMscUJBQXZEO0FBQ0FHLFNBQUtELE1BQUwsRUFBYUUsTUFBYjtBQUNBLFdBQU9MLE1BQVA7QUFDRDs7QUFFRCxXQUFTSSxJQUFULENBQWNELE1BQWQsRUFBc0JFLE1BQXRCLEVBQThCO0FBQzVCLFFBQUlDLG1CQUFtQixLQUF2QjtBQUNBamEsWUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVFvVixnQkFBUixFQUEwQixvRkFBb0YsOERBQXBGLEdBQXFKLDZFQUFySixHQUFxTyw2REFBL1AsRUFBOFRILE1BQTlULEVBQXNVdkIsUUFBdFUsRUFBZ1Z5QixNQUFoVixDQUF4QyxHQUFrWSxLQUFLLENBQXZZO0FBQ0Q7QUFDRixDOzs7Ozs7OztBQ3hRRDs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlwVSxpQkFBaUIsbUJBQUFoQixDQUFRLENBQVIsQ0FBckI7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCOztBQUVBLFNBQVNzVixTQUFULENBQW1CYixLQUFuQixFQUEwQmMsT0FBMUIsRUFBbUM7QUFDakMsU0FBTyxDQUFDZCxRQUFRYyxPQUFULE1BQXNCQSxPQUE3QjtBQUNEOztBQUVELElBQUlDLHVCQUF1QjtBQUN6Qjs7OztBQUlBQyxxQkFBbUIsR0FMTTtBQU16QkMscUJBQW1CLEdBTk07QUFPekJDLHFCQUFtQixHQVBNO0FBUXpCQyw4QkFBNEIsT0FBTyxHQVJWO0FBU3pCQyxnQ0FBOEIsSUFUTDs7QUFXekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkFDLDJCQUF5QixpQ0FBVUMsaUJBQVYsRUFBNkI7QUFDcEQsUUFBSUMsWUFBWVIsb0JBQWhCO0FBQ0EsUUFBSVMsYUFBYUYsa0JBQWtCRSxVQUFsQixJQUFnQyxFQUFqRDtBQUNBLFFBQUlDLHlCQUF5Qkgsa0JBQWtCRyxzQkFBbEIsSUFBNEMsRUFBekU7QUFDQSxRQUFJQyxvQkFBb0JKLGtCQUFrQkksaUJBQWxCLElBQXVDLEVBQS9EO0FBQ0EsUUFBSUMsbUJBQW1CTCxrQkFBa0JLLGdCQUFsQixJQUFzQyxFQUE3RDtBQUNBLFFBQUlDLHFCQUFxQk4sa0JBQWtCTSxrQkFBbEIsSUFBd0MsRUFBakU7O0FBRUEsUUFBSU4sa0JBQWtCTyxpQkFBdEIsRUFBeUM7QUFDdkNyVixrQkFBWXNWLDJCQUFaLENBQXdDblosSUFBeEMsQ0FBNkMyWSxrQkFBa0JPLGlCQUEvRDtBQUNEOztBQUVELFNBQUssSUFBSTNDLFFBQVQsSUFBcUJzQyxVQUFyQixFQUFpQztBQUMvQixPQUFDLENBQUNoVixZQUFZdVYsVUFBWixDQUF1QnJULGNBQXZCLENBQXNDd1EsUUFBdEMsQ0FBRixHQUFvRHZZLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsNlBBQWpCLEVBQWdSdVUsUUFBaFIsQ0FBeEMsR0FBb1UzUyxlQUFlLElBQWYsRUFBcUIyUyxRQUFyQixDQUF4WCxHQUF5WixLQUFLLENBQTlaOztBQUVBLFVBQUk4QyxhQUFhOUMsU0FBUytDLFdBQVQsRUFBakI7QUFDQSxVQUFJQyxhQUFhVixXQUFXdEMsUUFBWCxDQUFqQjs7QUFFQSxVQUFJaUQsZUFBZTtBQUNqQkMsdUJBQWVKLFVBREU7QUFFakJLLDRCQUFvQixJQUZIO0FBR2pCQyxzQkFBY3BELFFBSEc7QUFJakJxRCx3QkFBZ0IsSUFKQzs7QUFNakJDLHlCQUFpQjNCLFVBQVVxQixVQUFWLEVBQXNCWCxVQUFVUCxpQkFBaEMsQ0FOQTtBQU9qQnlCLHlCQUFpQjVCLFVBQVVxQixVQUFWLEVBQXNCWCxVQUFVTixpQkFBaEMsQ0FQQTtBQVFqQnlCLHlCQUFpQjdCLFVBQVVxQixVQUFWLEVBQXNCWCxVQUFVTCxpQkFBaEMsQ0FSQTtBQVNqQnlCLGlDQUF5QjlCLFVBQVVxQixVQUFWLEVBQXNCWCxVQUFVSiwwQkFBaEMsQ0FUUjtBQVVqQnlCLG1DQUEyQi9CLFVBQVVxQixVQUFWLEVBQXNCWCxVQUFVSCw0QkFBaEM7QUFWVixPQUFuQjtBQVlBLFFBQUVlLGFBQWFNLGVBQWIsR0FBK0JOLGFBQWFPLGVBQTVDLEdBQThEUCxhQUFhUyx5QkFBM0UsSUFBd0csQ0FBMUcsSUFBK0dqYyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLDJHQUFqQixFQUE4SHVVLFFBQTlILENBQXhDLEdBQWtMM1MsZUFBZSxJQUFmLEVBQXFCMlMsUUFBckIsQ0FBalMsR0FBa1UsS0FBSyxDQUF2VTs7QUFFQSxVQUFJdlksUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMrQixvQkFBWXFXLHVCQUFaLENBQW9DYixVQUFwQyxJQUFrRDlDLFFBQWxEO0FBQ0Q7O0FBRUQsVUFBSXdDLGtCQUFrQmhULGNBQWxCLENBQWlDd1EsUUFBakMsQ0FBSixFQUFnRDtBQUM5QyxZQUFJa0QsZ0JBQWdCVixrQkFBa0J4QyxRQUFsQixDQUFwQjtBQUNBaUQscUJBQWFDLGFBQWIsR0FBNkJBLGFBQTdCO0FBQ0EsWUFBSXpiLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDK0Isc0JBQVlxVyx1QkFBWixDQUFvQ1QsYUFBcEMsSUFBcURsRCxRQUFyRDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSXVDLHVCQUF1Qi9TLGNBQXZCLENBQXNDd1EsUUFBdEMsQ0FBSixFQUFxRDtBQUNuRGlELHFCQUFhRSxrQkFBYixHQUFrQ1osdUJBQXVCdkMsUUFBdkIsQ0FBbEM7QUFDRDs7QUFFRCxVQUFJeUMsaUJBQWlCalQsY0FBakIsQ0FBZ0N3USxRQUFoQyxDQUFKLEVBQStDO0FBQzdDaUQscUJBQWFHLFlBQWIsR0FBNEJYLGlCQUFpQnpDLFFBQWpCLENBQTVCO0FBQ0Q7O0FBRUQsVUFBSTBDLG1CQUFtQmxULGNBQW5CLENBQWtDd1EsUUFBbEMsQ0FBSixFQUFpRDtBQUMvQ2lELHFCQUFhSSxjQUFiLEdBQThCWCxtQkFBbUIxQyxRQUFuQixDQUE5QjtBQUNEOztBQUVEMVMsa0JBQVl1VixVQUFaLENBQXVCN0MsUUFBdkIsSUFBbUNpRCxZQUFuQztBQUNEO0FBQ0Y7QUFqR3dCLENBQTNCOztBQW9HQTtBQUNBLElBQUlXLDRCQUE0QiwrS0FBaEM7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBLElBQUl0VyxjQUFjO0FBQ2hCRyxxQkFBbUIsY0FESDtBQUVoQm9XLHVCQUFxQixnQkFGTDs7QUFJaEJELDZCQUEyQkEseUJBSlg7QUFLaEJFLHVCQUFxQkYsNEJBQTRCLDhDQUxqQzs7QUFPaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkFmLGNBQVksRUFuQ0k7O0FBcUNoQjs7Ozs7Ozs7O0FBU0FjLDJCQUF5QmxjLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDLEVBQUV3WSxXQUFXLFdBQWIsRUFBeEMsR0FBcUUsSUE5QzlFOztBQWdEaEI7OztBQUdBbkIsK0JBQTZCLEVBbkRiOztBQXFEaEI7Ozs7QUFJQUQscUJBQW1CLDJCQUFVTyxhQUFWLEVBQXlCO0FBQzFDLFNBQUssSUFBSTFaLElBQUksQ0FBYixFQUFnQkEsSUFBSThELFlBQVlzViwyQkFBWixDQUF3QzlaLE1BQTVELEVBQW9FVSxHQUFwRSxFQUF5RTtBQUN2RSxVQUFJd2Esc0JBQXNCMVcsWUFBWXNWLDJCQUFaLENBQXdDcFosQ0FBeEMsQ0FBMUI7QUFDQSxVQUFJd2Esb0JBQW9CZCxhQUFwQixDQUFKLEVBQXdDO0FBQ3RDLGVBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFDRCxXQUFPLEtBQVA7QUFDRCxHQWpFZTs7QUFtRWhCNUUsYUFBV3VEO0FBbkVLLENBQWxCOztBQXNFQW5hLE9BQU9DLE9BQVAsR0FBaUIyRixXQUFqQixDOzs7Ozs7OztBQy9NQTs7Ozs7Ozs7OztBQVVBOzs7O0FBRUEsSUFBSTRNLFVBQVUsbUJBQUE3TixDQUFRLEVBQVIsQ0FBZDs7QUFFQSxJQUFJcUgsb0JBQW9CLG1CQUFBckgsQ0FBUSxFQUFSLENBQXhCOztBQUVBLElBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkO0FBQ0EsSUFBSTRYLG9CQUFvQixtQkFBQTVYLENBQVEsRUFBUixDQUF4QjtBQUNBLElBQUltRCxpQkFBaUJlLE9BQU8zRyxTQUFQLENBQWlCNEYsY0FBdEM7O0FBRUEsSUFBSW1LLHFCQUFxQixtQkFBQXROLENBQVEsRUFBUixDQUF6Qjs7QUFFQSxJQUFJNlgsaUJBQWlCO0FBQ25CL1IsT0FBSyxJQURjO0FBRW5CZ1MsT0FBSyxJQUZjO0FBR25CQyxVQUFRLElBSFc7QUFJbkJDLFlBQVU7QUFKUyxDQUFyQjs7QUFPQSxJQUFJQywwQkFBSixFQUFnQ0MsMEJBQWhDOztBQUVBLFNBQVNDLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQTZCO0FBQzNCLE1BQUloZCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxRQUFJaUUsZUFBZWxILElBQWYsQ0FBb0JtYyxNQUFwQixFQUE0QixLQUE1QixDQUFKLEVBQXdDO0FBQ3RDLFVBQUlDLFNBQVNuVSxPQUFPb1Usd0JBQVAsQ0FBZ0NGLE1BQWhDLEVBQXdDLEtBQXhDLEVBQStDeFAsR0FBNUQ7QUFDQSxVQUFJeVAsVUFBVUEsT0FBT0UsY0FBckIsRUFBcUM7QUFDbkMsZUFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBT0gsT0FBT04sR0FBUCxLQUFlM1ksU0FBdEI7QUFDRDs7QUFFRCxTQUFTcVosV0FBVCxDQUFxQkosTUFBckIsRUFBNkI7QUFDM0IsTUFBSWhkLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFFBQUlpRSxlQUFlbEgsSUFBZixDQUFvQm1jLE1BQXBCLEVBQTRCLEtBQTVCLENBQUosRUFBd0M7QUFDdEMsVUFBSUMsU0FBU25VLE9BQU9vVSx3QkFBUCxDQUFnQ0YsTUFBaEMsRUFBd0MsS0FBeEMsRUFBK0N4UCxHQUE1RDtBQUNBLFVBQUl5UCxVQUFVQSxPQUFPRSxjQUFyQixFQUFxQztBQUNuQyxlQUFPLEtBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxTQUFPSCxPQUFPdFMsR0FBUCxLQUFlM0csU0FBdEI7QUFDRDs7QUFFRCxTQUFTc1osMEJBQVQsQ0FBb0NDLEtBQXBDLEVBQTJDNU8sV0FBM0MsRUFBd0Q7QUFDdEQsTUFBSTZPLHdCQUF3QixTQUF4QkEscUJBQXdCLEdBQVk7QUFDdEMsUUFBSSxDQUFDViwwQkFBTCxFQUFpQztBQUMvQkEsbUNBQTZCLElBQTdCO0FBQ0E3YyxjQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsOERBQThELGdFQUE5RCxHQUFpSSxzRUFBakksR0FBME0sMkNBQXpOLEVBQXNRNkosV0FBdFEsQ0FBeEMsR0FBNlQsS0FBSyxDQUFsVTtBQUNEO0FBQ0YsR0FMRDtBQU1BNk8sd0JBQXNCSixjQUF0QixHQUF1QyxJQUF2QztBQUNBclUsU0FBT2lRLGNBQVAsQ0FBc0J1RSxLQUF0QixFQUE2QixLQUE3QixFQUFvQztBQUNsQzlQLFNBQUsrUCxxQkFENkI7QUFFbEMxRCxrQkFBYztBQUZvQixHQUFwQztBQUlEOztBQUVELFNBQVMyRCwwQkFBVCxDQUFvQ0YsS0FBcEMsRUFBMkM1TyxXQUEzQyxFQUF3RDtBQUN0RCxNQUFJK08sd0JBQXdCLFNBQXhCQSxxQkFBd0IsR0FBWTtBQUN0QyxRQUFJLENBQUNYLDBCQUFMLEVBQWlDO0FBQy9CQSxtQ0FBNkIsSUFBN0I7QUFDQTljLGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSw4REFBOEQsZ0VBQTlELEdBQWlJLHNFQUFqSSxHQUEwTSwyQ0FBek4sRUFBc1E2SixXQUF0USxDQUF4QyxHQUE2VCxLQUFLLENBQWxVO0FBQ0Q7QUFDRixHQUxEO0FBTUErTyx3QkFBc0JOLGNBQXRCLEdBQXVDLElBQXZDO0FBQ0FyVSxTQUFPaVEsY0FBUCxDQUFzQnVFLEtBQXRCLEVBQTZCLEtBQTdCLEVBQW9DO0FBQ2xDOVAsU0FBS2lRLHFCQUQ2QjtBQUVsQzVELGtCQUFjO0FBRm9CLEdBQXBDO0FBSUQ7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLElBQUk2RCxlQUFlLFNBQWZBLFlBQWUsQ0FBVWpQLElBQVYsRUFBZ0IvRCxHQUFoQixFQUFxQmdTLEdBQXJCLEVBQTBCaUIsSUFBMUIsRUFBZ0N0VCxNQUFoQyxFQUF3QytGLEtBQXhDLEVBQStDa04sS0FBL0MsRUFBc0Q7QUFDdkUsTUFBSTlPLFVBQVU7QUFDWjtBQUNBK0QsY0FBVUwsa0JBRkU7O0FBSVo7QUFDQXpELFVBQU1BLElBTE07QUFNWi9ELFNBQUtBLEdBTk87QUFPWmdTLFNBQUtBLEdBUE87QUFRWlksV0FBT0EsS0FSSzs7QUFVWjtBQUNBak4sWUFBUUQ7QUFYSSxHQUFkOztBQWNBLE1BQUlwUSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBMEssWUFBUW9QLE1BQVIsR0FBaUIsRUFBakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJcEIsaUJBQUosRUFBdUI7QUFDckIxVCxhQUFPaVEsY0FBUCxDQUFzQnZLLFFBQVFvUCxNQUE5QixFQUFzQyxXQUF0QyxFQUFtRDtBQUNqRC9ELHNCQUFjLEtBRG1DO0FBRWpEZ0Usb0JBQVksS0FGcUM7QUFHakRDLGtCQUFVLElBSHVDO0FBSWpEekUsZUFBTztBQUowQyxPQUFuRDtBQU1BO0FBQ0F2USxhQUFPaVEsY0FBUCxDQUFzQnZLLE9BQXRCLEVBQStCLE9BQS9CLEVBQXdDO0FBQ3RDcUwsc0JBQWMsS0FEd0I7QUFFdENnRSxvQkFBWSxLQUYwQjtBQUd0Q0Msa0JBQVUsS0FINEI7QUFJdEN6RSxlQUFPc0U7QUFKK0IsT0FBeEM7QUFNQTtBQUNBO0FBQ0E3VSxhQUFPaVEsY0FBUCxDQUFzQnZLLE9BQXRCLEVBQStCLFNBQS9CLEVBQTBDO0FBQ3hDcUwsc0JBQWMsS0FEMEI7QUFFeENnRSxvQkFBWSxLQUY0QjtBQUd4Q0Msa0JBQVUsS0FIOEI7QUFJeEN6RSxlQUFPaFA7QUFKaUMsT0FBMUM7QUFNRCxLQXRCRCxNQXNCTztBQUNMbUUsY0FBUW9QLE1BQVIsQ0FBZUcsU0FBZixHQUEyQixLQUEzQjtBQUNBdlAsY0FBUXdQLEtBQVIsR0FBZ0JMLElBQWhCO0FBQ0FuUCxjQUFRUSxPQUFSLEdBQWtCM0UsTUFBbEI7QUFDRDtBQUNELFFBQUl2QixPQUFPbVYsTUFBWCxFQUFtQjtBQUNqQm5WLGFBQU9tVixNQUFQLENBQWN6UCxRQUFROE8sS0FBdEI7QUFDQXhVLGFBQU9tVixNQUFQLENBQWN6UCxPQUFkO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPQSxPQUFQO0FBQ0QsQ0E1REQ7O0FBOERBOzs7O0FBSUFrUCxhQUFhNVMsYUFBYixHQUE2QixVQUFVMkQsSUFBVixFQUFnQnVPLE1BQWhCLEVBQXdCdFYsUUFBeEIsRUFBa0M7QUFDN0QsTUFBSTZRLFFBQUo7O0FBRUE7QUFDQSxNQUFJK0UsUUFBUSxFQUFaOztBQUVBLE1BQUk1UyxNQUFNLElBQVY7QUFDQSxNQUFJZ1MsTUFBTSxJQUFWO0FBQ0EsTUFBSWlCLE9BQU8sSUFBWDtBQUNBLE1BQUl0VCxTQUFTLElBQWI7O0FBRUEsTUFBSTJTLFVBQVUsSUFBZCxFQUFvQjtBQUNsQixRQUFJRCxZQUFZQyxNQUFaLENBQUosRUFBeUI7QUFDdkJOLFlBQU1NLE9BQU9OLEdBQWI7QUFDRDtBQUNELFFBQUlVLFlBQVlKLE1BQVosQ0FBSixFQUF5QjtBQUN2QnRTLFlBQU0sS0FBS3NTLE9BQU90UyxHQUFsQjtBQUNEOztBQUVEaVQsV0FBT1gsT0FBT0wsTUFBUCxLQUFrQjVZLFNBQWxCLEdBQThCLElBQTlCLEdBQXFDaVosT0FBT0wsTUFBbkQ7QUFDQXRTLGFBQVMyUyxPQUFPSixRQUFQLEtBQW9CN1ksU0FBcEIsR0FBZ0MsSUFBaEMsR0FBdUNpWixPQUFPSixRQUF2RDtBQUNBO0FBQ0EsU0FBS3JFLFFBQUwsSUFBaUJ5RSxNQUFqQixFQUF5QjtBQUN2QixVQUFJalYsZUFBZWxILElBQWYsQ0FBb0JtYyxNQUFwQixFQUE0QnpFLFFBQTVCLEtBQXlDLENBQUNrRSxlQUFlMVUsY0FBZixDQUE4QndRLFFBQTlCLENBQTlDLEVBQXVGO0FBQ3JGK0UsY0FBTS9FLFFBQU4sSUFBa0J5RSxPQUFPekUsUUFBUCxDQUFsQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsTUFBSTJGLGlCQUFpQnBjLFVBQVVULE1BQVYsR0FBbUIsQ0FBeEM7QUFDQSxNQUFJNmMsbUJBQW1CLENBQXZCLEVBQTBCO0FBQ3hCWixVQUFNNVYsUUFBTixHQUFpQkEsUUFBakI7QUFDRCxHQUZELE1BRU8sSUFBSXdXLGlCQUFpQixDQUFyQixFQUF3QjtBQUM3QixRQUFJQyxhQUFhdGMsTUFBTXFjLGNBQU4sQ0FBakI7QUFDQSxTQUFLLElBQUluYyxJQUFJLENBQWIsRUFBZ0JBLElBQUltYyxjQUFwQixFQUFvQ25jLEdBQXBDLEVBQXlDO0FBQ3ZDb2MsaUJBQVdwYyxDQUFYLElBQWdCRCxVQUFVQyxJQUFJLENBQWQsQ0FBaEI7QUFDRDtBQUNELFFBQUkvQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJZ0YsT0FBT21WLE1BQVgsRUFBbUI7QUFDakJuVixlQUFPbVYsTUFBUCxDQUFjRSxVQUFkO0FBQ0Q7QUFDRjtBQUNEYixVQUFNNVYsUUFBTixHQUFpQnlXLFVBQWpCO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJMVAsUUFBUUEsS0FBSzJQLFlBQWpCLEVBQStCO0FBQzdCLFFBQUlBLGVBQWUzUCxLQUFLMlAsWUFBeEI7QUFDQSxTQUFLN0YsUUFBTCxJQUFpQjZGLFlBQWpCLEVBQStCO0FBQzdCLFVBQUlkLE1BQU0vRSxRQUFOLE1BQW9CeFUsU0FBeEIsRUFBbUM7QUFDakN1WixjQUFNL0UsUUFBTixJQUFrQjZGLGFBQWE3RixRQUFiLENBQWxCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsTUFBSXZZLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFFBQUk0RyxPQUFPZ1MsR0FBWCxFQUFnQjtBQUNkLFVBQUksT0FBT1ksTUFBTS9LLFFBQWIsS0FBMEIsV0FBMUIsSUFBeUMrSyxNQUFNL0ssUUFBTixLQUFtQkwsa0JBQWhFLEVBQW9GO0FBQ2xGLFlBQUl4RCxjQUFjLE9BQU9ELElBQVAsS0FBZ0IsVUFBaEIsR0FBNkJBLEtBQUtDLFdBQUwsSUFBb0JELEtBQUtuTCxJQUF6QixJQUFpQyxTQUE5RCxHQUEwRW1MLElBQTVGO0FBQ0EsWUFBSS9ELEdBQUosRUFBUztBQUNQMlMscUNBQTJCQyxLQUEzQixFQUFrQzVPLFdBQWxDO0FBQ0Q7QUFDRCxZQUFJZ08sR0FBSixFQUFTO0FBQ1BjLHFDQUEyQkYsS0FBM0IsRUFBa0M1TyxXQUFsQztBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0QsU0FBT2dQLGFBQWFqUCxJQUFiLEVBQW1CL0QsR0FBbkIsRUFBd0JnUyxHQUF4QixFQUE2QmlCLElBQTdCLEVBQW1DdFQsTUFBbkMsRUFBMkM0QixrQkFBa0J1RSxPQUE3RCxFQUFzRThNLEtBQXRFLENBQVA7QUFDRCxDQXRFRDs7QUF3RUE7Ozs7QUFJQUksYUFBYVcsYUFBYixHQUE2QixVQUFVNVAsSUFBVixFQUFnQjtBQUMzQyxNQUFJNlAsVUFBVVosYUFBYTVTLGFBQWIsQ0FBMkJ5VCxJQUEzQixDQUFnQyxJQUFoQyxFQUFzQzlQLElBQXRDLENBQWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E2UCxVQUFRN1AsSUFBUixHQUFlQSxJQUFmO0FBQ0EsU0FBTzZQLE9BQVA7QUFDRCxDQVREOztBQVdBWixhQUFhYyxrQkFBYixHQUFrQyxVQUFVQyxVQUFWLEVBQXNCQyxNQUF0QixFQUE4QjtBQUM5RCxNQUFJQyxhQUFhakIsYUFBYWUsV0FBV2hRLElBQXhCLEVBQThCaVEsTUFBOUIsRUFBc0NELFdBQVcvQixHQUFqRCxFQUFzRCtCLFdBQVdULEtBQWpFLEVBQXdFUyxXQUFXelAsT0FBbkYsRUFBNEZ5UCxXQUFXcE8sTUFBdkcsRUFBK0dvTyxXQUFXbkIsS0FBMUgsQ0FBakI7O0FBRUEsU0FBT3FCLFVBQVA7QUFDRCxDQUpEOztBQU1BOzs7O0FBSUFqQixhQUFha0IsWUFBYixHQUE0QixVQUFVcFEsT0FBVixFQUFtQndPLE1BQW5CLEVBQTJCdFYsUUFBM0IsRUFBcUM7QUFDL0QsTUFBSTZRLFFBQUo7O0FBRUE7QUFDQSxNQUFJK0UsUUFBUTdLLFFBQVEsRUFBUixFQUFZakUsUUFBUThPLEtBQXBCLENBQVo7O0FBRUE7QUFDQSxNQUFJNVMsTUFBTThELFFBQVE5RCxHQUFsQjtBQUNBLE1BQUlnUyxNQUFNbE8sUUFBUWtPLEdBQWxCO0FBQ0E7QUFDQSxNQUFJaUIsT0FBT25QLFFBQVF3UCxLQUFuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUkzVCxTQUFTbUUsUUFBUVEsT0FBckI7O0FBRUE7QUFDQSxNQUFJb0IsUUFBUTVCLFFBQVE2QixNQUFwQjs7QUFFQSxNQUFJMk0sVUFBVSxJQUFkLEVBQW9CO0FBQ2xCLFFBQUlELFlBQVlDLE1BQVosQ0FBSixFQUF5QjtBQUN2QjtBQUNBTixZQUFNTSxPQUFPTixHQUFiO0FBQ0F0TSxjQUFRbkUsa0JBQWtCdUUsT0FBMUI7QUFDRDtBQUNELFFBQUk0TSxZQUFZSixNQUFaLENBQUosRUFBeUI7QUFDdkJ0UyxZQUFNLEtBQUtzUyxPQUFPdFMsR0FBbEI7QUFDRDs7QUFFRDtBQUNBLFFBQUkwVCxZQUFKO0FBQ0EsUUFBSTVQLFFBQVFDLElBQVIsSUFBZ0JELFFBQVFDLElBQVIsQ0FBYTJQLFlBQWpDLEVBQStDO0FBQzdDQSxxQkFBZTVQLFFBQVFDLElBQVIsQ0FBYTJQLFlBQTVCO0FBQ0Q7QUFDRCxTQUFLN0YsUUFBTCxJQUFpQnlFLE1BQWpCLEVBQXlCO0FBQ3ZCLFVBQUlqVixlQUFlbEgsSUFBZixDQUFvQm1jLE1BQXBCLEVBQTRCekUsUUFBNUIsS0FBeUMsQ0FBQ2tFLGVBQWUxVSxjQUFmLENBQThCd1EsUUFBOUIsQ0FBOUMsRUFBdUY7QUFDckYsWUFBSXlFLE9BQU96RSxRQUFQLE1BQXFCeFUsU0FBckIsSUFBa0NxYSxpQkFBaUJyYSxTQUF2RCxFQUFrRTtBQUNoRTtBQUNBdVosZ0JBQU0vRSxRQUFOLElBQWtCNkYsYUFBYTdGLFFBQWIsQ0FBbEI7QUFDRCxTQUhELE1BR087QUFDTCtFLGdCQUFNL0UsUUFBTixJQUFrQnlFLE9BQU96RSxRQUFQLENBQWxCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBLE1BQUkyRixpQkFBaUJwYyxVQUFVVCxNQUFWLEdBQW1CLENBQXhDO0FBQ0EsTUFBSTZjLG1CQUFtQixDQUF2QixFQUEwQjtBQUN4QlosVUFBTTVWLFFBQU4sR0FBaUJBLFFBQWpCO0FBQ0QsR0FGRCxNQUVPLElBQUl3VyxpQkFBaUIsQ0FBckIsRUFBd0I7QUFDN0IsUUFBSUMsYUFBYXRjLE1BQU1xYyxjQUFOLENBQWpCO0FBQ0EsU0FBSyxJQUFJbmMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJbWMsY0FBcEIsRUFBb0NuYyxHQUFwQyxFQUF5QztBQUN2Q29jLGlCQUFXcGMsQ0FBWCxJQUFnQkQsVUFBVUMsSUFBSSxDQUFkLENBQWhCO0FBQ0Q7QUFDRHViLFVBQU01VixRQUFOLEdBQWlCeVcsVUFBakI7QUFDRDs7QUFFRCxTQUFPVCxhQUFhbFAsUUFBUUMsSUFBckIsRUFBMkIvRCxHQUEzQixFQUFnQ2dTLEdBQWhDLEVBQXFDaUIsSUFBckMsRUFBMkN0VCxNQUEzQyxFQUFtRCtGLEtBQW5ELEVBQTBEa04sS0FBMUQsQ0FBUDtBQUNELENBNUREOztBQThEQTs7Ozs7OztBQU9BSSxhQUFhckwsY0FBYixHQUE4QixVQUFVQyxNQUFWLEVBQWtCO0FBQzlDLFNBQU8sUUFBT0EsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFsQixJQUE4QkEsV0FBVyxJQUF6QyxJQUFpREEsT0FBT0MsUUFBUCxLQUFvQkwsa0JBQTVFO0FBQ0QsQ0FGRDs7QUFJQWpTLE9BQU9DLE9BQVAsR0FBaUJ3ZCxZQUFqQixDOzs7Ozs7OztBQ25WQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJOVgsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCOztBQUVBLElBQUlaLFlBQVksbUJBQUFZLENBQVEsQ0FBUixDQUFoQjs7QUFFQTs7Ozs7OztBQU9BLElBQUlpYSxvQkFBb0IsU0FBcEJBLGlCQUFvQixDQUFVQyxjQUFWLEVBQTBCO0FBQ2hELE1BQUlDLFFBQVEsSUFBWjtBQUNBLE1BQUlBLE1BQU1DLFlBQU4sQ0FBbUIzZCxNQUF2QixFQUErQjtBQUM3QixRQUFJNGQsV0FBV0YsTUFBTUMsWUFBTixDQUFtQnhXLEdBQW5CLEVBQWY7QUFDQXVXLFVBQU1sZSxJQUFOLENBQVdvZSxRQUFYLEVBQXFCSCxjQUFyQjtBQUNBLFdBQU9HLFFBQVA7QUFDRCxHQUpELE1BSU87QUFDTCxXQUFPLElBQUlGLEtBQUosQ0FBVUQsY0FBVixDQUFQO0FBQ0Q7QUFDRixDQVREOztBQVdBLElBQUlJLG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVVDLEVBQVYsRUFBY0MsRUFBZCxFQUFrQjtBQUN4QyxNQUFJTCxRQUFRLElBQVo7QUFDQSxNQUFJQSxNQUFNQyxZQUFOLENBQW1CM2QsTUFBdkIsRUFBK0I7QUFDN0IsUUFBSTRkLFdBQVdGLE1BQU1DLFlBQU4sQ0FBbUJ4VyxHQUFuQixFQUFmO0FBQ0F1VyxVQUFNbGUsSUFBTixDQUFXb2UsUUFBWCxFQUFxQkUsRUFBckIsRUFBeUJDLEVBQXpCO0FBQ0EsV0FBT0gsUUFBUDtBQUNELEdBSkQsTUFJTztBQUNMLFdBQU8sSUFBSUYsS0FBSixDQUFVSSxFQUFWLEVBQWNDLEVBQWQsQ0FBUDtBQUNEO0FBQ0YsQ0FURDs7QUFXQSxJQUFJQyxzQkFBc0IsU0FBdEJBLG1CQUFzQixDQUFVRixFQUFWLEVBQWNDLEVBQWQsRUFBa0JFLEVBQWxCLEVBQXNCO0FBQzlDLE1BQUlQLFFBQVEsSUFBWjtBQUNBLE1BQUlBLE1BQU1DLFlBQU4sQ0FBbUIzZCxNQUF2QixFQUErQjtBQUM3QixRQUFJNGQsV0FBV0YsTUFBTUMsWUFBTixDQUFtQnhXLEdBQW5CLEVBQWY7QUFDQXVXLFVBQU1sZSxJQUFOLENBQVdvZSxRQUFYLEVBQXFCRSxFQUFyQixFQUF5QkMsRUFBekIsRUFBNkJFLEVBQTdCO0FBQ0EsV0FBT0wsUUFBUDtBQUNELEdBSkQsTUFJTztBQUNMLFdBQU8sSUFBSUYsS0FBSixDQUFVSSxFQUFWLEVBQWNDLEVBQWQsRUFBa0JFLEVBQWxCLENBQVA7QUFDRDtBQUNGLENBVEQ7O0FBV0EsSUFBSTVGLHFCQUFxQixTQUFyQkEsa0JBQXFCLENBQVV5RixFQUFWLEVBQWNDLEVBQWQsRUFBa0JFLEVBQWxCLEVBQXNCQyxFQUF0QixFQUEwQjtBQUNqRCxNQUFJUixRQUFRLElBQVo7QUFDQSxNQUFJQSxNQUFNQyxZQUFOLENBQW1CM2QsTUFBdkIsRUFBK0I7QUFDN0IsUUFBSTRkLFdBQVdGLE1BQU1DLFlBQU4sQ0FBbUJ4VyxHQUFuQixFQUFmO0FBQ0F1VyxVQUFNbGUsSUFBTixDQUFXb2UsUUFBWCxFQUFxQkUsRUFBckIsRUFBeUJDLEVBQXpCLEVBQTZCRSxFQUE3QixFQUFpQ0MsRUFBakM7QUFDQSxXQUFPTixRQUFQO0FBQ0QsR0FKRCxNQUlPO0FBQ0wsV0FBTyxJQUFJRixLQUFKLENBQVVJLEVBQVYsRUFBY0MsRUFBZCxFQUFrQkUsRUFBbEIsRUFBc0JDLEVBQXRCLENBQVA7QUFDRDtBQUNGLENBVEQ7O0FBV0EsSUFBSUMsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBVVAsUUFBVixFQUFvQjtBQUN6QyxNQUFJRixRQUFRLElBQVo7QUFDQSxJQUFFRSxvQkFBb0JGLEtBQXRCLElBQStCL2UsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixnRUFBakIsQ0FBeEMsR0FBNkg0QixlQUFlLElBQWYsQ0FBNUosR0FBbUwsS0FBSyxDQUF4TDtBQUNBcVosV0FBUzFLLFVBQVQ7QUFDQSxNQUFJd0ssTUFBTUMsWUFBTixDQUFtQjNkLE1BQW5CLEdBQTRCMGQsTUFBTVUsUUFBdEMsRUFBZ0Q7QUFDOUNWLFVBQU1DLFlBQU4sQ0FBbUJoZCxJQUFuQixDQUF3QmlkLFFBQXhCO0FBQ0Q7QUFDRixDQVBEOztBQVNBLElBQUlTLG9CQUFvQixFQUF4QjtBQUNBLElBQUlDLGlCQUFpQmQsaUJBQXJCOztBQUVBOzs7Ozs7Ozs7QUFTQSxJQUFJakssZUFBZSxTQUFmQSxZQUFlLENBQVVnTCxlQUFWLEVBQTJCQyxNQUEzQixFQUFtQztBQUNwRDtBQUNBO0FBQ0EsTUFBSUMsV0FBV0YsZUFBZjtBQUNBRSxXQUFTZCxZQUFULEdBQXdCLEVBQXhCO0FBQ0FjLFdBQVM1TSxTQUFULEdBQXFCMk0sVUFBVUYsY0FBL0I7QUFDQSxNQUFJLENBQUNHLFNBQVNMLFFBQWQsRUFBd0I7QUFDdEJLLGFBQVNMLFFBQVQsR0FBb0JDLGlCQUFwQjtBQUNEO0FBQ0RJLFdBQVN0TCxPQUFULEdBQW1CZ0wsZ0JBQW5CO0FBQ0EsU0FBT00sUUFBUDtBQUNELENBWEQ7O0FBYUEsSUFBSW5OLGNBQWM7QUFDaEJpQyxnQkFBY0EsWUFERTtBQUVoQmlLLHFCQUFtQkEsaUJBRkg7QUFHaEJLLHFCQUFtQkEsaUJBSEg7QUFJaEJHLHVCQUFxQkEsbUJBSkw7QUFLaEIzRixzQkFBb0JBO0FBTEosQ0FBbEI7O0FBUUF6WixPQUFPQyxPQUFQLEdBQWlCeVMsV0FBakIsQzs7Ozs7Ozs7QUM5R0E7Ozs7Ozs7OztBQVNBOztBQUVBOzs7Ozs7O0FBT0EsSUFBSTlOLFVBQVUsbUJBQVcsQ0FBRSxDQUEzQjs7QUFFQSxJQUFJN0UsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNlLFlBQVUsaUJBQVNaLFNBQVQsRUFBb0JKLE1BQXBCLEVBQTRCakMsSUFBNUIsRUFBa0M7QUFDMUMsUUFBSUgsTUFBTUssVUFBVVQsTUFBcEI7QUFDQU8sV0FBTyxJQUFJQyxLQUFKLENBQVVKLE1BQU0sQ0FBTixHQUFVQSxNQUFNLENBQWhCLEdBQW9CLENBQTlCLENBQVA7QUFDQSxTQUFLLElBQUlpSixNQUFNLENBQWYsRUFBa0JBLE1BQU1qSixHQUF4QixFQUE2QmlKLEtBQTdCLEVBQW9DO0FBQ2xDOUksV0FBSzhJLE1BQU0sQ0FBWCxJQUFnQjVJLFVBQVU0SSxHQUFWLENBQWhCO0FBQ0Q7QUFDRCxRQUFJN0csV0FBV0UsU0FBZixFQUEwQjtBQUN4QixZQUFNLElBQUl6RCxLQUFKLENBQ0osOERBQ0Esa0JBRkksQ0FBTjtBQUlEOztBQUVELFFBQUl1RCxPQUFPeEMsTUFBUCxHQUFnQixFQUFoQixJQUF1QixVQUFELENBQWFtTCxJQUFiLENBQWtCM0ksTUFBbEIsQ0FBMUIsRUFBcUQ7QUFDbkQsWUFBTSxJQUFJdkQsS0FBSixDQUNKLGlFQUNBLHVEQURBLEdBQzBEdUQsTUFGdEQsQ0FBTjtBQUlEOztBQUVELFFBQUksQ0FBQ0ksU0FBTCxFQUFnQjtBQUNkLFVBQUlPLFdBQVcsQ0FBZjtBQUNBLFVBQUlTLFVBQVUsY0FDWnBCLE9BQU9ZLE9BQVAsQ0FBZSxLQUFmLEVBQXNCLFlBQVc7QUFDL0IsZUFBTzdDLEtBQUs0QyxVQUFMLENBQVA7QUFDRCxPQUZELENBREY7QUFJQSxVQUFJLE9BQU9VLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDbENBLGdCQUFRWCxLQUFSLENBQWNVLE9BQWQ7QUFDRDtBQUNELFVBQUk7QUFDRjtBQUNBO0FBQ0EsY0FBTSxJQUFJM0UsS0FBSixDQUFVMkUsT0FBVixDQUFOO0FBQ0QsT0FKRCxDQUlFLE9BQU1FLENBQU4sRUFBUyxDQUFFO0FBQ2Q7QUFDRixHQW5DRDtBQW9DRDs7QUFFRGxGLE9BQU9DLE9BQVAsR0FBaUIyRSxPQUFqQixDOzs7Ozs7OztBQzNEQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUk0TixVQUFVLG1CQUFBN04sQ0FBUSxFQUFSLENBQWQ7O0FBRUEsSUFBSW1iLG1CQUFtQixtQkFBQW5iLENBQVEsRUFBUixDQUF2QjtBQUNBLElBQUlvYixnQkFBZ0IsbUJBQUFwYixDQUFRLEdBQVIsQ0FBcEI7QUFDQSxJQUFJcWIsb0JBQW9CLG1CQUFBcmIsQ0FBUSxHQUFSLENBQXhCO0FBQ0EsSUFBSThZLGVBQWUsbUJBQUE5WSxDQUFRLEVBQVIsQ0FBbkI7QUFDQSxJQUFJc2IsaUJBQWlCLG1CQUFBdGIsQ0FBUSxHQUFSLENBQXJCO0FBQ0EsSUFBSXViLGVBQWUsbUJBQUF2YixDQUFRLEdBQVIsQ0FBbkI7O0FBRUEsSUFBSXdiLG1CQUFtQixtQkFBQXhiLENBQVEsR0FBUixDQUF2QjtBQUNBLElBQUl5YixZQUFZLG1CQUFBemIsQ0FBUSxHQUFSLENBQWhCOztBQUVBLElBQUlrRyxnQkFBZ0I0UyxhQUFhNVMsYUFBakM7QUFDQSxJQUFJdVQsZ0JBQWdCWCxhQUFhVyxhQUFqQztBQUNBLElBQUlPLGVBQWVsQixhQUFha0IsWUFBaEM7O0FBRUEsSUFBSTVlLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLE1BQUl3YyxxQkFBcUIsbUJBQUExYixDQUFRLEVBQVIsQ0FBekI7QUFDQSxNQUFJNFgsb0JBQW9CLG1CQUFBNVgsQ0FBUSxFQUFSLENBQXhCO0FBQ0EsTUFBSTJiLHdCQUF3QixtQkFBQTNiLENBQVEsRUFBUixDQUE1QjtBQUNBLE1BQUk0Yiw2QkFBNkIsS0FBakM7QUFDQTFWLGtCQUFnQnlWLHNCQUFzQnpWLGFBQXRDO0FBQ0F1VCxrQkFBZ0JrQyxzQkFBc0JsQyxhQUF0QztBQUNBTyxpQkFBZTJCLHNCQUFzQjNCLFlBQXJDO0FBQ0Q7O0FBRUQsSUFBSTZCLFdBQVdoTyxPQUFmO0FBQ0EsSUFBSWlPLGNBQWMscUJBQVVDLEtBQVYsRUFBaUI7QUFDakMsU0FBT0EsS0FBUDtBQUNELENBRkQ7O0FBSUEsSUFBSTNnQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJOGMsa0JBQWtCLEtBQXRCO0FBQ0EsTUFBSUMsdUJBQXVCLEtBQTNCO0FBQ0FKLGFBQVcsb0JBQVk7QUFDckJILHVCQUFtQk0sZUFBbkIsRUFBb0MsOERBQThELGlFQUE5RCxHQUFrSSxrRUFBbEksR0FBdU0sOERBQTNPO0FBQ0FBLHNCQUFrQixJQUFsQjtBQUNBLFdBQU9uTyxRQUFRclEsS0FBUixDQUFjLElBQWQsRUFBb0JOLFNBQXBCLENBQVA7QUFDRCxHQUpEOztBQU1BNGUsZ0JBQWMscUJBQVVDLEtBQVYsRUFBaUI7QUFDN0JMLHVCQUFtQk8sb0JBQW5CLEVBQXlDLDZEQUE2RCxzQ0FBN0QsR0FBc0csMkNBQXRHLEdBQW9KLG9FQUE3TDtBQUNBQSwyQkFBdUIsSUFBdkI7QUFDQSxXQUFPRixLQUFQO0FBQ0QsR0FKRDtBQUtEOztBQUVELElBQUlHLFFBQVE7QUFDVjs7QUFFQUMsWUFBVTtBQUNScFgsU0FBS3FXLGNBQWNyVyxHQURYO0FBRVJLLGFBQVNnVyxjQUFjaFcsT0FGZjtBQUdSZ1gsV0FBT2hCLGNBQWNnQixLQUhiO0FBSVJDLGFBQVNqQixjQUFjaUIsT0FKZjtBQUtSQyxVQUFNYjtBQUxFLEdBSEE7O0FBV1ZjLGFBQVdwQixpQkFBaUJvQixTQVhsQjtBQVlWQyxpQkFBZXJCLGlCQUFpQnFCLGFBWnRCOztBQWNWdFcsaUJBQWVBLGFBZEw7QUFlVjhULGdCQUFjQSxZQWZKO0FBZ0JWdk0sa0JBQWdCcUwsYUFBYXJMLGNBaEJuQjs7QUFrQlY7O0FBRUFnUCxhQUFXbkIsY0FwQkQ7QUFxQlZvQixlQUFhbEIsZ0JBckJIO0FBc0JWL0IsaUJBQWVBLGFBdEJMO0FBdUJWcUMsZUFBYUEsV0F2Qkg7O0FBeUJWO0FBQ0E7QUFDQWEsT0FBS3RCLGlCQTNCSzs7QUE2QlZ4ZCxXQUFTMGQsWUE3QkM7O0FBK0JWO0FBQ0FNLFlBQVVBO0FBaENBLENBQVo7O0FBbUNBLElBQUl6Z0IsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSTBkLHVCQUF1QixLQUEzQjtBQUNBLE1BQUloRixpQkFBSixFQUF1QjtBQUNyQjFULFdBQU9pUSxjQUFQLENBQXNCK0gsS0FBdEIsRUFBNkIsV0FBN0IsRUFBMEM7QUFDeEN0VCxXQUFLLGVBQVk7QUFDZjhTLDJCQUFtQkUsMEJBQW5CLEVBQStDLGtFQUFrRSx1Q0FBbEUsR0FBNEcsc0VBQTVHLEdBQXFMLDZEQUFyTCxHQUFxUCwrQkFBcFM7QUFDQUEscUNBQTZCLElBQTdCO0FBQ0EsZUFBT04sY0FBUDtBQUNEO0FBTHVDLEtBQTFDOztBQVFBcFgsV0FBT2lRLGNBQVAsQ0FBc0IrSCxLQUF0QixFQUE2QixhQUE3QixFQUE0QztBQUMxQ3RULFdBQUssZUFBWTtBQUNmOFMsMkJBQW1Ca0Isb0JBQW5CLEVBQXlDLG9FQUFvRSxzQ0FBcEUsR0FBNkcsMkRBQTdHLEdBQTJLLDBEQUEzSyxHQUF3Tyw4Q0FBeE8sR0FBeVIsb0RBQWxVO0FBQ0FBLCtCQUF1QixJQUF2QjtBQUNBLGVBQU9wQixnQkFBUDtBQUNEO0FBTHlDLEtBQTVDO0FBT0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0FVLFFBQU1TLEdBQU4sR0FBWSxFQUFaO0FBQ0EsTUFBSUUscUJBQXFCLEtBQXpCO0FBQ0EzWSxTQUFPb0IsSUFBUCxDQUFZK1YsaUJBQVosRUFBK0JqVyxPQUEvQixDQUF1QyxVQUFVc1UsT0FBVixFQUFtQjtBQUN4RHdDLFVBQU1TLEdBQU4sQ0FBVWpELE9BQVYsSUFBcUIsWUFBWTtBQUMvQixVQUFJLENBQUNtRCxrQkFBTCxFQUF5QjtBQUN2Qm5CLDJCQUFtQixLQUFuQixFQUEwQiwrREFBK0QseUNBQS9ELEdBQTJHLHVDQUEzRyxHQUFxSiw4Q0FBckosR0FBc00sdURBQWhPLEVBQXlSaEMsT0FBelI7QUFDQW1ELDZCQUFxQixJQUFyQjtBQUNEO0FBQ0QsYUFBT3hCLGtCQUFrQjNCLE9BQWxCLEVBQTJCbGMsS0FBM0IsQ0FBaUM2ZCxpQkFBakMsRUFBb0RuZSxTQUFwRCxDQUFQO0FBQ0QsS0FORDtBQU9ELEdBUkQ7QUFTRDs7QUFFRDdCLE9BQU9DLE9BQVAsR0FBaUI0Z0IsS0FBakIsQzs7Ozs7Ozs7QUNsSUE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7Ozs7OztBQU9BLFNBQVN2YixrQkFBVCxDQUE0QkMsSUFBNUIsRUFBa0M7QUFDaEMsTUFBSUMsV0FBVzNELFVBQVVULE1BQVYsR0FBbUIsQ0FBbEM7O0FBRUEsTUFBSTRELFVBQVUsMkJBQTJCTyxJQUEzQixHQUFrQyxVQUFsQyxHQUErQyxvRUFBL0MsR0FBc0hBLElBQXBJOztBQUVBLE9BQUssSUFBSUUsU0FBUyxDQUFsQixFQUFxQkEsU0FBU0QsUUFBOUIsRUFBd0NDLFFBQXhDLEVBQWtEO0FBQ2hEVCxlQUFXLGFBQWFVLG1CQUFtQjdELFVBQVU0RCxTQUFTLENBQW5CLENBQW5CLENBQXhCO0FBQ0Q7O0FBRURULGFBQVcsa0VBQWtFLG1EQUE3RTs7QUFFQSxNQUFJVixRQUFRLElBQUlqRSxLQUFKLENBQVUyRSxPQUFWLENBQVo7QUFDQVYsUUFBTWpCLElBQU4sR0FBYSxxQkFBYjtBQUNBaUIsUUFBTUcsV0FBTixHQUFvQixDQUFwQixDQWJnQyxDQWFUOztBQUV2QixRQUFNSCxLQUFOO0FBQ0Q7O0FBRUR0RSxPQUFPQyxPQUFQLEdBQWlCcUYsa0JBQWpCLEM7Ozs7Ozs7QUNyQ0E7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJbWMsV0FBVyxtQkFBQTljLENBQVEsR0FBUixDQUFmO0FBQ0EsSUFBSStjLHVCQUF1QixtQkFBQS9jLENBQVEsRUFBUixDQUEzQjs7QUFFQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQTs7OztBQUlBLFNBQVNnZCxVQUFULEdBQXNCO0FBQ3BCRixXQUFTRSxVQUFULENBQW9CLElBQXBCLEVBQTBCLEtBQUtqTSxlQUEvQjtBQUNEOztBQUVELElBQUk5QyxrQkFBa0I7QUFDcEI7Ozs7Ozs7Ozs7O0FBV0FnUCxrQkFBZ0Isd0JBQVVDLGdCQUFWLEVBQTRCMU0sV0FBNUIsRUFBeUMyTSxVQUF6QyxFQUFxREMsaUJBQXJELEVBQXdFekwsT0FBeEUsRUFBaUYwTCxhQUFqRixFQUFnRztBQUNoSDtBQUNFLFFBQUlqaUIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSWdlLGlCQUFpQnJSLFFBQWpCLEtBQThCLENBQWxDLEVBQXFDO0FBQ25Da1IsNkJBQXFCM1AsU0FBckIsQ0FBK0J6QyxzQkFBL0IsQ0FBc0R1UyxpQkFBaUJyUixRQUF2RSxFQUFpRnFSLGlCQUFpQm5NLGVBQWxHLEVBQW1Ic00sYUFBbkg7QUFDRDtBQUNGO0FBQ0QsUUFBSUMsU0FBU0osaUJBQWlCRCxjQUFqQixDQUFnQ3pNLFdBQWhDLEVBQTZDMk0sVUFBN0MsRUFBeURDLGlCQUF6RCxFQUE0RXpMLE9BQTVFLEVBQXFGMEwsYUFBckYsQ0FBYjtBQUNBLFFBQUlILGlCQUFpQm5NLGVBQWpCLElBQW9DbU0saUJBQWlCbk0sZUFBakIsQ0FBaUMrRyxHQUFqQyxJQUF3QyxJQUFoRixFQUFzRjtBQUNwRnRILGtCQUFZK00sa0JBQVosR0FBaUNsTSxPQUFqQyxDQUF5QzJMLFVBQXpDLEVBQXFERSxnQkFBckQ7QUFDRDtBQUNELFFBQUk5aEIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSWdlLGlCQUFpQnJSLFFBQWpCLEtBQThCLENBQWxDLEVBQXFDO0FBQ25Da1IsNkJBQXFCM1AsU0FBckIsQ0FBK0JyQyxnQkFBL0IsQ0FBZ0RtUyxpQkFBaUJyUixRQUFqRTtBQUNEO0FBQ0Y7QUFDRCxXQUFPeVIsTUFBUDtBQUNELEdBN0JtQjs7QUErQnBCOzs7O0FBSUFFLGVBQWEscUJBQVVOLGdCQUFWLEVBQTRCO0FBQ3ZDLFdBQU9BLGlCQUFpQk0sV0FBakIsRUFBUDtBQUNELEdBckNtQjs7QUF1Q3BCOzs7Ozs7QUFNQUMsb0JBQWtCLDBCQUFVUCxnQkFBVixFQUE0QlEsTUFBNUIsRUFBb0M7QUFDcEQsUUFBSXRpQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJZ2UsaUJBQWlCclIsUUFBakIsS0FBOEIsQ0FBbEMsRUFBcUM7QUFDbkNrUiw2QkFBcUIzUCxTQUFyQixDQUErQnVRLHdCQUEvQixDQUF3RFQsaUJBQWlCclIsUUFBekU7QUFDRDtBQUNGO0FBQ0RpUixhQUFTYyxVQUFULENBQW9CVixnQkFBcEIsRUFBc0NBLGlCQUFpQm5NLGVBQXZEO0FBQ0FtTSxxQkFBaUJPLGdCQUFqQixDQUFrQ0MsTUFBbEM7QUFDQSxRQUFJdGlCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUlnZSxpQkFBaUJyUixRQUFqQixLQUE4QixDQUFsQyxFQUFxQztBQUNuQ2tSLDZCQUFxQjNQLFNBQXJCLENBQStCbEMsa0JBQS9CLENBQWtEZ1MsaUJBQWlCclIsUUFBbkU7QUFDRDtBQUNGO0FBQ0YsR0ExRG1COztBQTREcEI7Ozs7Ozs7OztBQVNBZ1Msb0JBQWtCLDBCQUFVWCxnQkFBVixFQUE0QlksV0FBNUIsRUFBeUN0TixXQUF6QyxFQUFzRG1CLE9BQXRELEVBQStEO0FBQy9FLFFBQUlvTSxjQUFjYixpQkFBaUJuTSxlQUFuQzs7QUFFQSxRQUFJK00sZ0JBQWdCQyxXQUFoQixJQUErQnBNLFlBQVl1TCxpQkFBaUJjLFFBQWhFLEVBQTBFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNEOztBQUVELFFBQUk1aUIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSWdlLGlCQUFpQnJSLFFBQWpCLEtBQThCLENBQWxDLEVBQXFDO0FBQ25Da1IsNkJBQXFCM1AsU0FBckIsQ0FBK0J0Qyx1QkFBL0IsQ0FBdURvUyxpQkFBaUJyUixRQUF4RSxFQUFrRmlTLFdBQWxGO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJRyxjQUFjbkIsU0FBU29CLGdCQUFULENBQTBCSCxXQUExQixFQUF1Q0QsV0FBdkMsQ0FBbEI7O0FBRUEsUUFBSUcsV0FBSixFQUFpQjtBQUNmbkIsZUFBU2MsVUFBVCxDQUFvQlYsZ0JBQXBCLEVBQXNDYSxXQUF0QztBQUNEOztBQUVEYixxQkFBaUJXLGdCQUFqQixDQUFrQ0MsV0FBbEMsRUFBK0N0TixXQUEvQyxFQUE0RG1CLE9BQTVEOztBQUVBLFFBQUlzTSxlQUFlZixpQkFBaUJuTSxlQUFoQyxJQUFtRG1NLGlCQUFpQm5NLGVBQWpCLENBQWlDK0csR0FBakMsSUFBd0MsSUFBL0YsRUFBcUc7QUFDbkd0SCxrQkFBWStNLGtCQUFaLEdBQWlDbE0sT0FBakMsQ0FBeUMyTCxVQUF6QyxFQUFxREUsZ0JBQXJEO0FBQ0Q7O0FBRUQsUUFBSTloQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJZ2UsaUJBQWlCclIsUUFBakIsS0FBOEIsQ0FBbEMsRUFBcUM7QUFDbkNrUiw2QkFBcUIzUCxTQUFyQixDQUErQm5DLGlCQUEvQixDQUFpRGlTLGlCQUFpQnJSLFFBQWxFO0FBQ0Q7QUFDRjtBQUNGLEdBN0dtQjs7QUErR3BCOzs7Ozs7O0FBT0FxRiw0QkFBMEIsa0NBQVVnTSxnQkFBVixFQUE0QjFNLFdBQTVCLEVBQXlDcEMsaUJBQXpDLEVBQTREO0FBQ3BGLFFBQUk4TyxpQkFBaUJ6TCxrQkFBakIsS0FBd0NyRCxpQkFBNUMsRUFBK0Q7QUFDN0Q7QUFDQTtBQUNBaFQsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVFpZCxpQkFBaUJ6TCxrQkFBakIsSUFBdUMsSUFBdkMsSUFBK0N5TCxpQkFBaUJ6TCxrQkFBakIsS0FBd0NyRCxvQkFBb0IsQ0FBbkgsRUFBc0gsb0VBQW9FLGFBQTFMLEVBQXlNQSxpQkFBek0sRUFBNE44TyxpQkFBaUJ6TCxrQkFBN08sQ0FBeEMsR0FBMlMsS0FBSyxDQUFoVDtBQUNBO0FBQ0Q7QUFDRCxRQUFJclcsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSWdlLGlCQUFpQnJSLFFBQWpCLEtBQThCLENBQWxDLEVBQXFDO0FBQ25Da1IsNkJBQXFCM1AsU0FBckIsQ0FBK0J0Qyx1QkFBL0IsQ0FBdURvUyxpQkFBaUJyUixRQUF4RSxFQUFrRnFSLGlCQUFpQm5NLGVBQW5HO0FBQ0Q7QUFDRjtBQUNEbU0scUJBQWlCaE0sd0JBQWpCLENBQTBDVixXQUExQztBQUNBLFFBQUlwVixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJZ2UsaUJBQWlCclIsUUFBakIsS0FBOEIsQ0FBbEMsRUFBcUM7QUFDbkNrUiw2QkFBcUIzUCxTQUFyQixDQUErQm5DLGlCQUEvQixDQUFpRGlTLGlCQUFpQnJSLFFBQWxFO0FBQ0Q7QUFDRjtBQUNGO0FBeEltQixDQUF0Qjs7QUEySUF4USxPQUFPQyxPQUFQLEdBQWlCMlMsZUFBakIsQzs7Ozs7Ozs7QUNwS0E7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJa1EsZ0JBQWdCLG1CQUFBbmUsQ0FBUSxFQUFSLENBQXBCO0FBQ0EsSUFBSW9lLGVBQWUsbUJBQUFwZSxDQUFRLEVBQVIsQ0FBbkI7O0FBRUEsSUFBSXFlLHFDQUFxQyxtQkFBQXJlLENBQVEsRUFBUixDQUF6QztBQUNBLElBQUlzZSxpQkFBaUIsbUJBQUF0ZSxDQUFRLEVBQVIsQ0FBckI7O0FBRUEsSUFBSXVlLG9CQUFvQixDQUF4QjtBQUNBLElBQUlDLDhCQUE4QixFQUFsQzs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxJQUFJQyxhQUFhLE9BQU94WSxRQUFQLEtBQW9CLFdBQXBCLElBQW1DLE9BQU9BLFNBQVN5WSxZQUFoQixLQUFpQyxRQUFwRSxJQUFnRixPQUFPQyxTQUFQLEtBQXFCLFdBQXJCLElBQW9DLE9BQU9BLFVBQVVDLFNBQWpCLEtBQStCLFFBQW5FLElBQStFLGFBQWFoWCxJQUFiLENBQWtCK1csVUFBVUMsU0FBNUIsQ0FBaEw7O0FBRUEsU0FBU0Msa0JBQVQsQ0FBNEJDLElBQTVCLEVBQWtDO0FBQ2hDLE1BQUksQ0FBQ0wsVUFBTCxFQUFpQjtBQUNmO0FBQ0Q7QUFDRCxNQUFJN2MsT0FBT2tkLEtBQUtsZCxJQUFoQjtBQUNBLE1BQUlrQixXQUFXZ2MsS0FBS2hjLFFBQXBCO0FBQ0EsTUFBSUEsU0FBU3JHLE1BQWIsRUFBcUI7QUFDbkIsU0FBSyxJQUFJVSxJQUFJLENBQWIsRUFBZ0JBLElBQUkyRixTQUFTckcsTUFBN0IsRUFBcUNVLEdBQXJDLEVBQTBDO0FBQ3hDNGhCLHVCQUFpQm5kLElBQWpCLEVBQXVCa0IsU0FBUzNGLENBQVQsQ0FBdkIsRUFBb0MsSUFBcEM7QUFDRDtBQUNGLEdBSkQsTUFJTyxJQUFJMmhCLEtBQUtFLElBQUwsSUFBYSxJQUFqQixFQUF1QjtBQUM1QlosaUJBQWF4YyxJQUFiLEVBQW1Ca2QsS0FBS0UsSUFBeEI7QUFDRCxHQUZNLE1BRUEsSUFBSUYsS0FBS2xVLElBQUwsSUFBYSxJQUFqQixFQUF1QjtBQUM1QjBULG1CQUFlMWMsSUFBZixFQUFxQmtkLEtBQUtsVSxJQUExQjtBQUNEO0FBQ0Y7O0FBRUQsSUFBSW1VLG1CQUFtQlYsbUNBQW1DLFVBQVUzYSxVQUFWLEVBQXNCb2IsSUFBdEIsRUFBNEJHLGFBQTVCLEVBQTJDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlILEtBQUtsZCxJQUFMLENBQVVFLFFBQVYsS0FBdUIwYywyQkFBdkIsSUFBc0RNLEtBQUtsZCxJQUFMLENBQVVFLFFBQVYsS0FBdUJ5YyxpQkFBdkIsSUFBNENPLEtBQUtsZCxJQUFMLENBQVVzZCxRQUFWLENBQW1CeEksV0FBbkIsT0FBcUMsUUFBakYsS0FBOEZvSSxLQUFLbGQsSUFBTCxDQUFVdWQsWUFBVixJQUEwQixJQUExQixJQUFrQ0wsS0FBS2xkLElBQUwsQ0FBVXVkLFlBQVYsS0FBMkJoQixjQUFjYSxJQUF6SyxDQUExRCxFQUEwTztBQUN4T0gsdUJBQW1CQyxJQUFuQjtBQUNBcGIsZUFBVzBiLFlBQVgsQ0FBd0JOLEtBQUtsZCxJQUE3QixFQUFtQ3FkLGFBQW5DO0FBQ0QsR0FIRCxNQUdPO0FBQ0x2YixlQUFXMGIsWUFBWCxDQUF3Qk4sS0FBS2xkLElBQTdCLEVBQW1DcWQsYUFBbkM7QUFDQUosdUJBQW1CQyxJQUFuQjtBQUNEO0FBQ0YsQ0Fkc0IsQ0FBdkI7O0FBZ0JBLFNBQVNPLG9CQUFULENBQThCQyxPQUE5QixFQUF1Q0MsT0FBdkMsRUFBZ0Q7QUFDOUNELFVBQVE1YixVQUFSLENBQW1COGIsWUFBbkIsQ0FBZ0NELFFBQVEzZCxJQUF4QyxFQUE4QzBkLE9BQTlDO0FBQ0FULHFCQUFtQlUsT0FBbkI7QUFDRDs7QUFFRCxTQUFTRSxVQUFULENBQW9CQyxVQUFwQixFQUFnQ0MsU0FBaEMsRUFBMkM7QUFDekMsTUFBSWxCLFVBQUosRUFBZ0I7QUFDZGlCLGVBQVc1YyxRQUFYLENBQW9CMUYsSUFBcEIsQ0FBeUJ1aUIsU0FBekI7QUFDRCxHQUZELE1BRU87QUFDTEQsZUFBVzlkLElBQVgsQ0FBZ0JnZSxXQUFoQixDQUE0QkQsVUFBVS9kLElBQXRDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTaWUsU0FBVCxDQUFtQmYsSUFBbkIsRUFBeUJFLElBQXpCLEVBQStCO0FBQzdCLE1BQUlQLFVBQUosRUFBZ0I7QUFDZEssU0FBS0UsSUFBTCxHQUFZQSxJQUFaO0FBQ0QsR0FGRCxNQUVPO0FBQ0xaLGlCQUFhVSxLQUFLbGQsSUFBbEIsRUFBd0JvZCxJQUF4QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU2MsU0FBVCxDQUFtQmhCLElBQW5CLEVBQXlCbFUsSUFBekIsRUFBK0I7QUFDN0IsTUFBSTZULFVBQUosRUFBZ0I7QUFDZEssU0FBS2xVLElBQUwsR0FBWUEsSUFBWjtBQUNELEdBRkQsTUFFTztBQUNMMFQsbUJBQWVRLEtBQUtsZCxJQUFwQixFQUEwQmdKLElBQTFCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTbkosUUFBVCxHQUFvQjtBQUNsQixTQUFPLEtBQUtHLElBQUwsQ0FBVXNkLFFBQWpCO0FBQ0Q7O0FBRUQsU0FBU2EsV0FBVCxDQUFxQm5lLElBQXJCLEVBQTJCO0FBQ3pCLFNBQU87QUFDTEEsVUFBTUEsSUFERDtBQUVMa0IsY0FBVSxFQUZMO0FBR0xrYyxVQUFNLElBSEQ7QUFJTHBVLFVBQU0sSUFKRDtBQUtMbkosY0FBVUE7QUFMTCxHQUFQO0FBT0Q7O0FBRURzZSxZQUFZaEIsZ0JBQVosR0FBK0JBLGdCQUEvQjtBQUNBZ0IsWUFBWVYsb0JBQVosR0FBbUNBLG9CQUFuQztBQUNBVSxZQUFZTixVQUFaLEdBQXlCQSxVQUF6QjtBQUNBTSxZQUFZRixTQUFaLEdBQXdCQSxTQUF4QjtBQUNBRSxZQUFZRCxTQUFaLEdBQXdCQSxTQUF4Qjs7QUFFQXprQixPQUFPQyxPQUFQLEdBQWlCeWtCLFdBQWpCLEM7Ozs7Ozs7QUNwSEE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJQyxpQkFBaUIsbUJBQUFoZ0IsQ0FBUSxFQUFSLENBQXJCO0FBQ0EsSUFBSWlnQixtQkFBbUIsbUJBQUFqZ0IsQ0FBUSxFQUFSLENBQXZCOztBQUVBLElBQUlrZ0IsaUJBQWlCLG1CQUFBbGdCLENBQVEsRUFBUixDQUFyQjtBQUNBLElBQUltZ0IscUJBQXFCLG1CQUFBbmdCLENBQVEsRUFBUixDQUF6QjtBQUNBLElBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUlvZ0IsY0FBY0osZUFBZUksV0FBakM7O0FBRUE7Ozs7QUFJQSxTQUFTQyxlQUFULENBQXlCOWQsSUFBekIsRUFBK0JxUSxLQUEvQixFQUFzQzBOLGdCQUF0QyxFQUF3RDtBQUN0RCxNQUFJQyxtQkFBbUIzTixNQUFNTSxjQUFOLENBQXFCc04sdUJBQXJCLENBQTZDRixnQkFBN0MsQ0FBdkI7QUFDQSxTQUFPRixZQUFZN2QsSUFBWixFQUFrQmdlLGdCQUFsQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVNFLCtCQUFULENBQXlDbGUsSUFBekMsRUFBK0NtZSxLQUEvQyxFQUFzRDlOLEtBQXRELEVBQTZEO0FBQzNELE1BQUl4WCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzlELFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRc0MsSUFBUixFQUFjLG1DQUFkLENBQXhDLEdBQTZGLEtBQUssQ0FBbEc7QUFDRDtBQUNELE1BQUlvZSxXQUFXTixnQkFBZ0I5ZCxJQUFoQixFQUFzQnFRLEtBQXRCLEVBQTZCOE4sS0FBN0IsQ0FBZjtBQUNBLE1BQUlDLFFBQUosRUFBYztBQUNaL04sVUFBTWdPLGtCQUFOLEdBQTJCVixlQUFldE4sTUFBTWdPLGtCQUFyQixFQUF5Q0QsUUFBekMsQ0FBM0I7QUFDQS9OLFVBQU1pTyxrQkFBTixHQUEyQlgsZUFBZXROLE1BQU1pTyxrQkFBckIsRUFBeUN0ZSxJQUF6QyxDQUEzQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTdWUsa0NBQVQsQ0FBNENsTyxLQUE1QyxFQUFtRDtBQUNqRCxNQUFJQSxTQUFTQSxNQUFNTSxjQUFOLENBQXFCc04sdUJBQWxDLEVBQTJEO0FBQ3pEUCxxQkFBaUJjLGdCQUFqQixDQUFrQ25PLE1BQU1ZLFdBQXhDLEVBQXFEaU4sK0JBQXJELEVBQXNGN04sS0FBdEY7QUFDRDtBQUNGOztBQUVEOzs7QUFHQSxTQUFTb08sNENBQVQsQ0FBc0RwTyxLQUF0RCxFQUE2RDtBQUMzRCxNQUFJQSxTQUFTQSxNQUFNTSxjQUFOLENBQXFCc04sdUJBQWxDLEVBQTJEO0FBQ3pELFFBQUlyTixhQUFhUCxNQUFNWSxXQUF2QjtBQUNBLFFBQUl5TixhQUFhOU4sYUFBYThNLGlCQUFpQmlCLGlCQUFqQixDQUFtQy9OLFVBQW5DLENBQWIsR0FBOEQsSUFBL0U7QUFDQThNLHFCQUFpQmMsZ0JBQWpCLENBQWtDRSxVQUFsQyxFQUE4Q1IsK0JBQTlDLEVBQStFN04sS0FBL0U7QUFDRDtBQUNGOztBQUVEOzs7OztBQUtBLFNBQVN1TyxvQkFBVCxDQUE4QjVlLElBQTlCLEVBQW9DNmUsZ0JBQXBDLEVBQXNEeE8sS0FBdEQsRUFBNkQ7QUFDM0QsTUFBSUEsU0FBU0EsTUFBTU0sY0FBTixDQUFxQnFOLGdCQUFsQyxFQUFvRDtBQUNsRCxRQUFJQSxtQkFBbUIzTixNQUFNTSxjQUFOLENBQXFCcU4sZ0JBQTVDO0FBQ0EsUUFBSUksV0FBV1AsWUFBWTdkLElBQVosRUFBa0JnZSxnQkFBbEIsQ0FBZjtBQUNBLFFBQUlJLFFBQUosRUFBYztBQUNaL04sWUFBTWdPLGtCQUFOLEdBQTJCVixlQUFldE4sTUFBTWdPLGtCQUFyQixFQUF5Q0QsUUFBekMsQ0FBM0I7QUFDQS9OLFlBQU1pTyxrQkFBTixHQUEyQlgsZUFBZXROLE1BQU1pTyxrQkFBckIsRUFBeUN0ZSxJQUF6QyxDQUEzQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7QUFLQSxTQUFTOGUsZ0NBQVQsQ0FBMEN6TyxLQUExQyxFQUFpRDtBQUMvQyxNQUFJQSxTQUFTQSxNQUFNTSxjQUFOLENBQXFCcU4sZ0JBQWxDLEVBQW9EO0FBQ2xEWSx5QkFBcUJ2TyxNQUFNWSxXQUEzQixFQUF3QyxJQUF4QyxFQUE4Q1osS0FBOUM7QUFDRDtBQUNGOztBQUVELFNBQVMwTyw0QkFBVCxDQUFzQ0MsTUFBdEMsRUFBOEM7QUFDNUNwQixxQkFBbUJvQixNQUFuQixFQUEyQlQsa0NBQTNCO0FBQ0Q7O0FBRUQsU0FBU1Usc0NBQVQsQ0FBZ0RELE1BQWhELEVBQXdEO0FBQ3REcEIscUJBQW1Cb0IsTUFBbkIsRUFBMkJQLDRDQUEzQjtBQUNEOztBQUVELFNBQVNTLDhCQUFULENBQXdDQyxLQUF4QyxFQUErQ0MsS0FBL0MsRUFBc0RqYyxJQUF0RCxFQUE0REMsRUFBNUQsRUFBZ0U7QUFDOURzYSxtQkFBaUIyQixrQkFBakIsQ0FBb0NsYyxJQUFwQyxFQUEwQ0MsRUFBMUMsRUFBOEN3YixvQkFBOUMsRUFBb0VPLEtBQXBFLEVBQTJFQyxLQUEzRTtBQUNEOztBQUVELFNBQVNFLDBCQUFULENBQW9DTixNQUFwQyxFQUE0QztBQUMxQ3BCLHFCQUFtQm9CLE1BQW5CLEVBQTJCRixnQ0FBM0I7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7QUFXQSxJQUFJUyxtQkFBbUI7QUFDckJSLGdDQUE4QkEsNEJBRFQ7QUFFckJFLDBDQUF3Q0Esc0NBRm5CO0FBR3JCSyw4QkFBNEJBLDBCQUhQO0FBSXJCSixrQ0FBZ0NBO0FBSlgsQ0FBdkI7O0FBT0FwbUIsT0FBT0MsT0FBUCxHQUFpQndtQixnQkFBakIsQzs7Ozs7Ozs7QUNwSUE7Ozs7Ozs7Ozs7QUFVQTs7OztBQUVBLElBQUk5Z0IsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCOztBQUVBLElBQUkraEIsc0JBQXNCLG1CQUFBL2hCLENBQVEsRUFBUixDQUExQjtBQUNBLElBQUlpZ0IsbUJBQW1CLG1CQUFBamdCLENBQVEsRUFBUixDQUF2QjtBQUNBLElBQUlnaUIsa0JBQWtCLG1CQUFBaGlCLENBQVEsRUFBUixDQUF0Qjs7QUFFQSxJQUFJa2dCLGlCQUFpQixtQkFBQWxnQixDQUFRLEVBQVIsQ0FBckI7QUFDQSxJQUFJbWdCLHFCQUFxQixtQkFBQW5nQixDQUFRLEVBQVIsQ0FBekI7QUFDQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7O0FBRUE7OztBQUdBLElBQUlpaUIsZUFBZSxFQUFuQjs7QUFFQTs7OztBQUlBLElBQUlDLGFBQWEsSUFBakI7O0FBRUE7Ozs7Ozs7QUFPQSxJQUFJQyw4QkFBOEIsU0FBOUJBLDJCQUE4QixDQUFVdlAsS0FBVixFQUFpQndQLFNBQWpCLEVBQTRCO0FBQzVELE1BQUl4UCxLQUFKLEVBQVc7QUFDVHFOLHFCQUFpQm9DLHdCQUFqQixDQUEwQ3pQLEtBQTFDLEVBQWlEd1AsU0FBakQ7O0FBRUEsUUFBSSxDQUFDeFAsTUFBTXNCLFlBQU4sRUFBTCxFQUEyQjtBQUN6QnRCLFlBQU1jLFdBQU4sQ0FBa0I5RCxPQUFsQixDQUEwQmdELEtBQTFCO0FBQ0Q7QUFDRjtBQUNGLENBUkQ7QUFTQSxJQUFJMFAsdUNBQXVDLFNBQXZDQSxvQ0FBdUMsQ0FBVXptQixDQUFWLEVBQWE7QUFDdEQsU0FBT3NtQiw0QkFBNEJ0bUIsQ0FBNUIsRUFBK0IsSUFBL0IsQ0FBUDtBQUNELENBRkQ7QUFHQSxJQUFJMG1CLHNDQUFzQyxTQUF0Q0EsbUNBQXNDLENBQVUxbUIsQ0FBVixFQUFhO0FBQ3JELFNBQU9zbUIsNEJBQTRCdG1CLENBQTVCLEVBQStCLEtBQS9CLENBQVA7QUFDRCxDQUZEOztBQUlBLElBQUkybUIsbUJBQW1CLFNBQW5CQSxnQkFBbUIsQ0FBVWpnQixJQUFWLEVBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxTQUFPLE1BQU1BLEtBQUtrZ0IsV0FBbEI7QUFDRCxDQUpEOztBQU1BLFNBQVNDLGFBQVQsQ0FBdUJDLEdBQXZCLEVBQTRCO0FBQzFCLFNBQU9BLFFBQVEsUUFBUixJQUFvQkEsUUFBUSxPQUE1QixJQUF1Q0EsUUFBUSxRQUEvQyxJQUEyREEsUUFBUSxVQUExRTtBQUNEOztBQUVELFNBQVNDLHVCQUFULENBQWlDbGtCLElBQWpDLEVBQXVDbUwsSUFBdkMsRUFBNkM2TyxLQUE3QyxFQUFvRDtBQUNsRCxVQUFRaGEsSUFBUjtBQUNFLFNBQUssU0FBTDtBQUNBLFNBQUssZ0JBQUw7QUFDQSxTQUFLLGVBQUw7QUFDQSxTQUFLLHNCQUFMO0FBQ0EsU0FBSyxhQUFMO0FBQ0EsU0FBSyxvQkFBTDtBQUNBLFNBQUssYUFBTDtBQUNBLFNBQUssb0JBQUw7QUFDQSxTQUFLLFdBQUw7QUFDQSxTQUFLLGtCQUFMO0FBQ0UsYUFBTyxDQUFDLEVBQUVnYSxNQUFNbUssUUFBTixJQUFrQkgsY0FBYzdZLElBQWQsQ0FBcEIsQ0FBUjtBQUNGO0FBQ0UsYUFBTyxLQUFQO0FBYko7QUFlRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQSxJQUFJbVcsaUJBQWlCO0FBQ25COzs7QUFHQS9OLGFBQVc7QUFDVDs7OztBQUlBNlEsNEJBQXdCZixvQkFBb0JlLHNCQUxuQzs7QUFPVDs7O0FBR0FDLDhCQUEwQmhCLG9CQUFvQmdCO0FBVnJDLEdBSlE7O0FBaUJuQjs7Ozs7OztBQU9BQyxlQUFhLHFCQUFVemdCLElBQVYsRUFBZ0JnZSxnQkFBaEIsRUFBa0NJLFFBQWxDLEVBQTRDO0FBQ3ZELE1BQUUsT0FBT0EsUUFBUCxLQUFvQixVQUF0QixJQUFvQ3ZsQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLDREQUFqQixFQUErRW1oQixnQkFBL0UsU0FBd0dJLFFBQXhHLHlDQUF3R0EsUUFBeEcsRUFBeEMsR0FBNEozZixlQUFlLElBQWYsRUFBcUJ1ZixnQkFBckIsU0FBOENJLFFBQTlDLHlDQUE4Q0EsUUFBOUMsRUFBaE0sR0FBMFAsS0FBSyxDQUEvUDs7QUFFQSxRQUFJN2EsTUFBTTBjLGlCQUFpQmpnQixJQUFqQixDQUFWO0FBQ0EsUUFBSTBnQiwwQkFBMEJoQixhQUFhMUIsZ0JBQWIsTUFBbUMwQixhQUFhMUIsZ0JBQWIsSUFBaUMsRUFBcEUsQ0FBOUI7QUFDQTBDLDRCQUF3Qm5kLEdBQXhCLElBQStCNmEsUUFBL0I7O0FBRUEsUUFBSXVDLGVBQWVuQixvQkFBb0JvQix1QkFBcEIsQ0FBNEM1QyxnQkFBNUMsQ0FBbkI7QUFDQSxRQUFJMkMsZ0JBQWdCQSxhQUFhRSxjQUFqQyxFQUFpRDtBQUMvQ0YsbUJBQWFFLGNBQWIsQ0FBNEI3Z0IsSUFBNUIsRUFBa0NnZSxnQkFBbEMsRUFBb0RJLFFBQXBEO0FBQ0Q7QUFDRixHQW5Da0I7O0FBcUNuQjs7Ozs7QUFLQVAsZUFBYSxxQkFBVTdkLElBQVYsRUFBZ0JnZSxnQkFBaEIsRUFBa0M7QUFDN0M7QUFDQTtBQUNBLFFBQUkwQywwQkFBMEJoQixhQUFhMUIsZ0JBQWIsQ0FBOUI7QUFDQSxRQUFJcUMsd0JBQXdCckMsZ0JBQXhCLEVBQTBDaGUsS0FBS3dPLGVBQUwsQ0FBcUJsSCxJQUEvRCxFQUFxRXRILEtBQUt3TyxlQUFMLENBQXFCMkgsS0FBMUYsQ0FBSixFQUFzRztBQUNwRyxhQUFPLElBQVA7QUFDRDtBQUNELFFBQUk1UyxNQUFNMGMsaUJBQWlCamdCLElBQWpCLENBQVY7QUFDQSxXQUFPMGdCLDJCQUEyQkEsd0JBQXdCbmQsR0FBeEIsQ0FBbEM7QUFDRCxHQW5Ea0I7O0FBcURuQjs7Ozs7O0FBTUF1ZCxrQkFBZ0Isd0JBQVU5Z0IsSUFBVixFQUFnQmdlLGdCQUFoQixFQUFrQztBQUNoRCxRQUFJMkMsZUFBZW5CLG9CQUFvQm9CLHVCQUFwQixDQUE0QzVDLGdCQUE1QyxDQUFuQjtBQUNBLFFBQUkyQyxnQkFBZ0JBLGFBQWFJLGtCQUFqQyxFQUFxRDtBQUNuREosbUJBQWFJLGtCQUFiLENBQWdDL2dCLElBQWhDLEVBQXNDZ2UsZ0JBQXRDO0FBQ0Q7O0FBRUQsUUFBSTBDLDBCQUEwQmhCLGFBQWExQixnQkFBYixDQUE5QjtBQUNBO0FBQ0EsUUFBSTBDLHVCQUFKLEVBQTZCO0FBQzNCLFVBQUluZCxNQUFNMGMsaUJBQWlCamdCLElBQWpCLENBQVY7QUFDQSxhQUFPMGdCLHdCQUF3Qm5kLEdBQXhCLENBQVA7QUFDRDtBQUNGLEdBdkVrQjs7QUF5RW5COzs7OztBQUtBeWQsc0JBQW9CLDRCQUFVaGhCLElBQVYsRUFBZ0I7QUFDbEMsUUFBSXVELE1BQU0wYyxpQkFBaUJqZ0IsSUFBakIsQ0FBVjtBQUNBLFNBQUssSUFBSWdlLGdCQUFULElBQTZCMEIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSSxDQUFDQSxhQUFhOWUsY0FBYixDQUE0Qm9kLGdCQUE1QixDQUFMLEVBQW9EO0FBQ2xEO0FBQ0Q7O0FBRUQsVUFBSSxDQUFDMEIsYUFBYTFCLGdCQUFiLEVBQStCemEsR0FBL0IsQ0FBTCxFQUEwQztBQUN4QztBQUNEOztBQUVELFVBQUlvZCxlQUFlbkIsb0JBQW9Cb0IsdUJBQXBCLENBQTRDNUMsZ0JBQTVDLENBQW5CO0FBQ0EsVUFBSTJDLGdCQUFnQkEsYUFBYUksa0JBQWpDLEVBQXFEO0FBQ25ESixxQkFBYUksa0JBQWIsQ0FBZ0MvZ0IsSUFBaEMsRUFBc0NnZSxnQkFBdEM7QUFDRDs7QUFFRCxhQUFPMEIsYUFBYTFCLGdCQUFiLEVBQStCemEsR0FBL0IsQ0FBUDtBQUNEO0FBQ0YsR0FoR2tCOztBQWtHbkI7Ozs7Ozs7QUFPQTBkLGlCQUFlLHVCQUFVQyxZQUFWLEVBQXdCdFEsVUFBeEIsRUFBb0NDLFdBQXBDLEVBQWlEQyxpQkFBakQsRUFBb0U7QUFDakYsUUFBSWtPLE1BQUo7QUFDQSxRQUFJbUMsVUFBVTNCLG9CQUFvQjJCLE9BQWxDO0FBQ0EsU0FBSyxJQUFJdm1CLElBQUksQ0FBYixFQUFnQkEsSUFBSXVtQixRQUFRam5CLE1BQTVCLEVBQW9DVSxHQUFwQyxFQUF5QztBQUN2QztBQUNBLFVBQUl3bUIsaUJBQWlCRCxRQUFRdm1CLENBQVIsQ0FBckI7QUFDQSxVQUFJd21CLGNBQUosRUFBb0I7QUFDbEIsWUFBSUMsa0JBQWtCRCxlQUFlSCxhQUFmLENBQTZCQyxZQUE3QixFQUEyQ3RRLFVBQTNDLEVBQXVEQyxXQUF2RCxFQUFvRUMsaUJBQXBFLENBQXRCO0FBQ0EsWUFBSXVRLGVBQUosRUFBcUI7QUFDbkJyQyxtQkFBU3JCLGVBQWVxQixNQUFmLEVBQXVCcUMsZUFBdkIsQ0FBVDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFdBQU9yQyxNQUFQO0FBQ0QsR0F2SGtCOztBQXlIbkI7Ozs7Ozs7QUFPQXNDLGlCQUFlLHVCQUFVdEMsTUFBVixFQUFrQjtBQUMvQixRQUFJQSxNQUFKLEVBQVk7QUFDVlcsbUJBQWFoQyxlQUFlZ0MsVUFBZixFQUEyQlgsTUFBM0IsQ0FBYjtBQUNEO0FBQ0YsR0FwSWtCOztBQXNJbkI7Ozs7O0FBS0F1QyxxQkFBbUIsMkJBQVUxQixTQUFWLEVBQXFCO0FBQ3RDO0FBQ0E7QUFDQSxRQUFJMkIsdUJBQXVCN0IsVUFBM0I7QUFDQUEsaUJBQWEsSUFBYjtBQUNBLFFBQUlFLFNBQUosRUFBZTtBQUNiakMseUJBQW1CNEQsb0JBQW5CLEVBQXlDekIsb0NBQXpDO0FBQ0QsS0FGRCxNQUVPO0FBQ0xuQyx5QkFBbUI0RCxvQkFBbkIsRUFBeUN4QixtQ0FBekM7QUFDRDtBQUNELEtBQUMsQ0FBQ0wsVUFBRixHQUFlOW1CLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsc0lBQWpCLENBQXhDLEdBQW1NNEIsZUFBZSxJQUFmLENBQWxOLEdBQXlPLEtBQUssQ0FBOU87QUFDQTtBQUNBZ2hCLG9CQUFnQmdDLGtCQUFoQjtBQUNELEdBeEprQjs7QUEwSm5COzs7QUFHQUMsV0FBUyxtQkFBWTtBQUNuQmhDLG1CQUFlLEVBQWY7QUFDRCxHQS9Ka0I7O0FBaUtuQmlDLHFCQUFtQiw2QkFBWTtBQUM3QixXQUFPakMsWUFBUDtBQUNEO0FBbktrQixDQUFyQjs7QUFzS0E1bUIsT0FBT0MsT0FBUCxHQUFpQjBrQixjQUFqQixDOzs7Ozs7OztBQ2hSQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUkvTSxpQkFBaUIsbUJBQUFqVCxDQUFRLEVBQVIsQ0FBckI7O0FBRUEsSUFBSW1rQixpQkFBaUIsbUJBQUFua0IsQ0FBUSxFQUFSLENBQXJCOztBQUVBOzs7O0FBSUEsSUFBSW9rQixtQkFBbUI7QUFDckJDLFFBQU0sY0FBVXpSLEtBQVYsRUFBaUI7QUFDckIsUUFBSUEsTUFBTXlSLElBQVYsRUFBZ0I7QUFDZCxhQUFPelIsTUFBTXlSLElBQWI7QUFDRDs7QUFFRCxRQUFJN2UsU0FBUzJlLGVBQWV2UixLQUFmLENBQWI7QUFDQSxRQUFJcE4sT0FBT1EsTUFBUCxLQUFrQlIsTUFBdEIsRUFBOEI7QUFDNUI7QUFDQSxhQUFPQSxNQUFQO0FBQ0Q7O0FBRUQsUUFBSThlLE1BQU05ZSxPQUFPK2UsYUFBakI7QUFDQTtBQUNBLFFBQUlELEdBQUosRUFBUztBQUNQLGFBQU9BLElBQUlFLFdBQUosSUFBbUJGLElBQUlHLFlBQTlCO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBT3plLE1BQVA7QUFDRDtBQUNGLEdBbkJvQjtBQW9CckIwZSxVQUFRLGdCQUFVOVIsS0FBVixFQUFpQjtBQUN2QixXQUFPQSxNQUFNOFIsTUFBTixJQUFnQixDQUF2QjtBQUNEO0FBdEJvQixDQUF2Qjs7QUF5QkE7Ozs7OztBQU1BLFNBQVNDLGdCQUFULENBQTBCelIsY0FBMUIsRUFBMEMwUixjQUExQyxFQUEwRHhSLFdBQTFELEVBQXVFQyxpQkFBdkUsRUFBMEY7QUFDeEYsU0FBT0osZUFBZWhYLElBQWYsQ0FBb0IsSUFBcEIsRUFBMEJpWCxjQUExQixFQUEwQzBSLGNBQTFDLEVBQTBEeFIsV0FBMUQsRUFBdUVDLGlCQUF2RSxDQUFQO0FBQ0Q7O0FBRURKLGVBQWV5QixZQUFmLENBQTRCaVEsZ0JBQTVCLEVBQThDUCxnQkFBOUM7O0FBRUEvb0IsT0FBT0MsT0FBUCxHQUFpQnFwQixnQkFBakIsQzs7Ozs7OztBQ3pEQTs7Ozs7Ozs7OztBQVVBOztBQUVBOzs7Ozs7O0FBT0E7O0FBRUEsSUFBSUUsbUJBQW1CO0FBQ3JCOzs7OztBQUtBQyxVQUFRLGdCQUFVaGYsR0FBVixFQUFlO0FBQ3JCQSxRQUFJaWYsc0JBQUosR0FBNkI1bEIsU0FBN0I7QUFDRCxHQVJvQjs7QUFVckJ5SixPQUFLLGFBQVU5QyxHQUFWLEVBQWU7QUFDbEIsV0FBT0EsSUFBSWlmLHNCQUFYO0FBQ0QsR0Fab0I7O0FBY3JCQyxPQUFLLGFBQVVsZixHQUFWLEVBQWU7QUFDbEIsV0FBT0EsSUFBSWlmLHNCQUFKLEtBQStCNWxCLFNBQXRDO0FBQ0QsR0FoQm9COztBQWtCckJ3SixPQUFLLGFBQVU3QyxHQUFWLEVBQWUyTyxLQUFmLEVBQXNCO0FBQ3pCM08sUUFBSWlmLHNCQUFKLEdBQTZCdFEsS0FBN0I7QUFDRDtBQXBCb0IsQ0FBdkI7O0FBdUJBcFosT0FBT0MsT0FBUCxHQUFpQnVwQixnQkFBakIsQzs7Ozs7OztBQzVDQTs7QUFFQXZwQixRQUFRMnBCLFVBQVIsR0FBcUIsSUFBckI7QUFDQSxJQUFJQyxrQkFBa0I1cEIsUUFBUTRwQixlQUFSLEdBQTBCLFNBQVNBLGVBQVQsQ0FBeUJDLElBQXpCLEVBQStCO0FBQzdFLFNBQU9BLEtBQUtDLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQW5CLEdBQXlCRCxJQUF6QixHQUFnQyxNQUFNQSxJQUE3QztBQUNELENBRkQ7O0FBSUEsSUFBSUUsb0JBQW9CL3BCLFFBQVErcEIsaUJBQVIsR0FBNEIsU0FBU0EsaUJBQVQsQ0FBMkJGLElBQTNCLEVBQWlDO0FBQ25GLFNBQU9BLEtBQUtDLE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQW5CLEdBQXlCRCxLQUFLaGMsTUFBTCxDQUFZLENBQVosQ0FBekIsR0FBMENnYyxJQUFqRDtBQUNELENBRkQ7O0FBSUEsSUFBSUcsY0FBY2hxQixRQUFRZ3FCLFdBQVIsR0FBc0IsU0FBU0EsV0FBVCxDQUFxQkgsSUFBckIsRUFBMkJJLE1BQTNCLEVBQW1DO0FBQ3pFLFNBQU8sSUFBSTVkLE1BQUosQ0FBVyxNQUFNNGQsTUFBTixHQUFlLGVBQTFCLEVBQTJDLEdBQTNDLEVBQWdEM2QsSUFBaEQsQ0FBcUR1ZCxJQUFyRCxDQUFQO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJSyxnQkFBZ0JscUIsUUFBUWtxQixhQUFSLEdBQXdCLFNBQVNBLGFBQVQsQ0FBdUJMLElBQXZCLEVBQTZCSSxNQUE3QixFQUFxQztBQUMvRSxTQUFPRCxZQUFZSCxJQUFaLEVBQWtCSSxNQUFsQixJQUE0QkosS0FBS2hjLE1BQUwsQ0FBWW9jLE9BQU85b0IsTUFBbkIsQ0FBNUIsR0FBeUQwb0IsSUFBaEU7QUFDRCxDQUZEOztBQUlBLElBQUlNLHFCQUFxQm5xQixRQUFRbXFCLGtCQUFSLEdBQTZCLFNBQVNBLGtCQUFULENBQTRCTixJQUE1QixFQUFrQztBQUN0RixTQUFPQSxLQUFLQyxNQUFMLENBQVlELEtBQUsxb0IsTUFBTCxHQUFjLENBQTFCLE1BQWlDLEdBQWpDLEdBQXVDMG9CLEtBQUt6akIsS0FBTCxDQUFXLENBQVgsRUFBYyxDQUFDLENBQWYsQ0FBdkMsR0FBMkR5akIsSUFBbEU7QUFDRCxDQUZEOztBQUlBLElBQUlPLFlBQVlwcUIsUUFBUW9xQixTQUFSLEdBQW9CLFNBQVNBLFNBQVQsQ0FBbUJQLElBQW5CLEVBQXlCO0FBQzNELE1BQUlRLFdBQVdSLFFBQVEsR0FBdkI7QUFDQSxNQUFJUyxTQUFTLEVBQWI7QUFDQSxNQUFJQyxPQUFPLEVBQVg7O0FBRUEsTUFBSUMsWUFBWUgsU0FBU25sQixPQUFULENBQWlCLEdBQWpCLENBQWhCO0FBQ0EsTUFBSXNsQixjQUFjLENBQUMsQ0FBbkIsRUFBc0I7QUFDcEJELFdBQU9GLFNBQVN4YyxNQUFULENBQWdCMmMsU0FBaEIsQ0FBUDtBQUNBSCxlQUFXQSxTQUFTeGMsTUFBVCxDQUFnQixDQUFoQixFQUFtQjJjLFNBQW5CLENBQVg7QUFDRDs7QUFFRCxNQUFJQyxjQUFjSixTQUFTbmxCLE9BQVQsQ0FBaUIsR0FBakIsQ0FBbEI7QUFDQSxNQUFJdWxCLGdCQUFnQixDQUFDLENBQXJCLEVBQXdCO0FBQ3RCSCxhQUFTRCxTQUFTeGMsTUFBVCxDQUFnQjRjLFdBQWhCLENBQVQ7QUFDQUosZUFBV0EsU0FBU3hjLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFBbUI0YyxXQUFuQixDQUFYO0FBQ0Q7O0FBRUQsU0FBTztBQUNMSixjQUFVQSxRQURMO0FBRUxDLFlBQVFBLFdBQVcsR0FBWCxHQUFpQixFQUFqQixHQUFzQkEsTUFGekI7QUFHTEMsVUFBTUEsU0FBUyxHQUFULEdBQWUsRUFBZixHQUFvQkE7QUFIckIsR0FBUDtBQUtELENBdEJEOztBQXdCQSxJQUFJRyxhQUFhMXFCLFFBQVEwcUIsVUFBUixHQUFxQixTQUFTQSxVQUFULENBQW9CQyxRQUFwQixFQUE4QjtBQUNsRSxNQUFJTixXQUFXTSxTQUFTTixRQUF4QjtBQUFBLE1BQ0lDLFNBQVNLLFNBQVNMLE1BRHRCO0FBQUEsTUFFSUMsT0FBT0ksU0FBU0osSUFGcEI7O0FBS0EsTUFBSVYsT0FBT1EsWUFBWSxHQUF2Qjs7QUFFQSxNQUFJQyxVQUFVQSxXQUFXLEdBQXpCLEVBQThCVCxRQUFRUyxPQUFPUixNQUFQLENBQWMsQ0FBZCxNQUFxQixHQUFyQixHQUEyQlEsTUFBM0IsR0FBb0MsTUFBTUEsTUFBbEQ7O0FBRTlCLE1BQUlDLFFBQVFBLFNBQVMsR0FBckIsRUFBMEJWLFFBQVFVLEtBQUtULE1BQUwsQ0FBWSxDQUFaLE1BQW1CLEdBQW5CLEdBQXlCUyxJQUF6QixHQUFnQyxNQUFNQSxJQUE5Qzs7QUFFMUIsU0FBT1YsSUFBUDtBQUNELENBYkQsQzs7Ozs7OztBQy9DQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJdk4sb0JBQW9CLEtBQXhCO0FBQ0EsSUFBSXhjLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLE1BQUk7QUFDRjtBQUNBZ0YsV0FBT2lRLGNBQVAsQ0FBc0IsRUFBdEIsRUFBMEIsR0FBMUIsRUFBK0IsRUFBRXZMLEtBQUssZUFBWSxDQUFFLENBQXJCLEVBQS9CO0FBQ0FnUCx3QkFBb0IsSUFBcEI7QUFDRCxHQUpELENBSUUsT0FBT3JYLENBQVAsRUFBVTtBQUNWO0FBQ0Q7QUFDRjs7QUFFRGxGLE9BQU9DLE9BQVAsR0FBaUJzYyxpQkFBakIsQzs7Ozs7Ozs7QUN4QkE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJc08sY0FBYyxFQUFsQjs7QUFFQSxJQUFJOXFCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDZ0YsU0FBT21WLE1BQVAsQ0FBYzZNLFdBQWQ7QUFDRDs7QUFFRDdxQixPQUFPQyxPQUFQLEdBQWlCNHFCLFdBQWpCLEM7Ozs7Ozs7O0FDbEJBOzs7Ozs7Ozs7OztBQVdBOztBQUVBLElBQUlsbEIsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCOztBQUVBLElBQUlaLFlBQVksbUJBQUFZLENBQVEsQ0FBUixDQUFoQjs7QUFFQTs7O0FBR0EsSUFBSW1tQixtQkFBbUIsSUFBdkI7O0FBRUE7OztBQUdBLElBQUlDLGlCQUFpQixFQUFyQjs7QUFFQTs7Ozs7QUFLQSxTQUFTQyx1QkFBVCxHQUFtQztBQUNqQyxNQUFJLENBQUNGLGdCQUFMLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDRDtBQUNELE9BQUssSUFBSUcsVUFBVCxJQUF1QkYsY0FBdkIsRUFBdUM7QUFDckMsUUFBSUcsZUFBZUgsZUFBZUUsVUFBZixDQUFuQjtBQUNBLFFBQUlFLGNBQWNMLGlCQUFpQjNsQixPQUFqQixDQUF5QjhsQixVQUF6QixDQUFsQjtBQUNBLE1BQUVFLGNBQWMsQ0FBQyxDQUFqQixJQUFzQnByQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLGtHQUFqQixFQUFxSGtuQixVQUFySCxDQUF4QyxHQUEyS3RsQixlQUFlLElBQWYsRUFBcUJzbEIsVUFBckIsQ0FBak0sR0FBb08sS0FBSyxDQUF6TztBQUNBLFFBQUl2RSxvQkFBb0IyQixPQUFwQixDQUE0QjhDLFdBQTVCLENBQUosRUFBOEM7QUFDNUM7QUFDRDtBQUNELEtBQUNELGFBQWEvQyxhQUFkLEdBQThCcG9CLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsaUdBQWpCLEVBQW9Ia25CLFVBQXBILENBQXhDLEdBQTBLdGxCLGVBQWUsSUFBZixFQUFxQnNsQixVQUFyQixDQUF4TSxHQUEyTyxLQUFLLENBQWhQO0FBQ0F2RSx3QkFBb0IyQixPQUFwQixDQUE0QjhDLFdBQTVCLElBQTJDRCxZQUEzQztBQUNBLFFBQUlFLGtCQUFrQkYsYUFBYUcsVUFBbkM7QUFDQSxTQUFLLElBQUlDLFNBQVQsSUFBc0JGLGVBQXRCLEVBQXVDO0FBQ3JDLE9BQUNHLHNCQUFzQkgsZ0JBQWdCRSxTQUFoQixDQUF0QixFQUFrREosWUFBbEQsRUFBZ0VJLFNBQWhFLENBQUQsR0FBOEV2ckIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixvRUFBakIsRUFBdUZ1bkIsU0FBdkYsRUFBa0dMLFVBQWxHLENBQXhDLEdBQXdKdGxCLGVBQWUsSUFBZixFQUFxQjJsQixTQUFyQixFQUFnQ0wsVUFBaEMsQ0FBdE8sR0FBb1IsS0FBSyxDQUF6UjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTTSxxQkFBVCxDQUErQjFULGNBQS9CLEVBQStDcVQsWUFBL0MsRUFBNkRJLFNBQTdELEVBQXdFO0FBQ3RFLEdBQUMsQ0FBQzVFLG9CQUFvQjhFLHdCQUFwQixDQUE2QzFqQixjQUE3QyxDQUE0RHdqQixTQUE1RCxDQUFGLEdBQTJFdnJCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsc0ZBQWpCLEVBQXlHdW5CLFNBQXpHLENBQXhDLEdBQThKM2xCLGVBQWUsSUFBZixFQUFxQjJsQixTQUFyQixDQUF6TyxHQUEyUSxLQUFLLENBQWhSO0FBQ0E1RSxzQkFBb0I4RSx3QkFBcEIsQ0FBNkNGLFNBQTdDLElBQTBEelQsY0FBMUQ7O0FBRUEsTUFBSXNOLDBCQUEwQnROLGVBQWVzTix1QkFBN0M7QUFDQSxNQUFJQSx1QkFBSixFQUE2QjtBQUMzQixTQUFLLElBQUlzRyxTQUFULElBQXNCdEcsdUJBQXRCLEVBQStDO0FBQzdDLFVBQUlBLHdCQUF3QnJkLGNBQXhCLENBQXVDMmpCLFNBQXZDLENBQUosRUFBdUQ7QUFDckQsWUFBSUMseUJBQXlCdkcsd0JBQXdCc0csU0FBeEIsQ0FBN0I7QUFDQUUsZ0NBQXdCRCxzQkFBeEIsRUFBZ0RSLFlBQWhELEVBQThESSxTQUE5RDtBQUNEO0FBQ0Y7QUFDRCxXQUFPLElBQVA7QUFDRCxHQVJELE1BUU8sSUFBSXpULGVBQWVxTixnQkFBbkIsRUFBcUM7QUFDMUN5Ryw0QkFBd0I5VCxlQUFlcU4sZ0JBQXZDLEVBQXlEZ0csWUFBekQsRUFBdUVJLFNBQXZFO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTSyx1QkFBVCxDQUFpQ3pHLGdCQUFqQyxFQUFtRGdHLFlBQW5ELEVBQWlFSSxTQUFqRSxFQUE0RTtBQUMxRSxHQUFDLENBQUM1RSxvQkFBb0JvQix1QkFBcEIsQ0FBNEM1QyxnQkFBNUMsQ0FBRixHQUFrRW5sQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLDZGQUFqQixFQUFnSG1oQixnQkFBaEgsQ0FBeEMsR0FBNEt2ZixlQUFlLEtBQWYsRUFBc0J1ZixnQkFBdEIsQ0FBOU8sR0FBd1IsS0FBSyxDQUE3UjtBQUNBd0Isc0JBQW9Cb0IsdUJBQXBCLENBQTRDNUMsZ0JBQTVDLElBQWdFZ0csWUFBaEU7QUFDQXhFLHNCQUFvQmtGLDRCQUFwQixDQUFpRDFHLGdCQUFqRCxJQUFxRWdHLGFBQWFHLFVBQWIsQ0FBd0JDLFNBQXhCLEVBQW1DTyxZQUF4Rzs7QUFFQSxNQUFJOXJCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFFBQUlpb0IsaUJBQWlCNUcsaUJBQWlCN0osV0FBakIsRUFBckI7QUFDQXFMLHdCQUFvQnFGLHlCQUFwQixDQUE4Q0QsY0FBOUMsSUFBZ0U1RyxnQkFBaEU7O0FBRUEsUUFBSUEscUJBQXFCLGVBQXpCLEVBQTBDO0FBQ3hDd0IsMEJBQW9CcUYseUJBQXBCLENBQThDQyxVQUE5QyxHQUEyRDlHLGdCQUEzRDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7QUFLQSxJQUFJd0Isc0JBQXNCO0FBQ3hCOzs7QUFHQTJCLFdBQVMsRUFKZTs7QUFNeEI7OztBQUdBbUQsNEJBQTBCLEVBVEY7O0FBV3hCOzs7QUFHQTFELDJCQUF5QixFQWREOztBQWdCeEI7OztBQUdBOEQsZ0NBQThCLEVBbkJOOztBQXFCeEI7Ozs7OztBQU1BRyw2QkFBMkJoc0IsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0MsRUFBeEMsR0FBNkMsSUEzQmhEO0FBNEJ4Qjs7QUFFQTs7Ozs7Ozs7O0FBU0E0akIsMEJBQXdCLGdDQUFVd0Usd0JBQVYsRUFBb0M7QUFDMUQsS0FBQyxDQUFDbkIsZ0JBQUYsR0FBcUIvcUIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixxSUFBakIsQ0FBeEMsR0FBa000QixlQUFlLEtBQWYsQ0FBdk4sR0FBK08sS0FBSyxDQUFwUDtBQUNBO0FBQ0FtbEIsdUJBQW1CbHBCLE1BQU1NLFNBQU4sQ0FBZ0JtRSxLQUFoQixDQUFzQnpGLElBQXRCLENBQTJCcXJCLHdCQUEzQixDQUFuQjtBQUNBakI7QUFDRCxHQTVDdUI7O0FBOEN4Qjs7Ozs7Ozs7OztBQVVBdEQsNEJBQTBCLGtDQUFVd0Usc0JBQVYsRUFBa0M7QUFDMUQsUUFBSUMsa0JBQWtCLEtBQXRCO0FBQ0EsU0FBSyxJQUFJbEIsVUFBVCxJQUF1QmlCLHNCQUF2QixFQUErQztBQUM3QyxVQUFJLENBQUNBLHVCQUF1QnBrQixjQUF2QixDQUFzQ21qQixVQUF0QyxDQUFMLEVBQXdEO0FBQ3REO0FBQ0Q7QUFDRCxVQUFJQyxlQUFlZ0IsdUJBQXVCakIsVUFBdkIsQ0FBbkI7QUFDQSxVQUFJLENBQUNGLGVBQWVqakIsY0FBZixDQUE4Qm1qQixVQUE5QixDQUFELElBQThDRixlQUFlRSxVQUFmLE1BQStCQyxZQUFqRixFQUErRjtBQUM3RixTQUFDLENBQUNILGVBQWVFLFVBQWYsQ0FBRixHQUErQmxyQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLDJGQUFqQixFQUE4R2tuQixVQUE5RyxDQUF4QyxHQUFvS3RsQixlQUFlLEtBQWYsRUFBc0JzbEIsVUFBdEIsQ0FBbk0sR0FBdU8sS0FBSyxDQUE1TztBQUNBRix1QkFBZUUsVUFBZixJQUE2QkMsWUFBN0I7QUFDQWlCLDBCQUFrQixJQUFsQjtBQUNEO0FBQ0Y7QUFDRCxRQUFJQSxlQUFKLEVBQXFCO0FBQ25CbkI7QUFDRDtBQUNGLEdBeEV1Qjs7QUEwRXhCOzs7Ozs7O0FBT0FvQiwyQkFBeUIsaUNBQVU3VSxLQUFWLEVBQWlCO0FBQ3hDLFFBQUlNLGlCQUFpQk4sTUFBTU0sY0FBM0I7QUFDQSxRQUFJQSxlQUFlcU4sZ0JBQW5CLEVBQXFDO0FBQ25DLGFBQU93QixvQkFBb0JvQix1QkFBcEIsQ0FBNENqUSxlQUFlcU4sZ0JBQTNELEtBQWdGLElBQXZGO0FBQ0Q7QUFDRCxRQUFJck4sZUFBZXNOLHVCQUFmLEtBQTJDcmhCLFNBQS9DLEVBQTBEO0FBQ3hEO0FBQ0E7QUFDQSxVQUFJcWhCLDBCQUEwQnROLGVBQWVzTix1QkFBN0M7O0FBRUEsV0FBSyxJQUFJRSxLQUFULElBQWtCRix1QkFBbEIsRUFBMkM7QUFDekMsWUFBSSxDQUFDQSx3QkFBd0JyZCxjQUF4QixDQUF1Q3VkLEtBQXZDLENBQUwsRUFBb0Q7QUFDbEQ7QUFDRDtBQUNELFlBQUk2RixlQUFleEUsb0JBQW9Cb0IsdUJBQXBCLENBQTRDM0Msd0JBQXdCRSxLQUF4QixDQUE1QyxDQUFuQjtBQUNBLFlBQUk2RixZQUFKLEVBQWtCO0FBQ2hCLGlCQUFPQSxZQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsV0FBTyxJQUFQO0FBQ0QsR0F0R3VCOztBQXdHeEI7Ozs7QUFJQW1CLHNCQUFvQiw4QkFBWTtBQUM5QnZCLHVCQUFtQixJQUFuQjtBQUNBLFNBQUssSUFBSUcsVUFBVCxJQUF1QkYsY0FBdkIsRUFBdUM7QUFDckMsVUFBSUEsZUFBZWpqQixjQUFmLENBQThCbWpCLFVBQTlCLENBQUosRUFBK0M7QUFDN0MsZUFBT0YsZUFBZUUsVUFBZixDQUFQO0FBQ0Q7QUFDRjtBQUNEdkUsd0JBQW9CMkIsT0FBcEIsQ0FBNEJqbkIsTUFBNUIsR0FBcUMsQ0FBckM7O0FBRUEsUUFBSW9xQiwyQkFBMkI5RSxvQkFBb0I4RSx3QkFBbkQ7QUFDQSxTQUFLLElBQUlGLFNBQVQsSUFBc0JFLHdCQUF0QixFQUFnRDtBQUM5QyxVQUFJQSx5QkFBeUIxakIsY0FBekIsQ0FBd0N3akIsU0FBeEMsQ0FBSixFQUF3RDtBQUN0RCxlQUFPRSx5QkFBeUJGLFNBQXpCLENBQVA7QUFDRDtBQUNGOztBQUVELFFBQUl4RCwwQkFBMEJwQixvQkFBb0JvQix1QkFBbEQ7QUFDQSxTQUFLLElBQUk1QyxnQkFBVCxJQUE2QjRDLHVCQUE3QixFQUFzRDtBQUNwRCxVQUFJQSx3QkFBd0JoZ0IsY0FBeEIsQ0FBdUNvZCxnQkFBdkMsQ0FBSixFQUE4RDtBQUM1RCxlQUFPNEMsd0JBQXdCNUMsZ0JBQXhCLENBQVA7QUFDRDtBQUNGOztBQUVELFFBQUlubEIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSWtvQiw0QkFBNEJyRixvQkFBb0JxRix5QkFBcEQ7QUFDQSxXQUFLLElBQUlELGNBQVQsSUFBMkJDLHlCQUEzQixFQUFzRDtBQUNwRCxZQUFJQSwwQkFBMEJqa0IsY0FBMUIsQ0FBeUNna0IsY0FBekMsQ0FBSixFQUE4RDtBQUM1RCxpQkFBT0MsMEJBQTBCRCxjQUExQixDQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUEzSXVCLENBQTFCOztBQThJQTlyQixPQUFPQyxPQUFQLEdBQWlCeW1CLG1CQUFqQixDOzs7Ozs7OztBQzNQQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJL2dCLGlCQUFpQixtQkFBQWhCLENBQVEsQ0FBUixDQUFyQjs7QUFFQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7O0FBRUEsSUFBSTJuQixpQkFBaUIsRUFBckI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2REEsSUFBSUMsa0JBQWtCO0FBQ3BCOzs7Ozs7O0FBT0FwWSwyQkFBeUIsbUNBQVk7QUFDbkMsU0FBS3FZLG1CQUFMLEdBQTJCLEtBQUtuWSxzQkFBTCxFQUEzQjtBQUNBLFFBQUksS0FBS29ZLGVBQVQsRUFBMEI7QUFDeEIsV0FBS0EsZUFBTCxDQUFxQnJyQixNQUFyQixHQUE4QixDQUE5QjtBQUNELEtBRkQsTUFFTztBQUNMLFdBQUtxckIsZUFBTCxHQUF1QixFQUF2QjtBQUNEO0FBQ0QsU0FBS0MsZ0JBQUwsR0FBd0IsS0FBeEI7QUFDRCxHQWhCbUI7O0FBa0JwQkEsb0JBQWtCLEtBbEJFOztBQW9CcEI7Ozs7QUFJQXJZLDBCQUF3QixJQXhCSjs7QUEwQnBCc1ksbUJBQWlCLDJCQUFZO0FBQzNCLFdBQU8sQ0FBQyxDQUFDLEtBQUtELGdCQUFkO0FBQ0QsR0E1Qm1COztBQThCcEI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBbFksV0FBUyxpQkFBVUMsTUFBVixFQUFrQkMsS0FBbEIsRUFBeUJ6USxDQUF6QixFQUE0QkMsQ0FBNUIsRUFBK0JDLENBQS9CLEVBQWtDQyxDQUFsQyxFQUFxQzVELENBQXJDLEVBQXdDNkQsQ0FBeEMsRUFBMkM7QUFDbEQ7QUFDQSxLQUFDLENBQUMsS0FBS3NvQixlQUFMLEVBQUYsR0FBMkI1c0IsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiw2R0FBakIsQ0FBeEMsR0FBMEs0QixlQUFlLElBQWYsQ0FBck0sR0FBNE4sS0FBSyxDQUFqTztBQUNBLFFBQUlpbkIsV0FBSjtBQUNBLFFBQUlDLEdBQUo7QUFDQSxRQUFJO0FBQ0YsV0FBS0gsZ0JBQUwsR0FBd0IsSUFBeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBRSxvQkFBYyxJQUFkO0FBQ0EsV0FBS0UsYUFBTCxDQUFtQixDQUFuQjtBQUNBRCxZQUFNcFksT0FBTzdULElBQVAsQ0FBWThULEtBQVosRUFBbUJ6USxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUJDLENBQXpCLEVBQTRCQyxDQUE1QixFQUErQjVELENBQS9CLEVBQWtDNkQsQ0FBbEMsQ0FBTjtBQUNBdW9CLG9CQUFjLEtBQWQ7QUFDRCxLQVZELFNBVVU7QUFDUixVQUFJO0FBQ0YsWUFBSUEsV0FBSixFQUFpQjtBQUNmO0FBQ0E7QUFDQSxjQUFJO0FBQ0YsaUJBQUtHLFFBQUwsQ0FBYyxDQUFkO0FBQ0QsV0FGRCxDQUVFLE9BQU83aUIsR0FBUCxFQUFZLENBQUU7QUFDakIsU0FORCxNQU1PO0FBQ0w7QUFDQTtBQUNBLGVBQUs2aUIsUUFBTCxDQUFjLENBQWQ7QUFDRDtBQUNGLE9BWkQsU0FZVTtBQUNSLGFBQUtMLGdCQUFMLEdBQXdCLEtBQXhCO0FBQ0Q7QUFDRjtBQUNELFdBQU9HLEdBQVA7QUFDRCxHQWxGbUI7O0FBb0ZwQkMsaUJBQWUsdUJBQVVFLFVBQVYsRUFBc0I7QUFDbkMsUUFBSVIsc0JBQXNCLEtBQUtBLG1CQUEvQjtBQUNBLFNBQUssSUFBSTFxQixJQUFJa3JCLFVBQWIsRUFBeUJsckIsSUFBSTBxQixvQkFBb0JwckIsTUFBakQsRUFBeURVLEdBQXpELEVBQThEO0FBQzVELFVBQUltckIsVUFBVVQsb0JBQW9CMXFCLENBQXBCLENBQWQ7QUFDQSxVQUFJO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLMnFCLGVBQUwsQ0FBcUIzcUIsQ0FBckIsSUFBMEJ3cUIsY0FBMUI7QUFDQSxhQUFLRyxlQUFMLENBQXFCM3FCLENBQXJCLElBQTBCbXJCLFFBQVF6WixVQUFSLEdBQXFCeVosUUFBUXpaLFVBQVIsQ0FBbUI1UyxJQUFuQixDQUF3QixJQUF4QixDQUFyQixHQUFxRCxJQUEvRTtBQUNELE9BUEQsU0FPVTtBQUNSLFlBQUksS0FBSzZyQixlQUFMLENBQXFCM3FCLENBQXJCLE1BQTRCd3FCLGNBQWhDLEVBQWdEO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGNBQUk7QUFDRixpQkFBS1EsYUFBTCxDQUFtQmhyQixJQUFJLENBQXZCO0FBQ0QsV0FGRCxDQUVFLE9BQU9vSSxHQUFQLEVBQVksQ0FBRTtBQUNqQjtBQUNGO0FBQ0Y7QUFDRixHQTFHbUI7O0FBNEdwQjs7Ozs7O0FBTUE2aUIsWUFBVSxrQkFBVUMsVUFBVixFQUFzQjtBQUM5QixLQUFDLEtBQUtMLGVBQUwsRUFBRCxHQUEwQjVzQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHNFQUFqQixDQUF4QyxHQUFtSTRCLGVBQWUsSUFBZixDQUE3SixHQUFvTCxLQUFLLENBQXpMO0FBQ0EsUUFBSTZtQixzQkFBc0IsS0FBS0EsbUJBQS9CO0FBQ0EsU0FBSyxJQUFJMXFCLElBQUlrckIsVUFBYixFQUF5QmxyQixJQUFJMHFCLG9CQUFvQnByQixNQUFqRCxFQUF5RFUsR0FBekQsRUFBOEQ7QUFDNUQsVUFBSW1yQixVQUFVVCxvQkFBb0IxcUIsQ0FBcEIsQ0FBZDtBQUNBLFVBQUlvckIsV0FBVyxLQUFLVCxlQUFMLENBQXFCM3FCLENBQXJCLENBQWY7QUFDQSxVQUFJOHFCLFdBQUo7QUFDQSxVQUFJO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQUEsc0JBQWMsSUFBZDtBQUNBLFlBQUlNLGFBQWFaLGNBQWIsSUFBK0JXLFFBQVF2WixLQUEzQyxFQUFrRDtBQUNoRHVaLGtCQUFRdlosS0FBUixDQUFjOVMsSUFBZCxDQUFtQixJQUFuQixFQUF5QnNzQixRQUF6QjtBQUNEO0FBQ0ROLHNCQUFjLEtBQWQ7QUFDRCxPQVZELFNBVVU7QUFDUixZQUFJQSxXQUFKLEVBQWlCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsY0FBSTtBQUNGLGlCQUFLRyxRQUFMLENBQWNqckIsSUFBSSxDQUFsQjtBQUNELFdBRkQsQ0FFRSxPQUFPdEIsQ0FBUCxFQUFVLENBQUU7QUFDZjtBQUNGO0FBQ0Y7QUFDRCxTQUFLaXNCLGVBQUwsQ0FBcUJyckIsTUFBckIsR0FBOEIsQ0FBOUI7QUFDRDtBQS9JbUIsQ0FBdEI7O0FBa0pBcEIsT0FBT0MsT0FBUCxHQUFpQnNzQixlQUFqQixDOzs7Ozs7OztBQ2xPQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlqRCxtQkFBbUIsbUJBQUEza0IsQ0FBUSxFQUFSLENBQXZCO0FBQ0EsSUFBSXdvQixrQkFBa0IsbUJBQUF4b0IsQ0FBUSxFQUFSLENBQXRCOztBQUVBLElBQUl5b0Isd0JBQXdCLG1CQUFBem9CLENBQVEsRUFBUixDQUE1Qjs7QUFFQTs7OztBQUlBLElBQUkwb0Isc0JBQXNCO0FBQ3hCQyxXQUFTLElBRGU7QUFFeEJDLFdBQVMsSUFGZTtBQUd4QkMsV0FBUyxJQUhlO0FBSXhCQyxXQUFTLElBSmU7QUFLeEJDLFdBQVMsSUFMZTtBQU14QkMsWUFBVSxJQU5jO0FBT3hCQyxVQUFRLElBUGdCO0FBUXhCQyxXQUFTLElBUmU7QUFTeEJDLG9CQUFrQlYscUJBVE07QUFVeEJXLFVBQVEsZ0JBQVV4VyxLQUFWLEVBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFFBQUl3VyxTQUFTeFcsTUFBTXdXLE1BQW5CO0FBQ0EsUUFBSSxXQUFXeFcsS0FBZixFQUFzQjtBQUNwQixhQUFPd1csTUFBUDtBQUNEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFPQSxXQUFXLENBQVgsR0FBZSxDQUFmLEdBQW1CQSxXQUFXLENBQVgsR0FBZSxDQUFmLEdBQW1CLENBQTdDO0FBQ0QsR0F2QnVCO0FBd0J4QkMsV0FBUyxJQXhCZTtBQXlCeEJDLGlCQUFlLHVCQUFVMVcsS0FBVixFQUFpQjtBQUM5QixXQUFPQSxNQUFNMFcsYUFBTixLQUF3QjFXLE1BQU0yVyxXQUFOLEtBQXNCM1csTUFBTTRXLFVBQTVCLEdBQXlDNVcsTUFBTTZXLFNBQS9DLEdBQTJEN1csTUFBTTJXLFdBQXpGLENBQVA7QUFDRCxHQTNCdUI7QUE0QnhCO0FBQ0FHLFNBQU8sZUFBVTlXLEtBQVYsRUFBaUI7QUFDdEIsV0FBTyxXQUFXQSxLQUFYLEdBQW1CQSxNQUFNOFcsS0FBekIsR0FBaUM5VyxNQUFNaVcsT0FBTixHQUFnQkwsZ0JBQWdCbUIsaUJBQXhFO0FBQ0QsR0EvQnVCO0FBZ0N4QkMsU0FBTyxlQUFVaFgsS0FBVixFQUFpQjtBQUN0QixXQUFPLFdBQVdBLEtBQVgsR0FBbUJBLE1BQU1nWCxLQUF6QixHQUFpQ2hYLE1BQU1rVyxPQUFOLEdBQWdCTixnQkFBZ0JxQixnQkFBeEU7QUFDRDtBQWxDdUIsQ0FBMUI7O0FBcUNBOzs7Ozs7QUFNQSxTQUFTQyxtQkFBVCxDQUE2QjVXLGNBQTdCLEVBQTZDMFIsY0FBN0MsRUFBNkR4UixXQUE3RCxFQUEwRUMsaUJBQTFFLEVBQTZGO0FBQzNGLFNBQU9zUixpQkFBaUIxb0IsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEJpWCxjQUE1QixFQUE0QzBSLGNBQTVDLEVBQTREeFIsV0FBNUQsRUFBeUVDLGlCQUF6RSxDQUFQO0FBQ0Q7O0FBRURzUixpQkFBaUJqUSxZQUFqQixDQUE4Qm9WLG1CQUE5QixFQUFtRHBCLG1CQUFuRDs7QUFFQXJ0QixPQUFPQyxPQUFQLEdBQWlCd3VCLG1CQUFqQixDOzs7Ozs7O0FDdEVBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSTNqQix1QkFBdUIsbUJBQUFuRyxDQUFRLENBQVIsQ0FBM0I7QUFDQSxJQUFJbWUsZ0JBQWdCLG1CQUFBbmUsQ0FBUSxFQUFSLENBQXBCOztBQUVBLElBQUkrcEIsa0JBQWtCLGNBQXRCO0FBQ0EsSUFBSUMsa0JBQWtCLHNEQUF0Qjs7QUFFQSxJQUFJM0wscUNBQXFDLG1CQUFBcmUsQ0FBUSxFQUFSLENBQXpDOztBQUVBO0FBQ0EsSUFBSWlxQixvQkFBSjs7QUFFQTs7Ozs7Ozs7QUFRQSxJQUFJN0wsZUFBZUMsbUNBQW1DLFVBQVV6YyxJQUFWLEVBQWdCb2QsSUFBaEIsRUFBc0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsTUFBSXBkLEtBQUt1ZCxZQUFMLEtBQXNCaEIsY0FBYytMLEdBQXBDLElBQTJDLEVBQUUsZUFBZXRvQixJQUFqQixDQUEvQyxFQUF1RTtBQUNyRXFvQiwyQkFBdUJBLHdCQUF3QmhrQixTQUFTQyxhQUFULENBQXVCLEtBQXZCLENBQS9DO0FBQ0ErakIseUJBQXFCRSxTQUFyQixHQUFpQyxVQUFVbkwsSUFBVixHQUFpQixRQUFsRDtBQUNBLFFBQUlvTCxVQUFVSCxxQkFBcUJobkIsVUFBbkM7QUFDQSxXQUFPbW5CLFFBQVFubkIsVUFBZixFQUEyQjtBQUN6QnJCLFdBQUtnZSxXQUFMLENBQWlCd0ssUUFBUW5uQixVQUF6QjtBQUNEO0FBQ0YsR0FQRCxNQU9PO0FBQ0xyQixTQUFLdW9CLFNBQUwsR0FBaUJuTCxJQUFqQjtBQUNEO0FBQ0YsQ0Fka0IsQ0FBbkI7O0FBZ0JBLElBQUk3WSxxQkFBcUJKLFNBQXpCLEVBQW9DO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSXNrQixjQUFjcGtCLFNBQVNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBbEI7QUFDQW1rQixjQUFZRixTQUFaLEdBQXdCLEdBQXhCO0FBQ0EsTUFBSUUsWUFBWUYsU0FBWixLQUEwQixFQUE5QixFQUFrQztBQUNoQy9MLG1CQUFlLHNCQUFVeGMsSUFBVixFQUFnQm9kLElBQWhCLEVBQXNCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJcGQsS0FBSzhCLFVBQVQsRUFBcUI7QUFDbkI5QixhQUFLOEIsVUFBTCxDQUFnQjhiLFlBQWhCLENBQTZCNWQsSUFBN0IsRUFBbUNBLElBQW5DO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJbW9CLGdCQUFnQm5pQixJQUFoQixDQUFxQm9YLElBQXJCLEtBQThCQSxLQUFLLENBQUwsTUFBWSxHQUFaLElBQW1CZ0wsZ0JBQWdCcGlCLElBQWhCLENBQXFCb1gsSUFBckIsQ0FBckQsRUFBaUY7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FwZCxhQUFLdW9CLFNBQUwsR0FBaUJub0IsT0FBTzZDLFlBQVAsQ0FBb0IsTUFBcEIsSUFBOEJtYSxJQUEvQzs7QUFFQTtBQUNBO0FBQ0EsWUFBSXNMLFdBQVcxb0IsS0FBS3FCLFVBQXBCO0FBQ0EsWUFBSXFuQixTQUFTQyxJQUFULENBQWM5dEIsTUFBZCxLQUF5QixDQUE3QixFQUFnQztBQUM5Qm1GLGVBQUs0b0IsV0FBTCxDQUFpQkYsUUFBakI7QUFDRCxTQUZELE1BRU87QUFDTEEsbUJBQVNHLFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUIsQ0FBdkI7QUFDRDtBQUNGLE9BakJELE1BaUJPO0FBQ0w3b0IsYUFBS3VvQixTQUFMLEdBQWlCbkwsSUFBakI7QUFDRDtBQUNGLEtBbENEO0FBbUNEO0FBQ0RxTCxnQkFBYyxJQUFkO0FBQ0Q7O0FBRURodkIsT0FBT0MsT0FBUCxHQUFpQjhpQixZQUFqQixDOzs7Ozs7O0FDaEdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1DQTs7QUFFQTtBQUNBOzs7OztBQUtBLElBQUlzTSxrQkFBa0IsU0FBdEI7O0FBRUE7Ozs7Ozs7O0FBUUEsU0FBU0MsVUFBVCxDQUFvQkMsTUFBcEIsRUFBNEI7QUFDMUIsTUFBSUMsTUFBTSxLQUFLRCxNQUFmO0FBQ0EsTUFBSUUsUUFBUUosZ0JBQWdCSyxJQUFoQixDQUFxQkYsR0FBckIsQ0FBWjs7QUFFQSxNQUFJLENBQUNDLEtBQUwsRUFBWTtBQUNWLFdBQU9ELEdBQVA7QUFDRDs7QUFFRCxNQUFJRyxNQUFKO0FBQ0EsTUFBSWhNLE9BQU8sRUFBWDtBQUNBLE1BQUlpTSxRQUFRLENBQVo7QUFDQSxNQUFJQyxZQUFZLENBQWhCOztBQUVBLE9BQUtELFFBQVFILE1BQU1HLEtBQW5CLEVBQTBCQSxRQUFRSixJQUFJcHVCLE1BQXRDLEVBQThDd3VCLE9BQTlDLEVBQXVEO0FBQ3JELFlBQVFKLElBQUlNLFVBQUosQ0FBZUYsS0FBZixDQUFSO0FBQ0UsV0FBSyxFQUFMO0FBQ0U7QUFDQUQsaUJBQVMsUUFBVDtBQUNBO0FBQ0YsV0FBSyxFQUFMO0FBQ0U7QUFDQUEsaUJBQVMsT0FBVDtBQUNBO0FBQ0YsV0FBSyxFQUFMO0FBQ0U7QUFDQUEsaUJBQVMsUUFBVCxDQUZGLENBRXFCO0FBQ25CO0FBQ0YsV0FBSyxFQUFMO0FBQ0U7QUFDQUEsaUJBQVMsTUFBVDtBQUNBO0FBQ0YsV0FBSyxFQUFMO0FBQ0U7QUFDQUEsaUJBQVMsTUFBVDtBQUNBO0FBQ0Y7QUFDRTtBQXRCSjs7QUF5QkEsUUFBSUUsY0FBY0QsS0FBbEIsRUFBeUI7QUFDdkJqTSxjQUFRNkwsSUFBSU8sU0FBSixDQUFjRixTQUFkLEVBQXlCRCxLQUF6QixDQUFSO0FBQ0Q7O0FBRURDLGdCQUFZRCxRQUFRLENBQXBCO0FBQ0FqTSxZQUFRZ00sTUFBUjtBQUNEOztBQUVELFNBQU9FLGNBQWNELEtBQWQsR0FBc0JqTSxPQUFPNkwsSUFBSU8sU0FBSixDQUFjRixTQUFkLEVBQXlCRCxLQUF6QixDQUE3QixHQUErRGpNLElBQXRFO0FBQ0Q7QUFDRDs7QUFFQTs7Ozs7O0FBTUEsU0FBU3FNLDJCQUFULENBQXFDemdCLElBQXJDLEVBQTJDO0FBQ3pDLE1BQUksT0FBT0EsSUFBUCxLQUFnQixTQUFoQixJQUE2QixPQUFPQSxJQUFQLEtBQWdCLFFBQWpELEVBQTJEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLFdBQU8sS0FBS0EsSUFBWjtBQUNEO0FBQ0QsU0FBTytmLFdBQVcvZixJQUFYLENBQVA7QUFDRDs7QUFFRHZQLE9BQU9DLE9BQVAsR0FBaUIrdkIsMkJBQWpCLEM7Ozs7Ozs7QUN4SEE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJeGQsVUFBVSxtQkFBQTdOLENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUkraEIsc0JBQXNCLG1CQUFBL2hCLENBQVEsRUFBUixDQUExQjtBQUNBLElBQUlzckIseUJBQXlCLG1CQUFBdHJCLENBQVEsR0FBUixDQUE3QjtBQUNBLElBQUl3b0Isa0JBQWtCLG1CQUFBeG9CLENBQVEsRUFBUixDQUF0Qjs7QUFFQSxJQUFJdXJCLDZCQUE2QixtQkFBQXZyQixDQUFRLEdBQVIsQ0FBakM7QUFDQSxJQUFJd3JCLG1CQUFtQixtQkFBQXhyQixDQUFRLEVBQVIsQ0FBdkI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1REEsSUFBSXlyQixjQUFKO0FBQ0EsSUFBSUMscUJBQXFCLEVBQXpCO0FBQ0EsSUFBSUMsMEJBQTBCLEtBQTlCO0FBQ0EsSUFBSUMsMkJBQTJCLENBQS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUlDLGtCQUFrQjtBQUNwQkMsWUFBVSxPQURVO0FBRXBCQyxtQkFBaUJSLDJCQUEyQixjQUEzQixLQUE4QyxjQUYzQztBQUdwQlMseUJBQXVCVCwyQkFBMkIsb0JBQTNCLEtBQW9ELG9CQUh2RDtBQUlwQlUscUJBQW1CViwyQkFBMkIsZ0JBQTNCLEtBQWdELGdCQUovQztBQUtwQlcsV0FBUyxNQUxXO0FBTXBCQyxjQUFZLFNBTlE7QUFPcEJDLHFCQUFtQixnQkFQQztBQVFwQkMsYUFBVyxRQVJTO0FBU3BCQyxZQUFVLE9BVFU7QUFVcEJDLHFCQUFtQixnQkFWQztBQVdwQkMsdUJBQXFCLGtCQVhEO0FBWXBCQyx3QkFBc0IsbUJBWkY7QUFhcEJDLGtCQUFnQixhQWJJO0FBY3BCQyxXQUFTLE1BZFc7QUFlcEJDLFVBQVEsS0FmWTtBQWdCcEJDLGtCQUFnQixVQWhCSTtBQWlCcEJDLFdBQVMsTUFqQlc7QUFrQnBCQyxjQUFZLFNBbEJRO0FBbUJwQkMsZ0JBQWMsV0FuQk07QUFvQnBCQyxlQUFhLFVBcEJPO0FBcUJwQkMsZ0JBQWMsV0FyQk07QUFzQnBCQyxlQUFhLFVBdEJPO0FBdUJwQkMsZ0JBQWMsV0F2Qk07QUF3QnBCQyxXQUFTLE1BeEJXO0FBeUJwQkMscUJBQW1CLGdCQXpCQztBQTBCcEJDLGNBQVksU0ExQlE7QUEyQnBCQyxnQkFBYyxXQTNCTTtBQTRCcEJDLFlBQVUsT0E1QlU7QUE2QnBCQyxZQUFVLE9BN0JVO0FBOEJwQkMsWUFBVSxPQTlCVTtBQStCcEJDLFlBQVUsT0EvQlU7QUFnQ3BCQyxjQUFZLFNBaENRO0FBaUNwQkMsZUFBYSxVQWpDTztBQWtDcEJDLFlBQVUsT0FsQ1U7QUFtQ3BCQyxpQkFBZSxZQW5DSztBQW9DcEJDLHFCQUFtQixnQkFwQ0M7QUFxQ3BCQyxnQkFBYyxXQXJDTTtBQXNDcEJDLGdCQUFjLFdBdENNO0FBdUNwQkMsZ0JBQWMsV0F2Q007QUF3Q3BCQyxlQUFhLFVBeENPO0FBeUNwQkMsZ0JBQWMsV0F6Q007QUEwQ3BCQyxjQUFZLFNBMUNRO0FBMkNwQkMsWUFBVSxPQTNDVTtBQTRDcEJDLFlBQVUsT0E1Q1U7QUE2Q3BCQyxXQUFTLE1BN0NXO0FBOENwQkMsY0FBWSxTQTlDUTtBQStDcEJDLGVBQWEsVUEvQ087QUFnRHBCQyxpQkFBZSxZQWhESztBQWlEcEJDLGFBQVcsUUFqRFM7QUFrRHBCQyxhQUFXLFFBbERTO0FBbURwQkMsY0FBWSxTQW5EUTtBQW9EcEJDLHNCQUFvQixpQkFwREE7QUFxRHBCQyxjQUFZLFNBckRRO0FBc0RwQkMsY0FBWSxTQXREUTtBQXVEcEJDLGdCQUFjLFdBdkRNO0FBd0RwQkMsaUJBQWUsWUF4REs7QUF5RHBCQyxrQkFBZ0IsYUF6REk7QUEwRHBCQyxlQUFhLFVBMURPO0FBMkRwQkMsZ0JBQWMsV0EzRE07QUE0RHBCQyxpQkFBZSxZQTVESztBQTZEcEJDLG9CQUFrQm5FLDJCQUEyQixlQUEzQixLQUErQyxlQTdEN0M7QUE4RHBCb0UsbUJBQWlCLGNBOURHO0FBK0RwQkMsY0FBWSxTQS9EUTtBQWdFcEJDLFlBQVU7QUFoRVUsQ0FBdEI7O0FBbUVBOzs7QUFHQSxJQUFJQyxvQkFBb0Isc0JBQXNCOXRCLE9BQU9ULEtBQUtDLE1BQUwsRUFBUCxFQUFzQkUsS0FBdEIsQ0FBNEIsQ0FBNUIsQ0FBOUM7O0FBRUEsU0FBU3F1Qix1QkFBVCxDQUFpQ0MsT0FBakMsRUFBMEM7QUFDeEM7QUFDQTtBQUNBLE1BQUksQ0FBQzlyQixPQUFPM0csU0FBUCxDQUFpQjRGLGNBQWpCLENBQWdDbEgsSUFBaEMsQ0FBcUMrekIsT0FBckMsRUFBOENGLGlCQUE5QyxDQUFMLEVBQXVFO0FBQ3JFRSxZQUFRRixpQkFBUixJQUE2QmxFLDBCQUE3QjtBQUNBRix1QkFBbUJzRSxRQUFRRixpQkFBUixDQUFuQixJQUFpRCxFQUFqRDtBQUNEO0FBQ0QsU0FBT3BFLG1CQUFtQnNFLFFBQVFGLGlCQUFSLENBQW5CLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBLElBQUlHLDJCQUEyQnBpQixRQUFRLEVBQVIsRUFBWXlkLHNCQUFaLEVBQW9DO0FBQ2pFOzs7QUFHQTRFLHNCQUFvQixJQUo2Qzs7QUFNakVqZSxhQUFXO0FBQ1Q7OztBQUdBa2UsOEJBQTBCLGtDQUFVRCxrQkFBVixFQUE4QjtBQUN0REEseUJBQW1CRSxpQkFBbkIsQ0FBcUNILHlCQUF5QkksY0FBOUQ7QUFDQUosK0JBQXlCQyxrQkFBekIsR0FBOENBLGtCQUE5QztBQUNEO0FBUFEsR0FOc0Q7O0FBZ0JqRTs7Ozs7QUFLQUksY0FBWSxvQkFBVUMsT0FBVixFQUFtQjtBQUM3QixRQUFJTix5QkFBeUJDLGtCQUE3QixFQUFpRDtBQUMvQ0QsK0JBQXlCQyxrQkFBekIsQ0FBNENJLFVBQTVDLENBQXVEQyxPQUF2RDtBQUNEO0FBQ0YsR0F6QmdFOztBQTJCakU7OztBQUdBQyxhQUFXLHFCQUFZO0FBQ3JCLFdBQU8sQ0FBQyxFQUFFUCx5QkFBeUJDLGtCQUF6QixJQUErQ0QseUJBQXlCQyxrQkFBekIsQ0FBNENNLFNBQTVDLEVBQWpELENBQVI7QUFDRCxHQWhDZ0U7O0FBa0NqRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBQyxZQUFVLGtCQUFVbFEsZ0JBQVYsRUFBNEJtUSxxQkFBNUIsRUFBbUQ7QUFDM0QsUUFBSVYsVUFBVVUscUJBQWQ7QUFDQSxRQUFJQyxjQUFjWix3QkFBd0JDLE9BQXhCLENBQWxCO0FBQ0EsUUFBSTlJLGVBQWVuRixvQkFBb0JrRiw0QkFBcEIsQ0FBaUQxRyxnQkFBakQsQ0FBbkI7O0FBRUEsU0FBSyxJQUFJcGpCLElBQUksQ0FBYixFQUFnQkEsSUFBSStwQixhQUFhenFCLE1BQWpDLEVBQXlDVSxHQUF6QyxFQUE4QztBQUM1QyxVQUFJeXpCLGFBQWExSixhQUFhL3BCLENBQWIsQ0FBakI7QUFDQSxVQUFJLEVBQUV3ekIsWUFBWXh0QixjQUFaLENBQTJCeXRCLFVBQTNCLEtBQTBDRCxZQUFZQyxVQUFaLENBQTVDLENBQUosRUFBMEU7QUFDeEUsWUFBSUEsZUFBZSxVQUFuQixFQUErQjtBQUM3QixjQUFJcEYsaUJBQWlCLE9BQWpCLENBQUosRUFBK0I7QUFDN0J5RSxxQ0FBeUJDLGtCQUF6QixDQUE0Q1csZ0JBQTVDLENBQTZELFVBQTdELEVBQXlFLE9BQXpFLEVBQWtGYixPQUFsRjtBQUNELFdBRkQsTUFFTyxJQUFJeEUsaUJBQWlCLFlBQWpCLENBQUosRUFBb0M7QUFDekN5RSxxQ0FBeUJDLGtCQUF6QixDQUE0Q1csZ0JBQTVDLENBQTZELFVBQTdELEVBQXlFLFlBQXpFLEVBQXVGYixPQUF2RjtBQUNELFdBRk0sTUFFQTtBQUNMO0FBQ0E7QUFDQUMscUNBQXlCQyxrQkFBekIsQ0FBNENXLGdCQUE1QyxDQUE2RCxVQUE3RCxFQUF5RSxnQkFBekUsRUFBMkZiLE9BQTNGO0FBQ0Q7QUFDRixTQVZELE1BVU8sSUFBSVksZUFBZSxXQUFuQixFQUFnQztBQUNyQyxjQUFJcEYsaUJBQWlCLFFBQWpCLEVBQTJCLElBQTNCLENBQUosRUFBc0M7QUFDcEN5RSxxQ0FBeUJDLGtCQUF6QixDQUE0Q1ksaUJBQTVDLENBQThELFdBQTlELEVBQTJFLFFBQTNFLEVBQXFGZCxPQUFyRjtBQUNELFdBRkQsTUFFTztBQUNMQyxxQ0FBeUJDLGtCQUF6QixDQUE0Q1csZ0JBQTVDLENBQTZELFdBQTdELEVBQTBFLFFBQTFFLEVBQW9GWix5QkFBeUJDLGtCQUF6QixDQUE0Q2EsYUFBaEk7QUFDRDtBQUNGLFNBTk0sTUFNQSxJQUFJSCxlQUFlLFVBQWYsSUFBNkJBLGVBQWUsU0FBaEQsRUFBMkQ7QUFDaEUsY0FBSXBGLGlCQUFpQixPQUFqQixFQUEwQixJQUExQixDQUFKLEVBQXFDO0FBQ25DeUUscUNBQXlCQyxrQkFBekIsQ0FBNENZLGlCQUE1QyxDQUE4RCxVQUE5RCxFQUEwRSxPQUExRSxFQUFtRmQsT0FBbkY7QUFDQUMscUNBQXlCQyxrQkFBekIsQ0FBNENZLGlCQUE1QyxDQUE4RCxTQUE5RCxFQUF5RSxNQUF6RSxFQUFpRmQsT0FBakY7QUFDRCxXQUhELE1BR08sSUFBSXhFLGlCQUFpQixTQUFqQixDQUFKLEVBQWlDO0FBQ3RDO0FBQ0E7QUFDQXlFLHFDQUF5QkMsa0JBQXpCLENBQTRDVyxnQkFBNUMsQ0FBNkQsVUFBN0QsRUFBeUUsU0FBekUsRUFBb0ZiLE9BQXBGO0FBQ0FDLHFDQUF5QkMsa0JBQXpCLENBQTRDVyxnQkFBNUMsQ0FBNkQsU0FBN0QsRUFBd0UsVUFBeEUsRUFBb0ZiLE9BQXBGO0FBQ0Q7O0FBRUQ7QUFDQVcsc0JBQVl6RSxPQUFaLEdBQXNCLElBQXRCO0FBQ0F5RSxzQkFBWWhELFFBQVosR0FBdUIsSUFBdkI7QUFDRCxTQWRNLE1BY0EsSUFBSTlCLGdCQUFnQjFvQixjQUFoQixDQUErQnl0QixVQUEvQixDQUFKLEVBQWdEO0FBQ3JEWCxtQ0FBeUJDLGtCQUF6QixDQUE0Q1csZ0JBQTVDLENBQTZERCxVQUE3RCxFQUF5RS9FLGdCQUFnQitFLFVBQWhCLENBQXpFLEVBQXNHWixPQUF0RztBQUNEOztBQUVEVyxvQkFBWUMsVUFBWixJQUEwQixJQUExQjtBQUNEO0FBQ0Y7QUFDRixHQXBHZ0U7O0FBc0dqRUMsb0JBQWtCLDBCQUFVcE4sWUFBVixFQUF3QnVOLGVBQXhCLEVBQXlDQyxNQUF6QyxFQUFpRDtBQUNqRSxXQUFPaEIseUJBQXlCQyxrQkFBekIsQ0FBNENXLGdCQUE1QyxDQUE2RHBOLFlBQTdELEVBQTJFdU4sZUFBM0UsRUFBNEZDLE1BQTVGLENBQVA7QUFDRCxHQXhHZ0U7O0FBMEdqRUgscUJBQW1CLDJCQUFVck4sWUFBVixFQUF3QnVOLGVBQXhCLEVBQXlDQyxNQUF6QyxFQUFpRDtBQUNsRSxXQUFPaEIseUJBQXlCQyxrQkFBekIsQ0FBNENZLGlCQUE1QyxDQUE4RHJOLFlBQTlELEVBQTRFdU4sZUFBNUUsRUFBNkZDLE1BQTdGLENBQVA7QUFDRCxHQTVHZ0U7O0FBOEdqRTs7Ozs7QUFLQUMsdUJBQXFCLCtCQUFZO0FBQy9CLFFBQUksQ0FBQ2pyQixTQUFTa3JCLFdBQWQsRUFBMkI7QUFDekIsYUFBTyxLQUFQO0FBQ0Q7QUFDRCxRQUFJQyxLQUFLbnJCLFNBQVNrckIsV0FBVCxDQUFxQixZQUFyQixDQUFUO0FBQ0EsV0FBT0MsTUFBTSxJQUFOLElBQWMsV0FBV0EsRUFBaEM7QUFDRCxHQXpIZ0U7O0FBMkhqRTs7Ozs7Ozs7Ozs7QUFXQUMsK0JBQTZCLHVDQUFZO0FBQ3ZDLFFBQUk1RixtQkFBbUJ0c0IsU0FBdkIsRUFBa0M7QUFDaENzc0IsdUJBQWlCd0UseUJBQXlCaUIsbUJBQXpCLEVBQWpCO0FBQ0Q7QUFDRCxRQUFJLENBQUN6RixjQUFELElBQW1CLENBQUNFLHVCQUF4QixFQUFpRDtBQUMvQyxVQUFJMkYsVUFBVTlJLGdCQUFnQitJLG1CQUE5QjtBQUNBdEIsK0JBQXlCQyxrQkFBekIsQ0FBNENzQixrQkFBNUMsQ0FBK0RGLE9BQS9EO0FBQ0EzRixnQ0FBMEIsSUFBMUI7QUFDRDtBQUNGO0FBL0lnRSxDQUFwQyxDQUEvQjs7QUFrSkF0d0IsT0FBT0MsT0FBUCxHQUFpQjIwQix3QkFBakIsQzs7Ozs7OztBQ2xVQTs7Ozs7Ozs7O0FBU0E7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0EsSUFBSTd3QixZQUFZLFNBQVpBLFNBQVksQ0FBU0MsU0FBVCxFQUFvQkosTUFBcEIsRUFBNEJLLENBQTVCLEVBQStCQyxDQUEvQixFQUFrQ0MsQ0FBbEMsRUFBcUNDLENBQXJDLEVBQXdDNUQsQ0FBeEMsRUFBMkM2RCxDQUEzQyxFQUE4QztBQUM1RCxNQUFJdEUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsUUFBSUQsV0FBV0UsU0FBZixFQUEwQjtBQUN4QixZQUFNLElBQUl6RCxLQUFKLENBQVUsOENBQVYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSSxDQUFDMkQsU0FBTCxFQUFnQjtBQUNkLFFBQUlNLEtBQUo7QUFDQSxRQUFJVixXQUFXRSxTQUFmLEVBQTBCO0FBQ3hCUSxjQUFRLElBQUlqRSxLQUFKLENBQ04sdUVBQ0EsNkRBRk0sQ0FBUjtBQUlELEtBTEQsTUFLTztBQUNMLFVBQUlzQixPQUFPLENBQUNzQyxDQUFELEVBQUlDLENBQUosRUFBT0MsQ0FBUCxFQUFVQyxDQUFWLEVBQWE1RCxDQUFiLEVBQWdCNkQsQ0FBaEIsQ0FBWDtBQUNBLFVBQUlFLFdBQVcsQ0FBZjtBQUNBRCxjQUFRLElBQUlqRSxLQUFKLENBQ051RCxPQUFPWSxPQUFQLENBQWUsS0FBZixFQUFzQixZQUFXO0FBQUUsZUFBTzdDLEtBQUs0QyxVQUFMLENBQVA7QUFBMEIsT0FBN0QsQ0FETSxDQUFSO0FBR0FELFlBQU1qQixJQUFOLEdBQWEscUJBQWI7QUFDRDs7QUFFRGlCLFVBQU1HLFdBQU4sR0FBb0IsQ0FBcEIsQ0FoQmMsQ0FnQlM7QUFDdkIsVUFBTUgsS0FBTjtBQUNEO0FBQ0YsQ0ExQkQ7O0FBNEJBdEUsT0FBT0MsT0FBUCxHQUFpQjhELFNBQWpCLEM7Ozs7Ozs7O0FDbERBOzs7Ozs7QUFNQTtBQUNBOztBQUNBLElBQUk2RSx3QkFBd0JDLE9BQU9ELHFCQUFuQztBQUNBLElBQUlkLGlCQUFpQmUsT0FBTzNHLFNBQVAsQ0FBaUI0RixjQUF0QztBQUNBLElBQUlnQixtQkFBbUJELE9BQU8zRyxTQUFQLENBQWlCNkcsb0JBQXhDOztBQUVBLFNBQVNDLFFBQVQsQ0FBa0JDLEdBQWxCLEVBQXVCO0FBQ3RCLEtBQUlBLFFBQVEsSUFBUixJQUFnQkEsUUFBUW5GLFNBQTVCLEVBQXVDO0FBQ3RDLFFBQU0sSUFBSW9GLFNBQUosQ0FBYyx1REFBZCxDQUFOO0FBQ0E7O0FBRUQsUUFBT0wsT0FBT0ksR0FBUCxDQUFQO0FBQ0E7O0FBRUQsU0FBU0UsZUFBVCxHQUEyQjtBQUMxQixLQUFJO0FBQ0gsTUFBSSxDQUFDTixPQUFPTyxNQUFaLEVBQW9CO0FBQ25CLFVBQU8sS0FBUDtBQUNBOztBQUVEOztBQUVBO0FBQ0EsTUFBSUMsUUFBUSxJQUFJMUMsTUFBSixDQUFXLEtBQVgsQ0FBWixDQVJHLENBUTZCO0FBQ2hDMEMsUUFBTSxDQUFOLElBQVcsSUFBWDtBQUNBLE1BQUlSLE9BQU9TLG1CQUFQLENBQTJCRCxLQUEzQixFQUFrQyxDQUFsQyxNQUF5QyxHQUE3QyxFQUFrRDtBQUNqRCxVQUFPLEtBQVA7QUFDQTs7QUFFRDtBQUNBLE1BQUlFLFFBQVEsRUFBWjtBQUNBLE9BQUssSUFBSXpILElBQUksQ0FBYixFQUFnQkEsSUFBSSxFQUFwQixFQUF3QkEsR0FBeEIsRUFBNkI7QUFDNUJ5SCxTQUFNLE1BQU01QyxPQUFPNkMsWUFBUCxDQUFvQjFILENBQXBCLENBQVosSUFBc0NBLENBQXRDO0FBQ0E7QUFDRCxNQUFJMkgsU0FBU1osT0FBT1MsbUJBQVAsQ0FBMkJDLEtBQTNCLEVBQWtDRyxHQUFsQyxDQUFzQyxVQUFVQyxDQUFWLEVBQWE7QUFDL0QsVUFBT0osTUFBTUksQ0FBTixDQUFQO0FBQ0EsR0FGWSxDQUFiO0FBR0EsTUFBSUYsT0FBT0csSUFBUCxDQUFZLEVBQVosTUFBb0IsWUFBeEIsRUFBc0M7QUFDckMsVUFBTyxLQUFQO0FBQ0E7O0FBRUQ7QUFDQSxNQUFJQyxRQUFRLEVBQVo7QUFDQSx5QkFBdUJDLEtBQXZCLENBQTZCLEVBQTdCLEVBQWlDQyxPQUFqQyxDQUF5QyxVQUFVQyxNQUFWLEVBQWtCO0FBQzFESCxTQUFNRyxNQUFOLElBQWdCQSxNQUFoQjtBQUNBLEdBRkQ7QUFHQSxNQUFJbkIsT0FBT29CLElBQVAsQ0FBWXBCLE9BQU9PLE1BQVAsQ0FBYyxFQUFkLEVBQWtCUyxLQUFsQixDQUFaLEVBQXNDRCxJQUF0QyxDQUEyQyxFQUEzQyxNQUNGLHNCQURGLEVBQzBCO0FBQ3pCLFVBQU8sS0FBUDtBQUNBOztBQUVELFNBQU8sSUFBUDtBQUNBLEVBckNELENBcUNFLE9BQU9NLEdBQVAsRUFBWTtBQUNiO0FBQ0EsU0FBTyxLQUFQO0FBQ0E7QUFDRDs7QUFFRGxLLE9BQU9DLE9BQVAsR0FBaUJrSixvQkFBb0JOLE9BQU9PLE1BQTNCLEdBQW9DLFVBQVVlLE1BQVYsRUFBa0JDLE1BQWxCLEVBQTBCO0FBQzlFLEtBQUlDLElBQUo7QUFDQSxLQUFJQyxLQUFLdEIsU0FBU21CLE1BQVQsQ0FBVDtBQUNBLEtBQUlJLE9BQUo7O0FBRUEsTUFBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUkzSSxVQUFVVCxNQUE5QixFQUFzQ29KLEdBQXRDLEVBQTJDO0FBQzFDSCxTQUFPeEIsT0FBT2hILFVBQVUySSxDQUFWLENBQVAsQ0FBUDs7QUFFQSxPQUFLLElBQUlDLEdBQVQsSUFBZ0JKLElBQWhCLEVBQXNCO0FBQ3JCLE9BQUl2QyxlQUFlbEgsSUFBZixDQUFvQnlKLElBQXBCLEVBQTBCSSxHQUExQixDQUFKLEVBQW9DO0FBQ25DSCxPQUFHRyxHQUFILElBQVVKLEtBQUtJLEdBQUwsQ0FBVjtBQUNBO0FBQ0Q7O0FBRUQsTUFBSTdCLHFCQUFKLEVBQTJCO0FBQzFCMkIsYUFBVTNCLHNCQUFzQnlCLElBQXRCLENBQVY7QUFDQSxRQUFLLElBQUl2SSxJQUFJLENBQWIsRUFBZ0JBLElBQUl5SSxRQUFRbkosTUFBNUIsRUFBb0NVLEdBQXBDLEVBQXlDO0FBQ3hDLFFBQUlnSCxpQkFBaUJsSSxJQUFqQixDQUFzQnlKLElBQXRCLEVBQTRCRSxRQUFRekksQ0FBUixDQUE1QixDQUFKLEVBQTZDO0FBQzVDd0ksUUFBR0MsUUFBUXpJLENBQVIsQ0FBSCxJQUFpQnVJLEtBQUtFLFFBQVF6SSxDQUFSLENBQUwsQ0FBakI7QUFDQTtBQUNEO0FBQ0Q7QUFDRDs7QUFFRCxRQUFPd0ksRUFBUDtBQUNBLENBekJELEM7Ozs7Ozs7QUNoRUE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFjQSxJQUFJK1YscUJBQXFCLDhCQUFZLENBQUUsQ0FBdkM7O0FBRUEsSUFBSXRnQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJZ0IsZUFBZSxTQUFmQSxZQUFlLENBQVVqQixNQUFWLEVBQWtCO0FBQ25DLFNBQUssSUFBSWtCLE9BQU9qRCxVQUFVVCxNQUFyQixFQUE2Qk8sT0FBT0MsTUFBTWtELE9BQU8sQ0FBUCxHQUFXQSxPQUFPLENBQWxCLEdBQXNCLENBQTVCLENBQXBDLEVBQW9FQyxPQUFPLENBQWhGLEVBQW1GQSxPQUFPRCxJQUExRixFQUFnR0MsTUFBaEcsRUFBd0c7QUFDdEdwRCxXQUFLb0QsT0FBTyxDQUFaLElBQWlCbEQsVUFBVWtELElBQVYsQ0FBakI7QUFDRDs7QUFFRCxRQUFJUixXQUFXLENBQWY7QUFDQSxRQUFJUyxVQUFVLGNBQWNwQixPQUFPWSxPQUFQLENBQWUsS0FBZixFQUFzQixZQUFZO0FBQzVELGFBQU83QyxLQUFLNEMsVUFBTCxDQUFQO0FBQ0QsS0FGMkIsQ0FBNUI7QUFHQSxRQUFJLE9BQU9VLE9BQVAsS0FBbUIsV0FBdkIsRUFBb0M7QUFDbENBLGNBQVE2VSxJQUFSLENBQWE5VSxPQUFiO0FBQ0Q7QUFDRCxRQUFJO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsWUFBTSxJQUFJM0UsS0FBSixDQUFVMkUsT0FBVixDQUFOO0FBQ0QsS0FMRCxDQUtFLE9BQU9FLENBQVAsRUFBVSxDQUFFO0FBQ2YsR0FsQkQ7O0FBb0JBbWIsdUJBQXFCLDRCQUFVcmMsU0FBVixFQUFxQkosTUFBckIsRUFBNkI7QUFDaEQsUUFBSUEsV0FBV0UsU0FBZixFQUEwQjtBQUN4QixZQUFNLElBQUl6RCxLQUFKLENBQVUsOERBQThELGtCQUF4RSxDQUFOO0FBQ0Q7QUFDRCxRQUFJLENBQUMyRCxTQUFMLEVBQWdCO0FBQ2QsV0FBSyxJQUFJb0IsUUFBUXZELFVBQVVULE1BQXRCLEVBQThCTyxPQUFPQyxNQUFNd0QsUUFBUSxDQUFSLEdBQVlBLFFBQVEsQ0FBcEIsR0FBd0IsQ0FBOUIsQ0FBckMsRUFBdUVDLFFBQVEsQ0FBcEYsRUFBdUZBLFFBQVFELEtBQS9GLEVBQXNHQyxPQUF0RyxFQUErRztBQUM3RzFELGFBQUswRCxRQUFRLENBQWIsSUFBa0J4RCxVQUFVd0QsS0FBVixDQUFsQjtBQUNEOztBQUVEUixtQkFBYTFDLEtBQWIsQ0FBbUIyQixTQUFuQixFQUE4QixDQUFDRixNQUFELEVBQVN2QyxNQUFULENBQWdCTSxJQUFoQixDQUE5QjtBQUNEO0FBQ0YsR0FYRDtBQVlEOztBQUVEM0IsT0FBT0MsT0FBUCxHQUFpQm9nQixrQkFBakIsQzs7Ozs7Ozs7QUMvREE7Ozs7Ozs7OztBQVNBOztBQUVBLElBQUkrVix1QkFBdUIsOENBQTNCOztBQUVBcDJCLE9BQU9DLE9BQVAsR0FBaUJtMkIsb0JBQWpCLEM7Ozs7Ozs7QUNiQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl6d0IsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCOztBQUVBLElBQUlnaUIsa0JBQWtCLG1CQUFBaGlCLENBQVEsRUFBUixDQUF0Qjs7QUFFQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQTs7OztBQUlBOzs7O0FBSUEsSUFBSTB4QixhQUFKO0FBQ0EsSUFBSUMsYUFBSjtBQUNBLElBQUkxZixZQUFZO0FBQ2QyZix1QkFBcUIsNkJBQVVDLFFBQVYsRUFBb0I7QUFDdkNILG9CQUFnQkcsUUFBaEI7QUFDQSxRQUFJejJCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDOUQsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVE0eEIsWUFBWUEsU0FBUy90QixtQkFBckIsSUFBNEMrdEIsU0FBU2h1QixtQkFBN0QsRUFBa0YsbUVBQW1FLCtEQUFySixDQUF4QyxHQUFnUSxLQUFLLENBQXJRO0FBQ0Q7QUFDRixHQU5hO0FBT2RpdUIsdUJBQXFCLDZCQUFVRCxRQUFWLEVBQW9CO0FBQ3ZDRixvQkFBZ0JFLFFBQWhCO0FBQ0EsUUFBSXoyQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzlELGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRNHhCLFlBQVlBLFNBQVNFLFVBQXJCLElBQW1DRixTQUFTRyx1QkFBcEQsRUFBNkUsbUVBQW1FLDBEQUFoSixDQUF4QyxHQUFzUCxLQUFLLENBQTNQO0FBQ0Q7QUFDRjtBQVphLENBQWhCOztBQWVBLFNBQVNDLFFBQVQsQ0FBa0J4TyxZQUFsQixFQUFnQztBQUM5QixTQUFPQSxpQkFBaUIsWUFBakIsSUFBaUNBLGlCQUFpQixhQUFsRCxJQUFtRUEsaUJBQWlCLGdCQUEzRjtBQUNEOztBQUVELFNBQVN5TyxTQUFULENBQW1Cek8sWUFBbkIsRUFBaUM7QUFDL0IsU0FBT0EsaUJBQWlCLGNBQWpCLElBQW1DQSxpQkFBaUIsY0FBM0Q7QUFDRDtBQUNELFNBQVMwTyxVQUFULENBQW9CMU8sWUFBcEIsRUFBa0M7QUFDaEMsU0FBT0EsaUJBQWlCLGNBQWpCLElBQW1DQSxpQkFBaUIsZUFBM0Q7QUFDRDs7QUFFRCxJQUFJMk8sdUJBQUo7QUFDQSxJQUFJaDNCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDa3pCLDRCQUEwQixpQ0FBVXhmLEtBQVYsRUFBaUI7QUFDekMsUUFBSXlmLG9CQUFvQnpmLE1BQU1nTyxrQkFBOUI7QUFDQSxRQUFJMFIsb0JBQW9CMWYsTUFBTWlPLGtCQUE5Qjs7QUFFQSxRQUFJMFIsaUJBQWlCdDFCLE1BQU11MUIsT0FBTixDQUFjSCxpQkFBZCxDQUFyQjtBQUNBLFFBQUlJLGVBQWVGLGlCQUFpQkYsa0JBQWtCNTFCLE1BQW5DLEdBQTRDNDFCLG9CQUFvQixDQUFwQixHQUF3QixDQUF2Rjs7QUFFQSxRQUFJSyxpQkFBaUJ6MUIsTUFBTXUxQixPQUFOLENBQWNGLGlCQUFkLENBQXJCO0FBQ0EsUUFBSUssZUFBZUQsaUJBQWlCSixrQkFBa0I3MUIsTUFBbkMsR0FBNEM2MUIsb0JBQW9CLENBQXBCLEdBQXdCLENBQXZGOztBQUVBbDNCLFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFReXlCLG1CQUFtQkgsY0FBbkIsSUFBcUNJLGlCQUFpQkYsWUFBOUQsRUFBNEUsb0NBQTVFLENBQXhDLEdBQTRKLEtBQUssQ0FBaks7QUFDRCxHQVhEO0FBWUQ7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTRyxlQUFULENBQXlCaGdCLEtBQXpCLEVBQWdDd1AsU0FBaEMsRUFBMkN6QixRQUEzQyxFQUFxRHBlLElBQXJELEVBQTJEO0FBQ3pELE1BQUlzSCxPQUFPK0ksTUFBTS9JLElBQU4sSUFBYyxlQUF6QjtBQUNBK0ksUUFBTUwsYUFBTixHQUFzQjBOLGlCQUFpQm5jLG1CQUFqQixDQUFxQ3ZCLElBQXJDLENBQXRCO0FBQ0EsTUFBSTZmLFNBQUosRUFBZTtBQUNiSixvQkFBZ0I2USw4QkFBaEIsQ0FBK0NocEIsSUFBL0MsRUFBcUQ4VyxRQUFyRCxFQUErRC9OLEtBQS9EO0FBQ0QsR0FGRCxNQUVPO0FBQ0xvUCxvQkFBZ0I4USxxQkFBaEIsQ0FBc0NqcEIsSUFBdEMsRUFBNEM4VyxRQUE1QyxFQUFzRC9OLEtBQXREO0FBQ0Q7QUFDREEsUUFBTUwsYUFBTixHQUFzQixJQUF0QjtBQUNEOztBQUVEOzs7QUFHQSxTQUFTOFAsd0JBQVQsQ0FBa0N6UCxLQUFsQyxFQUF5Q3dQLFNBQXpDLEVBQW9EO0FBQ2xELE1BQUlpUSxvQkFBb0J6ZixNQUFNZ08sa0JBQTlCO0FBQ0EsTUFBSTBSLG9CQUFvQjFmLE1BQU1pTyxrQkFBOUI7QUFDQSxNQUFJemxCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDa3pCLDRCQUF3QnhmLEtBQXhCO0FBQ0Q7QUFDRCxNQUFJM1YsTUFBTXUxQixPQUFOLENBQWNILGlCQUFkLENBQUosRUFBc0M7QUFDcEMsU0FBSyxJQUFJbDFCLElBQUksQ0FBYixFQUFnQkEsSUFBSWsxQixrQkFBa0I1MUIsTUFBdEMsRUFBOENVLEdBQTlDLEVBQW1EO0FBQ2pELFVBQUl5VixNQUFNbUIsb0JBQU4sRUFBSixFQUFrQztBQUNoQztBQUNEO0FBQ0Q7QUFDQTZlLHNCQUFnQmhnQixLQUFoQixFQUF1QndQLFNBQXZCLEVBQWtDaVEsa0JBQWtCbDFCLENBQWxCLENBQWxDLEVBQXdEbTFCLGtCQUFrQm4xQixDQUFsQixDQUF4RDtBQUNEO0FBQ0YsR0FSRCxNQVFPLElBQUlrMUIsaUJBQUosRUFBdUI7QUFDNUJPLG9CQUFnQmhnQixLQUFoQixFQUF1QndQLFNBQXZCLEVBQWtDaVEsaUJBQWxDLEVBQXFEQyxpQkFBckQ7QUFDRDtBQUNEMWYsUUFBTWdPLGtCQUFOLEdBQTJCLElBQTNCO0FBQ0FoTyxRQUFNaU8sa0JBQU4sR0FBMkIsSUFBM0I7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVNrUyxzQ0FBVCxDQUFnRG5nQixLQUFoRCxFQUF1RDtBQUNyRCxNQUFJeWYsb0JBQW9CemYsTUFBTWdPLGtCQUE5QjtBQUNBLE1BQUkwUixvQkFBb0IxZixNQUFNaU8sa0JBQTlCO0FBQ0EsTUFBSXpsQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q2t6Qiw0QkFBd0J4ZixLQUF4QjtBQUNEO0FBQ0QsTUFBSTNWLE1BQU11MUIsT0FBTixDQUFjSCxpQkFBZCxDQUFKLEVBQXNDO0FBQ3BDLFNBQUssSUFBSWwxQixJQUFJLENBQWIsRUFBZ0JBLElBQUlrMUIsa0JBQWtCNTFCLE1BQXRDLEVBQThDVSxHQUE5QyxFQUFtRDtBQUNqRCxVQUFJeVYsTUFBTW1CLG9CQUFOLEVBQUosRUFBa0M7QUFDaEM7QUFDRDtBQUNEO0FBQ0EsVUFBSXNlLGtCQUFrQmwxQixDQUFsQixFQUFxQnlWLEtBQXJCLEVBQTRCMGYsa0JBQWtCbjFCLENBQWxCLENBQTVCLENBQUosRUFBdUQ7QUFDckQsZUFBT20xQixrQkFBa0JuMUIsQ0FBbEIsQ0FBUDtBQUNEO0FBQ0Y7QUFDRixHQVZELE1BVU8sSUFBSWsxQixpQkFBSixFQUF1QjtBQUM1QixRQUFJQSxrQkFBa0J6ZixLQUFsQixFQUF5QjBmLGlCQUF6QixDQUFKLEVBQWlEO0FBQy9DLGFBQU9BLGlCQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU8sSUFBUDtBQUNEOztBQUVEOzs7QUFHQSxTQUFTVSxrQ0FBVCxDQUE0Q3BnQixLQUE1QyxFQUFtRDtBQUNqRCxNQUFJc1YsTUFBTTZLLHVDQUF1Q25nQixLQUF2QyxDQUFWO0FBQ0FBLFFBQU1pTyxrQkFBTixHQUEyQixJQUEzQjtBQUNBak8sUUFBTWdPLGtCQUFOLEdBQTJCLElBQTNCO0FBQ0EsU0FBT3NILEdBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBUytLLHFCQUFULENBQStCcmdCLEtBQS9CLEVBQXNDO0FBQ3BDLE1BQUl4WCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q2t6Qiw0QkFBd0J4ZixLQUF4QjtBQUNEO0FBQ0QsTUFBSXNnQixtQkFBbUJ0Z0IsTUFBTWdPLGtCQUE3QjtBQUNBLE1BQUl1UyxtQkFBbUJ2Z0IsTUFBTWlPLGtCQUE3QjtBQUNBLEdBQUMsQ0FBQzVqQixNQUFNdTFCLE9BQU4sQ0FBY1UsZ0JBQWQsQ0FBRixHQUFvQzkzQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLDhDQUFqQixDQUF4QyxHQUEyRzRCLGVBQWUsS0FBZixDQUEvSSxHQUF1SyxLQUFLLENBQTVLO0FBQ0E0UixRQUFNTCxhQUFOLEdBQXNCMmdCLG1CQUFtQmpULGlCQUFpQm5jLG1CQUFqQixDQUFxQ3F2QixnQkFBckMsQ0FBbkIsR0FBNEUsSUFBbEc7QUFDQSxNQUFJQyxNQUFNRixtQkFBbUJBLGlCQUFpQnRnQixLQUFqQixDQUFuQixHQUE2QyxJQUF2RDtBQUNBQSxRQUFNTCxhQUFOLEdBQXNCLElBQXRCO0FBQ0FLLFFBQU1nTyxrQkFBTixHQUEyQixJQUEzQjtBQUNBaE8sUUFBTWlPLGtCQUFOLEdBQTJCLElBQTNCO0FBQ0EsU0FBT3VTLEdBQVA7QUFDRDs7QUFFRDs7OztBQUlBLFNBQVNDLGFBQVQsQ0FBdUJ6Z0IsS0FBdkIsRUFBOEI7QUFDNUIsU0FBTyxDQUFDLENBQUNBLE1BQU1nTyxrQkFBZjtBQUNEOztBQUVEOzs7QUFHQSxJQUFJWCxtQkFBbUI7QUFDckJnUyxZQUFVQSxRQURXO0FBRXJCQyxhQUFXQSxTQUZVO0FBR3JCQyxjQUFZQSxVQUhTOztBQUtyQmMseUJBQXVCQSxxQkFMRjtBQU1yQjVRLDRCQUEwQkEsd0JBTkw7QUFPckIyUSxzQ0FBb0NBLGtDQVBmO0FBUXJCSyxpQkFBZUEsYUFSTTs7QUFVckJ4dkIsdUJBQXFCLDZCQUFVakMsSUFBVixFQUFnQjtBQUNuQyxXQUFPOHZCLGNBQWM3dEIsbUJBQWQsQ0FBa0NqQyxJQUFsQyxDQUFQO0FBQ0QsR0Fab0I7QUFhckJrQyx1QkFBcUIsNkJBQVVsQyxJQUFWLEVBQWdCO0FBQ25DLFdBQU84dkIsY0FBYzV0QixtQkFBZCxDQUFrQ2xDLElBQWxDLENBQVA7QUFDRCxHQWZvQjtBQWdCckJtd0IsY0FBWSxvQkFBVXp5QixDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFDMUIsV0FBT295QixjQUFjSSxVQUFkLENBQXlCenlCLENBQXpCLEVBQTRCQyxDQUE1QixDQUFQO0FBQ0QsR0FsQm9CO0FBbUJyQnl5QiwyQkFBeUIsaUNBQVUxeUIsQ0FBVixFQUFhQyxDQUFiLEVBQWdCO0FBQ3ZDLFdBQU9veUIsY0FBY0ssdUJBQWQsQ0FBc0MxeUIsQ0FBdEMsRUFBeUNDLENBQXpDLENBQVA7QUFDRCxHQXJCb0I7QUFzQnJCMmhCLHFCQUFtQiwyQkFBVTNlLElBQVYsRUFBZ0I7QUFDakMsV0FBT292QixjQUFjelEsaUJBQWQsQ0FBZ0MzZSxJQUFoQyxDQUFQO0FBQ0QsR0F4Qm9CO0FBeUJyQndlLG9CQUFrQiwwQkFBVXZiLE1BQVYsRUFBa0IrQixFQUFsQixFQUFzQnNGLEdBQXRCLEVBQTJCO0FBQzNDLFdBQU84a0IsY0FBYzVRLGdCQUFkLENBQStCdmIsTUFBL0IsRUFBdUMrQixFQUF2QyxFQUEyQ3NGLEdBQTNDLENBQVA7QUFDRCxHQTNCb0I7QUE0QnJCK1Usc0JBQW9CLDRCQUFVbGMsSUFBVixFQUFnQkMsRUFBaEIsRUFBb0I0QixFQUFwQixFQUF3QityQixPQUF4QixFQUFpQ0MsS0FBakMsRUFBd0M7QUFDMUQsV0FBTzVCLGNBQWMvUCxrQkFBZCxDQUFpQ2xjLElBQWpDLEVBQXVDQyxFQUF2QyxFQUEyQzRCLEVBQTNDLEVBQStDK3JCLE9BQS9DLEVBQXdEQyxLQUF4RCxDQUFQO0FBQ0QsR0E5Qm9COztBQWdDckJ0aEIsYUFBV0E7QUFoQ1UsQ0FBdkI7O0FBbUNBNVcsT0FBT0MsT0FBUCxHQUFpQjJrQixnQkFBakIsQzs7Ozs7Ozs7QUNoT0E7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUEsSUFBSXVULGNBQWMsSUFBbEI7O0FBRUE7Ozs7Ozs7O0FBUUEsU0FBU1YscUJBQVQsQ0FBK0JwMEIsSUFBL0IsRUFBcUMrMEIsSUFBckMsRUFBMkNuMEIsQ0FBM0MsRUFBOEM7QUFDNUMsTUFBSTtBQUNGbTBCLFNBQUtuMEIsQ0FBTDtBQUNELEdBRkQsQ0FFRSxPQUFPaUIsQ0FBUCxFQUFVO0FBQ1YsUUFBSWl6QixnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEJBLG9CQUFjanpCLENBQWQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsSUFBSXloQixrQkFBa0I7QUFDcEI4USx5QkFBdUJBLHFCQURIOztBQUdwQjs7OztBQUlBRCxrQ0FBZ0NDLHFCQVBaOztBQVNwQjs7OztBQUlBOU8sc0JBQW9CLDhCQUFZO0FBQzlCLFFBQUl3UCxXQUFKLEVBQWlCO0FBQ2YsVUFBSTd6QixRQUFRNnpCLFdBQVo7QUFDQUEsb0JBQWMsSUFBZDtBQUNBLFlBQU03ekIsS0FBTjtBQUNEO0FBQ0Y7QUFuQm1CLENBQXRCOztBQXNCQSxJQUFJdkUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM7Ozs7QUFJQSxNQUFJLE9BQU84RyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDLE9BQU9BLE9BQU8wdEIsYUFBZCxLQUFnQyxVQUFqRSxJQUErRSxPQUFPenRCLFFBQVAsS0FBb0IsV0FBbkcsSUFBa0gsT0FBT0EsU0FBU2tyQixXQUFoQixLQUFnQyxVQUF0SixFQUFrSztBQUNoSyxRQUFJd0MsV0FBVzF0QixTQUFTQyxhQUFULENBQXVCLE9BQXZCLENBQWY7QUFDQThiLG9CQUFnQjhRLHFCQUFoQixHQUF3QyxVQUFVcDBCLElBQVYsRUFBZ0IrMEIsSUFBaEIsRUFBc0JuMEIsQ0FBdEIsRUFBeUI7QUFDL0QsVUFBSXMwQixZQUFZSCxLQUFLOVosSUFBTCxDQUFVLElBQVYsRUFBZ0JyYSxDQUFoQixDQUFoQjtBQUNBLFVBQUl1MEIsVUFBVSxXQUFXbjFCLElBQXpCO0FBQ0FpMUIsZUFBU3B0QixnQkFBVCxDQUEwQnN0QixPQUExQixFQUFtQ0QsU0FBbkMsRUFBOEMsS0FBOUM7QUFDQSxVQUFJRSxNQUFNN3RCLFNBQVNrckIsV0FBVCxDQUFxQixPQUFyQixDQUFWO0FBQ0EyQyxVQUFJQyxTQUFKLENBQWNGLE9BQWQsRUFBdUIsS0FBdkIsRUFBOEIsS0FBOUI7QUFDQUYsZUFBU0QsYUFBVCxDQUF1QkksR0FBdkI7QUFDQUgsZUFBU0ssbUJBQVQsQ0FBNkJILE9BQTdCLEVBQXNDRCxTQUF0QyxFQUFpRCxLQUFqRDtBQUNELEtBUkQ7QUFTRDtBQUNGOztBQUVEdjRCLE9BQU9DLE9BQVAsR0FBaUIwbUIsZUFBakIsQzs7Ozs7Ozs7QUMxRUE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7Ozs7Ozs7QUFRQSxTQUFTbUMsY0FBVCxDQUF3Qi9RLFdBQXhCLEVBQXFDO0FBQ25DLE1BQUk1TixTQUFTNE4sWUFBWTVOLE1BQVosSUFBc0I0TixZQUFZb1csVUFBbEMsSUFBZ0R4akIsTUFBN0Q7O0FBRUE7QUFDQSxNQUFJUixPQUFPeXVCLHVCQUFYLEVBQW9DO0FBQ2xDenVCLGFBQVNBLE9BQU95dUIsdUJBQWhCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFNBQU96dUIsT0FBTzFELFFBQVAsS0FBb0IsQ0FBcEIsR0FBd0IwRCxPQUFPOUIsVUFBL0IsR0FBNEM4QixNQUFuRDtBQUNEOztBQUVEbkssT0FBT0MsT0FBUCxHQUFpQjZvQixjQUFqQixDOzs7Ozs7O0FDakNBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSWhlLHVCQUF1QixtQkFBQW5HLENBQVEsQ0FBUixDQUEzQjs7QUFFQSxJQUFJazBCLGFBQUo7QUFDQSxJQUFJL3RCLHFCQUFxQkosU0FBekIsRUFBb0M7QUFDbENtdUIsa0JBQWdCanVCLFNBQVNrdUIsY0FBVCxJQUEyQmx1QixTQUFTa3VCLGNBQVQsQ0FBd0JDLFVBQW5EO0FBQ2hCO0FBQ0E7QUFDQW51QixXQUFTa3VCLGNBQVQsQ0FBd0JDLFVBQXhCLENBQW1DLEVBQW5DLEVBQXVDLEVBQXZDLE1BQStDLElBSC9DO0FBSUQ7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FBY0EsU0FBUzVJLGdCQUFULENBQTBCNkksZUFBMUIsRUFBMkNDLE9BQTNDLEVBQW9EO0FBQ2xELE1BQUksQ0FBQ251QixxQkFBcUJKLFNBQXRCLElBQW1DdXVCLFdBQVcsRUFBRSxzQkFBc0JydUIsUUFBeEIsQ0FBbEQsRUFBcUY7QUFDbkYsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsTUFBSTBnQixZQUFZLE9BQU8wTixlQUF2QjtBQUNBLE1BQUlFLGNBQWM1TixhQUFhMWdCLFFBQS9COztBQUVBLE1BQUksQ0FBQ3N1QixXQUFMLEVBQWtCO0FBQ2hCLFFBQUkzcUIsVUFBVTNELFNBQVNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZDtBQUNBMEQsWUFBUTRxQixZQUFSLENBQXFCN04sU0FBckIsRUFBZ0MsU0FBaEM7QUFDQTROLGtCQUFjLE9BQU8zcUIsUUFBUStjLFNBQVIsQ0FBUCxLQUE4QixVQUE1QztBQUNEOztBQUVELE1BQUksQ0FBQzROLFdBQUQsSUFBZ0JMLGFBQWhCLElBQWlDRyxvQkFBb0IsT0FBekQsRUFBa0U7QUFDaEU7QUFDQUUsa0JBQWN0dUIsU0FBU2t1QixjQUFULENBQXdCQyxVQUF4QixDQUFtQyxjQUFuQyxFQUFtRCxLQUFuRCxDQUFkO0FBQ0Q7O0FBRUQsU0FBT0csV0FBUDtBQUNEOztBQUVEbDVCLE9BQU9DLE9BQVAsR0FBaUJrd0IsZ0JBQWpCLEM7Ozs7Ozs7QUMxREE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7Ozs7QUFLQSxJQUFJaUosb0JBQW9CO0FBQ3RCQyxPQUFLLFFBRGlCO0FBRXRCQyxXQUFTLFNBRmE7QUFHdEJDLFFBQU0sU0FIZ0I7QUFJdEJDLFNBQU87QUFKZSxDQUF4Qjs7QUFPQTtBQUNBO0FBQ0E7QUFDQSxTQUFTQyxtQkFBVCxDQUE2QkMsTUFBN0IsRUFBcUM7QUFDbkMsTUFBSUMsaUJBQWlCLElBQXJCO0FBQ0EsTUFBSTVoQixjQUFjNGhCLGVBQWU1aEIsV0FBakM7QUFDQSxNQUFJQSxZQUFZK1YsZ0JBQWhCLEVBQWtDO0FBQ2hDLFdBQU8vVixZQUFZK1YsZ0JBQVosQ0FBNkI0TCxNQUE3QixDQUFQO0FBQ0Q7QUFDRCxNQUFJRSxVQUFVUixrQkFBa0JNLE1BQWxCLENBQWQ7QUFDQSxTQUFPRSxVQUFVLENBQUMsQ0FBQzdoQixZQUFZNmhCLE9BQVosQ0FBWixHQUFtQyxLQUExQztBQUNEOztBQUVELFNBQVN4TSxxQkFBVCxDQUErQnJWLFdBQS9CLEVBQTRDO0FBQzFDLFNBQU8waEIsbUJBQVA7QUFDRDs7QUFFRHo1QixPQUFPQyxPQUFQLEdBQWlCbXRCLHFCQUFqQixDOzs7Ozs7O0FDekNBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSTFJLGNBQWMsbUJBQUEvZixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJazFCLFNBQVMsbUJBQUFsMUIsQ0FBUSxHQUFSLENBQWI7QUFDQSxJQUFJZ0Usd0JBQXdCLG1CQUFBaEUsQ0FBUSxDQUFSLENBQTVCO0FBQ0EsSUFBSStjLHVCQUF1QixtQkFBQS9jLENBQVEsRUFBUixDQUEzQjs7QUFFQSxJQUFJcWUscUNBQXFDLG1CQUFBcmUsQ0FBUSxFQUFSLENBQXpDO0FBQ0EsSUFBSW9lLGVBQWUsbUJBQUFwZSxDQUFRLEVBQVIsQ0FBbkI7QUFDQSxJQUFJc2UsaUJBQWlCLG1CQUFBdGUsQ0FBUSxFQUFSLENBQXJCOztBQUVBLFNBQVNtMUIsWUFBVCxDQUFzQnp4QixVQUF0QixFQUFrQzlCLElBQWxDLEVBQXdDO0FBQ3RDO0FBQ0E7QUFDQSxNQUFJM0UsTUFBTXUxQixPQUFOLENBQWM1d0IsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCQSxXQUFPQSxLQUFLLENBQUwsQ0FBUDtBQUNEO0FBQ0QsU0FBT0EsT0FBT0EsS0FBSzJCLFdBQVosR0FBMEJHLFdBQVdULFVBQTVDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsSUFBSW15QixnQkFBZ0IvVyxtQ0FBbUMsVUFBVTNhLFVBQVYsRUFBc0JWLFNBQXRCLEVBQWlDaWMsYUFBakMsRUFBZ0Q7QUFDckc7QUFDQTtBQUNBO0FBQ0F2YixhQUFXMGIsWUFBWCxDQUF3QnBjLFNBQXhCLEVBQW1DaWMsYUFBbkM7QUFDRCxDQUxtQixDQUFwQjs7QUFPQSxTQUFTb1cscUJBQVQsQ0FBK0IzeEIsVUFBL0IsRUFBMkNpYyxTQUEzQyxFQUFzRFYsYUFBdEQsRUFBcUU7QUFDbkVjLGNBQVloQixnQkFBWixDQUE2QnJiLFVBQTdCLEVBQXlDaWMsU0FBekMsRUFBb0RWLGFBQXBEO0FBQ0Q7O0FBRUQsU0FBU3FXLFNBQVQsQ0FBbUI1eEIsVUFBbkIsRUFBK0JWLFNBQS9CLEVBQTBDaWMsYUFBMUMsRUFBeUQ7QUFDdkQsTUFBSWhpQixNQUFNdTFCLE9BQU4sQ0FBY3h2QixTQUFkLENBQUosRUFBOEI7QUFDNUJ1eUIsc0JBQWtCN3hCLFVBQWxCLEVBQThCVixVQUFVLENBQVYsQ0FBOUIsRUFBNENBLFVBQVUsQ0FBVixDQUE1QyxFQUEwRGljLGFBQTFEO0FBQ0QsR0FGRCxNQUVPO0FBQ0xtVyxrQkFBYzF4QixVQUFkLEVBQTBCVixTQUExQixFQUFxQ2ljLGFBQXJDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTdUwsV0FBVCxDQUFxQjltQixVQUFyQixFQUFpQ1YsU0FBakMsRUFBNEM7QUFDMUMsTUFBSS9GLE1BQU11MUIsT0FBTixDQUFjeHZCLFNBQWQsQ0FBSixFQUE4QjtBQUM1QixRQUFJd3lCLGlCQUFpQnh5QixVQUFVLENBQVYsQ0FBckI7QUFDQUEsZ0JBQVlBLFVBQVUsQ0FBVixDQUFaO0FBQ0F5eUIsd0JBQW9CL3hCLFVBQXBCLEVBQWdDVixTQUFoQyxFQUEyQ3d5QixjQUEzQztBQUNBOXhCLGVBQVc4bUIsV0FBWCxDQUF1QmdMLGNBQXZCO0FBQ0Q7QUFDRDl4QixhQUFXOG1CLFdBQVgsQ0FBdUJ4bkIsU0FBdkI7QUFDRDs7QUFFRCxTQUFTdXlCLGlCQUFULENBQTJCN3hCLFVBQTNCLEVBQXVDZ3lCLGNBQXZDLEVBQXVERixjQUF2RCxFQUF1RXZXLGFBQXZFLEVBQXNGO0FBQ3BGLE1BQUlyZCxPQUFPOHpCLGNBQVg7QUFDQSxTQUFPLElBQVAsRUFBYTtBQUNYLFFBQUlDLFdBQVcvekIsS0FBSzJCLFdBQXBCO0FBQ0E2eEIsa0JBQWMxeEIsVUFBZCxFQUEwQjlCLElBQTFCLEVBQWdDcWQsYUFBaEM7QUFDQSxRQUFJcmQsU0FBUzR6QixjQUFiLEVBQTZCO0FBQzNCO0FBQ0Q7QUFDRDV6QixXQUFPK3pCLFFBQVA7QUFDRDtBQUNGOztBQUVELFNBQVNGLG1CQUFULENBQTZCL3hCLFVBQTdCLEVBQXlDa3lCLFNBQXpDLEVBQW9ESixjQUFwRCxFQUFvRTtBQUNsRSxTQUFPLElBQVAsRUFBYTtBQUNYLFFBQUk1ekIsT0FBT2cwQixVQUFVcnlCLFdBQXJCO0FBQ0EsUUFBSTNCLFNBQVM0ekIsY0FBYixFQUE2QjtBQUMzQjtBQUNBO0FBQ0QsS0FIRCxNQUdPO0FBQ0w5eEIsaUJBQVc4bUIsV0FBWCxDQUF1QjVvQixJQUF2QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTaTBCLG9CQUFULENBQThCSCxjQUE5QixFQUE4Q0YsY0FBOUMsRUFBOERNLFVBQTlELEVBQTBFO0FBQ3hFLE1BQUlweUIsYUFBYWd5QixlQUFlaHlCLFVBQWhDO0FBQ0EsTUFBSXF5QixtQkFBbUJMLGVBQWVueUIsV0FBdEM7QUFDQSxNQUFJd3lCLHFCQUFxQlAsY0FBekIsRUFBeUM7QUFDdkM7QUFDQTtBQUNBLFFBQUlNLFVBQUosRUFBZ0I7QUFDZFYsb0JBQWMxeEIsVUFBZCxFQUEwQnVDLFNBQVMrdkIsY0FBVCxDQUF3QkYsVUFBeEIsQ0FBMUIsRUFBK0RDLGdCQUEvRDtBQUNEO0FBQ0YsR0FORCxNQU1PO0FBQ0wsUUFBSUQsVUFBSixFQUFnQjtBQUNkO0FBQ0E7QUFDQXhYLHFCQUFleVgsZ0JBQWYsRUFBaUNELFVBQWpDO0FBQ0FMLDBCQUFvQi94QixVQUFwQixFQUFnQ3F5QixnQkFBaEMsRUFBa0RQLGNBQWxEO0FBQ0QsS0FMRCxNQUtPO0FBQ0xDLDBCQUFvQi94QixVQUFwQixFQUFnQ2d5QixjQUFoQyxFQUFnREYsY0FBaEQ7QUFDRDtBQUNGOztBQUVELE1BQUlwNkIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM2ZCx5QkFBcUIzUCxTQUFyQixDQUErQjZvQixlQUEvQixDQUErQztBQUM3Q0Msa0JBQVlseUIsc0JBQXNCSCxtQkFBdEIsQ0FBMEM2eEIsY0FBMUMsRUFBMEQ3cEIsUUFEekI7QUFFN0NoQyxZQUFNLGNBRnVDO0FBRzdDc3NCLGVBQVNMO0FBSG9DLEtBQS9DO0FBS0Q7QUFDRjs7QUFFRCxJQUFJTSxtQ0FBbUNsQixPQUFPa0IsZ0NBQTlDO0FBQ0EsSUFBSWg3QixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q2szQixxQ0FBbUMsMENBQVVDLFFBQVYsRUFBb0IvWSxNQUFwQixFQUE0QmdaLFlBQTVCLEVBQTBDO0FBQzNFcEIsV0FBT2tCLGdDQUFQLENBQXdDQyxRQUF4QyxFQUFrRC9ZLE1BQWxEO0FBQ0EsUUFBSWdaLGFBQWF6cUIsUUFBYixLQUEwQixDQUE5QixFQUFpQztBQUMvQmtSLDJCQUFxQjNQLFNBQXJCLENBQStCNm9CLGVBQS9CLENBQStDO0FBQzdDQyxvQkFBWUksYUFBYXpxQixRQURvQjtBQUU3Q2hDLGNBQU0sY0FGdUM7QUFHN0Nzc0IsaUJBQVM3WSxPQUFPN2IsUUFBUDtBQUhvQyxPQUEvQztBQUtELEtBTkQsTUFNTztBQUNMLFVBQUk4MEIsZUFBZXZ5QixzQkFBc0JILG1CQUF0QixDQUEwQ3laLE9BQU8xYixJQUFqRCxDQUFuQjtBQUNBLFVBQUkyMEIsYUFBYTFxQixRQUFiLEtBQTBCLENBQTlCLEVBQWlDO0FBQy9Ca1IsNkJBQXFCM1AsU0FBckIsQ0FBK0I2b0IsZUFBL0IsQ0FBK0M7QUFDN0NDLHNCQUFZSyxhQUFhMXFCLFFBRG9CO0FBRTdDaEMsZ0JBQU0sT0FGdUM7QUFHN0Nzc0IsbUJBQVM3WSxPQUFPN2IsUUFBUDtBQUhvQyxTQUEvQztBQUtEO0FBQ0Y7QUFDRixHQWxCRDtBQW1CRDs7QUFFRDs7O0FBR0EsSUFBSSswQix3QkFBd0I7QUFDMUJKLG9DQUFrQ0EsZ0NBRFI7O0FBRzFCUCx3QkFBc0JBLG9CQUhJOztBQUsxQjs7Ozs7OztBQU9BWSxrQkFBZ0Isd0JBQVUveUIsVUFBVixFQUFzQmd6QixPQUF0QixFQUErQjtBQUM3QyxRQUFJdDdCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUl5M0Isb0JBQW9CM3lCLHNCQUFzQkgsbUJBQXRCLENBQTBDSCxVQUExQyxFQUFzRG1JLFFBQTlFO0FBQ0Q7O0FBRUQsU0FBSyxJQUFJK3FCLElBQUksQ0FBYixFQUFnQkEsSUFBSUYsUUFBUWo2QixNQUE1QixFQUFvQ202QixHQUFwQyxFQUF5QztBQUN2QyxVQUFJQyxTQUFTSCxRQUFRRSxDQUFSLENBQWI7QUFDQSxjQUFRQyxPQUFPaHRCLElBQWY7QUFDRSxhQUFLLGVBQUw7QUFDRXdyQixnQ0FBc0IzeEIsVUFBdEIsRUFBa0NtekIsT0FBT0MsT0FBekMsRUFBa0QzQixhQUFhenhCLFVBQWIsRUFBeUJtekIsT0FBT0UsU0FBaEMsQ0FBbEQ7QUFDQSxjQUFJMzdCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNmQsaUNBQXFCM1AsU0FBckIsQ0FBK0I2b0IsZUFBL0IsQ0FBK0M7QUFDN0NDLDBCQUFZUyxpQkFEaUM7QUFFN0M5c0Isb0JBQU0sY0FGdUM7QUFHN0Nzc0IsdUJBQVM7QUFDUGEseUJBQVNILE9BQU9HLE9BRFQ7QUFFUEYseUJBQVNELE9BQU9DLE9BQVAsQ0FBZXIxQixRQUFmO0FBRkY7QUFIb0MsYUFBL0M7QUFRRDtBQUNEO0FBQ0YsYUFBSyxlQUFMO0FBQ0U2ekIsb0JBQVU1eEIsVUFBVixFQUFzQm16QixPQUFPSSxRQUE3QixFQUF1QzlCLGFBQWF6eEIsVUFBYixFQUF5Qm16QixPQUFPRSxTQUFoQyxDQUF2QztBQUNBLGNBQUkzN0IsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM2ZCxpQ0FBcUIzUCxTQUFyQixDQUErQjZvQixlQUEvQixDQUErQztBQUM3Q0MsMEJBQVlTLGlCQURpQztBQUU3QzlzQixvQkFBTSxZQUZ1QztBQUc3Q3NzQix1QkFBUyxFQUFFZSxXQUFXTCxPQUFPSyxTQUFwQixFQUErQkYsU0FBU0gsT0FBT0csT0FBL0M7QUFIb0MsYUFBL0M7QUFLRDtBQUNEO0FBQ0YsYUFBSyxZQUFMO0FBQ0U1WSx1QkFBYTFhLFVBQWIsRUFBeUJtekIsT0FBT0MsT0FBaEM7QUFDQSxjQUFJMTdCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNmQsaUNBQXFCM1AsU0FBckIsQ0FBK0I2b0IsZUFBL0IsQ0FBK0M7QUFDN0NDLDBCQUFZUyxpQkFEaUM7QUFFN0M5c0Isb0JBQU0sa0JBRnVDO0FBRzdDc3NCLHVCQUFTVSxPQUFPQyxPQUFQLENBQWVyMUIsUUFBZjtBQUhvQyxhQUEvQztBQUtEO0FBQ0Q7QUFDRixhQUFLLGNBQUw7QUFDRTZjLHlCQUFlNWEsVUFBZixFQUEyQm16QixPQUFPQyxPQUFsQztBQUNBLGNBQUkxN0IsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM2ZCxpQ0FBcUIzUCxTQUFyQixDQUErQjZvQixlQUEvQixDQUErQztBQUM3Q0MsMEJBQVlTLGlCQURpQztBQUU3QzlzQixvQkFBTSxjQUZ1QztBQUc3Q3NzQix1QkFBU1UsT0FBT0MsT0FBUCxDQUFlcjFCLFFBQWY7QUFIb0MsYUFBL0M7QUFLRDtBQUNEO0FBQ0YsYUFBSyxhQUFMO0FBQ0Urb0Isc0JBQVk5bUIsVUFBWixFQUF3Qm16QixPQUFPSSxRQUEvQjtBQUNBLGNBQUk3N0IsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM2ZCxpQ0FBcUIzUCxTQUFyQixDQUErQjZvQixlQUEvQixDQUErQztBQUM3Q0MsMEJBQVlTLGlCQURpQztBQUU3QzlzQixvQkFBTSxjQUZ1QztBQUc3Q3NzQix1QkFBUyxFQUFFZSxXQUFXTCxPQUFPSyxTQUFwQjtBQUhvQyxhQUEvQztBQUtEO0FBQ0Q7QUFyREo7QUF1REQ7QUFDRjtBQTNFeUIsQ0FBNUI7O0FBOEVBNzdCLE9BQU9DLE9BQVAsR0FBaUJrN0IscUJBQWpCLEM7Ozs7Ozs7O0FDaE9BOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSXJZLGdCQUFnQjtBQUNsQmEsUUFBTSw4QkFEWTtBQUVsQm1ZLFVBQVEsb0NBRlU7QUFHbEJqTixPQUFLO0FBSGEsQ0FBcEI7O0FBTUE3dUIsT0FBT0MsT0FBUCxHQUFpQjZpQixhQUFqQixDOzs7Ozs7O0FDbEJBOzs7Ozs7Ozs7O0FBVUE7O0FBRUE7O0FBRUE7Ozs7QUFJQSxJQUFJRSxxQ0FBcUMsU0FBckNBLGtDQUFxQyxDQUFVb1YsSUFBVixFQUFnQjtBQUN2RCxNQUFJLE9BQU8yRCxLQUFQLEtBQWlCLFdBQWpCLElBQWdDQSxNQUFNQyx1QkFBMUMsRUFBbUU7QUFDakUsV0FBTyxVQUFVQyxJQUFWLEVBQWdCQyxJQUFoQixFQUFzQkMsSUFBdEIsRUFBNEJDLElBQTVCLEVBQWtDO0FBQ3ZDTCxZQUFNQyx1QkFBTixDQUE4QixZQUFZO0FBQ3hDLGVBQU81RCxLQUFLNkQsSUFBTCxFQUFXQyxJQUFYLEVBQWlCQyxJQUFqQixFQUF1QkMsSUFBdkIsQ0FBUDtBQUNELE9BRkQ7QUFHRCxLQUpEO0FBS0QsR0FORCxNQU1PO0FBQ0wsV0FBT2hFLElBQVA7QUFDRDtBQUNGLENBVkQ7O0FBWUFwNEIsT0FBT0MsT0FBUCxHQUFpQitpQixrQ0FBakIsQzs7Ozs7OztBQzlCQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlyZCxpQkFBaUIsbUJBQUFoQixDQUFRLENBQVIsQ0FBckI7O0FBRUEsSUFBSXl4Qix1QkFBdUIsbUJBQUF6eEIsQ0FBUSxFQUFSLENBQTNCO0FBQ0EsSUFBSTAzQixtQkFBbUIsbUJBQUExM0IsQ0FBUSxFQUFSLENBQXZCOztBQUVBLElBQUlrYyxRQUFRLG1CQUFBbGMsQ0FBUSxFQUFSLENBQVo7QUFDQSxJQUFJeWMsWUFBWWliLGlCQUFpQnhiLE1BQU16TyxjQUF2QixDQUFoQjs7QUFFQSxJQUFJck8sWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCO0FBQ0EsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUEsSUFBSTIzQixtQkFBbUI7QUFDckJ2TyxVQUFRLElBRGE7QUFFckJ3TyxZQUFVLElBRlc7QUFHckJDLFNBQU8sSUFIYztBQUlyQkMsVUFBUSxJQUphO0FBS3JCQyxTQUFPLElBTGM7QUFNckIzb0IsU0FBTyxJQU5jO0FBT3JCNG9CLFVBQVE7QUFQYSxDQUF2Qjs7QUFVQSxTQUFTQyxpQkFBVCxDQUEyQkMsVUFBM0IsRUFBdUM7QUFDckMsSUFBRUEsV0FBV0MsV0FBWCxJQUEwQixJQUExQixJQUFrQ0QsV0FBV0UsU0FBWCxJQUF3QixJQUE1RCxJQUFvRWg5QixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHlJQUFqQixDQUF4QyxHQUFzTTRCLGVBQWUsSUFBZixDQUExUSxHQUFpUyxLQUFLLENBQXRTO0FBQ0Q7QUFDRCxTQUFTcTNCLGdCQUFULENBQTBCSCxVQUExQixFQUFzQztBQUNwQ0Qsb0JBQWtCQyxVQUFsQjtBQUNBLElBQUVBLFdBQVd6akIsS0FBWCxJQUFvQixJQUFwQixJQUE0QnlqQixXQUFXSSxRQUFYLElBQXVCLElBQXJELElBQTZEbDlCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsNElBQWpCLENBQXhDLEdBQXlNNEIsZUFBZSxJQUFmLENBQXRRLEdBQTZSLEtBQUssQ0FBbFM7QUFDRDs7QUFFRCxTQUFTdTNCLGtCQUFULENBQTRCTCxVQUE1QixFQUF3QztBQUN0Q0Qsb0JBQWtCQyxVQUFsQjtBQUNBLElBQUVBLFdBQVdNLE9BQVgsSUFBc0IsSUFBdEIsSUFBOEJOLFdBQVdJLFFBQVgsSUFBdUIsSUFBdkQsSUFBK0RsOUIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiw0SkFBakIsQ0FBeEMsR0FBeU40QixlQUFlLElBQWYsQ0FBeFIsR0FBK1MsS0FBSyxDQUFwVDtBQUNEOztBQUVELElBQUl5M0IsWUFBWTtBQUNkaGtCLFNBQU8sZUFBVWlFLEtBQVYsRUFBaUIvRSxRQUFqQixFQUEyQitrQixhQUEzQixFQUEwQztBQUMvQyxRQUFJLENBQUNoZ0IsTUFBTS9FLFFBQU4sQ0FBRCxJQUFvQmdrQixpQkFBaUJqZixNQUFNN08sSUFBdkIsQ0FBcEIsSUFBb0Q2TyxNQUFNNGYsUUFBMUQsSUFBc0U1ZixNQUFNaWdCLFFBQTVFLElBQXdGamdCLE1BQU1tSyxRQUFsRyxFQUE0RztBQUMxRyxhQUFPLElBQVA7QUFDRDtBQUNELFdBQU8sSUFBSW5uQixLQUFKLENBQVUsNERBQTRELDZEQUE1RCxHQUE0SCw2REFBNUgsR0FBNEwsc0NBQXRNLENBQVA7QUFDRCxHQU5hO0FBT2Q4OEIsV0FBUyxpQkFBVTlmLEtBQVYsRUFBaUIvRSxRQUFqQixFQUEyQitrQixhQUEzQixFQUEwQztBQUNqRCxRQUFJLENBQUNoZ0IsTUFBTS9FLFFBQU4sQ0FBRCxJQUFvQitFLE1BQU00ZixRQUExQixJQUFzQzVmLE1BQU1pZ0IsUUFBNUMsSUFBd0RqZ0IsTUFBTW1LLFFBQWxFLEVBQTRFO0FBQzFFLGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBTyxJQUFJbm5CLEtBQUosQ0FBVSw4REFBOEQsNkRBQTlELEdBQThILCtEQUE5SCxHQUFnTSxzQ0FBMU0sQ0FBUDtBQUNELEdBWmE7QUFhZDQ4QixZQUFVN2IsVUFBVWdYO0FBYk4sQ0FBaEI7O0FBZ0JBLElBQUltRixxQkFBcUIsRUFBekI7QUFDQSxTQUFTQywyQkFBVCxDQUFxQ3J0QixLQUFyQyxFQUE0QztBQUMxQyxNQUFJQSxLQUFKLEVBQVc7QUFDVCxRQUFJOU0sT0FBTzhNLE1BQU1FLE9BQU4sRUFBWDtBQUNBLFFBQUloTixJQUFKLEVBQVU7QUFDUixhQUFPLGtDQUFrQ0EsSUFBbEMsR0FBeUMsSUFBaEQ7QUFDRDtBQUNGO0FBQ0QsU0FBTyxFQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxJQUFJbzZCLG1CQUFtQjtBQUNyQkMsa0JBQWdCLHdCQUFVQyxPQUFWLEVBQW1CdGdCLEtBQW5CLEVBQTBCbE4sS0FBMUIsRUFBaUM7QUFDL0MsU0FBSyxJQUFJbUksUUFBVCxJQUFxQjhrQixTQUFyQixFQUFnQztBQUM5QixVQUFJQSxVQUFVdDFCLGNBQVYsQ0FBeUJ3USxRQUF6QixDQUFKLEVBQXdDO0FBQ3RDLFlBQUloVSxRQUFRODRCLFVBQVU5a0IsUUFBVixFQUFvQitFLEtBQXBCLEVBQTJCL0UsUUFBM0IsRUFBcUNxbEIsT0FBckMsRUFBOEMsTUFBOUMsRUFBc0QsSUFBdEQsRUFBNER2SCxvQkFBNUQsQ0FBWjtBQUNEO0FBQ0QsVUFBSTl4QixpQkFBaUJqRSxLQUFqQixJQUEwQixFQUFFaUUsTUFBTVUsT0FBTixJQUFpQnU0QixrQkFBbkIsQ0FBOUIsRUFBc0U7QUFDcEU7QUFDQTtBQUNBQSwyQkFBbUJqNUIsTUFBTVUsT0FBekIsSUFBb0MsSUFBcEM7O0FBRUEsWUFBSTQ0QixXQUFXSiw0QkFBNEJydEIsS0FBNUIsQ0FBZjtBQUNBcFEsZ0JBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSw0QkFBZixFQUE2Q04sTUFBTVUsT0FBbkQsRUFBNEQ0NEIsUUFBNUQsQ0FBeEMsR0FBZ0gsS0FBSyxDQUFySDtBQUNEO0FBQ0Y7QUFDRixHQWZvQjs7QUFpQnJCOzs7O0FBSUFDLFlBQVUsa0JBQVVoQixVQUFWLEVBQXNCO0FBQzlCLFFBQUlBLFdBQVdFLFNBQWYsRUFBMEI7QUFDeEJDLHVCQUFpQkgsVUFBakI7QUFDQSxhQUFPQSxXQUFXRSxTQUFYLENBQXFCM2pCLEtBQTVCO0FBQ0Q7QUFDRCxXQUFPeWpCLFdBQVd6akIsS0FBbEI7QUFDRCxHQTNCb0I7O0FBNkJyQjs7Ozs7QUFLQTBrQixjQUFZLG9CQUFVakIsVUFBVixFQUFzQjtBQUNoQyxRQUFJQSxXQUFXQyxXQUFmLEVBQTRCO0FBQzFCSSx5QkFBbUJMLFVBQW5CO0FBQ0EsYUFBT0EsV0FBV0MsV0FBWCxDQUF1QjFqQixLQUE5QjtBQUNEO0FBQ0QsV0FBT3lqQixXQUFXTSxPQUFsQjtBQUNELEdBeENvQjs7QUEwQ3JCOzs7O0FBSUFZLG1CQUFpQix5QkFBVWxCLFVBQVYsRUFBc0J0bEIsS0FBdEIsRUFBNkI7QUFDNUMsUUFBSXNsQixXQUFXRSxTQUFmLEVBQTBCO0FBQ3hCQyx1QkFBaUJILFVBQWpCO0FBQ0EsYUFBT0EsV0FBV0UsU0FBWCxDQUFxQmlCLGFBQXJCLENBQW1Dem1CLE1BQU1wTixNQUFOLENBQWFpUCxLQUFoRCxDQUFQO0FBQ0QsS0FIRCxNQUdPLElBQUl5akIsV0FBV0MsV0FBZixFQUE0QjtBQUNqQ0kseUJBQW1CTCxVQUFuQjtBQUNBLGFBQU9BLFdBQVdDLFdBQVgsQ0FBdUJrQixhQUF2QixDQUFxQ3ptQixNQUFNcE4sTUFBTixDQUFhZ3pCLE9BQWxELENBQVA7QUFDRCxLQUhNLE1BR0EsSUFBSU4sV0FBV0ksUUFBZixFQUF5QjtBQUM5QixhQUFPSixXQUFXSSxRQUFYLENBQW9CcjhCLElBQXBCLENBQXlCa0QsU0FBekIsRUFBb0N5VCxLQUFwQyxDQUFQO0FBQ0Q7QUFDRjtBQXhEb0IsQ0FBdkI7O0FBMkRBdlgsT0FBT0MsT0FBUCxHQUFpQnc5QixnQkFBakIsQzs7Ozs7Ozs7QUN4SUE7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUEsSUFBSTkzQixpQkFBaUIsbUJBQUFoQixDQUFRLENBQVIsQ0FBckI7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCOztBQUVBLElBQUlzNUIsV0FBVyxLQUFmOztBQUVBLElBQUlDLDRCQUE0QjtBQUM5Qjs7OztBQUlBQyx5QkFBdUIsSUFMTzs7QUFPOUI7Ozs7QUFJQUMsMEJBQXdCLElBWE07O0FBYTlCeG5CLGFBQVc7QUFDVHluQix1QkFBbUIsMkJBQVVDLFdBQVYsRUFBdUI7QUFDeEMsT0FBQyxDQUFDTCxRQUFGLEdBQWFsK0IsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQix1RUFBakIsQ0FBeEMsR0FBb0k0QixlQUFlLEtBQWYsQ0FBakosR0FBeUssS0FBSyxDQUE5SztBQUNBdTRCLGdDQUEwQkMscUJBQTFCLEdBQWtERyxZQUFZSCxxQkFBOUQ7QUFDQUQsZ0NBQTBCRSxzQkFBMUIsR0FBbURFLFlBQVlGLHNCQUEvRDtBQUNBSCxpQkFBVyxJQUFYO0FBQ0Q7QUFOUTtBQWJtQixDQUFoQzs7QUF1QkFqK0IsT0FBT0MsT0FBUCxHQUFpQmkrQix5QkFBakIsQzs7Ozs7Ozs7QUMxQ0E7Ozs7Ozs7Ozs7OztBQVlBOztBQUVBOzs7O0FBRUEsSUFBSXAyQixpQkFBaUJlLE9BQU8zRyxTQUFQLENBQWlCNEYsY0FBdEM7O0FBRUE7Ozs7QUFJQSxTQUFTeTJCLEVBQVQsQ0FBWXI1QixDQUFaLEVBQWVzNUIsQ0FBZixFQUFrQjtBQUNoQjtBQUNBLE1BQUl0NUIsTUFBTXM1QixDQUFWLEVBQWE7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFPdDVCLE1BQU0sQ0FBTixJQUFXczVCLE1BQU0sQ0FBakIsSUFBc0IsSUFBSXQ1QixDQUFKLEtBQVUsSUFBSXM1QixDQUEzQztBQUNELEdBTEQsTUFLTztBQUNMO0FBQ0EsV0FBT3Q1QixNQUFNQSxDQUFOLElBQVdzNUIsTUFBTUEsQ0FBeEI7QUFDRDtBQUNGOztBQUVEOzs7OztBQUtBLFNBQVNDLFlBQVQsQ0FBc0JDLElBQXRCLEVBQTRCQyxJQUE1QixFQUFrQztBQUNoQyxNQUFJSixHQUFHRyxJQUFILEVBQVNDLElBQVQsQ0FBSixFQUFvQjtBQUNsQixXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFJLFFBQU9ELElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFBNEJBLFNBQVMsSUFBckMsSUFBNkMsUUFBT0MsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUE3RCxJQUF5RUEsU0FBUyxJQUF0RixFQUE0RjtBQUMxRixXQUFPLEtBQVA7QUFDRDs7QUFFRCxNQUFJQyxRQUFRLzFCLE9BQU9vQixJQUFQLENBQVl5MEIsSUFBWixDQUFaO0FBQ0EsTUFBSUcsUUFBUWgyQixPQUFPb0IsSUFBUCxDQUFZMDBCLElBQVosQ0FBWjs7QUFFQSxNQUFJQyxNQUFNeDlCLE1BQU4sS0FBaUJ5OUIsTUFBTXo5QixNQUEzQixFQUFtQztBQUNqQyxXQUFPLEtBQVA7QUFDRDs7QUFFRDtBQUNBLE9BQUssSUFBSVUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJODhCLE1BQU14OUIsTUFBMUIsRUFBa0NVLEdBQWxDLEVBQXVDO0FBQ3JDLFFBQUksQ0FBQ2dHLGVBQWVsSCxJQUFmLENBQW9CKzlCLElBQXBCLEVBQTBCQyxNQUFNOThCLENBQU4sQ0FBMUIsQ0FBRCxJQUF3QyxDQUFDeThCLEdBQUdHLEtBQUtFLE1BQU05OEIsQ0FBTixDQUFMLENBQUgsRUFBbUI2OEIsS0FBS0MsTUFBTTk4QixDQUFOLENBQUwsQ0FBbkIsQ0FBN0MsRUFBaUY7QUFDL0UsYUFBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLElBQVA7QUFDRDs7QUFFRDlCLE9BQU9DLE9BQVAsR0FBaUJ3K0IsWUFBakIsQzs7Ozs7OztBQ2xFQTs7Ozs7Ozs7OztBQVVBOztBQUVBOzs7Ozs7Ozs7Ozs7OztBQVlBLFNBQVNLLDBCQUFULENBQW9DcGMsV0FBcEMsRUFBaURELFdBQWpELEVBQThEO0FBQzVELE1BQUlzYyxZQUFZcmMsZ0JBQWdCLElBQWhCLElBQXdCQSxnQkFBZ0IsS0FBeEQ7QUFDQSxNQUFJc2MsWUFBWXZjLGdCQUFnQixJQUFoQixJQUF3QkEsZ0JBQWdCLEtBQXhEO0FBQ0EsTUFBSXNjLGFBQWFDLFNBQWpCLEVBQTRCO0FBQzFCLFdBQU9ELGNBQWNDLFNBQXJCO0FBQ0Q7O0FBRUQsTUFBSUMsa0JBQWtCdmMsV0FBbEIseUNBQWtCQSxXQUFsQixDQUFKO0FBQ0EsTUFBSXdjLGtCQUFrQnpjLFdBQWxCLHlDQUFrQkEsV0FBbEIsQ0FBSjtBQUNBLE1BQUl3YyxhQUFhLFFBQWIsSUFBeUJBLGFBQWEsUUFBMUMsRUFBb0Q7QUFDbEQsV0FBT0MsYUFBYSxRQUFiLElBQXlCQSxhQUFhLFFBQTdDO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT0EsYUFBYSxRQUFiLElBQXlCeGMsWUFBWWxVLElBQVosS0FBcUJpVSxZQUFZalUsSUFBMUQsSUFBa0VrVSxZQUFZalksR0FBWixLQUFvQmdZLFlBQVloWSxHQUF6RztBQUNEO0FBQ0Y7O0FBRUR6SyxPQUFPQyxPQUFQLEdBQWlCNitCLDBCQUFqQixDOzs7Ozs7O0FDeENBOzs7Ozs7Ozs7OztBQVdBOztBQUVBOzs7Ozs7O0FBT0EsU0FBU25QLE1BQVQsQ0FBZ0JsbEIsR0FBaEIsRUFBcUI7QUFDbkIsTUFBSTAwQixjQUFjLE9BQWxCO0FBQ0EsTUFBSUMsZ0JBQWdCO0FBQ2xCLFNBQUssSUFEYTtBQUVsQixTQUFLO0FBRmEsR0FBcEI7QUFJQSxNQUFJQyxnQkFBZ0IsQ0FBQyxLQUFLNTBCLEdBQU4sRUFBV2pHLE9BQVgsQ0FBbUIyNkIsV0FBbkIsRUFBZ0MsVUFBVTFQLEtBQVYsRUFBaUI7QUFDbkUsV0FBTzJQLGNBQWMzUCxLQUFkLENBQVA7QUFDRCxHQUZtQixDQUFwQjs7QUFJQSxTQUFPLE1BQU00UCxhQUFiO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVNDLFFBQVQsQ0FBa0I3MEIsR0FBbEIsRUFBdUI7QUFDckIsTUFBSTgwQixnQkFBZ0IsVUFBcEI7QUFDQSxNQUFJQyxrQkFBa0I7QUFDcEIsVUFBTSxHQURjO0FBRXBCLFVBQU07QUFGYyxHQUF0QjtBQUlBLE1BQUlDLGVBQWVoMUIsSUFBSSxDQUFKLE1BQVcsR0FBWCxJQUFrQkEsSUFBSSxDQUFKLE1BQVcsR0FBN0IsR0FBbUNBLElBQUlzbEIsU0FBSixDQUFjLENBQWQsQ0FBbkMsR0FBc0R0bEIsSUFBSXNsQixTQUFKLENBQWMsQ0FBZCxDQUF6RTs7QUFFQSxTQUFPLENBQUMsS0FBSzBQLFlBQU4sRUFBb0JqN0IsT0FBcEIsQ0FBNEIrNkIsYUFBNUIsRUFBMkMsVUFBVTlQLEtBQVYsRUFBaUI7QUFDakUsV0FBTytQLGdCQUFnQi9QLEtBQWhCLENBQVA7QUFDRCxHQUZNLENBQVA7QUFHRDs7QUFFRCxJQUFJaVEsaUJBQWlCO0FBQ25CL1AsVUFBUUEsTUFEVztBQUVuQjJQLFlBQVVBO0FBRlMsQ0FBckI7O0FBS0F0L0IsT0FBT0MsT0FBUCxHQUFpQnkvQixjQUFqQixDOzs7Ozs7O0FDekRBOzs7Ozs7Ozs7O0FBVUE7Ozs7QUFFQSxJQUFJLzVCLGlCQUFpQixtQkFBQWhCLENBQVEsQ0FBUixDQUFyQjs7QUFFQSxJQUFJcUgsb0JBQW9CLG1CQUFBckgsQ0FBUSxFQUFSLENBQXhCO0FBQ0EsSUFBSTZrQixtQkFBbUIsbUJBQUE3a0IsQ0FBUSxFQUFSLENBQXZCO0FBQ0EsSUFBSStjLHVCQUF1QixtQkFBQS9jLENBQVEsRUFBUixDQUEzQjtBQUNBLElBQUkwTyxlQUFlLG1CQUFBMU8sQ0FBUSxFQUFSLENBQW5COztBQUVBLElBQUlaLFlBQVksbUJBQUFZLENBQVEsQ0FBUixDQUFoQjtBQUNBLElBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLFNBQVN1UixhQUFULENBQXVCMkwsZ0JBQXZCLEVBQXlDO0FBQ3ZDeE8sZUFBYTZDLGFBQWIsQ0FBMkIyTCxnQkFBM0I7QUFDRDs7QUFFRCxTQUFTOGQsd0JBQVQsQ0FBa0NudUIsR0FBbEMsRUFBdUM7QUFDckMsTUFBSWhELGNBQWNnRCxHQUFkLHlDQUFjQSxHQUFkLENBQUo7QUFDQSxNQUFJaEQsU0FBUyxRQUFiLEVBQXVCO0FBQ3JCLFdBQU9BLElBQVA7QUFDRDtBQUNELE1BQUlDLGNBQWMrQyxJQUFJNkcsV0FBSixJQUFtQjdHLElBQUk2RyxXQUFKLENBQWdCaFYsSUFBbkMsSUFBMkNtTCxJQUE3RDtBQUNBLE1BQUl2RSxPQUFPcEIsT0FBT29CLElBQVAsQ0FBWXVILEdBQVosQ0FBWDtBQUNBLE1BQUl2SCxLQUFLN0ksTUFBTCxHQUFjLENBQWQsSUFBbUI2SSxLQUFLN0ksTUFBTCxHQUFjLEVBQXJDLEVBQXlDO0FBQ3ZDLFdBQU9xTixjQUFjLFVBQWQsR0FBMkJ4RSxLQUFLTCxJQUFMLENBQVUsSUFBVixDQUEzQixHQUE2QyxHQUFwRDtBQUNEO0FBQ0QsU0FBTzZFLFdBQVA7QUFDRDs7QUFFRCxTQUFTbXhCLGlDQUFULENBQTJDQyxjQUEzQyxFQUEyREMsVUFBM0QsRUFBdUU7QUFDckUsTUFBSWplLG1CQUFtQjJILGlCQUFpQmpjLEdBQWpCLENBQXFCc3lCLGNBQXJCLENBQXZCO0FBQ0EsTUFBSSxDQUFDaGUsZ0JBQUwsRUFBdUI7QUFDckIsUUFBSTloQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJazhCLE9BQU9GLGVBQWV4bkIsV0FBMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQXRZLGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLENBQUNrN0IsVUFBVCxFQUFxQiwrREFBK0QsZ0VBQS9ELEdBQWtJLDhEQUF2SixFQUF1TkEsVUFBdk4sRUFBbU9BLFVBQW5PLEVBQStPQyxTQUFTQSxLQUFLdHhCLFdBQUwsSUFBb0JzeEIsS0FBSzE4QixJQUFsQyxLQUEyQyxZQUExUixDQUF4QyxHQUFrVixLQUFLLENBQXZWO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFJdEQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM5RCxZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUW9ILGtCQUFrQnVFLE9BQWxCLElBQTZCLElBQXJDLEVBQTJDLHlFQUF5RSxzRUFBekUsR0FBa0osNERBQWxKLEdBQWlOLHdEQUFqTixHQUE0USx1QkFBdlQsRUFBZ1Z1dkIsVUFBaFYsQ0FBeEMsR0FBc1ksS0FBSyxDQUEzWTtBQUNEOztBQUVELFNBQU9qZSxnQkFBUDtBQUNEOztBQUVEOzs7O0FBSUEsSUFBSW1lLG1CQUFtQjtBQUNyQjs7Ozs7OztBQU9BNXdCLGFBQVcsbUJBQVV5d0IsY0FBVixFQUEwQjtBQUNuQyxRQUFJOS9CLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUlzTSxRQUFRbkUsa0JBQWtCdUUsT0FBOUI7QUFDQSxVQUFJSixVQUFVLElBQWQsRUFBb0I7QUFDbEJwUSxnQkFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVF1TCxNQUFNOHZCLHdCQUFkLEVBQXdDLDZEQUE2RCxtRUFBN0QsR0FBbUksb0VBQW5JLEdBQTBNLGlFQUExTSxHQUE4USw2QkFBdFQsRUFBcVY5dkIsTUFBTUUsT0FBTixNQUFtQixhQUF4VyxDQUF4QyxHQUFpYSxLQUFLLENBQXRhO0FBQ0FGLGNBQU04dkIsd0JBQU4sR0FBaUMsSUFBakM7QUFDRDtBQUNGO0FBQ0QsUUFBSXBlLG1CQUFtQjJILGlCQUFpQmpjLEdBQWpCLENBQXFCc3lCLGNBQXJCLENBQXZCO0FBQ0EsUUFBSWhlLGdCQUFKLEVBQXNCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGFBQU8sQ0FBQyxDQUFDQSxpQkFBaUI3YSxrQkFBMUI7QUFDRCxLQUxELE1BS087QUFDTCxhQUFPLEtBQVA7QUFDRDtBQUNGLEdBekJvQjs7QUEyQnJCOzs7Ozs7Ozs7QUFTQWs1QixtQkFBaUIseUJBQVVMLGNBQVYsRUFBMEJockIsUUFBMUIsRUFBb0NpckIsVUFBcEMsRUFBZ0Q7QUFDL0RFLHFCQUFpQkcsZ0JBQWpCLENBQWtDdHJCLFFBQWxDLEVBQTRDaXJCLFVBQTVDO0FBQ0EsUUFBSWplLG1CQUFtQitkLGtDQUFrQ0MsY0FBbEMsQ0FBdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUksQ0FBQ2hlLGdCQUFMLEVBQXVCO0FBQ3JCLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUlBLGlCQUFpQnZNLGlCQUFyQixFQUF3QztBQUN0Q3VNLHVCQUFpQnZNLGlCQUFqQixDQUFtQ3ZULElBQW5DLENBQXdDOFMsUUFBeEM7QUFDRCxLQUZELE1BRU87QUFDTGdOLHVCQUFpQnZNLGlCQUFqQixHQUFxQyxDQUFDVCxRQUFELENBQXJDO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBcUIsa0JBQWMyTCxnQkFBZDtBQUNELEdBM0RvQjs7QUE2RHJCdWUsMkJBQXlCLGlDQUFVdmUsZ0JBQVYsRUFBNEJoTixRQUE1QixFQUFzQztBQUM3RCxRQUFJZ04saUJBQWlCdk0saUJBQXJCLEVBQXdDO0FBQ3RDdU0sdUJBQWlCdk0saUJBQWpCLENBQW1DdlQsSUFBbkMsQ0FBd0M4UyxRQUF4QztBQUNELEtBRkQsTUFFTztBQUNMZ04sdUJBQWlCdk0saUJBQWpCLEdBQXFDLENBQUNULFFBQUQsQ0FBckM7QUFDRDtBQUNEcUIsa0JBQWMyTCxnQkFBZDtBQUNELEdBcEVvQjs7QUFzRXJCOzs7Ozs7Ozs7Ozs7O0FBYUF3ZSxzQkFBb0IsNEJBQVVSLGNBQVYsRUFBMEI7QUFDNUMsUUFBSWhlLG1CQUFtQitkLGtDQUFrQ0MsY0FBbEMsRUFBa0QsYUFBbEQsQ0FBdkI7O0FBRUEsUUFBSSxDQUFDaGUsZ0JBQUwsRUFBdUI7QUFDckI7QUFDRDs7QUFFREEscUJBQWlCeWUsbUJBQWpCLEdBQXVDLElBQXZDOztBQUVBcHFCLGtCQUFjMkwsZ0JBQWQ7QUFDRCxHQTdGb0I7O0FBK0ZyQjs7Ozs7Ozs7Ozs7QUFXQTBlLHVCQUFxQiw2QkFBVVYsY0FBVixFQUEwQlcsYUFBMUIsRUFBeUMzckIsUUFBekMsRUFBbUQ7QUFDdEUsUUFBSWdOLG1CQUFtQitkLGtDQUFrQ0MsY0FBbEMsRUFBa0QsY0FBbEQsQ0FBdkI7O0FBRUEsUUFBSSxDQUFDaGUsZ0JBQUwsRUFBdUI7QUFDckI7QUFDRDs7QUFFREEscUJBQWlCNGUsa0JBQWpCLEdBQXNDLENBQUNELGFBQUQsQ0FBdEM7QUFDQTNlLHFCQUFpQjZlLG9CQUFqQixHQUF3QyxJQUF4Qzs7QUFFQTtBQUNBLFFBQUk3ckIsYUFBYS9RLFNBQWIsSUFBMEIrUSxhQUFhLElBQTNDLEVBQWlEO0FBQy9DbXJCLHVCQUFpQkcsZ0JBQWpCLENBQWtDdHJCLFFBQWxDLEVBQTRDLGNBQTVDO0FBQ0EsVUFBSWdOLGlCQUFpQnZNLGlCQUFyQixFQUF3QztBQUN0Q3VNLHlCQUFpQnZNLGlCQUFqQixDQUFtQ3ZULElBQW5DLENBQXdDOFMsUUFBeEM7QUFDRCxPQUZELE1BRU87QUFDTGdOLHlCQUFpQnZNLGlCQUFqQixHQUFxQyxDQUFDVCxRQUFELENBQXJDO0FBQ0Q7QUFDRjs7QUFFRHFCLGtCQUFjMkwsZ0JBQWQ7QUFDRCxHQS9Ib0I7O0FBaUlyQjs7Ozs7Ozs7OztBQVVBOGUsbUJBQWlCLHlCQUFVZCxjQUFWLEVBQTBCZSxZQUExQixFQUF3QztBQUN2RCxRQUFJN2dDLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNmQsMkJBQXFCM1AsU0FBckIsQ0FBK0I4dUIsVUFBL0I7QUFDQTlnQyxjQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUWc4QixnQkFBZ0IsSUFBeEIsRUFBOEIsa0VBQWtFLDZCQUFoRyxDQUF4QyxHQUF5SyxLQUFLLENBQTlLO0FBQ0Q7O0FBRUQsUUFBSS9lLG1CQUFtQitkLGtDQUFrQ0MsY0FBbEMsRUFBa0QsVUFBbEQsQ0FBdkI7O0FBRUEsUUFBSSxDQUFDaGUsZ0JBQUwsRUFBdUI7QUFDckI7QUFDRDs7QUFFRCxRQUFJOWdCLFFBQVE4Z0IsaUJBQWlCNGUsa0JBQWpCLEtBQXdDNWUsaUJBQWlCNGUsa0JBQWpCLEdBQXNDLEVBQTlFLENBQVo7QUFDQTEvQixVQUFNZ0IsSUFBTixDQUFXNitCLFlBQVg7O0FBRUExcUIsa0JBQWMyTCxnQkFBZDtBQUNELEdBM0pvQjs7QUE2SnJCaWYsMEJBQXdCLGdDQUFVamYsZ0JBQVYsRUFBNEJZLFdBQTVCLEVBQXlDc2UsV0FBekMsRUFBc0Q7QUFDNUVsZixxQkFBaUJtZixlQUFqQixHQUFtQ3ZlLFdBQW5DO0FBQ0E7QUFDQVoscUJBQWlCYyxRQUFqQixHQUE0Qm9lLFdBQTVCO0FBQ0E3cUIsa0JBQWMyTCxnQkFBZDtBQUNELEdBbEtvQjs7QUFvS3JCc2Usb0JBQWtCLDBCQUFVdHJCLFFBQVYsRUFBb0JpckIsVUFBcEIsRUFBZ0M7QUFDaEQsTUFBRSxDQUFDanJCLFFBQUQsSUFBYSxPQUFPQSxRQUFQLEtBQW9CLFVBQW5DLElBQWlEOVUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixpR0FBakIsRUFBb0grN0IsVUFBcEgsRUFBZ0lILHlCQUF5QjlxQixRQUF6QixDQUFoSSxDQUF4QyxHQUE4TWxQLGVBQWUsS0FBZixFQUFzQm02QixVQUF0QixFQUFrQ0gseUJBQXlCOXFCLFFBQXpCLENBQWxDLENBQS9QLEdBQXVVLEtBQUssQ0FBNVU7QUFDRDtBQXRLb0IsQ0FBdkI7O0FBeUtBN1UsT0FBT0MsT0FBUCxHQUFpQisvQixnQkFBakIsQzs7Ozs7Ozs7QUN4T0E7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJeHRCLFVBQVUsbUJBQUE3TixDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJRCxnQkFBZ0IsbUJBQUFDLENBQVEsRUFBUixDQUFwQjtBQUNBLElBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUlzOEIscUJBQXFCdjhCLGFBQXpCOztBQUVBLElBQUkzRSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUlxOUIsY0FBYyxDQUFDLFNBQUQsRUFBWSxRQUFaLEVBQXNCLE1BQXRCLEVBQThCLFNBQTlCLEVBQXlDLE9BQXpDLEVBQWtELE1BQWxELEVBQTBELFVBQTFELEVBQXNFLFNBQXRFLEVBQWlGLFlBQWpGLEVBQStGLE1BQS9GLEVBQXVHLElBQXZHLEVBQTZHLFFBQTdHLEVBQXVILFNBQXZILEVBQWtJLFFBQWxJLEVBQTRJLEtBQTVJLEVBQW1KLFVBQW5KLEVBQStKLElBQS9KLEVBQXFLLFNBQXJLLEVBQWdMLEtBQWhMLEVBQXVMLEtBQXZMLEVBQThMLElBQTlMLEVBQW9NLElBQXBNLEVBQTBNLE9BQTFNLEVBQW1OLFVBQW5OLEVBQStOLFlBQS9OLEVBQTZPLFFBQTdPLEVBQXVQLFFBQXZQLEVBQWlRLE1BQWpRLEVBQXlRLE9BQXpRLEVBQWtSLFVBQWxSLEVBQThSLElBQTlSLEVBQW9TLElBQXBTLEVBQTBTLElBQTFTLEVBQWdULElBQWhULEVBQXNULElBQXRULEVBQTRULElBQTVULEVBQWtVLE1BQWxVLEVBQTBVLFFBQTFVLEVBQW9WLFFBQXBWLEVBQThWLElBQTlWLEVBQW9XLE1BQXBXLEVBQTRXLFFBQTVXLEVBQXNYLEtBQXRYLEVBQTZYLE9BQTdYLEVBQXNZLFNBQXRZLEVBQWlaLElBQWpaLEVBQXVaLE1BQXZaLEVBQStaLFNBQS9aLEVBQTBhLE1BQTFhLEVBQWtiLFNBQWxiLEVBQTZiLE1BQTdiLEVBQXFjLFVBQXJjLEVBQWlkLE1BQWpkLEVBQXlkLEtBQXpkLEVBQWdlLFNBQWhlLEVBQTJlLFVBQTNlLEVBQXVmLFVBQXZmLEVBQW1nQixRQUFuZ0IsRUFBNmdCLElBQTdnQixFQUFtaEIsR0FBbmhCLEVBQXdoQixPQUF4aEIsRUFBaWlCLFdBQWppQixFQUE4aUIsS0FBOWlCLEVBQXFqQixRQUFyakIsRUFBK2pCLFNBQS9qQixFQUEwa0IsUUFBMWtCLEVBQW9sQixRQUFwbEIsRUFBOGxCLE9BQTlsQixFQUF1bUIsU0FBdm1CLEVBQWtuQixPQUFsbkIsRUFBMm5CLE9BQTNuQixFQUFvb0IsSUFBcG9CLEVBQTBvQixVQUExb0IsRUFBc3BCLFVBQXRwQixFQUFrcUIsT0FBbHFCLEVBQTJxQixJQUEzcUIsRUFBaXJCLE9BQWpyQixFQUEwckIsT0FBMXJCLEVBQW1zQixJQUFuc0IsRUFBeXNCLE9BQXpzQixFQUFrdEIsSUFBbHRCLEVBQXd0QixLQUF4dEIsRUFBK3RCLEtBQS90QixDQUFsQjs7QUFFQTtBQUNBLE1BQUlDLGNBQWMsQ0FBQyxRQUFELEVBQVcsU0FBWCxFQUFzQixNQUF0QixFQUE4QixPQUE5QixFQUF1QyxJQUF2QyxFQUE2QyxJQUE3QyxFQUFtRCxTQUFuRCxFQUE4RCxRQUE5RCxFQUF3RSxVQUF4RTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0EsaUJBTGtCLEVBS0QsTUFMQyxFQUtPLE9BTFAsQ0FBbEI7O0FBT0E7QUFDQSxNQUFJQyxrQkFBa0JELFlBQVk5L0IsTUFBWixDQUFtQixDQUFDLFFBQUQsQ0FBbkIsQ0FBdEI7O0FBRUE7QUFDQSxNQUFJZ2dDLGlCQUFpQixDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixFQUFtQixRQUFuQixFQUE2QixVQUE3QixFQUF5QyxHQUF6QyxFQUE4QyxJQUE5QyxFQUFvRCxJQUFwRCxDQUFyQjs7QUFFQSxNQUFJQyxvQkFBb0I7QUFDdEIvd0IsYUFBUyxJQURhOztBQUd0Qmd4QixhQUFTLElBSGE7QUFJdEJDLGlCQUFhLElBSlM7QUFLdEJDLHNCQUFrQixJQUxJO0FBTXRCQyxvQkFBZ0IsSUFOTTtBQU90QkMsdUJBQW1CLElBUEc7O0FBU3RCQyw0QkFBd0IsSUFURjtBQVV0QkMsMEJBQXNCO0FBVkEsR0FBeEI7O0FBYUEsTUFBSUMsc0JBQXNCLFNBQXRCQSxtQkFBc0IsQ0FBVUMsT0FBVixFQUFtQnphLEdBQW5CLEVBQXdCdEksUUFBeEIsRUFBa0M7QUFDMUQsUUFBSWdqQixlQUFleHZCLFFBQVEsRUFBUixFQUFZdXZCLFdBQVdULGlCQUF2QixDQUFuQjtBQUNBLFFBQUlweEIsT0FBTyxFQUFFb1gsS0FBS0EsR0FBUCxFQUFZdEksVUFBVUEsUUFBdEIsRUFBWDs7QUFFQSxRQUFJbWlCLFlBQVloOEIsT0FBWixDQUFvQm1pQixHQUFwQixNQUE2QixDQUFDLENBQWxDLEVBQXFDO0FBQ25DMGEsbUJBQWFSLFdBQWIsR0FBMkIsSUFBM0I7QUFDQVEsbUJBQWFQLGdCQUFiLEdBQWdDLElBQWhDO0FBQ0FPLG1CQUFhTixjQUFiLEdBQThCLElBQTlCO0FBQ0Q7QUFDRCxRQUFJTixnQkFBZ0JqOEIsT0FBaEIsQ0FBd0JtaUIsR0FBeEIsTUFBaUMsQ0FBQyxDQUF0QyxFQUF5QztBQUN2QzBhLG1CQUFhTCxpQkFBYixHQUFpQyxJQUFqQztBQUNEOztBQUVEO0FBQ0E7QUFDQSxRQUFJVCxZQUFZLzdCLE9BQVosQ0FBb0JtaUIsR0FBcEIsTUFBNkIsQ0FBQyxDQUE5QixJQUFtQ0EsUUFBUSxTQUEzQyxJQUF3REEsUUFBUSxLQUFoRSxJQUF5RUEsUUFBUSxHQUFyRixFQUEwRjtBQUN4RjBhLG1CQUFhSixzQkFBYixHQUFzQyxJQUF0QztBQUNBSSxtQkFBYUgsb0JBQWIsR0FBb0MsSUFBcEM7QUFDRDs7QUFFREcsaUJBQWF6eEIsT0FBYixHQUF1QkwsSUFBdkI7O0FBRUEsUUFBSW9YLFFBQVEsTUFBWixFQUFvQjtBQUNsQjBhLG1CQUFhVCxPQUFiLEdBQXVCcnhCLElBQXZCO0FBQ0Q7QUFDRCxRQUFJb1gsUUFBUSxHQUFaLEVBQWlCO0FBQ2YwYSxtQkFBYVIsV0FBYixHQUEyQnR4QixJQUEzQjtBQUNEO0FBQ0QsUUFBSW9YLFFBQVEsUUFBWixFQUFzQjtBQUNwQjBhLG1CQUFhUCxnQkFBYixHQUFnQ3Z4QixJQUFoQztBQUNEO0FBQ0QsUUFBSW9YLFFBQVEsTUFBWixFQUFvQjtBQUNsQjBhLG1CQUFhTixjQUFiLEdBQThCeHhCLElBQTlCO0FBQ0Q7QUFDRCxRQUFJb1gsUUFBUSxHQUFaLEVBQWlCO0FBQ2YwYSxtQkFBYUwsaUJBQWIsR0FBaUN6eEIsSUFBakM7QUFDRDtBQUNELFFBQUlvWCxRQUFRLElBQVosRUFBa0I7QUFDaEIwYSxtQkFBYUosc0JBQWIsR0FBc0MxeEIsSUFBdEM7QUFDRDtBQUNELFFBQUlvWCxRQUFRLElBQVIsSUFBZ0JBLFFBQVEsSUFBNUIsRUFBa0M7QUFDaEMwYSxtQkFBYUgsb0JBQWIsR0FBb0MzeEIsSUFBcEM7QUFDRDs7QUFFRCxXQUFPOHhCLFlBQVA7QUFDRCxHQTdDRDs7QUErQ0E7OztBQUdBLE1BQUlDLHVCQUF1QixTQUF2QkEsb0JBQXVCLENBQVUzYSxHQUFWLEVBQWU0YSxTQUFmLEVBQTBCO0FBQ25EO0FBQ0EsWUFBUUEsU0FBUjtBQUNFO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBTzVhLFFBQVEsUUFBUixJQUFvQkEsUUFBUSxVQUE1QixJQUEwQ0EsUUFBUSxPQUF6RDtBQUNGLFdBQUssVUFBTDtBQUNFLGVBQU9BLFFBQVEsUUFBUixJQUFvQkEsUUFBUSxPQUFuQztBQUNGO0FBQ0E7QUFDQSxXQUFLLFFBQUw7QUFDRSxlQUFPQSxRQUFRLE9BQWY7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQUssSUFBTDtBQUNFLGVBQU9BLFFBQVEsSUFBUixJQUFnQkEsUUFBUSxJQUF4QixJQUFnQ0EsUUFBUSxPQUF4QyxJQUFtREEsUUFBUSxRQUEzRCxJQUF1RUEsUUFBUSxVQUF0RjtBQUNGO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0UsZUFBT0EsUUFBUSxJQUFSLElBQWdCQSxRQUFRLE9BQXhCLElBQW1DQSxRQUFRLFFBQTNDLElBQXVEQSxRQUFRLFVBQXRFO0FBQ0Y7QUFDQSxXQUFLLFVBQUw7QUFDRSxlQUFPQSxRQUFRLEtBQVIsSUFBaUJBLFFBQVEsVUFBaEM7QUFDRjtBQUNBLFdBQUssT0FBTDtBQUNFLGVBQU9BLFFBQVEsU0FBUixJQUFxQkEsUUFBUSxVQUE3QixJQUEyQ0EsUUFBUSxPQUFuRCxJQUE4REEsUUFBUSxPQUF0RSxJQUFpRkEsUUFBUSxPQUF6RixJQUFvR0EsUUFBUSxPQUE1RyxJQUF1SEEsUUFBUSxRQUEvSCxJQUEySUEsUUFBUSxVQUExSjtBQUNGO0FBQ0EsV0FBSyxNQUFMO0FBQ0UsZUFBT0EsUUFBUSxNQUFSLElBQWtCQSxRQUFRLFVBQTFCLElBQXdDQSxRQUFRLFNBQWhELElBQTZEQSxRQUFRLE1BQXJFLElBQStFQSxRQUFRLE1BQXZGLElBQWlHQSxRQUFRLE9BQXpHLElBQW9IQSxRQUFRLFVBQTVILElBQTBJQSxRQUFRLFVBQWxKLElBQWdLQSxRQUFRLE9BQXhLLElBQW1MQSxRQUFRLFFBQTNMLElBQXVNQSxRQUFRLFVBQXROO0FBQ0Y7QUFDQSxXQUFLLE1BQUw7QUFDRSxlQUFPQSxRQUFRLE1BQVIsSUFBa0JBLFFBQVEsTUFBakM7QUFDRixXQUFLLFdBQUw7QUFDRSxlQUFPQSxRQUFRLE1BQWY7QUFwQ0o7O0FBdUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVFBLEdBQVI7QUFDRSxXQUFLLElBQUw7QUFDQSxXQUFLLElBQUw7QUFDQSxXQUFLLElBQUw7QUFDQSxXQUFLLElBQUw7QUFDQSxXQUFLLElBQUw7QUFDQSxXQUFLLElBQUw7QUFDRSxlQUFPNGEsY0FBYyxJQUFkLElBQXNCQSxjQUFjLElBQXBDLElBQTRDQSxjQUFjLElBQTFELElBQWtFQSxjQUFjLElBQWhGLElBQXdGQSxjQUFjLElBQXRHLElBQThHQSxjQUFjLElBQW5JOztBQUVGLFdBQUssSUFBTDtBQUNBLFdBQUssSUFBTDtBQUNFLGVBQU9iLGVBQWVsOEIsT0FBZixDQUF1Qis4QixTQUF2QixNQUFzQyxDQUFDLENBQTlDOztBQUVGLFdBQUssTUFBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssS0FBTDtBQUNBLFdBQUssVUFBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssTUFBTDtBQUNBLFdBQUssTUFBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssSUFBTDtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBT0EsYUFBYSxJQUFwQjtBQTlCSjs7QUFpQ0EsV0FBTyxJQUFQO0FBQ0QsR0E5RUQ7O0FBZ0ZBOzs7QUFHQSxNQUFJQyw0QkFBNEIsU0FBNUJBLHlCQUE0QixDQUFVN2EsR0FBVixFQUFlMGEsWUFBZixFQUE2QjtBQUMzRCxZQUFRMWEsR0FBUjtBQUNFLFdBQUssU0FBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssWUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssS0FBTDtBQUNBLFdBQUssS0FBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssVUFBTDtBQUNBLFdBQUssWUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssTUFBTDtBQUNBLFdBQUssTUFBTDtBQUNBLFdBQUssS0FBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssR0FBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssS0FBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssS0FBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssSUFBTDtBQUNBLFdBQUssSUFBTDtBQUNFLGVBQU8wYSxhQUFhTCxpQkFBcEI7O0FBRUYsV0FBSyxNQUFMO0FBQ0UsZUFBT0ssYUFBYVQsT0FBYixJQUF3QlMsYUFBYUwsaUJBQTVDOztBQUVGLFdBQUssSUFBTDtBQUNFLGVBQU9LLGFBQWFKLHNCQUFwQjs7QUFFRixXQUFLLElBQUw7QUFDQSxXQUFLLElBQUw7QUFDRSxlQUFPSSxhQUFhSCxvQkFBcEI7O0FBRUYsV0FBSyxRQUFMO0FBQ0UsZUFBT0csYUFBYVAsZ0JBQXBCOztBQUVGLFdBQUssR0FBTDtBQUNFO0FBQ0E7QUFDQSxlQUFPTyxhQUFhUixXQUFwQjs7QUFFRixXQUFLLE1BQUw7QUFDRSxlQUFPUSxhQUFhTixjQUFwQjtBQXpESjs7QUE0REEsV0FBTyxJQUFQO0FBQ0QsR0E5REQ7O0FBZ0VBOzs7O0FBSUEsTUFBSVUsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFVcGpCLFFBQVYsRUFBb0I7QUFDdkMsUUFBSSxDQUFDQSxRQUFMLEVBQWU7QUFDYixhQUFPLEVBQVA7QUFDRDs7QUFFRCxRQUFJNU4sUUFBUSxFQUFaO0FBQ0EsT0FBRztBQUNEQSxZQUFNclAsSUFBTixDQUFXaWQsUUFBWDtBQUNELEtBRkQsUUFFU0EsV0FBV0EsU0FBU3RKLGVBQVQsQ0FBeUJ0RixNQUY3QztBQUdBZ0IsVUFBTWl4QixPQUFOO0FBQ0EsV0FBT2p4QixLQUFQO0FBQ0QsR0FYRDs7QUFhQSxNQUFJa3hCLFVBQVUsRUFBZDs7QUFFQXJCLHVCQUFxQiw0QkFBVXNCLFFBQVYsRUFBb0JDLFNBQXBCLEVBQStCQyxhQUEvQixFQUE4Q1QsWUFBOUMsRUFBNEQ7QUFDL0VBLG1CQUFlQSxnQkFBZ0JWLGlCQUEvQjtBQUNBLFFBQUlvQixhQUFhVixhQUFhenhCLE9BQTlCO0FBQ0EsUUFBSTJ4QixZQUFZUSxjQUFjQSxXQUFXcGIsR0FBekM7O0FBRUEsUUFBSWtiLGFBQWEsSUFBakIsRUFBdUI7QUFDckJ6aUMsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEyOUIsWUFBWSxJQUFwQixFQUEwQix1RUFBMUIsQ0FBeEMsR0FBNkksS0FBSyxDQUFsSjtBQUNBQSxpQkFBVyxPQUFYO0FBQ0Q7O0FBRUQsUUFBSUksZ0JBQWdCVixxQkFBcUJNLFFBQXJCLEVBQStCTCxTQUEvQixJQUE0QyxJQUE1QyxHQUFtRFEsVUFBdkU7QUFDQSxRQUFJRSxrQkFBa0JELGdCQUFnQixJQUFoQixHQUF1QlIsMEJBQTBCSSxRQUExQixFQUFvQ1AsWUFBcEMsQ0FBN0M7QUFDQSxRQUFJYSxjQUFjRixpQkFBaUJDLGVBQW5DOztBQUVBLFFBQUlDLFdBQUosRUFBaUI7QUFDZixVQUFJQyxjQUFjRCxZQUFZdmIsR0FBOUI7QUFDQSxVQUFJeWIsbUJBQW1CRixZQUFZN2pCLFFBQW5DOztBQUVBLFVBQUlna0IsYUFBYVAsaUJBQWlCQSxjQUFjL3NCLGVBQWQsQ0FBOEJ0RixNQUFoRTtBQUNBLFVBQUk2eUIsZ0JBQWdCRixvQkFBb0JBLGlCQUFpQnJ0QixlQUFqQixDQUFpQ3RGLE1BQXpFOztBQUVBLFVBQUk4eUIsY0FBY2QsZUFBZVksVUFBZixDQUFsQjtBQUNBLFVBQUlHLGlCQUFpQmYsZUFBZWEsYUFBZixDQUFyQjs7QUFFQSxVQUFJRyxjQUFjbDlCLEtBQUttOUIsR0FBTCxDQUFTSCxZQUFZOWhDLE1BQXJCLEVBQTZCK2hDLGVBQWUvaEMsTUFBNUMsQ0FBbEI7QUFDQSxVQUFJVSxDQUFKOztBQUVBLFVBQUl3aEMsZ0JBQWdCLENBQUMsQ0FBckI7QUFDQSxXQUFLeGhDLElBQUksQ0FBVCxFQUFZQSxJQUFJc2hDLFdBQWhCLEVBQTZCdGhDLEdBQTdCLEVBQWtDO0FBQ2hDLFlBQUlvaEMsWUFBWXBoQyxDQUFaLE1BQW1CcWhDLGVBQWVyaEMsQ0FBZixDQUF2QixFQUEwQztBQUN4Q3doQywwQkFBZ0J4aEMsQ0FBaEI7QUFDRCxTQUZELE1BRU87QUFDTDtBQUNEO0FBQ0Y7O0FBRUQsVUFBSXloQyxVQUFVLFdBQWQ7QUFDQSxVQUFJQyxrQkFBa0JOLFlBQVk3OEIsS0FBWixDQUFrQmk5QixnQkFBZ0IsQ0FBbEMsRUFBcUM1NUIsR0FBckMsQ0FBeUMsVUFBVXhDLElBQVYsRUFBZ0I7QUFDN0UsZUFBT0EsS0FBS21KLE9BQUwsTUFBa0JrekIsT0FBekI7QUFDRCxPQUZxQixDQUF0QjtBQUdBLFVBQUlFLHFCQUFxQk4sZUFBZTk4QixLQUFmLENBQXFCaTlCLGdCQUFnQixDQUFyQyxFQUF3QzU1QixHQUF4QyxDQUE0QyxVQUFVeEMsSUFBVixFQUFnQjtBQUNuRixlQUFPQSxLQUFLbUosT0FBTCxNQUFrQmt6QixPQUF6QjtBQUNELE9BRndCLENBQXpCO0FBR0EsVUFBSUcsWUFBWSxHQUFHcmlDLE1BQUg7QUFDaEI7QUFDQTtBQUNBaWlDLHdCQUFrQixDQUFDLENBQW5CLEdBQXVCSixZQUFZSSxhQUFaLEVBQTJCanpCLE9BQTNCLE1BQXdDa3pCLE9BQS9ELEdBQXlFLEVBSHpELEVBRzZERSxrQkFIN0QsRUFHaUZYLFdBSGpGO0FBSWhCO0FBQ0FGLHdCQUFrQixDQUFDLEtBQUQsQ0FBbEIsR0FBNEIsRUFMWixFQUtnQlksZUFMaEIsRUFLaUNqQixRQUxqQyxFQUsyQzM0QixJQUwzQyxDQUtnRCxLQUxoRCxDQUFoQjs7QUFPQSxVQUFJKzVCLFVBQVUsQ0FBQyxDQUFDaEIsYUFBRixHQUFrQixHQUFsQixHQUF3QkosUUFBeEIsR0FBbUMsR0FBbkMsR0FBeUNPLFdBQXpDLEdBQXVELEdBQXZELEdBQTZEWSxTQUEzRTtBQUNBLFVBQUlwQixRQUFRcUIsT0FBUixDQUFKLEVBQXNCO0FBQ3BCO0FBQ0Q7QUFDRHJCLGNBQVFxQixPQUFSLElBQW1CLElBQW5COztBQUVBLFVBQUlDLGlCQUFpQnJCLFFBQXJCO0FBQ0EsVUFBSXNCLGlCQUFpQixFQUFyQjtBQUNBLFVBQUl0QixhQUFhLE9BQWpCLEVBQTBCO0FBQ3hCLFlBQUksS0FBS2gyQixJQUFMLENBQVVpMkIsU0FBVixDQUFKLEVBQTBCO0FBQ3hCb0IsMkJBQWlCLFlBQWpCO0FBQ0QsU0FGRCxNQUVPO0FBQ0xBLDJCQUFpQix1QkFBakI7QUFDQUMsMkJBQWlCLG9FQUFvRSxnQ0FBckY7QUFDRDtBQUNGLE9BUEQsTUFPTztBQUNMRCx5QkFBaUIsTUFBTXJCLFFBQU4sR0FBaUIsR0FBbEM7QUFDRDs7QUFFRCxVQUFJSSxhQUFKLEVBQW1CO0FBQ2pCLFlBQUl6eUIsT0FBTyxFQUFYO0FBQ0EsWUFBSTR5QixnQkFBZ0IsT0FBaEIsSUFBMkJQLGFBQWEsSUFBNUMsRUFBa0Q7QUFDaERyeUIsa0JBQVEsb0VBQW9FLGNBQTVFO0FBQ0Q7QUFDRG5RLGdCQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUscUVBQXFFLFdBQXBGLEVBQWlHZy9CLGNBQWpHLEVBQWlIZCxXQUFqSCxFQUE4SGUsY0FBOUgsRUFBOElILFNBQTlJLEVBQXlKeHpCLElBQXpKLENBQXhDLEdBQXlNLEtBQUssQ0FBOU07QUFDRCxPQU5ELE1BTU87QUFDTG5RLGdCQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsa0VBQWtFLGVBQWpGLEVBQWtHZy9CLGNBQWxHLEVBQWtIZCxXQUFsSCxFQUErSFksU0FBL0gsQ0FBeEMsR0FBb0wsS0FBSyxDQUF6TDtBQUNEO0FBQ0Y7QUFDRixHQS9FRDs7QUFpRkF6QyxxQkFBbUJhLG1CQUFuQixHQUF5Q0EsbUJBQXpDOztBQUVBO0FBQ0FiLHFCQUFtQjZDLG1CQUFuQixHQUF5QyxVQUFVeGMsR0FBVixFQUFlMGEsWUFBZixFQUE2QjtBQUNwRUEsbUJBQWVBLGdCQUFnQlYsaUJBQS9CO0FBQ0EsUUFBSW9CLGFBQWFWLGFBQWF6eEIsT0FBOUI7QUFDQSxRQUFJMnhCLFlBQVlRLGNBQWNBLFdBQVdwYixHQUF6QztBQUNBLFdBQU8yYSxxQkFBcUIzYSxHQUFyQixFQUEwQjRhLFNBQTFCLEtBQXdDLENBQUNDLDBCQUEwQjdhLEdBQTFCLEVBQStCMGEsWUFBL0IsQ0FBaEQ7QUFDRCxHQUxEO0FBTUQ7O0FBRURoaUMsT0FBT0MsT0FBUCxHQUFpQmdoQyxrQkFBakIsQzs7Ozs7Ozs7QUNqWEE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxTQUFTOEMsZ0JBQVQsQ0FBMEJoc0IsV0FBMUIsRUFBdUM7QUFDckMsTUFBSWlzQixRQUFKO0FBQ0EsTUFBSUMsVUFBVWxzQixZQUFZa3NCLE9BQTFCOztBQUVBLE1BQUksY0FBY2xzQixXQUFsQixFQUErQjtBQUM3QmlzQixlQUFXanNCLFlBQVlpc0IsUUFBdkI7O0FBRUE7QUFDQSxRQUFJQSxhQUFhLENBQWIsSUFBa0JDLFlBQVksRUFBbEMsRUFBc0M7QUFDcENELGlCQUFXLEVBQVg7QUFDRDtBQUNGLEdBUEQsTUFPTztBQUNMO0FBQ0FBLGVBQVdDLE9BQVg7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSUQsWUFBWSxFQUFaLElBQWtCQSxhQUFhLEVBQW5DLEVBQXVDO0FBQ3JDLFdBQU9BLFFBQVA7QUFDRDs7QUFFRCxTQUFPLENBQVA7QUFDRDs7QUFFRGhrQyxPQUFPQyxPQUFQLEdBQWlCOGpDLGdCQUFqQixDOzs7Ozs7O0FDaERBOztBQUVBOWpDLFFBQVEycEIsVUFBUixHQUFxQixJQUFyQjtBQUNBM3BCLFFBQVFpa0MsaUJBQVIsR0FBNEJqa0MsUUFBUWtrQyxjQUFSLEdBQXlCcmdDLFNBQXJEOztBQUVBLElBQUlzZ0MsV0FBV3Y3QixPQUFPTyxNQUFQLElBQWlCLFVBQVVlLE1BQVYsRUFBa0I7QUFBRSxPQUFLLElBQUlySSxJQUFJLENBQWIsRUFBZ0JBLElBQUlELFVBQVVULE1BQTlCLEVBQXNDVSxHQUF0QyxFQUEyQztBQUFFLFFBQUlzSSxTQUFTdkksVUFBVUMsQ0FBVixDQUFiLENBQTJCLEtBQUssSUFBSTJJLEdBQVQsSUFBZ0JMLE1BQWhCLEVBQXdCO0FBQUUsVUFBSXZCLE9BQU8zRyxTQUFQLENBQWlCNEYsY0FBakIsQ0FBZ0NsSCxJQUFoQyxDQUFxQ3dKLE1BQXJDLEVBQTZDSyxHQUE3QyxDQUFKLEVBQXVEO0FBQUVOLGVBQU9NLEdBQVAsSUFBY0wsT0FBT0ssR0FBUCxDQUFkO0FBQTRCO0FBQUU7QUFBRSxHQUFDLE9BQU9OLE1BQVA7QUFBZ0IsQ0FBaFE7O0FBRUEsSUFBSWs2QixtQkFBbUIsbUJBQUExL0IsQ0FBUSxHQUFSLENBQXZCOztBQUVBLElBQUkyL0Isb0JBQW9CQyx1QkFBdUJGLGdCQUF2QixDQUF4Qjs7QUFFQSxJQUFJRyxjQUFjLG1CQUFBNy9CLENBQVEsR0FBUixDQUFsQjs7QUFFQSxJQUFJOC9CLGVBQWVGLHVCQUF1QkMsV0FBdkIsQ0FBbkI7O0FBRUEsSUFBSUUsYUFBYSxtQkFBQS8vQixDQUFRLEVBQVIsQ0FBakI7O0FBRUEsU0FBUzQvQixzQkFBVCxDQUFnQ0ksR0FBaEMsRUFBcUM7QUFBRSxTQUFPQSxPQUFPQSxJQUFJL2EsVUFBWCxHQUF3QithLEdBQXhCLEdBQThCLEVBQUVDLFNBQVNELEdBQVgsRUFBckM7QUFBd0Q7O0FBRS9GLElBQUlSLGlCQUFpQmxrQyxRQUFRa2tDLGNBQVIsR0FBeUIsU0FBU0EsY0FBVCxDQUF3QnJhLElBQXhCLEVBQThCK2EsS0FBOUIsRUFBcUNwNkIsR0FBckMsRUFBMENxNkIsZUFBMUMsRUFBMkQ7QUFDdkcsTUFBSWxhLFdBQVcsS0FBSyxDQUFwQjtBQUNBLE1BQUksT0FBT2QsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QjtBQUNBYyxlQUFXLENBQUMsR0FBRzhaLFdBQVdyYSxTQUFmLEVBQTBCUCxJQUExQixDQUFYO0FBQ0FjLGFBQVNpYSxLQUFULEdBQWlCQSxLQUFqQjtBQUNELEdBSkQsTUFJTztBQUNMO0FBQ0FqYSxlQUFXd1osU0FBUyxFQUFULEVBQWF0YSxJQUFiLENBQVg7O0FBRUEsUUFBSWMsU0FBU04sUUFBVCxLQUFzQnhtQixTQUExQixFQUFxQzhtQixTQUFTTixRQUFULEdBQW9CLEVBQXBCOztBQUVyQyxRQUFJTSxTQUFTTCxNQUFiLEVBQXFCO0FBQ25CLFVBQUlLLFNBQVNMLE1BQVQsQ0FBZ0JSLE1BQWhCLENBQXVCLENBQXZCLE1BQThCLEdBQWxDLEVBQXVDYSxTQUFTTCxNQUFULEdBQWtCLE1BQU1LLFNBQVNMLE1BQWpDO0FBQ3hDLEtBRkQsTUFFTztBQUNMSyxlQUFTTCxNQUFULEdBQWtCLEVBQWxCO0FBQ0Q7O0FBRUQsUUFBSUssU0FBU0osSUFBYixFQUFtQjtBQUNqQixVQUFJSSxTQUFTSixJQUFULENBQWNULE1BQWQsQ0FBcUIsQ0FBckIsTUFBNEIsR0FBaEMsRUFBcUNhLFNBQVNKLElBQVQsR0FBZ0IsTUFBTUksU0FBU0osSUFBL0I7QUFDdEMsS0FGRCxNQUVPO0FBQ0xJLGVBQVNKLElBQVQsR0FBZ0IsRUFBaEI7QUFDRDs7QUFFRCxRQUFJcWEsVUFBVS9nQyxTQUFWLElBQXVCOG1CLFNBQVNpYSxLQUFULEtBQW1CL2dDLFNBQTlDLEVBQXlEOG1CLFNBQVNpYSxLQUFULEdBQWlCQSxLQUFqQjtBQUMxRDs7QUFFRCxNQUFJO0FBQ0ZqYSxhQUFTTixRQUFULEdBQW9CeWEsVUFBVW5hLFNBQVNOLFFBQW5CLENBQXBCO0FBQ0QsR0FGRCxDQUVFLE9BQU85cEIsQ0FBUCxFQUFVO0FBQ1YsUUFBSUEsYUFBYXdrQyxRQUFqQixFQUEyQjtBQUN6QixZQUFNLElBQUlBLFFBQUosQ0FBYSxlQUFlcGEsU0FBU04sUUFBeEIsR0FBbUMsMEJBQW5DLEdBQWdFLHVEQUE3RSxDQUFOO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsWUFBTTlwQixDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJaUssR0FBSixFQUFTbWdCLFNBQVNuZ0IsR0FBVCxHQUFlQSxHQUFmOztBQUVULE1BQUlxNkIsZUFBSixFQUFxQjtBQUNuQjtBQUNBLFFBQUksQ0FBQ2xhLFNBQVNOLFFBQWQsRUFBd0I7QUFDdEJNLGVBQVNOLFFBQVQsR0FBb0J3YSxnQkFBZ0J4YSxRQUFwQztBQUNELEtBRkQsTUFFTyxJQUFJTSxTQUFTTixRQUFULENBQWtCUCxNQUFsQixDQUF5QixDQUF6QixNQUFnQyxHQUFwQyxFQUF5QztBQUM5Q2EsZUFBU04sUUFBVCxHQUFvQixDQUFDLEdBQUdnYSxrQkFBa0JNLE9BQXRCLEVBQStCaGEsU0FBU04sUUFBeEMsRUFBa0R3YSxnQkFBZ0J4YSxRQUFsRSxDQUFwQjtBQUNEO0FBQ0YsR0FQRCxNQU9PO0FBQ0w7QUFDQSxRQUFJLENBQUNNLFNBQVNOLFFBQWQsRUFBd0I7QUFDdEJNLGVBQVNOLFFBQVQsR0FBb0IsR0FBcEI7QUFDRDtBQUNGOztBQUVELFNBQU9NLFFBQVA7QUFDRCxDQXRERDs7QUF3REEsSUFBSXNaLG9CQUFvQmprQyxRQUFRaWtDLGlCQUFSLEdBQTRCLFNBQVNBLGlCQUFULENBQTJCamdDLENBQTNCLEVBQThCQyxDQUE5QixFQUFpQztBQUNuRixTQUFPRCxFQUFFcW1CLFFBQUYsS0FBZXBtQixFQUFFb21CLFFBQWpCLElBQTZCcm1CLEVBQUVzbUIsTUFBRixLQUFhcm1CLEVBQUVxbUIsTUFBNUMsSUFBc0R0bUIsRUFBRXVtQixJQUFGLEtBQVd0bUIsRUFBRXNtQixJQUFuRSxJQUEyRXZtQixFQUFFd0csR0FBRixLQUFVdkcsRUFBRXVHLEdBQXZGLElBQThGLENBQUMsR0FBR2c2QixhQUFhRyxPQUFqQixFQUEwQjNnQyxFQUFFNGdDLEtBQTVCLEVBQW1DM2dDLEVBQUUyZ0MsS0FBckMsQ0FBckc7QUFDRCxDQUZELEM7Ozs7Ozs7QUMzRUE7O0FBRUE1a0MsUUFBUTJwQixVQUFSLEdBQXFCLElBQXJCOztBQUVBLElBQUlxYixXQUFXLG1CQUFBdGdDLENBQVEsRUFBUixDQUFmOztBQUVBLElBQUl1Z0MsWUFBWVgsdUJBQXVCVSxRQUF2QixDQUFoQjs7QUFFQSxTQUFTVixzQkFBVCxDQUFnQ0ksR0FBaEMsRUFBcUM7QUFBRSxTQUFPQSxPQUFPQSxJQUFJL2EsVUFBWCxHQUF3QithLEdBQXhCLEdBQThCLEVBQUVDLFNBQVNELEdBQVgsRUFBckM7QUFBd0Q7O0FBRS9GLElBQUlRLDBCQUEwQixTQUFTQSx1QkFBVCxHQUFtQztBQUMvRCxNQUFJQyxTQUFTLElBQWI7O0FBRUEsTUFBSUMsWUFBWSxTQUFTQSxTQUFULENBQW1CQyxVQUFuQixFQUErQjtBQUM3QyxLQUFDLEdBQUdKLFVBQVVOLE9BQWQsRUFBdUJRLFVBQVUsSUFBakMsRUFBdUMsOENBQXZDOztBQUVBQSxhQUFTRSxVQUFUOztBQUVBLFdBQU8sWUFBWTtBQUNqQixVQUFJRixXQUFXRSxVQUFmLEVBQTJCRixTQUFTLElBQVQ7QUFDNUIsS0FGRDtBQUdELEdBUkQ7O0FBVUEsTUFBSUcsc0JBQXNCLFNBQVNBLG1CQUFULENBQTZCM2EsUUFBN0IsRUFBdUMvUSxNQUF2QyxFQUErQzJyQixtQkFBL0MsRUFBb0Uzd0IsUUFBcEUsRUFBOEU7QUFDdEc7QUFDQTtBQUNBO0FBQ0EsUUFBSXV3QixVQUFVLElBQWQsRUFBb0I7QUFDbEIsVUFBSXJyQixTQUFTLE9BQU9xckIsTUFBUCxLQUFrQixVQUFsQixHQUErQkEsT0FBT3hhLFFBQVAsRUFBaUIvUSxNQUFqQixDQUEvQixHQUEwRHVyQixNQUF2RTs7QUFFQSxVQUFJLE9BQU9yckIsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QixZQUFJLE9BQU95ckIsbUJBQVAsS0FBK0IsVUFBbkMsRUFBK0M7QUFDN0NBLDhCQUFvQnpyQixNQUFwQixFQUE0QmxGLFFBQTVCO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsV0FBQyxHQUFHcXdCLFVBQVVOLE9BQWQsRUFBdUIsS0FBdkIsRUFBOEIsaUZBQTlCOztBQUVBL3ZCLG1CQUFTLElBQVQ7QUFDRDtBQUNGLE9BUkQsTUFRTztBQUNMO0FBQ0FBLGlCQUFTa0YsV0FBVyxLQUFwQjtBQUNEO0FBQ0YsS0FmRCxNQWVPO0FBQ0xsRixlQUFTLElBQVQ7QUFDRDtBQUNGLEdBdEJEOztBQXdCQSxNQUFJelIsWUFBWSxFQUFoQjs7QUFFQSxNQUFJcWlDLGlCQUFpQixTQUFTQSxjQUFULENBQXdCdjVCLEVBQXhCLEVBQTRCO0FBQy9DLFFBQUl3NUIsV0FBVyxJQUFmOztBQUVBLFFBQUlwZ0IsV0FBVyxTQUFTQSxRQUFULEdBQW9CO0FBQ2pDLFVBQUlvZ0IsUUFBSixFQUFjeDVCLEdBQUcvSixLQUFILENBQVMyQixTQUFULEVBQW9CakMsU0FBcEI7QUFDZixLQUZEOztBQUlBdUIsY0FBVXJCLElBQVYsQ0FBZXVqQixRQUFmOztBQUVBLFdBQU8sWUFBWTtBQUNqQm9nQixpQkFBVyxLQUFYO0FBQ0F0aUMsa0JBQVlBLFVBQVV1aUMsTUFBVixDQUFpQixVQUFVdDRCLElBQVYsRUFBZ0I7QUFDM0MsZUFBT0EsU0FBU2lZLFFBQWhCO0FBQ0QsT0FGVyxDQUFaO0FBR0QsS0FMRDtBQU1ELEdBZkQ7O0FBaUJBLE1BQUlzZ0Isa0JBQWtCLFNBQVNBLGVBQVQsR0FBMkI7QUFDL0MsU0FBSyxJQUFJOWdDLE9BQU9qRCxVQUFVVCxNQUFyQixFQUE2Qk8sT0FBT0MsTUFBTWtELElBQU4sQ0FBcEMsRUFBaURDLE9BQU8sQ0FBN0QsRUFBZ0VBLE9BQU9ELElBQXZFLEVBQTZFQyxNQUE3RSxFQUFxRjtBQUNuRnBELFdBQUtvRCxJQUFMLElBQWFsRCxVQUFVa0QsSUFBVixDQUFiO0FBQ0Q7O0FBRUQzQixjQUFVMkcsT0FBVixDQUFrQixVQUFVdWIsUUFBVixFQUFvQjtBQUNwQyxhQUFPQSxTQUFTbmpCLEtBQVQsQ0FBZTJCLFNBQWYsRUFBMEJuQyxJQUExQixDQUFQO0FBQ0QsS0FGRDtBQUdELEdBUkQ7O0FBVUEsU0FBTztBQUNMMGpDLGVBQVdBLFNBRE47QUFFTEUseUJBQXFCQSxtQkFGaEI7QUFHTEUsb0JBQWdCQSxjQUhYO0FBSUxHLHFCQUFpQkE7QUFKWixHQUFQO0FBTUQsQ0F4RUQ7O0FBMEVBM2xDLFFBQVEya0MsT0FBUixHQUFrQk8sdUJBQWxCLEM7Ozs7Ozs7Ozs7Ozs7OztBQzVFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBWEEsSUFBSWYsV0FBV3Y3QixPQUFPTyxNQUFQLElBQWlCLFVBQVVlLE1BQVYsRUFBa0I7QUFBRSxPQUFLLElBQUlySSxJQUFJLENBQWIsRUFBZ0JBLElBQUlELFVBQVVULE1BQTlCLEVBQXNDVSxHQUF0QyxFQUEyQztBQUFFLFFBQUlzSSxTQUFTdkksVUFBVUMsQ0FBVixDQUFiLENBQTJCLEtBQUssSUFBSTJJLEdBQVQsSUFBZ0JMLE1BQWhCLEVBQXdCO0FBQUUsVUFBSXZCLE9BQU8zRyxTQUFQLENBQWlCNEYsY0FBakIsQ0FBZ0NsSCxJQUFoQyxDQUFxQ3dKLE1BQXJDLEVBQTZDSyxHQUE3QyxDQUFKLEVBQXVEO0FBQUVOLGVBQU9NLEdBQVAsSUFBY0wsT0FBT0ssR0FBUCxDQUFkO0FBQTRCO0FBQUU7QUFBRSxHQUFDLE9BQU9OLE1BQVA7QUFBZ0IsQ0FBaFE7O0FBRUEsU0FBUzA3QixlQUFULENBQXlCN21CLFFBQXpCLEVBQW1DOG1CLFdBQW5DLEVBQWdEO0FBQUUsTUFBSSxFQUFFOW1CLG9CQUFvQjhtQixXQUF0QixDQUFKLEVBQXdDO0FBQUUsVUFBTSxJQUFJNThCLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQTJEO0FBQUU7O0FBRXpKLFNBQVM2OEIsMEJBQVQsQ0FBb0Nyb0IsSUFBcEMsRUFBMEM5YyxJQUExQyxFQUFnRDtBQUFFLE1BQUksQ0FBQzhjLElBQUwsRUFBVztBQUFFLFVBQU0sSUFBSXNvQixjQUFKLENBQW1CLDJEQUFuQixDQUFOO0FBQXdGLEdBQUMsT0FBT3BsQyxTQUFTLFFBQU9BLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFBNEIsT0FBT0EsSUFBUCxLQUFnQixVQUFyRCxJQUFtRUEsSUFBbkUsR0FBMEU4YyxJQUFqRjtBQUF3Rjs7QUFFaFAsU0FBU3VvQixTQUFULENBQW1CQyxRQUFuQixFQUE2QkMsVUFBN0IsRUFBeUM7QUFBRSxNQUFJLE9BQU9BLFVBQVAsS0FBc0IsVUFBdEIsSUFBb0NBLGVBQWUsSUFBdkQsRUFBNkQ7QUFBRSxVQUFNLElBQUlqOUIsU0FBSixDQUFjLHFFQUFvRWk5QixVQUFwRSx5Q0FBb0VBLFVBQXBFLEVBQWQsQ0FBTjtBQUFzRyxHQUFDRCxTQUFTaGtDLFNBQVQsR0FBcUIyRyxPQUFPb1EsTUFBUCxDQUFja3RCLGNBQWNBLFdBQVdqa0MsU0FBdkMsRUFBa0QsRUFBRW1XLGFBQWEsRUFBRWUsT0FBTzhzQixRQUFULEVBQW1CdG9CLFlBQVksS0FBL0IsRUFBc0NDLFVBQVUsSUFBaEQsRUFBc0RqRSxjQUFjLElBQXBFLEVBQWYsRUFBbEQsQ0FBckIsQ0FBcUssSUFBSXVzQixVQUFKLEVBQWdCdDlCLE9BQU91OUIsY0FBUCxHQUF3QnY5QixPQUFPdTlCLGNBQVAsQ0FBc0JGLFFBQXRCLEVBQWdDQyxVQUFoQyxDQUF4QixHQUFzRUQsU0FBU0csU0FBVCxHQUFxQkYsVUFBM0Y7QUFBd0c7O0FBTzllOzs7O0FBSUEsSUFBSXg2QixTQUFTLFVBQVUyNkIsZ0JBQVYsRUFBNEI7QUFDdkNMLFlBQVV0NkIsTUFBVixFQUFrQjI2QixnQkFBbEI7O0FBRUEsV0FBUzM2QixNQUFULEdBQWtCO0FBQ2hCLFFBQUk0NkIsS0FBSixFQUFXQyxLQUFYLEVBQWtCQyxJQUFsQjs7QUFFQVosb0JBQWdCLElBQWhCLEVBQXNCbDZCLE1BQXRCOztBQUVBLFNBQUssSUFBSTdHLE9BQU9qRCxVQUFVVCxNQUFyQixFQUE2Qk8sT0FBT0MsTUFBTWtELElBQU4sQ0FBcEMsRUFBaURDLE9BQU8sQ0FBN0QsRUFBZ0VBLE9BQU9ELElBQXZFLEVBQTZFQyxNQUE3RSxFQUFxRjtBQUNuRnBELFdBQUtvRCxJQUFMLElBQWFsRCxVQUFVa0QsSUFBVixDQUFiO0FBQ0Q7O0FBRUQsV0FBTzBoQyxRQUFRRixTQUFTQyxRQUFRVCwyQkFBMkIsSUFBM0IsRUFBaUNPLGlCQUFpQjFsQyxJQUFqQixDQUFzQnVCLEtBQXRCLENBQTRCbWtDLGdCQUE1QixFQUE4QyxDQUFDLElBQUQsRUFBT2psQyxNQUFQLENBQWNNLElBQWQsQ0FBOUMsQ0FBakMsQ0FBUixFQUE4RzZrQyxLQUF2SCxHQUErSEEsTUFBTTNCLEtBQU4sR0FBYztBQUMxSnBWLGFBQU8rVyxNQUFNRSxZQUFOLENBQW1CRixNQUFNbnBCLEtBQU4sQ0FBWXNwQixPQUFaLENBQW9CL2IsUUFBcEIsQ0FBNkJOLFFBQWhEO0FBRG1KLEtBQTdJLEVBRVppYyxLQUZJLEdBRUlSLDJCQUEyQlMsS0FBM0IsRUFBa0NDLElBQWxDLENBRlg7QUFHRDs7QUFFRDk2QixTQUFPekosU0FBUCxDQUFpQjBrQyxlQUFqQixHQUFtQyxTQUFTQSxlQUFULEdBQTJCO0FBQzVELFdBQU87QUFDTEMsY0FBUXpDLFNBQVMsRUFBVCxFQUFhLEtBQUs5dEIsT0FBTCxDQUFhdXdCLE1BQTFCLEVBQWtDO0FBQ3hDRixpQkFBUyxLQUFLdHBCLEtBQUwsQ0FBV3NwQixPQURvQjtBQUV4Q0csZUFBTztBQUNMbGMsb0JBQVUsS0FBS3ZOLEtBQUwsQ0FBV3NwQixPQUFYLENBQW1CL2IsUUFEeEI7QUFFTDZFLGlCQUFPLEtBQUtvVixLQUFMLENBQVdwVjtBQUZiO0FBRmlDLE9BQWxDO0FBREgsS0FBUDtBQVNELEdBVkQ7O0FBWUE5akIsU0FBT3pKLFNBQVAsQ0FBaUJ3a0MsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUFzQnBjLFFBQXRCLEVBQWdDO0FBQzlELFdBQU87QUFDTFIsWUFBTSxHQUREO0FBRUxpZCxXQUFLLEdBRkE7QUFHTEMsY0FBUSxFQUhIO0FBSUxDLGVBQVMzYyxhQUFhO0FBSmpCLEtBQVA7QUFNRCxHQVBEOztBQVNBM2UsU0FBT3pKLFNBQVAsQ0FBaUJnbEMsa0JBQWpCLEdBQXNDLFNBQVNBLGtCQUFULEdBQThCO0FBQ2xFLFFBQUlDLFNBQVMsSUFBYjs7QUFFQSxRQUFJQyxTQUFTLEtBQUsvcEIsS0FBbEI7QUFBQSxRQUNJNVYsV0FBVzIvQixPQUFPMy9CLFFBRHRCO0FBQUEsUUFFSWsvQixVQUFVUyxPQUFPVCxPQUZyQjs7QUFLQSw2QkFBVWwvQixZQUFZLElBQVosSUFBb0IsZ0JBQU1xWixRQUFOLENBQWVDLEtBQWYsQ0FBcUJ0WixRQUFyQixNQUFtQyxDQUFqRSxFQUFvRSw0Q0FBcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBSzQvQixRQUFMLEdBQWdCVixRQUFRVyxNQUFSLENBQWUsWUFBWTtBQUN6Q0gsYUFBT0ksUUFBUCxDQUFnQjtBQUNkOVgsZUFBTzBYLE9BQU9ULFlBQVAsQ0FBb0JDLFFBQVEvYixRQUFSLENBQWlCTixRQUFyQztBQURPLE9BQWhCO0FBR0QsS0FKZSxDQUFoQjtBQUtELEdBbEJEOztBQW9CQTNlLFNBQU96SixTQUFQLENBQWlCc2xDLHlCQUFqQixHQUE2QyxTQUFTQSx5QkFBVCxDQUFtQ0MsU0FBbkMsRUFBOEM7QUFDekYsMkJBQVEsS0FBS3BxQixLQUFMLENBQVdzcEIsT0FBWCxLQUF1QmMsVUFBVWQsT0FBekMsRUFBa0Qsb0NBQWxEO0FBQ0QsR0FGRDs7QUFJQWg3QixTQUFPekosU0FBUCxDQUFpQndsQyxvQkFBakIsR0FBd0MsU0FBU0Esb0JBQVQsR0FBZ0M7QUFDdEUsU0FBS0wsUUFBTDtBQUNELEdBRkQ7O0FBSUExN0IsU0FBT3pKLFNBQVAsQ0FBaUJ5bEMsTUFBakIsR0FBMEIsU0FBU0EsTUFBVCxHQUFrQjtBQUMxQyxRQUFJbGdDLFdBQVcsS0FBSzRWLEtBQUwsQ0FBVzVWLFFBQTFCOztBQUVBLFdBQU9BLFdBQVcsZ0JBQU1xWixRQUFOLENBQWVHLElBQWYsQ0FBb0J4WixRQUFwQixDQUFYLEdBQTJDLElBQWxEO0FBQ0QsR0FKRDs7QUFNQSxTQUFPa0UsTUFBUDtBQUNELENBekVZLENBeUVYLGdCQUFNdVYsU0F6RUssQ0FBYjs7QUEyRUF2VixPQUFPeXhCLFNBQVAsR0FBbUI7QUFDakJ1SixXQUFTLG9CQUFVdDBCLE1BQVYsQ0FBaUJ1MUIsVUFEVDtBQUVqQm5nQyxZQUFVLG9CQUFVbEI7QUFGSCxDQUFuQjtBQUlBb0YsT0FBT2s4QixZQUFQLEdBQXNCO0FBQ3BCaEIsVUFBUSxvQkFBVXgwQjtBQURFLENBQXRCO0FBR0ExRyxPQUFPbThCLGlCQUFQLEdBQTJCO0FBQ3pCakIsVUFBUSxvQkFBVXgwQixNQUFWLENBQWlCdTFCO0FBREEsQ0FBM0I7O2tCQUtlajhCLE07Ozs7Ozs7Ozs7Ozs7QUN4R2Y7Ozs7OztBQUVBLElBQUlvOEIsZUFBZSxFQUFuQjtBQUNBLElBQUlDLGFBQWEsS0FBakI7QUFDQSxJQUFJQyxhQUFhLENBQWpCOztBQUVBLElBQUlDLGNBQWMsU0FBU0EsV0FBVCxDQUFxQkMsT0FBckIsRUFBOEJDLE9BQTlCLEVBQXVDO0FBQ3ZELE1BQUlDLFdBQVcsS0FBS0QsUUFBUUUsR0FBYixHQUFtQkYsUUFBUUcsTUFBMUM7QUFDQSxNQUFJQyxRQUFRVCxhQUFhTSxRQUFiLE1BQTJCTixhQUFhTSxRQUFiLElBQXlCLEVBQXBELENBQVo7O0FBRUEsTUFBSUcsTUFBTUwsT0FBTixDQUFKLEVBQW9CLE9BQU9LLE1BQU1MLE9BQU4sQ0FBUDs7QUFFcEIsTUFBSWwrQixPQUFPLEVBQVg7QUFDQSxNQUFJdytCLEtBQUssNEJBQWFOLE9BQWIsRUFBc0JsK0IsSUFBdEIsRUFBNEJtK0IsT0FBNUIsQ0FBVDtBQUNBLE1BQUlNLGtCQUFrQixFQUFFRCxJQUFJQSxFQUFOLEVBQVV4K0IsTUFBTUEsSUFBaEIsRUFBdEI7O0FBRUEsTUFBSWcrQixhQUFhRCxVQUFqQixFQUE2QjtBQUMzQlEsVUFBTUwsT0FBTixJQUFpQk8sZUFBakI7QUFDQVQ7QUFDRDs7QUFFRCxTQUFPUyxlQUFQO0FBQ0QsQ0FoQkQ7O0FBa0JBOzs7QUFHQSxJQUFJNThCLFlBQVksU0FBU0EsU0FBVCxDQUFtQndlLFFBQW5CLEVBQTZCO0FBQzNDLE1BQUk4ZCxVQUFVdm1DLFVBQVVULE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JTLFVBQVUsQ0FBVixNQUFpQmlDLFNBQXpDLEdBQXFEakMsVUFBVSxDQUFWLENBQXJELEdBQW9FLEVBQWxGOztBQUVBLE1BQUksT0FBT3VtQyxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDQSxVQUFVLEVBQUV0ZSxNQUFNc2UsT0FBUixFQUFWOztBQUVqQyxNQUFJTyxXQUFXUCxPQUFmO0FBQUEsTUFDSVEsZ0JBQWdCRCxTQUFTN2UsSUFEN0I7QUFBQSxNQUVJQSxPQUFPOGUsa0JBQWtCOWtDLFNBQWxCLEdBQThCLEdBQTlCLEdBQW9DOGtDLGFBRi9DO0FBQUEsTUFHSUMsaUJBQWlCRixTQUFTRyxLQUg5QjtBQUFBLE1BSUlBLFFBQVFELG1CQUFtQi9rQyxTQUFuQixHQUErQixLQUEvQixHQUF1QytrQyxjQUpuRDtBQUFBLE1BS0lFLGtCQUFrQkosU0FBU0osTUFML0I7QUFBQSxNQU1JQSxTQUFTUSxvQkFBb0JqbEMsU0FBcEIsR0FBZ0MsS0FBaEMsR0FBd0NpbEMsZUFOckQ7O0FBUUEsTUFBSUMsZUFBZWQsWUFBWXBlLElBQVosRUFBa0IsRUFBRXdlLEtBQUtRLEtBQVAsRUFBY1AsUUFBUUEsTUFBdEIsRUFBbEIsQ0FBbkI7QUFBQSxNQUNJRSxLQUFLTyxhQUFhUCxFQUR0QjtBQUFBLE1BRUl4K0IsT0FBTysrQixhQUFhLytCLElBRnhCOztBQUlBLE1BQUl3bEIsUUFBUWdaLEdBQUcvWSxJQUFILENBQVFwRixRQUFSLENBQVo7O0FBRUEsTUFBSSxDQUFDbUYsS0FBTCxFQUFZLE9BQU8sSUFBUDs7QUFFWixNQUFJc1gsTUFBTXRYLE1BQU0sQ0FBTixDQUFWO0FBQUEsTUFDSXdaLFNBQVN4WixNQUFNcHBCLEtBQU4sQ0FBWSxDQUFaLENBRGI7O0FBR0EsTUFBSTRnQyxVQUFVM2MsYUFBYXljLEdBQTNCOztBQUVBLE1BQUkrQixTQUFTLENBQUM3QixPQUFkLEVBQXVCLE9BQU8sSUFBUDs7QUFFdkIsU0FBTztBQUNMbmQsVUFBTUEsSUFERCxFQUNPO0FBQ1ppZCxTQUFLamQsU0FBUyxHQUFULElBQWdCaWQsUUFBUSxFQUF4QixHQUE2QixHQUE3QixHQUFtQ0EsR0FGbkMsRUFFd0M7QUFDN0NFLGFBQVNBLE9BSEosRUFHYTtBQUNsQkQsWUFBUS84QixLQUFLaS9CLE1BQUwsQ0FBWSxVQUFVQyxJQUFWLEVBQWdCMStCLEdBQWhCLEVBQXFCbWxCLEtBQXJCLEVBQTRCO0FBQzlDdVosV0FBSzErQixJQUFJcEgsSUFBVCxJQUFpQjRsQyxPQUFPclosS0FBUCxDQUFqQjtBQUNBLGFBQU91WixJQUFQO0FBQ0QsS0FITyxFQUdMLEVBSEs7QUFKSCxHQUFQO0FBU0QsQ0FyQ0Q7O2tCQXVDZXI5QixTOzs7Ozs7O0FDbEVmOzs7Ozs7Ozs7O0FBVUE7Ozs7QUFFQSxJQUFJbkcsaUJBQWlCLG1CQUFBaEIsQ0FBUSxFQUFSLENBQXJCO0FBQUEsSUFDSTZOLFVBQVUsbUJBQUE3TixDQUFRLEVBQVIsQ0FEZDs7QUFHQSxJQUFJeWtDLHVCQUF1QixtQkFBQXprQyxDQUFRLEVBQVIsQ0FBM0I7O0FBRUEsSUFBSTRYLG9CQUFvQixtQkFBQTVYLENBQVEsRUFBUixDQUF4QjtBQUNBLElBQUlrbUIsY0FBYyxtQkFBQWxtQixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJMGIscUJBQXFCLG1CQUFBMWIsQ0FBUSxFQUFSLENBQXpCOztBQUVBOzs7QUFHQSxTQUFTMGtDLGNBQVQsQ0FBd0Joc0IsS0FBeEIsRUFBK0IvRyxPQUEvQixFQUF3Q2d6QixPQUF4QyxFQUFpRDtBQUMvQyxPQUFLanNCLEtBQUwsR0FBYUEsS0FBYjtBQUNBLE9BQUsvRyxPQUFMLEdBQWVBLE9BQWY7QUFDQSxPQUFLaXpCLElBQUwsR0FBWTFlLFdBQVo7QUFDQTtBQUNBO0FBQ0EsT0FBS3llLE9BQUwsR0FBZUEsV0FBV0Ysb0JBQTFCO0FBQ0Q7O0FBRURDLGVBQWVubkMsU0FBZixDQUF5QnNuQyxnQkFBekIsR0FBNEMsRUFBNUM7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkFILGVBQWVubkMsU0FBZixDQUF5QnFsQyxRQUF6QixHQUFvQyxVQUFVM0csWUFBVixFQUF3Qi9yQixRQUF4QixFQUFrQztBQUNwRSxJQUFFLFFBQU8rckIsWUFBUCx5Q0FBT0EsWUFBUCxPQUF3QixRQUF4QixJQUFvQyxPQUFPQSxZQUFQLEtBQXdCLFVBQTVELElBQTBFQSxnQkFBZ0IsSUFBNUYsSUFBb0c3Z0MsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQix1SEFBakIsQ0FBeEMsR0FBb0w0QixlQUFlLElBQWYsQ0FBeFIsR0FBK1MsS0FBSyxDQUFwVDtBQUNBLE9BQUsyakMsT0FBTCxDQUFhM0ksZUFBYixDQUE2QixJQUE3QixFQUFtQ0MsWUFBbkM7QUFDQSxNQUFJL3JCLFFBQUosRUFBYztBQUNaLFNBQUt5MEIsT0FBTCxDQUFhcEosZUFBYixDQUE2QixJQUE3QixFQUFtQ3JyQixRQUFuQyxFQUE2QyxVQUE3QztBQUNEO0FBQ0YsQ0FORDs7QUFRQTs7Ozs7Ozs7Ozs7Ozs7QUFjQXcwQixlQUFlbm5DLFNBQWYsQ0FBeUJ1bkMsV0FBekIsR0FBdUMsVUFBVTUwQixRQUFWLEVBQW9CO0FBQ3pELE9BQUt5MEIsT0FBTCxDQUFhakosa0JBQWIsQ0FBZ0MsSUFBaEM7QUFDQSxNQUFJeHJCLFFBQUosRUFBYztBQUNaLFNBQUt5MEIsT0FBTCxDQUFhcEosZUFBYixDQUE2QixJQUE3QixFQUFtQ3JyQixRQUFuQyxFQUE2QyxhQUE3QztBQUNEO0FBQ0YsQ0FMRDs7QUFPQTs7Ozs7QUFLQSxJQUFJOVUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSTZsQyxpQkFBaUI7QUFDbkJ0NkIsZUFBVyxDQUFDLFdBQUQsRUFBYywwRUFBMEUsK0NBQXhGLENBRFE7QUFFbkJ1NkIsa0JBQWMsQ0FBQyxjQUFELEVBQWlCLHFEQUFxRCxpREFBdEU7QUFGSyxHQUFyQjtBQUlBLE1BQUlDLDJCQUEyQixTQUEzQkEsd0JBQTJCLENBQVVDLFVBQVYsRUFBc0IzNUIsSUFBdEIsRUFBNEI7QUFDekQsUUFBSXFNLGlCQUFKLEVBQXVCO0FBQ3JCMVQsYUFBT2lRLGNBQVAsQ0FBc0J1d0IsZUFBZW5uQyxTQUFyQyxFQUFnRDJuQyxVQUFoRCxFQUE0RDtBQUMxRHQ4QixhQUFLLGVBQVk7QUFDZjhTLDZCQUFtQixLQUFuQixFQUEwQiw2REFBMUIsRUFBeUZuUSxLQUFLLENBQUwsQ0FBekYsRUFBa0dBLEtBQUssQ0FBTCxDQUFsRztBQUNBLGlCQUFPcE0sU0FBUDtBQUNEO0FBSnlELE9BQTVEO0FBTUQ7QUFDRixHQVREO0FBVUEsT0FBSyxJQUFJZ21DLE1BQVQsSUFBbUJKLGNBQW5CLEVBQW1DO0FBQ2pDLFFBQUlBLGVBQWU1aEMsY0FBZixDQUE4QmdpQyxNQUE5QixDQUFKLEVBQTJDO0FBQ3pDRiwrQkFBeUJFLE1BQXpCLEVBQWlDSixlQUFlSSxNQUFmLENBQWpDO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7QUFHQSxTQUFTQyxrQkFBVCxDQUE0QjFzQixLQUE1QixFQUFtQy9HLE9BQW5DLEVBQTRDZ3pCLE9BQTVDLEVBQXFEO0FBQ25EO0FBQ0EsT0FBS2pzQixLQUFMLEdBQWFBLEtBQWI7QUFDQSxPQUFLL0csT0FBTCxHQUFlQSxPQUFmO0FBQ0EsT0FBS2l6QixJQUFMLEdBQVkxZSxXQUFaO0FBQ0E7QUFDQTtBQUNBLE9BQUt5ZSxPQUFMLEdBQWVBLFdBQVdGLG9CQUExQjtBQUNEOztBQUVELFNBQVNZLGNBQVQsR0FBMEIsQ0FBRTtBQUM1QkEsZUFBZTluQyxTQUFmLEdBQTJCbW5DLGVBQWVubkMsU0FBMUM7QUFDQTZuQyxtQkFBbUI3bkMsU0FBbkIsR0FBK0IsSUFBSThuQyxjQUFKLEVBQS9CO0FBQ0FELG1CQUFtQjduQyxTQUFuQixDQUE2Qm1XLFdBQTdCLEdBQTJDMHhCLGtCQUEzQztBQUNBO0FBQ0F2M0IsUUFBUXUzQixtQkFBbUI3bkMsU0FBM0IsRUFBc0NtbkMsZUFBZW5uQyxTQUFyRDtBQUNBNm5DLG1CQUFtQjduQyxTQUFuQixDQUE2QituQyxvQkFBN0IsR0FBb0QsSUFBcEQ7O0FBRUFqcUMsT0FBT0MsT0FBUCxHQUFpQjtBQUNmaWhCLGFBQVdtb0IsY0FESTtBQUVmbG9CLGlCQUFlNG9CO0FBRkEsQ0FBakIsQzs7Ozs7Ozs7QUMxSUE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJbmxDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLFNBQVN1bEMsUUFBVCxDQUFrQnJLLGNBQWxCLEVBQWtDQyxVQUFsQyxFQUE4QztBQUM1QyxNQUFJLy9CLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFFBQUl3VSxjQUFjd25CLGVBQWV4bkIsV0FBakM7QUFDQXRZLFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSwrREFBK0QsZ0VBQS9ELEdBQWtJLDhEQUFqSixFQUFpTms3QixVQUFqTixFQUE2TkEsVUFBN04sRUFBeU96bkIsZ0JBQWdCQSxZQUFZNUosV0FBWixJQUEyQjRKLFlBQVloVixJQUF2RCxLQUFnRSxZQUF6UyxDQUF4QyxHQUFpVyxLQUFLLENBQXRXO0FBQ0Q7QUFDRjs7QUFFRDs7O0FBR0EsSUFBSStsQyx1QkFBdUI7QUFDekI7Ozs7Ozs7QUFPQWg2QixhQUFXLG1CQUFVeXdCLGNBQVYsRUFBMEI7QUFDbkMsV0FBTyxLQUFQO0FBQ0QsR0FWd0I7O0FBWXpCOzs7Ozs7OztBQVFBSyxtQkFBaUIseUJBQVVMLGNBQVYsRUFBMEJockIsUUFBMUIsRUFBb0MsQ0FBRSxDQXBCOUI7O0FBc0J6Qjs7Ozs7Ozs7Ozs7OztBQWFBd3JCLHNCQUFvQiw0QkFBVVIsY0FBVixFQUEwQjtBQUM1Q3FLLGFBQVNySyxjQUFULEVBQXlCLGFBQXpCO0FBQ0QsR0FyQ3dCOztBQXVDekI7Ozs7Ozs7Ozs7O0FBV0FVLHVCQUFxQiw2QkFBVVYsY0FBVixFQUEwQlcsYUFBMUIsRUFBeUM7QUFDNUQwSixhQUFTckssY0FBVCxFQUF5QixjQUF6QjtBQUNELEdBcER3Qjs7QUFzRHpCOzs7Ozs7Ozs7O0FBVUFjLG1CQUFpQix5QkFBVWQsY0FBVixFQUEwQmUsWUFBMUIsRUFBd0M7QUFDdkRzSixhQUFTckssY0FBVCxFQUF5QixVQUF6QjtBQUNEO0FBbEV3QixDQUEzQjs7QUFxRUE3L0IsT0FBT0MsT0FBUCxHQUFpQm1wQyxvQkFBakIsQzs7Ozs7Ozs7QUM3RkE7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJbjNCLHFCQUFxQixPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxPQUFPLEtBQVAsQ0FBaEMsSUFBaURBLE9BQU8sS0FBUCxFQUFjLGVBQWQsQ0FBakQsSUFBbUYsTUFBNUc7O0FBRUFsUyxPQUFPQyxPQUFQLEdBQWlCZ1Msa0JBQWpCLEM7Ozs7Ozs7QUNsQkE7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7O0FBRUEsSUFBSWs0QixrQkFBa0IsT0FBT2o0QixNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxPQUFPazRCLFFBQTdEO0FBQ0EsSUFBSUMsdUJBQXVCLFlBQTNCLEMsQ0FBeUM7O0FBRXpDOzs7Ozs7Ozs7Ozs7OztBQWNBLFNBQVNDLGFBQVQsQ0FBdUJDLGFBQXZCLEVBQXNDO0FBQ3BDLE1BQUlDLGFBQWFELGtCQUFrQkosbUJBQW1CSSxjQUFjSixlQUFkLENBQW5CLElBQXFESSxjQUFjRixvQkFBZCxDQUF2RSxDQUFqQjtBQUNBLE1BQUksT0FBT0csVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNwQyxXQUFPQSxVQUFQO0FBQ0Q7QUFDRjs7QUFFRHhxQyxPQUFPQyxPQUFQLEdBQWlCcXFDLGFBQWpCLEM7Ozs7Ozs7QUN2Q0E7Ozs7Ozs7Ozs7QUFVQTs7Ozs7OztBQU9BOzs7O0FBRUEsSUFBSXQrQixvQkFBb0IsbUJBQUFySCxDQUFRLEVBQVIsQ0FBeEI7QUFDQSxJQUFJZ0sseUJBQXlCLG1CQUFBaEssQ0FBUSxDQUFSLENBQTdCO0FBQ0EsSUFBSThZLGVBQWUsbUJBQUE5WSxDQUFRLEVBQVIsQ0FBbkI7O0FBRUEsSUFBSThsQyxxQkFBcUIsbUJBQUE5bEMsQ0FBUSxHQUFSLENBQXpCOztBQUVBLElBQUk0WCxvQkFBb0IsbUJBQUE1WCxDQUFRLEVBQVIsQ0FBeEI7QUFDQSxJQUFJMmxDLGdCQUFnQixtQkFBQTNsQyxDQUFRLEVBQVIsQ0FBcEI7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDtBQUNBLElBQUkwYixxQkFBcUIsbUJBQUExYixDQUFRLEVBQVIsQ0FBekI7O0FBRUEsU0FBUzY0QiwyQkFBVCxHQUF1QztBQUNyQyxNQUFJeHhCLGtCQUFrQnVFLE9BQXRCLEVBQStCO0FBQzdCLFFBQUlsTixPQUFPMkksa0JBQWtCdUUsT0FBbEIsQ0FBMEJGLE9BQTFCLEVBQVg7QUFDQSxRQUFJaE4sSUFBSixFQUFVO0FBQ1IsYUFBTyxrQ0FBa0NBLElBQWxDLEdBQXlDLElBQWhEO0FBQ0Q7QUFDRjtBQUNELFNBQU8sRUFBUDtBQUNEOztBQUVELFNBQVNxbkMsMEJBQVQsQ0FBb0NDLFlBQXBDLEVBQWtEO0FBQ2hELE1BQUlBLGlCQUFpQixJQUFqQixJQUF5QkEsaUJBQWlCN21DLFNBQTFDLElBQXVENm1DLGFBQWFodUIsUUFBYixLQUEwQjdZLFNBQXJGLEVBQWdHO0FBQzlGLFFBQUlzRyxTQUFTdWdDLGFBQWFodUIsUUFBMUI7QUFDQSxRQUFJdk8sV0FBV2hFLE9BQU9nRSxRQUFQLENBQWdCNUosT0FBaEIsQ0FBd0IsV0FBeEIsRUFBcUMsRUFBckMsQ0FBZjtBQUNBLFFBQUk2SixhQUFhakUsT0FBT2lFLFVBQXhCO0FBQ0EsV0FBTyx5QkFBeUJELFFBQXpCLEdBQW9DLEdBQXBDLEdBQTBDQyxVQUExQyxHQUF1RCxHQUE5RDtBQUNEO0FBQ0QsU0FBTyxFQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsSUFBSXU4Qix3QkFBd0IsRUFBNUI7O0FBRUEsU0FBU0MsNEJBQVQsQ0FBc0NDLFVBQXRDLEVBQWtEO0FBQ2hELE1BQUk1NkIsT0FBT3N0Qiw2QkFBWDs7QUFFQSxNQUFJLENBQUN0dEIsSUFBTCxFQUFXO0FBQ1QsUUFBSTY2QixhQUFhLE9BQU9ELFVBQVAsS0FBc0IsUUFBdEIsR0FBaUNBLFVBQWpDLEdBQThDQSxXQUFXcjhCLFdBQVgsSUFBMEJxOEIsV0FBV3puQyxJQUFwRztBQUNBLFFBQUkwbkMsVUFBSixFQUFnQjtBQUNkNzZCLGFBQU8sNkNBQTZDNjZCLFVBQTdDLEdBQTBELElBQWpFO0FBQ0Q7QUFDRjtBQUNELFNBQU83NkIsSUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7OztBQVdBLFNBQVM4NkIsbUJBQVQsQ0FBNkJ6OEIsT0FBN0IsRUFBc0N1OEIsVUFBdEMsRUFBa0Q7QUFDaEQsTUFBSSxDQUFDdjhCLFFBQVFvUCxNQUFULElBQW1CcFAsUUFBUW9QLE1BQVIsQ0FBZUcsU0FBbEMsSUFBK0N2UCxRQUFROUQsR0FBUixJQUFlLElBQWxFLEVBQXdFO0FBQ3RFO0FBQ0Q7QUFDRDhELFVBQVFvUCxNQUFSLENBQWVHLFNBQWYsR0FBMkIsSUFBM0I7O0FBRUEsTUFBSW10QixXQUFXTCxzQkFBc0JNLFNBQXRCLEtBQW9DTixzQkFBc0JNLFNBQXRCLEdBQWtDLEVBQXRFLENBQWY7O0FBRUEsTUFBSUMsNEJBQTRCTiw2QkFBNkJDLFVBQTdCLENBQWhDO0FBQ0EsTUFBSUcsU0FBU0UseUJBQVQsQ0FBSixFQUF5QztBQUN2QztBQUNEO0FBQ0RGLFdBQVNFLHlCQUFULElBQXNDLElBQXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUluSSxhQUFhLEVBQWpCO0FBQ0EsTUFBSXowQixXQUFXQSxRQUFRNkIsTUFBbkIsSUFBNkI3QixRQUFRNkIsTUFBUixLQUFtQnBFLGtCQUFrQnVFLE9BQXRFLEVBQStFO0FBQzdFO0FBQ0F5eUIsaUJBQWEsaUNBQWlDejBCLFFBQVE2QixNQUFSLENBQWVDLE9BQWYsRUFBakMsR0FBNEQsR0FBekU7QUFDRDs7QUFFRHRRLFVBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSx3RUFBd0UsbUVBQXZGLEVBQTRKdW1DLHlCQUE1SixFQUF1TG5JLFVBQXZMLEVBQW1NcjBCLHVCQUF1QnFCLHVCQUF2QixDQUErQ3pCLE9BQS9DLENBQW5NLENBQXhDLEdBQXNTLEtBQUssQ0FBM1M7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBUzY4QixpQkFBVCxDQUEyQjdrQyxJQUEzQixFQUFpQ3VrQyxVQUFqQyxFQUE2QztBQUMzQyxNQUFJLFFBQU92a0MsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUFwQixFQUE4QjtBQUM1QjtBQUNEO0FBQ0QsTUFBSTNFLE1BQU11MUIsT0FBTixDQUFjNXdCLElBQWQsQ0FBSixFQUF5QjtBQUN2QixTQUFLLElBQUl6RSxJQUFJLENBQWIsRUFBZ0JBLElBQUl5RSxLQUFLbkYsTUFBekIsRUFBaUNVLEdBQWpDLEVBQXNDO0FBQ3BDLFVBQUl1cEMsUUFBUTlrQyxLQUFLekUsQ0FBTCxDQUFaO0FBQ0EsVUFBSTJiLGFBQWFyTCxjQUFiLENBQTRCaTVCLEtBQTVCLENBQUosRUFBd0M7QUFDdENMLDRCQUFvQkssS0FBcEIsRUFBMkJQLFVBQTNCO0FBQ0Q7QUFDRjtBQUNGLEdBUEQsTUFPTyxJQUFJcnRCLGFBQWFyTCxjQUFiLENBQTRCN0wsSUFBNUIsQ0FBSixFQUF1QztBQUM1QztBQUNBLFFBQUlBLEtBQUtvWCxNQUFULEVBQWlCO0FBQ2ZwWCxXQUFLb1gsTUFBTCxDQUFZRyxTQUFaLEdBQXdCLElBQXhCO0FBQ0Q7QUFDRixHQUxNLE1BS0EsSUFBSXZYLElBQUosRUFBVTtBQUNmLFFBQUlpa0MsYUFBYUYsY0FBYy9qQyxJQUFkLENBQWpCO0FBQ0E7QUFDQSxRQUFJaWtDLFVBQUosRUFBZ0I7QUFDZCxVQUFJQSxlQUFlamtDLEtBQUsra0MsT0FBeEIsRUFBaUM7QUFDL0IsWUFBSWxCLFdBQVdJLFdBQVc1cEMsSUFBWCxDQUFnQjJGLElBQWhCLENBQWY7QUFDQSxZQUFJZ2xDLElBQUo7QUFDQSxlQUFPLENBQUMsQ0FBQ0EsT0FBT25CLFNBQVNvQixJQUFULEVBQVIsRUFBeUJDLElBQWpDLEVBQXVDO0FBQ3JDLGNBQUlodUIsYUFBYXJMLGNBQWIsQ0FBNEJtNUIsS0FBS255QixLQUFqQyxDQUFKLEVBQTZDO0FBQzNDNHhCLGdDQUFvQk8sS0FBS255QixLQUF6QixFQUFnQzB4QixVQUFoQztBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7O0FBTUEsU0FBU1ksaUJBQVQsQ0FBMkJuOUIsT0FBM0IsRUFBb0M7QUFDbEMsTUFBSW85QixpQkFBaUJwOUIsUUFBUUMsSUFBN0I7QUFDQSxNQUFJLE9BQU9tOUIsY0FBUCxLQUEwQixVQUE5QixFQUEwQztBQUN4QztBQUNEO0FBQ0QsTUFBSXRvQyxPQUFPc29DLGVBQWVsOUIsV0FBZixJQUE4Qms5QixlQUFldG9DLElBQXhEO0FBQ0EsTUFBSXNvQyxlQUFldk8sU0FBbkIsRUFBOEI7QUFDNUJxTix1QkFBbUJrQixlQUFldk8sU0FBbEMsRUFBNkM3dUIsUUFBUThPLEtBQXJELEVBQTRELE1BQTVELEVBQW9FaGEsSUFBcEUsRUFBMEVrTCxPQUExRSxFQUFtRixJQUFuRjtBQUNEO0FBQ0QsTUFBSSxPQUFPbzlCLGVBQWVDLGVBQXRCLEtBQTBDLFVBQTlDLEVBQTBEO0FBQ3hEN3JDLFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRK21DLGVBQWVDLGVBQWYsQ0FBK0JDLG9CQUF2QyxFQUE2RCwrREFBK0Qsa0VBQTVILENBQXhDLEdBQTBPLEtBQUssQ0FBL087QUFDRDtBQUNGOztBQUVELElBQUl2ckIsd0JBQXdCO0FBQzFCelYsaUJBQWUsdUJBQVUyRCxJQUFWLEVBQWdCNk8sS0FBaEIsRUFBdUI1VixRQUF2QixFQUFpQztBQUM5QyxRQUFJcWtDLFlBQVksT0FBT3Q5QixJQUFQLEtBQWdCLFFBQWhCLElBQTRCLE9BQU9BLElBQVAsS0FBZ0IsVUFBNUQ7QUFDQTtBQUNBO0FBQ0EsUUFBSSxDQUFDczlCLFNBQUwsRUFBZ0I7QUFDZCxVQUFJLE9BQU90OUIsSUFBUCxLQUFnQixVQUFoQixJQUE4QixPQUFPQSxJQUFQLEtBQWdCLFFBQWxELEVBQTREO0FBQzFELFlBQUkwQixPQUFPLEVBQVg7QUFDQSxZQUFJMUIsU0FBUzFLLFNBQVQsSUFBc0IsUUFBTzBLLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFBNEJBLFNBQVMsSUFBckMsSUFBNkMzRixPQUFPb0IsSUFBUCxDQUFZdUUsSUFBWixFQUFrQnBOLE1BQWxCLEtBQTZCLENBQXBHLEVBQXVHO0FBQ3JHOE8sa0JBQVEsK0RBQStELGtCQUF2RTtBQUNEOztBQUVELFlBQUk2N0IsYUFBYXJCLDJCQUEyQnJ0QixLQUEzQixDQUFqQjtBQUNBLFlBQUkwdUIsVUFBSixFQUFnQjtBQUNkNzdCLGtCQUFRNjdCLFVBQVI7QUFDRCxTQUZELE1BRU87QUFDTDc3QixrQkFBUXN0Qiw2QkFBUjtBQUNEOztBQUVEdHRCLGdCQUFRdkIsdUJBQXVCcUIsdUJBQXZCLEVBQVI7O0FBRUEsWUFBSWtCLGdCQUFnQm1NLFVBQVUsSUFBVixJQUFrQkEsVUFBVXZaLFNBQTVCLElBQXlDdVosTUFBTVYsUUFBTixLQUFtQjdZLFNBQTVELEdBQXdFdVosTUFBTVYsUUFBOUUsR0FBeUYsSUFBN0c7QUFDQWhPLCtCQUF1QnFDLDJCQUF2QixDQUFtRCxJQUFuRCxFQUF5REUsYUFBekQ7QUFDQW5SLGdCQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsb0VBQW9FLDBEQUFwRSxHQUFpSSw0QkFBaEosRUFBOEs0SixRQUFRLElBQVIsR0FBZUEsSUFBZixVQUE2QkEsSUFBN0IseUNBQTZCQSxJQUE3QixDQUE5SyxFQUFpTjBCLElBQWpOLENBQXhDLEdBQWlRLEtBQUssQ0FBdFE7QUFDQXZCLCtCQUF1QjBDLDBCQUF2QjtBQUNEO0FBQ0Y7O0FBRUQsUUFBSTlDLFVBQVVrUCxhQUFhNVMsYUFBYixDQUEyQjFJLEtBQTNCLENBQWlDLElBQWpDLEVBQXVDTixTQUF2QyxDQUFkOztBQUVBO0FBQ0E7QUFDQSxRQUFJME0sV0FBVyxJQUFmLEVBQXFCO0FBQ25CLGFBQU9BLE9BQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSXU5QixTQUFKLEVBQWU7QUFDYixXQUFLLElBQUlocUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxVQUFVVCxNQUE5QixFQUFzQ1UsR0FBdEMsRUFBMkM7QUFDekNzcEMsMEJBQWtCdnBDLFVBQVVDLENBQVYsQ0FBbEIsRUFBZ0MwTSxJQUFoQztBQUNEO0FBQ0Y7O0FBRURrOUIsc0JBQWtCbjlCLE9BQWxCOztBQUVBLFdBQU9BLE9BQVA7QUFDRCxHQWxEeUI7O0FBb0QxQjZQLGlCQUFlLHVCQUFVNVAsSUFBVixFQUFnQjtBQUM3QixRQUFJdzlCLG1CQUFtQjFyQixzQkFBc0J6VixhQUF0QixDQUFvQ3lULElBQXBDLENBQXlDLElBQXpDLEVBQStDOVAsSUFBL0MsQ0FBdkI7QUFDQTtBQUNBdzlCLHFCQUFpQng5QixJQUFqQixHQUF3QkEsSUFBeEI7O0FBRUEsUUFBSXpPLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUkwWSxpQkFBSixFQUF1QjtBQUNyQjFULGVBQU9pUSxjQUFQLENBQXNCa3pCLGdCQUF0QixFQUF3QyxNQUF4QyxFQUFnRDtBQUM5Q3B1QixzQkFBWSxLQURrQztBQUU5Q3JRLGVBQUssZUFBWTtBQUNmOFMsK0JBQW1CLEtBQW5CLEVBQTBCLDJEQUEyRCxxQ0FBckY7QUFDQXhYLG1CQUFPaVEsY0FBUCxDQUFzQixJQUF0QixFQUE0QixNQUE1QixFQUFvQztBQUNsQ00scUJBQU81SztBQUQyQixhQUFwQztBQUdBLG1CQUFPQSxJQUFQO0FBQ0Q7QUFSNkMsU0FBaEQ7QUFVRDtBQUNGOztBQUVELFdBQU93OUIsZ0JBQVA7QUFDRCxHQXpFeUI7O0FBMkUxQnJ0QixnQkFBYyxzQkFBVXBRLE9BQVYsRUFBbUI4TyxLQUFuQixFQUEwQjVWLFFBQTFCLEVBQW9DO0FBQ2hELFFBQUlpWCxhQUFhakIsYUFBYWtCLFlBQWIsQ0FBMEJ4YyxLQUExQixDQUFnQyxJQUFoQyxFQUFzQ04sU0FBdEMsQ0FBakI7QUFDQSxTQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsVUFBVVQsTUFBOUIsRUFBc0NVLEdBQXRDLEVBQTJDO0FBQ3pDc3BDLHdCQUFrQnZwQyxVQUFVQyxDQUFWLENBQWxCLEVBQWdDNGMsV0FBV2xRLElBQTNDO0FBQ0Q7QUFDRGs5QixzQkFBa0JodEIsVUFBbEI7QUFDQSxXQUFPQSxVQUFQO0FBQ0Q7QUFsRnlCLENBQTVCOztBQXFGQTFlLE9BQU9DLE9BQVAsR0FBaUJxZ0IscUJBQWpCLEM7Ozs7Ozs7O0FDN1BBOzs7Ozs7Ozs7QUFTQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJakMsVUFBVSxtQkFBQTFaLENBQVEsRUFBUixDQUFkO0FBQ0EzRSxPQUFPQyxPQUFQLEdBQWlCLFVBQVNtUyxjQUFULEVBQXlCO0FBQ3hDO0FBQ0EsTUFBSUcsc0JBQXNCLEtBQTFCO0FBQ0EsU0FBTzhMLFFBQVFqTSxjQUFSLEVBQXdCRyxtQkFBeEIsQ0FBUDtBQUNELENBSkQsQzs7Ozs7OztBQ2hCQTs7Ozs7Ozs7O0FBU0E7Ozs7QUFFQSxJQUFJN04sZ0JBQWdCLG1CQUFBQyxDQUFRLEVBQVIsQ0FBcEI7QUFDQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJeXhCLHVCQUF1QixtQkFBQXp4QixDQUFRLEVBQVIsQ0FBM0I7QUFDQSxJQUFJKzRCLGlCQUFpQixtQkFBQS80QixDQUFRLEdBQVIsQ0FBckI7O0FBRUEzRSxPQUFPQyxPQUFQLEdBQWlCLFVBQVNtUyxjQUFULEVBQXlCRyxtQkFBekIsRUFBOEM7QUFDN0Q7QUFDQSxNQUFJNDNCLGtCQUFrQixPQUFPajRCLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0NBLE9BQU9rNEIsUUFBN0Q7QUFDQSxNQUFJQyx1QkFBdUIsWUFBM0IsQ0FINkQsQ0FHcEI7O0FBRXpDOzs7Ozs7Ozs7Ozs7OztBQWNBLFdBQVNDLGFBQVQsQ0FBdUJDLGFBQXZCLEVBQXNDO0FBQ3BDLFFBQUlDLGFBQWFELGtCQUFrQkosbUJBQW1CSSxjQUFjSixlQUFkLENBQW5CLElBQXFESSxjQUFjRixvQkFBZCxDQUF2RSxDQUFqQjtBQUNBLFFBQUksT0FBT0csVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNwQyxhQUFPQSxVQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQ0EsTUFBSXlCLFlBQVksZUFBaEI7O0FBRUE7QUFDQTtBQUNBLE1BQUloc0IsaUJBQWlCO0FBQ25CaGUsV0FBT2lxQywyQkFBMkIsT0FBM0IsQ0FEWTtBQUVuQkMsVUFBTUQsMkJBQTJCLFNBQTNCLENBRmE7QUFHbkI5VCxVQUFNOFQsMkJBQTJCLFVBQTNCLENBSGE7QUFJbkJFLFlBQVFGLDJCQUEyQixRQUEzQixDQUpXO0FBS25CNzVCLFlBQVE2NUIsMkJBQTJCLFFBQTNCLENBTFc7QUFNbkIzYyxZQUFRMmMsMkJBQTJCLFFBQTNCLENBTlc7QUFPbkJHLFlBQVFILDJCQUEyQixRQUEzQixDQVBXOztBQVNuQkksU0FBS0Msc0JBVGM7QUFVbkJDLGFBQVNDLHdCQVZVO0FBV25CbCtCLGFBQVNtK0IsMEJBWFU7QUFZbkJDLGdCQUFZQyx5QkFaTztBQWFuQnJtQyxVQUFNc21DLG1CQWJhO0FBY25CQyxjQUFVQyx5QkFkUztBQWVuQkMsV0FBT0MscUJBZlk7QUFnQm5CQyxlQUFXQyxzQkFoQlE7QUFpQm5CQyxXQUFPQztBQWpCWSxHQUFyQjs7QUFvQkE7Ozs7QUFJQTtBQUNBLFdBQVM5TyxFQUFULENBQVlyNUIsQ0FBWixFQUFlczVCLENBQWYsRUFBa0I7QUFDaEI7QUFDQSxRQUFJdDVCLE1BQU1zNUIsQ0FBVixFQUFhO0FBQ1g7QUFDQTtBQUNBLGFBQU90NUIsTUFBTSxDQUFOLElBQVcsSUFBSUEsQ0FBSixLQUFVLElBQUlzNUIsQ0FBaEM7QUFDRCxLQUpELE1BSU87QUFDTDtBQUNBLGFBQU90NUIsTUFBTUEsQ0FBTixJQUFXczVCLE1BQU1BLENBQXhCO0FBQ0Q7QUFDRjtBQUNEOztBQUVBOzs7Ozs7O0FBT0EsV0FBUzhPLGFBQVQsQ0FBdUJ0b0MsT0FBdkIsRUFBZ0M7QUFDOUIsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0EsU0FBS29NLEtBQUwsR0FBYSxFQUFiO0FBQ0Q7QUFDRDtBQUNBazhCLGdCQUFjcHJDLFNBQWQsR0FBMEI3QixNQUFNNkIsU0FBaEM7O0FBRUEsV0FBU3FyQywwQkFBVCxDQUFvQ0MsUUFBcEMsRUFBOEM7QUFDNUMsUUFBSXp0QyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJNHBDLDBCQUEwQixFQUE5QjtBQUNBLFVBQUlDLDZCQUE2QixDQUFqQztBQUNEO0FBQ0QsYUFBU0MsU0FBVCxDQUFtQi9GLFVBQW5CLEVBQStCdnFCLEtBQS9CLEVBQXNDL0UsUUFBdEMsRUFBZ0Qra0IsYUFBaEQsRUFBK0R6UyxRQUEvRCxFQUF5RWdqQixZQUF6RSxFQUF1RkMsTUFBdkYsRUFBK0Y7QUFDN0Z4USxzQkFBZ0JBLGlCQUFpQjRPLFNBQWpDO0FBQ0EyQixxQkFBZUEsZ0JBQWdCdDFCLFFBQS9COztBQUVBLFVBQUl1MUIsV0FBV3pYLG9CQUFmLEVBQXFDO0FBQ25DLFlBQUk3akIsbUJBQUosRUFBeUI7QUFDdkI7QUFDQXhPLG9CQUNFLEtBREYsRUFFRSx5RkFDQSxpREFEQSxHQUVBLGdEQUpGO0FBTUQsU0FSRCxNQVFPLElBQUloRSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixJQUF5QyxPQUFPb0IsT0FBUCxLQUFtQixXQUFoRSxFQUE2RTtBQUNsRjtBQUNBLGNBQUlvakMsV0FBV2hMLGdCQUFnQixHQUFoQixHQUFzQi9rQixRQUFyQztBQUNBLGNBQ0UsQ0FBQ20xQix3QkFBd0JwRixRQUF4QixDQUFEO0FBQ0E7QUFDQXFGLHVDQUE2QixDQUgvQixFQUlFO0FBQ0E5b0Msb0JBQ0UsS0FERixFQUVFLDJEQUNBLHlEQURBLEdBRUEseURBRkEsR0FHQSxnRUFIQSxHQUlBLCtEQUpBLEdBSWtFLGNBTnBFLEVBT0VncEMsWUFQRixFQVFFdlEsYUFSRjtBQVVBb1Esb0NBQXdCcEYsUUFBeEIsSUFBb0MsSUFBcEM7QUFDQXFGO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsVUFBSXJ3QixNQUFNL0UsUUFBTixLQUFtQixJQUF2QixFQUE2QjtBQUMzQixZQUFJc3ZCLFVBQUosRUFBZ0I7QUFDZCxjQUFJdnFCLE1BQU0vRSxRQUFOLE1BQW9CLElBQXhCLEVBQThCO0FBQzVCLG1CQUFPLElBQUlnMUIsYUFBSixDQUFrQixTQUFTMWlCLFFBQVQsR0FBb0IsSUFBcEIsR0FBMkJnakIsWUFBM0IsR0FBMEMsMEJBQTFDLElBQXdFLFNBQVN2USxhQUFULEdBQXlCLDZCQUFqRyxDQUFsQixDQUFQO0FBQ0Q7QUFDRCxpQkFBTyxJQUFJaVEsYUFBSixDQUFrQixTQUFTMWlCLFFBQVQsR0FBb0IsSUFBcEIsR0FBMkJnakIsWUFBM0IsR0FBMEMsNkJBQTFDLElBQTJFLE1BQU12USxhQUFOLEdBQXNCLGtDQUFqRyxDQUFsQixDQUFQO0FBQ0Q7QUFDRCxlQUFPLElBQVA7QUFDRCxPQVJELE1BUU87QUFDTCxlQUFPbVEsU0FBU253QixLQUFULEVBQWdCL0UsUUFBaEIsRUFBMEIra0IsYUFBMUIsRUFBeUN6UyxRQUF6QyxFQUFtRGdqQixZQUFuRCxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJRSxtQkFBbUJILFVBQVVydkIsSUFBVixDQUFlLElBQWYsRUFBcUIsS0FBckIsQ0FBdkI7QUFDQXd2QixxQkFBaUJsRyxVQUFqQixHQUE4QitGLFVBQVVydkIsSUFBVixDQUFlLElBQWYsRUFBcUIsSUFBckIsQ0FBOUI7O0FBRUEsV0FBT3d2QixnQkFBUDtBQUNEOztBQUVELFdBQVM1QiwwQkFBVCxDQUFvQzZCLFlBQXBDLEVBQWtEO0FBQ2hELGFBQVNQLFFBQVQsQ0FBa0Jud0IsS0FBbEIsRUFBeUIvRSxRQUF6QixFQUFtQytrQixhQUFuQyxFQUFrRHpTLFFBQWxELEVBQTREZ2pCLFlBQTVELEVBQTBFQyxNQUExRSxFQUFrRjtBQUNoRixVQUFJRyxZQUFZM3dCLE1BQU0vRSxRQUFOLENBQWhCO0FBQ0EsVUFBSTIxQixXQUFXQyxZQUFZRixTQUFaLENBQWY7QUFDQSxVQUFJQyxhQUFhRixZQUFqQixFQUErQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxZQUFJSSxjQUFjQyxlQUFlSixTQUFmLENBQWxCOztBQUVBLGVBQU8sSUFBSVYsYUFBSixDQUFrQixhQUFhMWlCLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0JnakIsWUFBL0IsR0FBOEMsWUFBOUMsSUFBOEQsTUFBTU8sV0FBTixHQUFvQixpQkFBcEIsR0FBd0M5USxhQUF4QyxHQUF3RCxjQUF0SCxLQUF5SSxNQUFNMFEsWUFBTixHQUFxQixJQUE5SixDQUFsQixDQUFQO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRDtBQUNELFdBQU9SLDJCQUEyQkMsUUFBM0IsQ0FBUDtBQUNEOztBQUVELFdBQVNqQixvQkFBVCxHQUFnQztBQUM5QixXQUFPZ0IsMkJBQTJCN29DLGNBQWNrTixlQUF6QyxDQUFQO0FBQ0Q7O0FBRUQsV0FBUzY2Qix3QkFBVCxDQUFrQzRCLFdBQWxDLEVBQStDO0FBQzdDLGFBQVNiLFFBQVQsQ0FBa0Jud0IsS0FBbEIsRUFBeUIvRSxRQUF6QixFQUFtQytrQixhQUFuQyxFQUFrRHpTLFFBQWxELEVBQTREZ2pCLFlBQTVELEVBQTBFO0FBQ3hFLFVBQUksT0FBT1MsV0FBUCxLQUF1QixVQUEzQixFQUF1QztBQUNyQyxlQUFPLElBQUlmLGFBQUosQ0FBa0IsZUFBZU0sWUFBZixHQUE4QixrQkFBOUIsR0FBbUR2USxhQUFuRCxHQUFtRSxpREFBckYsQ0FBUDtBQUNEO0FBQ0QsVUFBSTJRLFlBQVkzd0IsTUFBTS9FLFFBQU4sQ0FBaEI7QUFDQSxVQUFJLENBQUMxVyxNQUFNdTFCLE9BQU4sQ0FBYzZXLFNBQWQsQ0FBTCxFQUErQjtBQUM3QixZQUFJQyxXQUFXQyxZQUFZRixTQUFaLENBQWY7QUFDQSxlQUFPLElBQUlWLGFBQUosQ0FBa0IsYUFBYTFpQixRQUFiLEdBQXdCLElBQXhCLEdBQStCZ2pCLFlBQS9CLEdBQThDLFlBQTlDLElBQThELE1BQU1LLFFBQU4sR0FBaUIsaUJBQWpCLEdBQXFDNVEsYUFBckMsR0FBcUQsdUJBQW5ILENBQWxCLENBQVA7QUFDRDtBQUNELFdBQUssSUFBSXY3QixJQUFJLENBQWIsRUFBZ0JBLElBQUlrc0MsVUFBVTVzQyxNQUE5QixFQUFzQ1UsR0FBdEMsRUFBMkM7QUFDekMsWUFBSXdDLFFBQVErcEMsWUFBWUwsU0FBWixFQUF1QmxzQyxDQUF2QixFQUEwQnU3QixhQUExQixFQUF5Q3pTLFFBQXpDLEVBQW1EZ2pCLGVBQWUsR0FBZixHQUFxQjlyQyxDQUFyQixHQUF5QixHQUE1RSxFQUFpRnMwQixvQkFBakYsQ0FBWjtBQUNBLFlBQUk5eEIsaUJBQWlCakUsS0FBckIsRUFBNEI7QUFDMUIsaUJBQU9pRSxLQUFQO0FBQ0Q7QUFDRjtBQUNELGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBT2lwQywyQkFBMkJDLFFBQTNCLENBQVA7QUFDRDs7QUFFRCxXQUFTZCx3QkFBVCxHQUFvQztBQUNsQyxhQUFTYyxRQUFULENBQWtCbndCLEtBQWxCLEVBQXlCL0UsUUFBekIsRUFBbUMra0IsYUFBbkMsRUFBa0R6UyxRQUFsRCxFQUE0RGdqQixZQUE1RCxFQUEwRTtBQUN4RSxVQUFJSSxZQUFZM3dCLE1BQU0vRSxRQUFOLENBQWhCO0FBQ0EsVUFBSSxDQUFDbEcsZUFBZTQ3QixTQUFmLENBQUwsRUFBZ0M7QUFDOUIsWUFBSUMsV0FBV0MsWUFBWUYsU0FBWixDQUFmO0FBQ0EsZUFBTyxJQUFJVixhQUFKLENBQWtCLGFBQWExaUIsUUFBYixHQUF3QixJQUF4QixHQUErQmdqQixZQUEvQixHQUE4QyxZQUE5QyxJQUE4RCxNQUFNSyxRQUFOLEdBQWlCLGlCQUFqQixHQUFxQzVRLGFBQXJDLEdBQXFELG9DQUFuSCxDQUFsQixDQUFQO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRDtBQUNELFdBQU9rUSwyQkFBMkJDLFFBQTNCLENBQVA7QUFDRDs7QUFFRCxXQUFTWix5QkFBVCxDQUFtQzBCLGFBQW5DLEVBQWtEO0FBQ2hELGFBQVNkLFFBQVQsQ0FBa0Jud0IsS0FBbEIsRUFBeUIvRSxRQUF6QixFQUFtQytrQixhQUFuQyxFQUFrRHpTLFFBQWxELEVBQTREZ2pCLFlBQTVELEVBQTBFO0FBQ3hFLFVBQUksRUFBRXZ3QixNQUFNL0UsUUFBTixhQUEyQmcyQixhQUE3QixDQUFKLEVBQWlEO0FBQy9DLFlBQUlDLG9CQUFvQkQsY0FBY2pyQyxJQUFkLElBQXNCNG9DLFNBQTlDO0FBQ0EsWUFBSXVDLGtCQUFrQkMsYUFBYXB4QixNQUFNL0UsUUFBTixDQUFiLENBQXRCO0FBQ0EsZUFBTyxJQUFJZzFCLGFBQUosQ0FBa0IsYUFBYTFpQixRQUFiLEdBQXdCLElBQXhCLEdBQStCZ2pCLFlBQS9CLEdBQThDLFlBQTlDLElBQThELE1BQU1ZLGVBQU4sR0FBd0IsaUJBQXhCLEdBQTRDblIsYUFBNUMsR0FBNEQsY0FBMUgsS0FBNkksa0JBQWtCa1IsaUJBQWxCLEdBQXNDLElBQW5MLENBQWxCLENBQVA7QUFDRDtBQUNELGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBT2hCLDJCQUEyQkMsUUFBM0IsQ0FBUDtBQUNEOztBQUVELFdBQVNQLHFCQUFULENBQStCeUIsY0FBL0IsRUFBK0M7QUFDN0MsUUFBSSxDQUFDOXNDLE1BQU11MUIsT0FBTixDQUFjdVgsY0FBZCxDQUFMLEVBQW9DO0FBQ2xDM3VDLGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxvRUFBZixDQUF4QyxHQUErSCxLQUFLLENBQXBJO0FBQ0EsYUFBT0YsY0FBY2tOLGVBQXJCO0FBQ0Q7O0FBRUQsYUFBUzQ3QixRQUFULENBQWtCbndCLEtBQWxCLEVBQXlCL0UsUUFBekIsRUFBbUMra0IsYUFBbkMsRUFBa0R6UyxRQUFsRCxFQUE0RGdqQixZQUE1RCxFQUEwRTtBQUN4RSxVQUFJSSxZQUFZM3dCLE1BQU0vRSxRQUFOLENBQWhCO0FBQ0EsV0FBSyxJQUFJeFcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNHNDLGVBQWV0dEMsTUFBbkMsRUFBMkNVLEdBQTNDLEVBQWdEO0FBQzlDLFlBQUl5OEIsR0FBR3lQLFNBQUgsRUFBY1UsZUFBZTVzQyxDQUFmLENBQWQsQ0FBSixFQUFzQztBQUNwQyxpQkFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJNnNDLGVBQWVDLEtBQUtDLFNBQUwsQ0FBZUgsY0FBZixDQUFuQjtBQUNBLGFBQU8sSUFBSXBCLGFBQUosQ0FBa0IsYUFBYTFpQixRQUFiLEdBQXdCLElBQXhCLEdBQStCZ2pCLFlBQS9CLEdBQThDLGNBQTlDLEdBQStESSxTQUEvRCxHQUEyRSxJQUEzRSxJQUFtRixrQkFBa0IzUSxhQUFsQixHQUFrQyxxQkFBbEMsR0FBMERzUixZQUExRCxHQUF5RSxHQUE1SixDQUFsQixDQUFQO0FBQ0Q7QUFDRCxXQUFPcEIsMkJBQTJCQyxRQUEzQixDQUFQO0FBQ0Q7O0FBRUQsV0FBU1QseUJBQVQsQ0FBbUNzQixXQUFuQyxFQUFnRDtBQUM5QyxhQUFTYixRQUFULENBQWtCbndCLEtBQWxCLEVBQXlCL0UsUUFBekIsRUFBbUMra0IsYUFBbkMsRUFBa0R6UyxRQUFsRCxFQUE0RGdqQixZQUE1RCxFQUEwRTtBQUN4RSxVQUFJLE9BQU9TLFdBQVAsS0FBdUIsVUFBM0IsRUFBdUM7QUFDckMsZUFBTyxJQUFJZixhQUFKLENBQWtCLGVBQWVNLFlBQWYsR0FBOEIsa0JBQTlCLEdBQW1EdlEsYUFBbkQsR0FBbUUsa0RBQXJGLENBQVA7QUFDRDtBQUNELFVBQUkyUSxZQUFZM3dCLE1BQU0vRSxRQUFOLENBQWhCO0FBQ0EsVUFBSTIxQixXQUFXQyxZQUFZRixTQUFaLENBQWY7QUFDQSxVQUFJQyxhQUFhLFFBQWpCLEVBQTJCO0FBQ3pCLGVBQU8sSUFBSVgsYUFBSixDQUFrQixhQUFhMWlCLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0JnakIsWUFBL0IsR0FBOEMsWUFBOUMsSUFBOEQsTUFBTUssUUFBTixHQUFpQixpQkFBakIsR0FBcUM1USxhQUFyQyxHQUFxRCx3QkFBbkgsQ0FBbEIsQ0FBUDtBQUNEO0FBQ0QsV0FBSyxJQUFJNXlCLEdBQVQsSUFBZ0J1akMsU0FBaEIsRUFBMkI7QUFDekIsWUFBSUEsVUFBVWxtQyxjQUFWLENBQXlCMkMsR0FBekIsQ0FBSixFQUFtQztBQUNqQyxjQUFJbkcsUUFBUStwQyxZQUFZTCxTQUFaLEVBQXVCdmpDLEdBQXZCLEVBQTRCNHlCLGFBQTVCLEVBQTJDelMsUUFBM0MsRUFBcURnakIsZUFBZSxHQUFmLEdBQXFCbmpDLEdBQTFFLEVBQStFMnJCLG9CQUEvRSxDQUFaO0FBQ0EsY0FBSTl4QixpQkFBaUJqRSxLQUFyQixFQUE0QjtBQUMxQixtQkFBT2lFLEtBQVA7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxhQUFPLElBQVA7QUFDRDtBQUNELFdBQU9pcEMsMkJBQTJCQyxRQUEzQixDQUFQO0FBQ0Q7O0FBRUQsV0FBU0wsc0JBQVQsQ0FBZ0MyQixtQkFBaEMsRUFBcUQ7QUFDbkQsUUFBSSxDQUFDbHRDLE1BQU11MUIsT0FBTixDQUFjMlgsbUJBQWQsQ0FBTCxFQUF5QztBQUN2Qy91QyxjQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsd0VBQWYsQ0FBeEMsR0FBbUksS0FBSyxDQUF4STtBQUNBLGFBQU9GLGNBQWNrTixlQUFyQjtBQUNEOztBQUVELFNBQUssSUFBSTlQLElBQUksQ0FBYixFQUFnQkEsSUFBSWd0QyxvQkFBb0IxdEMsTUFBeEMsRUFBZ0RVLEdBQWhELEVBQXFEO0FBQ25ELFVBQUlpdEMsVUFBVUQsb0JBQW9CaHRDLENBQXBCLENBQWQ7QUFDQSxVQUFJLE9BQU9pdEMsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQ25xQyxnQkFDRSxLQURGLEVBRUUsc0ZBQ0EsMEJBSEYsRUFJRW9xQyx5QkFBeUJELE9BQXpCLENBSkYsRUFLRWp0QyxDQUxGO0FBT0EsZUFBTzRDLGNBQWNrTixlQUFyQjtBQUNEO0FBQ0Y7O0FBRUQsYUFBUzQ3QixRQUFULENBQWtCbndCLEtBQWxCLEVBQXlCL0UsUUFBekIsRUFBbUMra0IsYUFBbkMsRUFBa0R6UyxRQUFsRCxFQUE0RGdqQixZQUE1RCxFQUEwRTtBQUN4RSxXQUFLLElBQUk5ckMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJZ3RDLG9CQUFvQjF0QyxNQUF4QyxFQUFnRFUsR0FBaEQsRUFBcUQ7QUFDbkQsWUFBSWl0QyxVQUFVRCxvQkFBb0JodEMsQ0FBcEIsQ0FBZDtBQUNBLFlBQUlpdEMsUUFBUTF4QixLQUFSLEVBQWUvRSxRQUFmLEVBQXlCK2tCLGFBQXpCLEVBQXdDelMsUUFBeEMsRUFBa0RnakIsWUFBbEQsRUFBZ0V4WCxvQkFBaEUsS0FBeUYsSUFBN0YsRUFBbUc7QUFDakcsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBRUQsYUFBTyxJQUFJa1gsYUFBSixDQUFrQixhQUFhMWlCLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0JnakIsWUFBL0IsR0FBOEMsZ0JBQTlDLElBQWtFLE1BQU12USxhQUFOLEdBQXNCLElBQXhGLENBQWxCLENBQVA7QUFDRDtBQUNELFdBQU9rUSwyQkFBMkJDLFFBQTNCLENBQVA7QUFDRDs7QUFFRCxXQUFTWCxpQkFBVCxHQUE2QjtBQUMzQixhQUFTVyxRQUFULENBQWtCbndCLEtBQWxCLEVBQXlCL0UsUUFBekIsRUFBbUMra0IsYUFBbkMsRUFBa0R6UyxRQUFsRCxFQUE0RGdqQixZQUE1RCxFQUEwRTtBQUN4RSxVQUFJLENBQUNxQixPQUFPNXhCLE1BQU0vRSxRQUFOLENBQVAsQ0FBTCxFQUE4QjtBQUM1QixlQUFPLElBQUlnMUIsYUFBSixDQUFrQixhQUFhMWlCLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0JnakIsWUFBL0IsR0FBOEMsZ0JBQTlDLElBQWtFLE1BQU12USxhQUFOLEdBQXNCLDBCQUF4RixDQUFsQixDQUFQO0FBQ0Q7QUFDRCxhQUFPLElBQVA7QUFDRDtBQUNELFdBQU9rUSwyQkFBMkJDLFFBQTNCLENBQVA7QUFDRDs7QUFFRCxXQUFTSCxzQkFBVCxDQUFnQzZCLFVBQWhDLEVBQTRDO0FBQzFDLGFBQVMxQixRQUFULENBQWtCbndCLEtBQWxCLEVBQXlCL0UsUUFBekIsRUFBbUMra0IsYUFBbkMsRUFBa0R6UyxRQUFsRCxFQUE0RGdqQixZQUE1RCxFQUEwRTtBQUN4RSxVQUFJSSxZQUFZM3dCLE1BQU0vRSxRQUFOLENBQWhCO0FBQ0EsVUFBSTIxQixXQUFXQyxZQUFZRixTQUFaLENBQWY7QUFDQSxVQUFJQyxhQUFhLFFBQWpCLEVBQTJCO0FBQ3pCLGVBQU8sSUFBSVgsYUFBSixDQUFrQixhQUFhMWlCLFFBQWIsR0FBd0IsSUFBeEIsR0FBK0JnakIsWUFBL0IsR0FBOEMsYUFBOUMsR0FBOERLLFFBQTlELEdBQXlFLElBQXpFLElBQWlGLGtCQUFrQjVRLGFBQWxCLEdBQWtDLHVCQUFuSCxDQUFsQixDQUFQO0FBQ0Q7QUFDRCxXQUFLLElBQUk1eUIsR0FBVCxJQUFnQnlrQyxVQUFoQixFQUE0QjtBQUMxQixZQUFJSCxVQUFVRyxXQUFXemtDLEdBQVgsQ0FBZDtBQUNBLFlBQUksQ0FBQ3NrQyxPQUFMLEVBQWM7QUFDWjtBQUNEO0FBQ0QsWUFBSXpxQyxRQUFReXFDLFFBQVFmLFNBQVIsRUFBbUJ2akMsR0FBbkIsRUFBd0I0eUIsYUFBeEIsRUFBdUN6UyxRQUF2QyxFQUFpRGdqQixlQUFlLEdBQWYsR0FBcUJuakMsR0FBdEUsRUFBMkUyckIsb0JBQTNFLENBQVo7QUFDQSxZQUFJOXhCLEtBQUosRUFBVztBQUNULGlCQUFPQSxLQUFQO0FBQ0Q7QUFDRjtBQUNELGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBT2lwQywyQkFBMkJDLFFBQTNCLENBQVA7QUFDRDs7QUFFRCxXQUFTeUIsTUFBVCxDQUFnQmpCLFNBQWhCLEVBQTJCO0FBQ3pCLG1CQUFlQSxTQUFmLHlDQUFlQSxTQUFmO0FBQ0UsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0EsV0FBSyxXQUFMO0FBQ0UsZUFBTyxJQUFQO0FBQ0YsV0FBSyxTQUFMO0FBQ0UsZUFBTyxDQUFDQSxTQUFSO0FBQ0YsV0FBSyxRQUFMO0FBQ0UsWUFBSXBzQyxNQUFNdTFCLE9BQU4sQ0FBYzZXLFNBQWQsQ0FBSixFQUE4QjtBQUM1QixpQkFBT0EsVUFBVW1CLEtBQVYsQ0FBZ0JGLE1BQWhCLENBQVA7QUFDRDtBQUNELFlBQUlqQixjQUFjLElBQWQsSUFBc0I1N0IsZUFBZTQ3QixTQUFmLENBQTFCLEVBQXFEO0FBQ25ELGlCQUFPLElBQVA7QUFDRDs7QUFFRCxZQUFJeEQsYUFBYUYsY0FBYzBELFNBQWQsQ0FBakI7QUFDQSxZQUFJeEQsVUFBSixFQUFnQjtBQUNkLGNBQUlKLFdBQVdJLFdBQVc1cEMsSUFBWCxDQUFnQm90QyxTQUFoQixDQUFmO0FBQ0EsY0FBSXpDLElBQUo7QUFDQSxjQUFJZixlQUFld0QsVUFBVTFDLE9BQTdCLEVBQXNDO0FBQ3BDLG1CQUFPLENBQUMsQ0FBQ0MsT0FBT25CLFNBQVNvQixJQUFULEVBQVIsRUFBeUJDLElBQWpDLEVBQXVDO0FBQ3JDLGtCQUFJLENBQUN3RCxPQUFPMUQsS0FBS255QixLQUFaLENBQUwsRUFBeUI7QUFDdkIsdUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRixXQU5ELE1BTU87QUFDTDtBQUNBLG1CQUFPLENBQUMsQ0FBQ215QixPQUFPbkIsU0FBU29CLElBQVQsRUFBUixFQUF5QkMsSUFBakMsRUFBdUM7QUFDckMsa0JBQUkyRCxRQUFRN0QsS0FBS255QixLQUFqQjtBQUNBLGtCQUFJZzJCLEtBQUosRUFBVztBQUNULG9CQUFJLENBQUNILE9BQU9HLE1BQU0sQ0FBTixDQUFQLENBQUwsRUFBdUI7QUFDckIseUJBQU8sS0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGO0FBQ0YsU0FwQkQsTUFvQk87QUFDTCxpQkFBTyxLQUFQO0FBQ0Q7O0FBRUQsZUFBTyxJQUFQO0FBQ0Y7QUFDRSxlQUFPLEtBQVA7QUExQ0o7QUE0Q0Q7O0FBRUQsV0FBU0MsUUFBVCxDQUFrQnBCLFFBQWxCLEVBQTRCRCxTQUE1QixFQUF1QztBQUNyQztBQUNBLFFBQUlDLGFBQWEsUUFBakIsRUFBMkI7QUFDekIsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJRCxVQUFVLGVBQVYsTUFBK0IsUUFBbkMsRUFBNkM7QUFDM0MsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJLE9BQU85N0IsTUFBUCxLQUFrQixVQUFsQixJQUFnQzg3QixxQkFBcUI5N0IsTUFBekQsRUFBaUU7QUFDL0QsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxXQUFTZzhCLFdBQVQsQ0FBcUJGLFNBQXJCLEVBQWdDO0FBQzlCLFFBQUlDLGtCQUFrQkQsU0FBbEIseUNBQWtCQSxTQUFsQixDQUFKO0FBQ0EsUUFBSXBzQyxNQUFNdTFCLE9BQU4sQ0FBYzZXLFNBQWQsQ0FBSixFQUE4QjtBQUM1QixhQUFPLE9BQVA7QUFDRDtBQUNELFFBQUlBLHFCQUFxQjFoQyxNQUF6QixFQUFpQztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxhQUFPLFFBQVA7QUFDRDtBQUNELFFBQUkraUMsU0FBU3BCLFFBQVQsRUFBbUJELFNBQW5CLENBQUosRUFBbUM7QUFDakMsYUFBTyxRQUFQO0FBQ0Q7QUFDRCxXQUFPQyxRQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFdBQVNHLGNBQVQsQ0FBd0JKLFNBQXhCLEVBQW1DO0FBQ2pDLFFBQUksT0FBT0EsU0FBUCxLQUFxQixXQUFyQixJQUFvQ0EsY0FBYyxJQUF0RCxFQUE0RDtBQUMxRCxhQUFPLEtBQUtBLFNBQVo7QUFDRDtBQUNELFFBQUlDLFdBQVdDLFlBQVlGLFNBQVosQ0FBZjtBQUNBLFFBQUlDLGFBQWEsUUFBakIsRUFBMkI7QUFDekIsVUFBSUQscUJBQXFCeDJCLElBQXpCLEVBQStCO0FBQzdCLGVBQU8sTUFBUDtBQUNELE9BRkQsTUFFTyxJQUFJdzJCLHFCQUFxQjFoQyxNQUF6QixFQUFpQztBQUN0QyxlQUFPLFFBQVA7QUFDRDtBQUNGO0FBQ0QsV0FBTzJoQyxRQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBLFdBQVNlLHdCQUFULENBQWtDNTFCLEtBQWxDLEVBQXlDO0FBQ3ZDLFFBQUk1SyxPQUFPNC9CLGVBQWVoMUIsS0FBZixDQUFYO0FBQ0EsWUFBUTVLLElBQVI7QUFDRSxXQUFLLE9BQUw7QUFDQSxXQUFLLFFBQUw7QUFDRSxlQUFPLFFBQVFBLElBQWY7QUFDRixXQUFLLFNBQUw7QUFDQSxXQUFLLE1BQUw7QUFDQSxXQUFLLFFBQUw7QUFDRSxlQUFPLE9BQU9BLElBQWQ7QUFDRjtBQUNFLGVBQU9BLElBQVA7QUFUSjtBQVdEOztBQUVEO0FBQ0EsV0FBU2lnQyxZQUFULENBQXNCVCxTQUF0QixFQUFpQztBQUMvQixRQUFJLENBQUNBLFVBQVUzMUIsV0FBWCxJQUEwQixDQUFDMjFCLFVBQVUzMUIsV0FBVixDQUFzQmhWLElBQXJELEVBQTJEO0FBQ3pELGFBQU80b0MsU0FBUDtBQUNEO0FBQ0QsV0FBTytCLFVBQVUzMUIsV0FBVixDQUFzQmhWLElBQTdCO0FBQ0Q7O0FBRUQ0YyxpQkFBZXlkLGNBQWYsR0FBZ0NBLGNBQWhDO0FBQ0F6ZCxpQkFBZW1CLFNBQWYsR0FBMkJuQixjQUEzQjs7QUFFQSxTQUFPQSxjQUFQO0FBQ0QsQ0E3ZUQsQzs7Ozs7Ozs7QUNsQkE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJcGEseUJBQXlCO0FBQzNCMkIsdUJBQXFCLEtBQUs7QUFEQyxDQUE3Qjs7QUFJQXhILE9BQU9DLE9BQVAsR0FBaUI0RixzQkFBakIsQzs7Ozs7OztBQ2hCQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJRixpQkFBaUIsbUJBQUFoQixDQUFRLENBQVIsQ0FBckI7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCOztBQUVBOzs7Ozs7Ozs7Ozs7O0FBYUEsU0FBU2tnQixjQUFULENBQXdCdFUsT0FBeEIsRUFBaUNpN0IsSUFBakMsRUFBdUM7QUFDckMsSUFBRUEsUUFBUSxJQUFWLElBQWtCenJDLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsdUVBQWpCLENBQXhDLEdBQW9JNEIsZUFBZSxJQUFmLENBQXRKLEdBQTZLLEtBQUssQ0FBbEw7O0FBRUEsTUFBSTRLLFdBQVcsSUFBZixFQUFxQjtBQUNuQixXQUFPaTdCLElBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSTVwQyxNQUFNdTFCLE9BQU4sQ0FBYzVtQixPQUFkLENBQUosRUFBNEI7QUFDMUIsUUFBSTNPLE1BQU11MUIsT0FBTixDQUFjcVUsSUFBZCxDQUFKLEVBQXlCO0FBQ3ZCajdCLGNBQVF4TyxJQUFSLENBQWFJLEtBQWIsQ0FBbUJvTyxPQUFuQixFQUE0Qmk3QixJQUE1QjtBQUNBLGFBQU9qN0IsT0FBUDtBQUNEO0FBQ0RBLFlBQVF4TyxJQUFSLENBQWF5cEMsSUFBYjtBQUNBLFdBQU9qN0IsT0FBUDtBQUNEOztBQUVELE1BQUkzTyxNQUFNdTFCLE9BQU4sQ0FBY3FVLElBQWQsQ0FBSixFQUF5QjtBQUN2QjtBQUNBLFdBQU8sQ0FBQ2o3QixPQUFELEVBQVVsUCxNQUFWLENBQWlCbXFDLElBQWpCLENBQVA7QUFDRDs7QUFFRCxTQUFPLENBQUNqN0IsT0FBRCxFQUFVaTdCLElBQVYsQ0FBUDtBQUNEOztBQUVEeHJDLE9BQU9DLE9BQVAsR0FBaUI0a0IsY0FBakIsQzs7Ozs7Ozs7QUN4REE7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7Ozs7Ozs7O0FBUUEsU0FBU0Msa0JBQVQsQ0FBNEJ3cUIsR0FBNUIsRUFBaUNDLEVBQWpDLEVBQXFDNzZCLEtBQXJDLEVBQTRDO0FBQzFDLE1BQUk5UyxNQUFNdTFCLE9BQU4sQ0FBY21ZLEdBQWQsQ0FBSixFQUF3QjtBQUN0QkEsUUFBSXZsQyxPQUFKLENBQVl3bEMsRUFBWixFQUFnQjc2QixLQUFoQjtBQUNELEdBRkQsTUFFTyxJQUFJNDZCLEdBQUosRUFBUztBQUNkQyxPQUFHM3VDLElBQUgsQ0FBUThULEtBQVIsRUFBZTQ2QixHQUFmO0FBQ0Q7QUFDRjs7QUFFRHR2QyxPQUFPQyxPQUFQLEdBQWlCNmtCLGtCQUFqQixDOzs7Ozs7O0FDN0JBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSWhhLHVCQUF1QixtQkFBQW5HLENBQVEsQ0FBUixDQUEzQjs7QUFFQSxJQUFJNnFDLGFBQWEsSUFBakI7O0FBRUE7Ozs7OztBQU1BLFNBQVNDLHNCQUFULEdBQWtDO0FBQ2hDLE1BQUksQ0FBQ0QsVUFBRCxJQUFlMWtDLHFCQUFxQkosU0FBeEMsRUFBbUQ7QUFDakQ7QUFDQTtBQUNBOGtDLGlCQUFhLGlCQUFpQjVrQyxTQUFTOGtDLGVBQTFCLEdBQTRDLGFBQTVDLEdBQTRELFdBQXpFO0FBQ0Q7QUFDRCxTQUFPRixVQUFQO0FBQ0Q7O0FBRUR4dkMsT0FBT0MsT0FBUCxHQUFpQnd2QyxzQkFBakIsQzs7Ozs7OztBQy9CQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJOXBDLGlCQUFpQixtQkFBQWhCLENBQVEsQ0FBUixDQUFyQjs7QUFFQSxTQUFTa2hDLGVBQVQsQ0FBeUI3bUIsUUFBekIsRUFBbUM4bUIsV0FBbkMsRUFBZ0Q7QUFBRSxNQUFJLEVBQUU5bUIsb0JBQW9COG1CLFdBQXRCLENBQUosRUFBd0M7QUFBRSxVQUFNLElBQUk1OEIsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosSUFBSXdKLGNBQWMsbUJBQUEvTixDQUFRLEVBQVIsQ0FBbEI7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCOztBQUVBOzs7Ozs7Ozs7Ozs7QUFZQSxJQUFJOE4sZ0JBQWdCLFlBQVk7QUFDOUIsV0FBU0EsYUFBVCxDQUF1QmpCLEdBQXZCLEVBQTRCO0FBQzFCcTBCLG9CQUFnQixJQUFoQixFQUFzQnB6QixhQUF0Qjs7QUFFQSxTQUFLazlCLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsU0FBS0MsSUFBTCxHQUFZcitCLEdBQVo7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFTQWlCLGdCQUFjdlEsU0FBZCxDQUF3QjhULE9BQXhCLEdBQWtDLFNBQVNBLE9BQVQsQ0FBaUJuQixRQUFqQixFQUEyQnlCLE9BQTNCLEVBQW9DO0FBQ3BFLFNBQUtxNUIsVUFBTCxHQUFrQixLQUFLQSxVQUFMLElBQW1CLEVBQXJDO0FBQ0EsU0FBS0EsVUFBTCxDQUFnQjV0QyxJQUFoQixDQUFxQjhTLFFBQXJCO0FBQ0EsU0FBSys2QixTQUFMLEdBQWlCLEtBQUtBLFNBQUwsSUFBa0IsRUFBbkM7QUFDQSxTQUFLQSxTQUFMLENBQWU3dEMsSUFBZixDQUFvQnVVLE9BQXBCO0FBQ0QsR0FMRDs7QUFPQTs7Ozs7OztBQVFBN0QsZ0JBQWN2USxTQUFkLENBQXdCOFIsU0FBeEIsR0FBb0MsU0FBU0EsU0FBVCxHQUFxQjtBQUN2RCxRQUFJcUIsWUFBWSxLQUFLczZCLFVBQXJCO0FBQ0EsUUFBSUcsV0FBVyxLQUFLRixTQUFwQjtBQUNBLFFBQUlwK0IsTUFBTSxLQUFLcStCLElBQWY7QUFDQSxRQUFJeDZCLGFBQWF5NkIsUUFBakIsRUFBMkI7QUFDekIsUUFBRXo2QixVQUFValUsTUFBVixLQUFxQjB1QyxTQUFTMXVDLE1BQWhDLElBQTBDckIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiwrQ0FBakIsQ0FBeEMsR0FBNEc0QixlQUFlLElBQWYsQ0FBdEosR0FBNkssS0FBSyxDQUFsTDtBQUNBLFdBQUtncUMsVUFBTCxHQUFrQixJQUFsQjtBQUNBLFdBQUtDLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxXQUFLLElBQUk5dEMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJdVQsVUFBVWpVLE1BQTlCLEVBQXNDVSxHQUF0QyxFQUEyQztBQUN6Q3VULGtCQUFVdlQsQ0FBVixFQUFhbEIsSUFBYixDQUFrQmt2QyxTQUFTaHVDLENBQVQsQ0FBbEIsRUFBK0IwUCxHQUEvQjtBQUNEO0FBQ0Q2RCxnQkFBVWpVLE1BQVYsR0FBbUIsQ0FBbkI7QUFDQTB1QyxlQUFTMXVDLE1BQVQsR0FBa0IsQ0FBbEI7QUFDRDtBQUNGLEdBZEQ7O0FBZ0JBcVIsZ0JBQWN2USxTQUFkLENBQXdCNnRDLFVBQXhCLEdBQXFDLFNBQVNBLFVBQVQsR0FBc0I7QUFDekQsV0FBTyxLQUFLSixVQUFMLEdBQWtCLEtBQUtBLFVBQUwsQ0FBZ0J2dUMsTUFBbEMsR0FBMkMsQ0FBbEQ7QUFDRCxHQUZEOztBQUlBcVIsZ0JBQWN2USxTQUFkLENBQXdCOHRDLFFBQXhCLEdBQW1DLFNBQVNBLFFBQVQsQ0FBa0J4dUMsR0FBbEIsRUFBdUI7QUFDeEQsUUFBSSxLQUFLbXVDLFVBQUwsSUFBbUIsS0FBS0MsU0FBNUIsRUFBdUM7QUFDckMsV0FBS0QsVUFBTCxDQUFnQnZ1QyxNQUFoQixHQUF5QkksR0FBekI7QUFDQSxXQUFLb3VDLFNBQUwsQ0FBZXh1QyxNQUFmLEdBQXdCSSxHQUF4QjtBQUNEO0FBQ0YsR0FMRDs7QUFPQTs7Ozs7O0FBT0FpUixnQkFBY3ZRLFNBQWQsQ0FBd0I2UixLQUF4QixHQUFnQyxTQUFTQSxLQUFULEdBQWlCO0FBQy9DLFNBQUs0N0IsVUFBTCxHQUFrQixJQUFsQjtBQUNBLFNBQUtDLFNBQUwsR0FBaUIsSUFBakI7QUFDRCxHQUhEOztBQUtBOzs7O0FBS0FuOUIsZ0JBQWN2USxTQUFkLENBQXdCb1MsVUFBeEIsR0FBcUMsU0FBU0EsVUFBVCxHQUFzQjtBQUN6RCxTQUFLUCxLQUFMO0FBQ0QsR0FGRDs7QUFJQSxTQUFPdEIsYUFBUDtBQUNELENBbEZtQixFQUFwQjs7QUFvRkF6UyxPQUFPQyxPQUFQLEdBQWlCeVMsWUFBWWlDLFlBQVosQ0FBeUJsQyxhQUF6QixDQUFqQixDOzs7Ozs7OztBQ3JIQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJRSxvQkFBb0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E2QyxzQkFBb0I7QUFKRSxDQUF4Qjs7QUFPQXhWLE9BQU9DLE9BQVAsR0FBaUIwUyxpQkFBakIsQzs7Ozs7OztBQ3BCQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUloSyx3QkFBd0IsbUJBQUFoRSxDQUFRLENBQVIsQ0FBNUI7O0FBRUEsU0FBU3NyQyxXQUFULENBQXFCQyxJQUFyQixFQUEyQjtBQUN6QixNQUFJMWhDLE9BQU8waEMsS0FBSzFoQyxJQUFoQjtBQUNBLE1BQUlxVixXQUFXcXNCLEtBQUtyc0IsUUFBcEI7QUFDQSxTQUFPQSxZQUFZQSxTQUFTeEksV0FBVCxPQUEyQixPQUF2QyxLQUFtRDdNLFNBQVMsVUFBVCxJQUF1QkEsU0FBUyxPQUFuRixDQUFQO0FBQ0Q7O0FBRUQsU0FBUzJoQyxVQUFULENBQW9CanBDLElBQXBCLEVBQTBCO0FBQ3hCLFNBQU9BLEtBQUtrcEMsYUFBTCxDQUFtQkMsWUFBMUI7QUFDRDs7QUFFRCxTQUFTQyxhQUFULENBQXVCcHBDLElBQXZCLEVBQTZCcXBDLE9BQTdCLEVBQXNDO0FBQ3BDcnBDLE9BQUtrcEMsYUFBTCxDQUFtQkMsWUFBbkIsR0FBa0NFLE9BQWxDO0FBQ0Q7O0FBRUQsU0FBU0MsYUFBVCxDQUF1QnRwQyxJQUF2QixFQUE2QjtBQUMzQixTQUFPQSxLQUFLa3BDLGFBQUwsQ0FBbUJDLFlBQTFCO0FBQ0Q7O0FBRUQsU0FBU0ksZ0JBQVQsQ0FBMEJscUMsSUFBMUIsRUFBZ0M7QUFDOUIsTUFBSTZTLEtBQUo7QUFDQSxNQUFJN1MsSUFBSixFQUFVO0FBQ1I2UyxZQUFRNjJCLFlBQVkxcEMsSUFBWixJQUFvQixLQUFLQSxLQUFLNDJCLE9BQTlCLEdBQXdDNTJCLEtBQUs2UyxLQUFyRDtBQUNEO0FBQ0QsU0FBT0EsS0FBUDtBQUNEOztBQUVELElBQUlzM0IscUJBQXFCO0FBQ3ZCO0FBQ0FDLHVCQUFxQiw2QkFBVXBxQyxJQUFWLEVBQWdCO0FBQ25DLFdBQU80cEMsV0FBV3huQyxzQkFBc0JILG1CQUF0QixDQUEwQ2pDLElBQTFDLENBQVgsQ0FBUDtBQUNELEdBSnNCOztBQU92QnFxQyxTQUFPLGVBQVUxcEMsSUFBVixFQUFnQjtBQUNyQixRQUFJaXBDLFdBQVdqcEMsSUFBWCxDQUFKLEVBQXNCO0FBQ3BCO0FBQ0Q7O0FBRUQsUUFBSVgsT0FBT29DLHNCQUFzQkYsbUJBQXRCLENBQTBDdkIsSUFBMUMsQ0FBWDtBQUNBLFFBQUkycEMsYUFBYVosWUFBWTFwQyxJQUFaLElBQW9CLFNBQXBCLEdBQWdDLE9BQWpEO0FBQ0EsUUFBSXVxQyxhQUFham9DLE9BQU9vVSx3QkFBUCxDQUFnQzFXLEtBQUs4UixXQUFMLENBQWlCblcsU0FBakQsRUFBNEQydUMsVUFBNUQsQ0FBakI7O0FBRUEsUUFBSUUsZUFBZSxLQUFLeHFDLEtBQUtzcUMsVUFBTCxDQUF4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUl0cUMsS0FBS3VCLGNBQUwsQ0FBb0Irb0MsVUFBcEIsS0FBbUMsT0FBT0MsV0FBV3ZqQyxHQUFsQixLQUEwQixVQUE3RCxJQUEyRSxPQUFPdWpDLFdBQVd4akMsR0FBbEIsS0FBMEIsVUFBekcsRUFBcUg7QUFDbkg7QUFDRDs7QUFFRHpFLFdBQU9pUSxjQUFQLENBQXNCdlMsSUFBdEIsRUFBNEJzcUMsVUFBNUIsRUFBd0M7QUFDdENqekIsa0JBQVlrekIsV0FBV2x6QixVQURlO0FBRXRDaEUsb0JBQWMsSUFGd0I7QUFHdENyTSxXQUFLLGVBQVk7QUFDZixlQUFPdWpDLFdBQVd2akMsR0FBWCxDQUFlM00sSUFBZixDQUFvQixJQUFwQixDQUFQO0FBQ0QsT0FMcUM7QUFNdEMwTSxXQUFLLGFBQVU4TCxLQUFWLEVBQWlCO0FBQ3BCMjNCLHVCQUFlLEtBQUszM0IsS0FBcEI7QUFDQTAzQixtQkFBV3hqQyxHQUFYLENBQWUxTSxJQUFmLENBQW9CLElBQXBCLEVBQTBCd1ksS0FBMUI7QUFDRDtBQVRxQyxLQUF4Qzs7QUFZQWszQixrQkFBY3BwQyxJQUFkLEVBQW9CO0FBQ2xCMjJCLGdCQUFVLG9CQUFZO0FBQ3BCLGVBQU9rVCxZQUFQO0FBQ0QsT0FIaUI7QUFJbEJDLGdCQUFVLGtCQUFVNTNCLEtBQVYsRUFBaUI7QUFDekIyM0IsdUJBQWUsS0FBSzMzQixLQUFwQjtBQUNELE9BTmlCO0FBT2xCNjNCLG9CQUFjLHdCQUFZO0FBQ3hCVCxzQkFBY3RwQyxJQUFkO0FBQ0EsZUFBT1gsS0FBS3NxQyxVQUFMLENBQVA7QUFDRDtBQVZpQixLQUFwQjtBQVlELEdBbERzQjs7QUFvRHZCSyx3QkFBc0IsOEJBQVVocUMsSUFBVixFQUFnQjtBQUNwQyxRQUFJLENBQUNBLElBQUwsRUFBVztBQUNULGFBQU8sS0FBUDtBQUNEO0FBQ0QsUUFBSXFwQyxVQUFVSixXQUFXanBDLElBQVgsQ0FBZDs7QUFFQSxRQUFJLENBQUNxcEMsT0FBTCxFQUFjO0FBQ1pHLHlCQUFtQkUsS0FBbkIsQ0FBeUIxcEMsSUFBekI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJaXFDLFlBQVlaLFFBQVExUyxRQUFSLEVBQWhCO0FBQ0EsUUFBSXVULFlBQVlYLGlCQUFpQjluQyxzQkFBc0JGLG1CQUF0QixDQUEwQ3ZCLElBQTFDLENBQWpCLENBQWhCOztBQUVBLFFBQUlrcUMsY0FBY0QsU0FBbEIsRUFBNkI7QUFDM0JaLGNBQVFTLFFBQVIsQ0FBaUJJLFNBQWpCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsV0FBTyxLQUFQO0FBQ0QsR0F4RXNCO0FBeUV2QkgsZ0JBQWMsc0JBQVUvcEMsSUFBVixFQUFnQjtBQUM1QixRQUFJcXBDLFVBQVVKLFdBQVdqcEMsSUFBWCxDQUFkO0FBQ0EsUUFBSXFwQyxPQUFKLEVBQWE7QUFDWEEsY0FBUVUsWUFBUjtBQUNEO0FBQ0Y7QUE5RXNCLENBQXpCOztBQWlGQWp4QyxPQUFPQyxPQUFQLEdBQWlCeXdDLGtCQUFqQixDOzs7Ozs7O0FDekhBOzs7Ozs7Ozs7OztBQVdBOztBQUVBOzs7O0FBSUEsSUFBSVcsc0JBQXNCO0FBQ3hCQyxTQUFPLElBRGlCO0FBRXhCQyxRQUFNLElBRmtCO0FBR3hCQyxZQUFVLElBSGM7QUFJeEIsb0JBQWtCLElBSk07QUFLeEJDLFNBQU8sSUFMaUI7QUFNeEJDLFNBQU8sSUFOaUI7QUFPeEJ0RixVQUFRLElBUGdCO0FBUXhCdUYsWUFBVSxJQVJjO0FBU3hCQyxTQUFPLElBVGlCO0FBVXhCcm5CLFVBQVEsSUFWZ0I7QUFXeEJzbkIsT0FBSyxJQVhtQjtBQVl4QnRpQyxRQUFNLElBWmtCO0FBYXhCcUcsUUFBTSxJQWJrQjtBQWN4Qm14QixPQUFLLElBZG1CO0FBZXhCK0ssUUFBTTtBQWZrQixDQUExQjs7QUFrQkEsU0FBU0Msa0JBQVQsQ0FBNEI3QixJQUE1QixFQUFrQztBQUNoQyxNQUFJcnNCLFdBQVdxc0IsUUFBUUEsS0FBS3JzQixRQUFiLElBQXlCcXNCLEtBQUtyc0IsUUFBTCxDQUFjeEksV0FBZCxFQUF4Qzs7QUFFQSxNQUFJd0ksYUFBYSxPQUFqQixFQUEwQjtBQUN4QixXQUFPLENBQUMsQ0FBQ3d0QixvQkFBb0JuQixLQUFLMWhDLElBQXpCLENBQVQ7QUFDRDs7QUFFRCxNQUFJcVYsYUFBYSxVQUFqQixFQUE2QjtBQUMzQixXQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFPLEtBQVA7QUFDRDs7QUFFRDdqQixPQUFPQyxPQUFQLEdBQWlCOHhDLGtCQUFqQixDOzs7Ozs7O0FDakRBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSTVrQixrQkFBa0I7QUFDcEJtQixxQkFBbUIsQ0FEQzs7QUFHcEJFLG9CQUFrQixDQUhFOztBQUtwQjBILHVCQUFxQiw2QkFBVThiLGNBQVYsRUFBMEI7QUFDN0M3a0Isb0JBQWdCbUIsaUJBQWhCLEdBQW9DMGpCLGVBQWU5c0MsQ0FBbkQ7QUFDQWlvQixvQkFBZ0JxQixnQkFBaEIsR0FBbUN3akIsZUFBZXhULENBQWxEO0FBQ0Q7QUFSbUIsQ0FBdEI7O0FBV0F4K0IsT0FBT0MsT0FBUCxHQUFpQmt0QixlQUFqQixDOzs7Ozs7O0FDdkJBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSXJpQix1QkFBdUIsbUJBQUFuRyxDQUFRLENBQVIsQ0FBM0I7QUFDQSxJQUFJcXJCLDhCQUE4QixtQkFBQXJyQixDQUFRLEVBQVIsQ0FBbEM7QUFDQSxJQUFJb2UsZUFBZSxtQkFBQXBlLENBQVEsRUFBUixDQUFuQjs7QUFFQTs7Ozs7Ozs7OztBQVVBLElBQUlzZSxpQkFBaUIsd0JBQVUxYyxJQUFWLEVBQWdCZ0osSUFBaEIsRUFBc0I7QUFDekMsTUFBSUEsSUFBSixFQUFVO0FBQ1IsUUFBSTNILGFBQWFyQixLQUFLcUIsVUFBdEI7O0FBRUEsUUFBSUEsY0FBY0EsZUFBZXJCLEtBQUswckMsU0FBbEMsSUFBK0NycUMsV0FBV25CLFFBQVgsS0FBd0IsQ0FBM0UsRUFBOEU7QUFDNUVtQixpQkFBV2hCLFNBQVgsR0FBdUIySSxJQUF2QjtBQUNBO0FBQ0Q7QUFDRjtBQUNEaEosT0FBSzJyQyxXQUFMLEdBQW1CM2lDLElBQW5CO0FBQ0QsQ0FWRDs7QUFZQSxJQUFJekUscUJBQXFCSixTQUF6QixFQUFvQztBQUNsQyxNQUFJLEVBQUUsaUJBQWlCRSxTQUFTOGtDLGVBQTVCLENBQUosRUFBa0Q7QUFDaER6c0IscUJBQWlCLHdCQUFVMWMsSUFBVixFQUFnQmdKLElBQWhCLEVBQXNCO0FBQ3JDLFVBQUloSixLQUFLRSxRQUFMLEtBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCRixhQUFLSyxTQUFMLEdBQWlCMkksSUFBakI7QUFDQTtBQUNEO0FBQ0R3VCxtQkFBYXhjLElBQWIsRUFBbUJ5cEIsNEJBQTRCemdCLElBQTVCLENBQW5CO0FBQ0QsS0FORDtBQU9EO0FBQ0Y7O0FBRUR2UCxPQUFPQyxPQUFQLEdBQWlCZ2pCLGNBQWpCLEM7Ozs7Ozs7QUNsREE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTs7OztBQUlBLFNBQVNrdkIsU0FBVCxDQUFtQjVyQyxJQUFuQixFQUF5QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxNQUFJO0FBQ0ZBLFNBQUs2ckMsS0FBTDtBQUNELEdBRkQsQ0FFRSxPQUFPNXhDLENBQVAsRUFBVSxDQUFFO0FBQ2Y7O0FBRURSLE9BQU9DLE9BQVAsR0FBaUJreUMsU0FBakIsQzs7Ozs7OztBQ3pCQTs7Ozs7Ozs7OztBQVVBOztBQUVBOzs7O0FBSUEsSUFBSUUsbUJBQW1CO0FBQ3JCQywyQkFBeUIsSUFESjtBQUVyQkMscUJBQW1CLElBRkU7QUFHckJDLG9CQUFrQixJQUhHO0FBSXJCQyxvQkFBa0IsSUFKRztBQUtyQkMsV0FBUyxJQUxZO0FBTXJCQyxnQkFBYyxJQU5PO0FBT3JCQyxtQkFBaUIsSUFQSTtBQVFyQkMsZUFBYSxJQVJRO0FBU3JCQyxRQUFNLElBVGU7QUFVckJDLFlBQVUsSUFWVztBQVdyQkMsZ0JBQWMsSUFYTztBQVlyQkMsY0FBWSxJQVpTO0FBYXJCQyxnQkFBYyxJQWJPO0FBY3JCQyxhQUFXLElBZFU7QUFlckJDLFdBQVMsSUFmWTtBQWdCckJDLGNBQVksSUFoQlM7QUFpQnJCQyxlQUFhLElBakJRO0FBa0JyQkMsZ0JBQWMsSUFsQk87QUFtQnJCQyxjQUFZLElBbkJTO0FBb0JyQkMsaUJBQWUsSUFwQk07QUFxQnJCQyxrQkFBZ0IsSUFyQks7QUFzQnJCQyxtQkFBaUIsSUF0Qkk7QUF1QnJCQyxjQUFZLElBdkJTO0FBd0JyQkMsYUFBVyxJQXhCVTtBQXlCckJDLGNBQVksSUF6QlM7QUEwQnJCQyxXQUFTLElBMUJZO0FBMkJyQkMsU0FBTyxJQTNCYztBQTRCckJDLFdBQVMsSUE1Qlk7QUE2QnJCQyxXQUFTLElBN0JZO0FBOEJyQkMsVUFBUSxJQTlCYTtBQStCckJDLFVBQVEsSUEvQmE7QUFnQ3JCQyxRQUFNLElBaENlOztBQWtDckI7QUFDQUMsZUFBYSxJQW5DUTtBQW9DckJDLGdCQUFjLElBcENPO0FBcUNyQkMsZUFBYSxJQXJDUTtBQXNDckJDLG1CQUFpQixJQXRDSTtBQXVDckJDLG9CQUFrQixJQXZDRztBQXdDckJDLG9CQUFrQixJQXhDRztBQXlDckJDLGlCQUFlLElBekNNO0FBMENyQkMsZUFBYTtBQTFDUSxDQUF2Qjs7QUE2Q0E7Ozs7OztBQU1BLFNBQVNDLFNBQVQsQ0FBbUI1cUIsTUFBbkIsRUFBMkJ6ZixHQUEzQixFQUFnQztBQUM5QixTQUFPeWYsU0FBU3pmLElBQUlzZixNQUFKLENBQVcsQ0FBWCxFQUFjZ3JCLFdBQWQsRUFBVCxHQUF1Q3RxQyxJQUFJc2xCLFNBQUosQ0FBYyxDQUFkLENBQTlDO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxJQUFJaWxCLFdBQVcsQ0FBQyxRQUFELEVBQVcsSUFBWCxFQUFpQixLQUFqQixFQUF3QixHQUF4QixDQUFmOztBQUVBO0FBQ0E7QUFDQW5zQyxPQUFPb0IsSUFBUCxDQUFZb29DLGdCQUFaLEVBQThCdG9DLE9BQTlCLENBQXNDLFVBQVVvUCxJQUFWLEVBQWdCO0FBQ3BENjdCLFdBQVNqckMsT0FBVCxDQUFpQixVQUFVbWdCLE1BQVYsRUFBa0I7QUFDakNtb0IscUJBQWlCeUMsVUFBVTVxQixNQUFWLEVBQWtCL1EsSUFBbEIsQ0FBakIsSUFBNENrNUIsaUJBQWlCbDVCLElBQWpCLENBQTVDO0FBQ0QsR0FGRDtBQUdELENBSkQ7O0FBTUE7Ozs7Ozs7OztBQVNBLElBQUk4N0IsOEJBQThCO0FBQ2hDQyxjQUFZO0FBQ1ZDLDBCQUFzQixJQURaO0FBRVZDLHFCQUFpQixJQUZQO0FBR1ZDLHFCQUFpQixJQUhQO0FBSVZDLHlCQUFxQixJQUpYO0FBS1ZDLHlCQUFxQixJQUxYO0FBTVZDLHNCQUFrQjtBQU5SLEdBRG9CO0FBU2hDQyxzQkFBb0I7QUFDbEJILHlCQUFxQixJQURIO0FBRWxCQyx5QkFBcUI7QUFGSCxHQVRZO0FBYWhDRyxVQUFRO0FBQ05DLGlCQUFhLElBRFA7QUFFTkMsaUJBQWEsSUFGUDtBQUdOQyxpQkFBYTtBQUhQLEdBYndCO0FBa0JoQ0MsZ0JBQWM7QUFDWkMsdUJBQW1CLElBRFA7QUFFWkMsdUJBQW1CLElBRlA7QUFHWkMsdUJBQW1CO0FBSFAsR0FsQmtCO0FBdUJoQ0MsY0FBWTtBQUNWQyxxQkFBaUIsSUFEUDtBQUVWQyxxQkFBaUIsSUFGUDtBQUdWQyxxQkFBaUI7QUFIUCxHQXZCb0I7QUE0QmhDQyxlQUFhO0FBQ1hDLHNCQUFrQixJQURQO0FBRVhDLHNCQUFrQixJQUZQO0FBR1hDLHNCQUFrQjtBQUhQLEdBNUJtQjtBQWlDaENDLGFBQVc7QUFDVEMsb0JBQWdCLElBRFA7QUFFVEMsb0JBQWdCLElBRlA7QUFHVEMsb0JBQWdCO0FBSFAsR0FqQ3FCO0FBc0NoQ0MsUUFBTTtBQUNKQyxlQUFXLElBRFA7QUFFSkMsaUJBQWEsSUFGVDtBQUdKcEQsZ0JBQVksSUFIUjtBQUlKcUQsY0FBVSxJQUpOO0FBS0puRCxnQkFBWSxJQUxSO0FBTUpvRCxnQkFBWTtBQU5SLEdBdEMwQjtBQThDaENDLFdBQVM7QUFDUEMsa0JBQWMsSUFEUDtBQUVQQyxrQkFBYyxJQUZQO0FBR1BDLGtCQUFjO0FBSFA7QUE5Q3VCLENBQWxDOztBQXFEQSxJQUFJQyxjQUFjO0FBQ2hCbEYsb0JBQWtCQSxnQkFERjtBQUVoQjRDLCtCQUE2QkE7QUFGYixDQUFsQjs7QUFLQWoxQyxPQUFPQyxPQUFQLEdBQWlCczNDLFdBQWpCLEM7Ozs7Ozs7QUN4SkE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJM3hDLGNBQWMsbUJBQUFqQixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJZ0Usd0JBQXdCLG1CQUFBaEUsQ0FBUSxDQUFSLENBQTVCO0FBQ0EsSUFBSStjLHVCQUF1QixtQkFBQS9jLENBQVEsRUFBUixDQUEzQjs7QUFFQSxJQUFJNnlDLGdDQUFnQyxtQkFBQTd5QyxDQUFRLEdBQVIsQ0FBcEM7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJOHlDLDZCQUE2QixJQUFJbnJDLE1BQUosQ0FBVyxPQUFPMUcsWUFBWXNXLHlCQUFuQixHQUErQyxJQUEvQyxHQUFzRHRXLFlBQVl3VyxtQkFBbEUsR0FBd0YsS0FBbkcsQ0FBakM7QUFDQSxJQUFJczdCLDRCQUE0QixFQUFoQztBQUNBLElBQUlDLDhCQUE4QixFQUFsQzs7QUFFQSxTQUFTQyxtQkFBVCxDQUE2QnA4QixhQUE3QixFQUE0QztBQUMxQyxNQUFJbThCLDRCQUE0Qjd2QyxjQUE1QixDQUEyQzBULGFBQTNDLENBQUosRUFBK0Q7QUFDN0QsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxNQUFJazhCLDBCQUEwQjV2QyxjQUExQixDQUF5QzBULGFBQXpDLENBQUosRUFBNkQ7QUFDM0QsV0FBTyxLQUFQO0FBQ0Q7QUFDRCxNQUFJaThCLDJCQUEyQmxyQyxJQUEzQixDQUFnQ2lQLGFBQWhDLENBQUosRUFBb0Q7QUFDbERtOEIsZ0NBQTRCbjhCLGFBQTVCLElBQTZDLElBQTdDO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7QUFDRGs4Qiw0QkFBMEJsOEIsYUFBMUIsSUFBMkMsSUFBM0M7QUFDQXpiLFVBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSw4QkFBZixFQUErQzRXLGFBQS9DLENBQXhDLEdBQXdHLEtBQUssQ0FBN0c7QUFDQSxTQUFPLEtBQVA7QUFDRDs7QUFFRCxTQUFTcThCLGlCQUFULENBQTJCdDhCLFlBQTNCLEVBQXlDbkMsS0FBekMsRUFBZ0Q7QUFDOUMsU0FBT0EsU0FBUyxJQUFULElBQWlCbUMsYUFBYU0sZUFBYixJQUFnQyxDQUFDekMsS0FBbEQsSUFBMkRtQyxhQUFhTyxlQUFiLElBQWdDZzhCLE1BQU0xK0IsS0FBTixDQUEzRixJQUEyR21DLGFBQWFRLHVCQUFiLElBQXdDM0MsUUFBUSxDQUEzSixJQUFnS21DLGFBQWFTLHlCQUFiLElBQTBDNUMsVUFBVSxLQUEzTjtBQUNEOztBQUVEOzs7QUFHQSxJQUFJMitCLHdCQUF3QjtBQUMxQjs7Ozs7O0FBTUFDLHFCQUFtQiwyQkFBVTVxQyxFQUFWLEVBQWM7QUFDL0IsV0FBT3hILFlBQVlHLGlCQUFaLEdBQWdDLEdBQWhDLEdBQXNDeXhDLDhCQUE4QnBxQyxFQUE5QixDQUE3QztBQUNELEdBVHlCOztBQVcxQjZxQyxxQkFBbUIsMkJBQVUxeEMsSUFBVixFQUFnQjZHLEVBQWhCLEVBQW9CO0FBQ3JDN0csU0FBSzR5QixZQUFMLENBQWtCdnpCLFlBQVlHLGlCQUE5QixFQUFpRHFILEVBQWpEO0FBQ0QsR0FieUI7O0FBZTFCOHFDLHVCQUFxQiwrQkFBWTtBQUMvQixXQUFPdHlDLFlBQVl1VyxtQkFBWixHQUFrQyxLQUF6QztBQUNELEdBakJ5Qjs7QUFtQjFCZzhCLHVCQUFxQiw2QkFBVTV4QyxJQUFWLEVBQWdCO0FBQ25DQSxTQUFLNHlCLFlBQUwsQ0FBa0J2ekIsWUFBWXVXLG1CQUE5QixFQUFtRCxFQUFuRDtBQUNELEdBckJ5Qjs7QUF1QjFCOzs7Ozs7O0FBT0FpOEIsMkJBQXlCLGlDQUFVLzBDLElBQVYsRUFBZ0IrVixLQUFoQixFQUF1QjtBQUM5QyxRQUFJbUMsZUFBZTNWLFlBQVl1VixVQUFaLENBQXVCclQsY0FBdkIsQ0FBc0N6RSxJQUF0QyxJQUE4Q3VDLFlBQVl1VixVQUFaLENBQXVCOVgsSUFBdkIsQ0FBOUMsR0FBNkUsSUFBaEc7QUFDQSxRQUFJa1ksWUFBSixFQUFrQjtBQUNoQixVQUFJczhCLGtCQUFrQnQ4QixZQUFsQixFQUFnQ25DLEtBQWhDLENBQUosRUFBNEM7QUFDMUMsZUFBTyxFQUFQO0FBQ0Q7QUFDRCxVQUFJb0MsZ0JBQWdCRCxhQUFhQyxhQUFqQztBQUNBLFVBQUlELGFBQWFNLGVBQWIsSUFBZ0NOLGFBQWFTLHlCQUFiLElBQTBDNUMsVUFBVSxJQUF4RixFQUE4RjtBQUM1RixlQUFPb0MsZ0JBQWdCLEtBQXZCO0FBQ0Q7QUFDRCxhQUFPQSxnQkFBZ0IsR0FBaEIsR0FBc0JnOEIsOEJBQThCcCtCLEtBQTlCLENBQTdCO0FBQ0QsS0FURCxNQVNPLElBQUl4VCxZQUFZcVYsaUJBQVosQ0FBOEI1WCxJQUE5QixDQUFKLEVBQXlDO0FBQzlDLFVBQUkrVixTQUFTLElBQWIsRUFBbUI7QUFDakIsZUFBTyxFQUFQO0FBQ0Q7QUFDRCxhQUFPL1YsT0FBTyxHQUFQLEdBQWFtMEMsOEJBQThCcCtCLEtBQTlCLENBQXBCO0FBQ0Q7QUFDRCxXQUFPLElBQVA7QUFDRCxHQWhEeUI7O0FBa0QxQjs7Ozs7OztBQU9BaS9CLGtDQUFnQyx3Q0FBVWgxQyxJQUFWLEVBQWdCK1YsS0FBaEIsRUFBdUI7QUFDckQsUUFBSSxDQUFDdytCLG9CQUFvQnYwQyxJQUFwQixDQUFELElBQThCK1YsU0FBUyxJQUEzQyxFQUFpRDtBQUMvQyxhQUFPLEVBQVA7QUFDRDtBQUNELFdBQU8vVixPQUFPLEdBQVAsR0FBYW0wQyw4QkFBOEJwK0IsS0FBOUIsQ0FBcEI7QUFDRCxHQTlEeUI7O0FBZ0UxQjs7Ozs7OztBQU9Bay9CLHVCQUFxQiw2QkFBVS94QyxJQUFWLEVBQWdCbEQsSUFBaEIsRUFBc0IrVixLQUF0QixFQUE2QjtBQUNoRCxRQUFJbUMsZUFBZTNWLFlBQVl1VixVQUFaLENBQXVCclQsY0FBdkIsQ0FBc0N6RSxJQUF0QyxJQUE4Q3VDLFlBQVl1VixVQUFaLENBQXVCOVgsSUFBdkIsQ0FBOUMsR0FBNkUsSUFBaEc7QUFDQSxRQUFJa1ksWUFBSixFQUFrQjtBQUNoQixVQUFJSSxpQkFBaUJKLGFBQWFJLGNBQWxDO0FBQ0EsVUFBSUEsY0FBSixFQUFvQjtBQUNsQkEsdUJBQWVwVixJQUFmLEVBQXFCNlMsS0FBckI7QUFDRCxPQUZELE1BRU8sSUFBSXkrQixrQkFBa0J0OEIsWUFBbEIsRUFBZ0NuQyxLQUFoQyxDQUFKLEVBQTRDO0FBQ2pELGFBQUttL0Isc0JBQUwsQ0FBNEJoeUMsSUFBNUIsRUFBa0NsRCxJQUFsQztBQUNBO0FBQ0QsT0FITSxNQUdBLElBQUlrWSxhQUFhSyxlQUFqQixFQUFrQztBQUN2QztBQUNBO0FBQ0FyVixhQUFLZ1YsYUFBYUcsWUFBbEIsSUFBa0N0QyxLQUFsQztBQUNELE9BSk0sTUFJQTtBQUNMLFlBQUlvQyxnQkFBZ0JELGFBQWFDLGFBQWpDO0FBQ0EsWUFBSWc5QixZQUFZajlCLGFBQWFFLGtCQUE3QjtBQUNBO0FBQ0E7QUFDQSxZQUFJKzhCLFNBQUosRUFBZTtBQUNianlDLGVBQUtreUMsY0FBTCxDQUFvQkQsU0FBcEIsRUFBK0JoOUIsYUFBL0IsRUFBOEMsS0FBS3BDLEtBQW5EO0FBQ0QsU0FGRCxNQUVPLElBQUltQyxhQUFhTSxlQUFiLElBQWdDTixhQUFhUyx5QkFBYixJQUEwQzVDLFVBQVUsSUFBeEYsRUFBOEY7QUFDbkc3UyxlQUFLNHlCLFlBQUwsQ0FBa0IzZCxhQUFsQixFQUFpQyxFQUFqQztBQUNELFNBRk0sTUFFQTtBQUNMalYsZUFBSzR5QixZQUFMLENBQWtCM2QsYUFBbEIsRUFBaUMsS0FBS3BDLEtBQXRDO0FBQ0Q7QUFDRjtBQUNGLEtBeEJELE1Bd0JPLElBQUl4VCxZQUFZcVYsaUJBQVosQ0FBOEI1WCxJQUE5QixDQUFKLEVBQXlDO0FBQzlDMDBDLDRCQUFzQlcsb0JBQXRCLENBQTJDbnlDLElBQTNDLEVBQWlEbEQsSUFBakQsRUFBdUQrVixLQUF2RDtBQUNBO0FBQ0Q7O0FBRUQsUUFBSXJaLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUlpM0IsVUFBVSxFQUFkO0FBQ0FBLGNBQVF6M0IsSUFBUixJQUFnQitWLEtBQWhCO0FBQ0FzSSwyQkFBcUIzUCxTQUFyQixDQUErQjZvQixlQUEvQixDQUErQztBQUM3Q0Msb0JBQVlseUIsc0JBQXNCSCxtQkFBdEIsQ0FBMENqQyxJQUExQyxFQUFnRGlLLFFBRGY7QUFFN0NoQyxjQUFNLGtCQUZ1QztBQUc3Q3NzQixpQkFBU0E7QUFIb0MsT0FBL0M7QUFLRDtBQUNGLEdBL0d5Qjs7QUFpSDFCNGQsd0JBQXNCLDhCQUFVbnlDLElBQVYsRUFBZ0JsRCxJQUFoQixFQUFzQitWLEtBQXRCLEVBQTZCO0FBQ2pELFFBQUksQ0FBQ3crQixvQkFBb0J2MEMsSUFBcEIsQ0FBTCxFQUFnQztBQUM5QjtBQUNEO0FBQ0QsUUFBSStWLFNBQVMsSUFBYixFQUFtQjtBQUNqQjdTLFdBQUtveUMsZUFBTCxDQUFxQnQxQyxJQUFyQjtBQUNELEtBRkQsTUFFTztBQUNMa0QsV0FBSzR5QixZQUFMLENBQWtCOTFCLElBQWxCLEVBQXdCLEtBQUsrVixLQUE3QjtBQUNEOztBQUVELFFBQUlyWixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJaTNCLFVBQVUsRUFBZDtBQUNBQSxjQUFRejNCLElBQVIsSUFBZ0IrVixLQUFoQjtBQUNBc0ksMkJBQXFCM1AsU0FBckIsQ0FBK0I2b0IsZUFBL0IsQ0FBK0M7QUFDN0NDLG9CQUFZbHlCLHNCQUFzQkgsbUJBQXRCLENBQTBDakMsSUFBMUMsRUFBZ0RpSyxRQURmO0FBRTdDaEMsY0FBTSxrQkFGdUM7QUFHN0Nzc0IsaUJBQVNBO0FBSG9DLE9BQS9DO0FBS0Q7QUFDRixHQXBJeUI7O0FBc0kxQjs7Ozs7O0FBTUE4ZCwyQkFBeUIsaUNBQVVyeUMsSUFBVixFQUFnQmxELElBQWhCLEVBQXNCO0FBQzdDa0QsU0FBS295QyxlQUFMLENBQXFCdDFDLElBQXJCO0FBQ0EsUUFBSXRELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNmQsMkJBQXFCM1AsU0FBckIsQ0FBK0I2b0IsZUFBL0IsQ0FBK0M7QUFDN0NDLG9CQUFZbHlCLHNCQUFzQkgsbUJBQXRCLENBQTBDakMsSUFBMUMsRUFBZ0RpSyxRQURmO0FBRTdDaEMsY0FBTSxrQkFGdUM7QUFHN0Nzc0IsaUJBQVN6M0I7QUFIb0MsT0FBL0M7QUFLRDtBQUNGLEdBckp5Qjs7QUF1SjFCOzs7Ozs7QUFNQWsxQywwQkFBd0IsZ0NBQVVoeUMsSUFBVixFQUFnQmxELElBQWhCLEVBQXNCO0FBQzVDLFFBQUlrWSxlQUFlM1YsWUFBWXVWLFVBQVosQ0FBdUJyVCxjQUF2QixDQUFzQ3pFLElBQXRDLElBQThDdUMsWUFBWXVWLFVBQVosQ0FBdUI5WCxJQUF2QixDQUE5QyxHQUE2RSxJQUFoRztBQUNBLFFBQUlrWSxZQUFKLEVBQWtCO0FBQ2hCLFVBQUlJLGlCQUFpQkosYUFBYUksY0FBbEM7QUFDQSxVQUFJQSxjQUFKLEVBQW9CO0FBQ2xCQSx1QkFBZXBWLElBQWYsRUFBcUJ6QyxTQUFyQjtBQUNELE9BRkQsTUFFTyxJQUFJeVgsYUFBYUssZUFBakIsRUFBa0M7QUFDdkMsWUFBSXRELFdBQVdpRCxhQUFhRyxZQUE1QjtBQUNBLFlBQUlILGFBQWFNLGVBQWpCLEVBQWtDO0FBQ2hDdFYsZUFBSytSLFFBQUwsSUFBaUIsS0FBakI7QUFDRCxTQUZELE1BRU87QUFDTC9SLGVBQUsrUixRQUFMLElBQWlCLEVBQWpCO0FBQ0Q7QUFDRixPQVBNLE1BT0E7QUFDTC9SLGFBQUtveUMsZUFBTCxDQUFxQnA5QixhQUFhQyxhQUFsQztBQUNEO0FBQ0YsS0FkRCxNQWNPLElBQUk1VixZQUFZcVYsaUJBQVosQ0FBOEI1WCxJQUE5QixDQUFKLEVBQXlDO0FBQzlDa0QsV0FBS295QyxlQUFMLENBQXFCdDFDLElBQXJCO0FBQ0Q7O0FBRUQsUUFBSXRELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNmQsMkJBQXFCM1AsU0FBckIsQ0FBK0I2b0IsZUFBL0IsQ0FBK0M7QUFDN0NDLG9CQUFZbHlCLHNCQUFzQkgsbUJBQXRCLENBQTBDakMsSUFBMUMsRUFBZ0RpSyxRQURmO0FBRTdDaEMsY0FBTSxrQkFGdUM7QUFHN0Nzc0IsaUJBQVN6M0I7QUFIb0MsT0FBL0M7QUFLRDtBQUNGO0FBeEx5QixDQUE1Qjs7QUEyTEFyRCxPQUFPQyxPQUFQLEdBQWlCODNDLHFCQUFqQixDOzs7Ozs7OztBQ3pPQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJM2hCLHVCQUF1Qiw4Q0FBM0I7O0FBRUFwMkIsT0FBT0MsT0FBUCxHQUFpQm0yQixvQkFBakIsQzs7Ozs7OztBQ2ZBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSTVqQixVQUFVLG1CQUFBN04sQ0FBUSxDQUFSLENBQWQ7O0FBRUEsSUFBSTg0QixtQkFBbUIsbUJBQUE5NEIsQ0FBUSxFQUFSLENBQXZCO0FBQ0EsSUFBSWdFLHdCQUF3QixtQkFBQWhFLENBQVEsQ0FBUixDQUE1QjtBQUNBLElBQUkwTyxlQUFlLG1CQUFBMU8sQ0FBUSxFQUFSLENBQW5COztBQUVBLElBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUlrMEMsbUJBQW1CLEtBQXZCO0FBQ0EsSUFBSUMsMkJBQTJCLEtBQS9COztBQUVBLFNBQVNDLHNDQUFULEdBQWtEO0FBQ2hELE1BQUksS0FBSzN4QixXQUFMLElBQW9CLEtBQUtncEIsYUFBTCxDQUFtQjRJLGFBQTNDLEVBQTBEO0FBQ3hELFNBQUs1SSxhQUFMLENBQW1CNEksYUFBbkIsR0FBbUMsS0FBbkM7O0FBRUEsUUFBSTM3QixRQUFRLEtBQUszSCxlQUFMLENBQXFCMkgsS0FBakM7QUFDQSxRQUFJakUsUUFBUXFrQixpQkFBaUJJLFFBQWpCLENBQTBCeGdCLEtBQTFCLENBQVo7O0FBRUEsUUFBSWpFLFNBQVMsSUFBYixFQUFtQjtBQUNqQjYvQixvQkFBYyxJQUFkLEVBQW9CQyxRQUFRNzdCLE1BQU04N0IsUUFBZCxDQUFwQixFQUE2Qy8vQixLQUE3QztBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFTb2tCLDJCQUFULENBQXFDcnRCLEtBQXJDLEVBQTRDO0FBQzFDLE1BQUlBLEtBQUosRUFBVztBQUNULFFBQUk5TSxPQUFPOE0sTUFBTUUsT0FBTixFQUFYO0FBQ0EsUUFBSWhOLElBQUosRUFBVTtBQUNSLGFBQU8sa0NBQWtDQSxJQUFsQyxHQUF5QyxJQUFoRDtBQUNEO0FBQ0Y7QUFDRCxTQUFPLEVBQVA7QUFDRDs7QUFFRCxJQUFJKzFDLGlCQUFpQixDQUFDLE9BQUQsRUFBVSxjQUFWLENBQXJCOztBQUVBOzs7O0FBSUEsU0FBU0Msb0JBQVQsQ0FBOEJueUMsSUFBOUIsRUFBb0NtVyxLQUFwQyxFQUEyQztBQUN6QyxNQUFJbE4sUUFBUWpKLEtBQUt3TyxlQUFMLENBQXFCdEYsTUFBakM7QUFDQXF0QixtQkFBaUJDLGNBQWpCLENBQWdDLFFBQWhDLEVBQTBDcmdCLEtBQTFDLEVBQWlEbE4sS0FBakQ7O0FBRUEsTUFBSWtOLE1BQU0wZixTQUFOLEtBQW9CajVCLFNBQXBCLElBQWlDLENBQUMrMEMsZ0JBQXRDLEVBQXdEO0FBQ3REOTRDLFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxpRkFBZixDQUF4QyxHQUE0SSxLQUFLLENBQWpKO0FBQ0FpMEMsdUJBQW1CLElBQW5CO0FBQ0Q7O0FBRUQsT0FBSyxJQUFJLzJDLElBQUksQ0FBYixFQUFnQkEsSUFBSXMzQyxlQUFlaDRDLE1BQW5DLEVBQTJDVSxHQUEzQyxFQUFnRDtBQUM5QyxRQUFJd1csV0FBVzhnQyxlQUFldDNDLENBQWYsQ0FBZjtBQUNBLFFBQUl1YixNQUFNL0UsUUFBTixLQUFtQixJQUF2QixFQUE2QjtBQUMzQjtBQUNEO0FBQ0QsUUFBSTZlLFVBQVV2MUIsTUFBTXUxQixPQUFOLENBQWM5WixNQUFNL0UsUUFBTixDQUFkLENBQWQ7QUFDQSxRQUFJK0UsTUFBTTg3QixRQUFOLElBQWtCLENBQUNoaUIsT0FBdkIsRUFBZ0M7QUFDOUJwM0IsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLDREQUE0RCx1QkFBM0UsRUFBb0cwVCxRQUFwRyxFQUE4R2tsQiw0QkFBNEJydEIsS0FBNUIsQ0FBOUcsQ0FBeEMsR0FBNEwsS0FBSyxDQUFqTTtBQUNELEtBRkQsTUFFTyxJQUFJLENBQUNrTixNQUFNODdCLFFBQVAsSUFBbUJoaUIsT0FBdkIsRUFBZ0M7QUFDckNwM0IsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLHlEQUF5RCxpQ0FBeEUsRUFBMkcwVCxRQUEzRyxFQUFxSGtsQiw0QkFBNEJydEIsS0FBNUIsQ0FBckgsQ0FBeEMsR0FBbU0sS0FBSyxDQUF4TTtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7O0FBTUEsU0FBUzhvQyxhQUFULENBQXVCL3hDLElBQXZCLEVBQTZCaXlDLFFBQTdCLEVBQXVDbkwsU0FBdkMsRUFBa0Q7QUFDaEQsTUFBSXNMLGFBQUosRUFBbUJ4M0MsQ0FBbkI7QUFDQSxNQUFJc21DLFVBQVV6L0Isc0JBQXNCRixtQkFBdEIsQ0FBMEN2QixJQUExQyxFQUFnRGtoQyxPQUE5RDs7QUFFQSxNQUFJK1EsUUFBSixFQUFjO0FBQ1pHLG9CQUFnQixFQUFoQjtBQUNBLFNBQUt4M0MsSUFBSSxDQUFULEVBQVlBLElBQUlrc0MsVUFBVTVzQyxNQUExQixFQUFrQ1UsR0FBbEMsRUFBdUM7QUFDckN3M0Msb0JBQWMsS0FBS3RMLFVBQVVsc0MsQ0FBVixDQUFuQixJQUFtQyxJQUFuQztBQUNEO0FBQ0QsU0FBS0EsSUFBSSxDQUFULEVBQVlBLElBQUlzbUMsUUFBUWhuQyxNQUF4QixFQUFnQ1UsR0FBaEMsRUFBcUM7QUFDbkMsVUFBSXkzQyxXQUFXRCxjQUFjeHhDLGNBQWQsQ0FBNkJzZ0MsUUFBUXRtQyxDQUFSLEVBQVdzWCxLQUF4QyxDQUFmO0FBQ0EsVUFBSWd2QixRQUFRdG1DLENBQVIsRUFBV3kzQyxRQUFYLEtBQXdCQSxRQUE1QixFQUFzQztBQUNwQ25SLGdCQUFRdG1DLENBQVIsRUFBV3kzQyxRQUFYLEdBQXNCQSxRQUF0QjtBQUNEO0FBQ0Y7QUFDRixHQVhELE1BV087QUFDTDtBQUNBO0FBQ0FELG9CQUFnQixLQUFLdEwsU0FBckI7QUFDQSxTQUFLbHNDLElBQUksQ0FBVCxFQUFZQSxJQUFJc21DLFFBQVFobkMsTUFBeEIsRUFBZ0NVLEdBQWhDLEVBQXFDO0FBQ25DLFVBQUlzbUMsUUFBUXRtQyxDQUFSLEVBQVdzWCxLQUFYLEtBQXFCa2dDLGFBQXpCLEVBQXdDO0FBQ3RDbFIsZ0JBQVF0bUMsQ0FBUixFQUFXeTNDLFFBQVgsR0FBc0IsSUFBdEI7QUFDQTtBQUNEO0FBQ0Y7QUFDRCxRQUFJblIsUUFBUWhuQyxNQUFaLEVBQW9CO0FBQ2xCZ25DLGNBQVEsQ0FBUixFQUFXbVIsUUFBWCxHQUFzQixJQUF0QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsSUFBSUMsaUJBQWlCO0FBQ25CQyxnQkFBYyxzQkFBVXZ5QyxJQUFWLEVBQWdCbVcsS0FBaEIsRUFBdUI7QUFDbkMsV0FBTzdLLFFBQVEsRUFBUixFQUFZNkssS0FBWixFQUFtQjtBQUN4QjRmLGdCQUFVLzFCLEtBQUtrcEMsYUFBTCxDQUFtQm5ULFFBREw7QUFFeEI3akIsYUFBT3RWO0FBRmlCLEtBQW5CLENBQVA7QUFJRCxHQU5rQjs7QUFRbkI0MUMsZ0JBQWMsc0JBQVV4eUMsSUFBVixFQUFnQm1XLEtBQWhCLEVBQXVCO0FBQ25DLFFBQUl0ZCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3cxQywyQkFBcUJueUMsSUFBckIsRUFBMkJtVyxLQUEzQjtBQUNEOztBQUVELFFBQUlqRSxRQUFRcWtCLGlCQUFpQkksUUFBakIsQ0FBMEJ4Z0IsS0FBMUIsQ0FBWjtBQUNBblcsU0FBS2twQyxhQUFMLEdBQXFCO0FBQ25CNEkscUJBQWUsS0FESTtBQUVuQlcsb0JBQWN2Z0MsU0FBUyxJQUFULEdBQWdCQSxLQUFoQixHQUF3QmlFLE1BQU11OEIsWUFGekI7QUFHbkJ4MkMsaUJBQVcsSUFIUTtBQUluQjY1QixnQkFBVTRjLGNBQWN2N0IsSUFBZCxDQUFtQnBYLElBQW5CLENBSlM7QUFLbkI0eUMsbUJBQWFaLFFBQVE3N0IsTUFBTTg3QixRQUFkO0FBTE0sS0FBckI7O0FBUUEsUUFBSTk3QixNQUFNakUsS0FBTixLQUFnQnRWLFNBQWhCLElBQTZCdVosTUFBTXU4QixZQUFOLEtBQXVCOTFDLFNBQXBELElBQWlFLENBQUNnMUMsd0JBQXRFLEVBQWdHO0FBQzlGLzRDLGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSwrREFBK0Qsb0VBQS9ELEdBQXNJLGtFQUF0SSxHQUEyTSxvREFBM00sR0FBa1EsMkNBQWpSLENBQXhDLEdBQXdXLEtBQUssQ0FBN1c7QUFDQWswQyxpQ0FBMkIsSUFBM0I7QUFDRDtBQUNGLEdBMUJrQjs7QUE0Qm5CaUIseUJBQXVCLCtCQUFVN3lDLElBQVYsRUFBZ0I7QUFDckM7QUFDQTtBQUNBLFdBQU9BLEtBQUtrcEMsYUFBTCxDQUFtQnVKLFlBQTFCO0FBQ0QsR0FoQ2tCOztBQWtDbkJLLHFCQUFtQiwyQkFBVTl5QyxJQUFWLEVBQWdCO0FBQ2pDLFFBQUltVyxRQUFRblcsS0FBS3dPLGVBQUwsQ0FBcUIySCxLQUFqQzs7QUFFQTtBQUNBO0FBQ0FuVyxTQUFLa3BDLGFBQUwsQ0FBbUJ1SixZQUFuQixHQUFrQzcxQyxTQUFsQzs7QUFFQSxRQUFJZzJDLGNBQWM1eUMsS0FBS2twQyxhQUFMLENBQW1CMEosV0FBckM7QUFDQTV5QyxTQUFLa3BDLGFBQUwsQ0FBbUIwSixXQUFuQixHQUFpQ1osUUFBUTc3QixNQUFNODdCLFFBQWQsQ0FBakM7O0FBRUEsUUFBSS8vQixRQUFRcWtCLGlCQUFpQkksUUFBakIsQ0FBMEJ4Z0IsS0FBMUIsQ0FBWjtBQUNBLFFBQUlqRSxTQUFTLElBQWIsRUFBbUI7QUFDakJsUyxXQUFLa3BDLGFBQUwsQ0FBbUI0SSxhQUFuQixHQUFtQyxLQUFuQztBQUNBQyxvQkFBYy94QyxJQUFkLEVBQW9CZ3lDLFFBQVE3N0IsTUFBTTg3QixRQUFkLENBQXBCLEVBQTZDLy9CLEtBQTdDO0FBQ0QsS0FIRCxNQUdPLElBQUkwZ0MsZ0JBQWdCWixRQUFRNzdCLE1BQU04N0IsUUFBZCxDQUFwQixFQUE2QztBQUNsRDtBQUNBLFVBQUk5N0IsTUFBTXU4QixZQUFOLElBQXNCLElBQTFCLEVBQWdDO0FBQzlCWCxzQkFBYy94QyxJQUFkLEVBQW9CZ3lDLFFBQVE3N0IsTUFBTTg3QixRQUFkLENBQXBCLEVBQTZDOTdCLE1BQU11OEIsWUFBbkQ7QUFDRCxPQUZELE1BRU87QUFDTDtBQUNBWCxzQkFBYy94QyxJQUFkLEVBQW9CZ3lDLFFBQVE3N0IsTUFBTTg3QixRQUFkLENBQXBCLEVBQTZDOTdCLE1BQU04N0IsUUFBTixHQUFpQixFQUFqQixHQUFzQixFQUFuRTtBQUNEO0FBQ0Y7QUFDRjtBQXpEa0IsQ0FBckI7O0FBNERBLFNBQVNVLGFBQVQsQ0FBdUJ0aUMsS0FBdkIsRUFBOEI7QUFDNUIsTUFBSThGLFFBQVEsS0FBSzNILGVBQUwsQ0FBcUIySCxLQUFqQztBQUNBLE1BQUk3RSxjQUFjaWxCLGlCQUFpQk0sZUFBakIsQ0FBaUMxZ0IsS0FBakMsRUFBd0M5RixLQUF4QyxDQUFsQjs7QUFFQSxNQUFJLEtBQUs2UCxXQUFULEVBQXNCO0FBQ3BCLFNBQUtncEIsYUFBTCxDQUFtQjRJLGFBQW5CLEdBQW1DLElBQW5DO0FBQ0Q7QUFDRDNsQyxlQUFhZ0QsSUFBYixDQUFrQjBpQyxzQ0FBbEIsRUFBMEQsSUFBMUQ7QUFDQSxTQUFPdmdDLFdBQVA7QUFDRDs7QUFFRHhZLE9BQU9DLE9BQVAsR0FBaUJ1NUMsY0FBakIsQzs7Ozs7Ozs7QUN0TUE7Ozs7Ozs7Ozs7QUFVQTs7OztBQUVBLElBQUk3ekMsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCO0FBQUEsSUFDSTZOLFVBQVUsbUJBQUE3TixDQUFRLENBQVIsQ0FEZDs7QUFHQSxJQUFJczFDLDBCQUEwQixtQkFBQXQxQyxDQUFRLEdBQVIsQ0FBOUI7QUFDQSxJQUFJdTFDLHNCQUFzQixtQkFBQXYxQyxDQUFRLEVBQVIsQ0FBMUI7QUFDQSxJQUFJdzFDLHFCQUFxQixtQkFBQXgxQyxDQUFRLEVBQVIsQ0FBekI7O0FBRUEsSUFBSXkxQyxpQkFBaUIsbUJBQUF6MUMsQ0FBUSxHQUFSLENBQXJCO0FBQ0EsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCO0FBQ0EsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUE7QUFDQSxJQUFJMDFDLGlDQUFpQyxTQUFqQ0EsOEJBQWlDLENBQVU5ckMsT0FBVixFQUFtQjtBQUN0RCxPQUFLeUssU0FBTCxDQUFlekssT0FBZjtBQUNELENBRkQ7O0FBSUEsU0FBU2l2QiwyQkFBVCxDQUFxQ3J0QixLQUFyQyxFQUE0QztBQUMxQyxNQUFJQSxLQUFKLEVBQVc7QUFDVCxRQUFJOU0sT0FBTzhNLE1BQU1FLE9BQU4sRUFBWDtBQUNBLFFBQUloTixJQUFKLEVBQVU7QUFDUixhQUFPLGtDQUFrQ0EsSUFBbEMsR0FBeUMsSUFBaEQ7QUFDRDtBQUNGO0FBQ0QsU0FBTyxFQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTaTNDLHVCQUFULENBQWlDOXJDLElBQWpDLEVBQXVDO0FBQ3JDLFNBQU8sT0FBT0EsSUFBUCxLQUFnQixVQUFoQixJQUE4QixPQUFPQSxLQUFLdE0sU0FBWixLQUEwQixXQUF4RCxJQUF1RSxPQUFPc00sS0FBS3RNLFNBQUwsQ0FBZTBmLGNBQXRCLEtBQXlDLFVBQWhILElBQThILE9BQU9wVCxLQUFLdE0sU0FBTCxDQUFlc2dCLGdCQUF0QixLQUEyQyxVQUFoTDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVMrM0IseUJBQVQsQ0FBbUNoMEMsSUFBbkMsRUFBeUNpMEMsaUJBQXpDLEVBQTREO0FBQzFELE1BQUl4N0IsUUFBSjs7QUFFQSxNQUFJelksU0FBUyxJQUFULElBQWlCQSxTQUFTLEtBQTlCLEVBQXFDO0FBQ25DeVksZUFBV2s3QixvQkFBb0JqaEMsTUFBcEIsQ0FBMkJzaEMseUJBQTNCLENBQVg7QUFDRCxHQUZELE1BRU8sSUFBSSxRQUFPaDBDLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBcEIsRUFBOEI7QUFDbkMsUUFBSWdJLFVBQVVoSSxJQUFkO0FBQ0EsUUFBSWlJLE9BQU9ELFFBQVFDLElBQW5CO0FBQ0EsUUFBSSxPQUFPQSxJQUFQLEtBQWdCLFVBQWhCLElBQThCLE9BQU9BLElBQVAsS0FBZ0IsUUFBbEQsRUFBNEQ7QUFDMUQsVUFBSTBCLE9BQU8sRUFBWDtBQUNBLFVBQUluUSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxZQUFJMkssU0FBUzFLLFNBQVQsSUFBc0IsUUFBTzBLLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFBNEJBLFNBQVMsSUFBckMsSUFBNkMzRixPQUFPb0IsSUFBUCxDQUFZdUUsSUFBWixFQUFrQnBOLE1BQWxCLEtBQTZCLENBQXBHLEVBQXVHO0FBQ3JHOE8sa0JBQVEsK0RBQStELGtCQUF2RTtBQUNEO0FBQ0Y7QUFDREEsY0FBUXN0Qiw0QkFBNEJqdkIsUUFBUTZCLE1BQXBDLENBQVI7QUFDQSxjQUFTclEsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixvSUFBakIsRUFBdUp5SyxRQUFRLElBQVIsR0FBZUEsSUFBZixVQUE2QkEsSUFBN0IseUNBQTZCQSxJQUE3QixDQUF2SixFQUEwTDBCLElBQTFMLENBQXhDLEdBQTBPdkssZUFBZSxLQUFmLEVBQXNCNkksUUFBUSxJQUFSLEdBQWVBLElBQWYsVUFBNkJBLElBQTdCLHlDQUE2QkEsSUFBN0IsQ0FBdEIsRUFBeUQwQixJQUF6RCxDQUFuUCxHQUFvVCxLQUFLLENBQXpUO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJLE9BQU8zQixRQUFRQyxJQUFmLEtBQXdCLFFBQTVCLEVBQXNDO0FBQ3BDd1EsaUJBQVdtN0IsbUJBQW1CTSx1QkFBbkIsQ0FBMkNsc0MsT0FBM0MsQ0FBWDtBQUNELEtBRkQsTUFFTyxJQUFJK3JDLHdCQUF3Qi9yQyxRQUFRQyxJQUFoQyxDQUFKLEVBQTJDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBd1EsaUJBQVcsSUFBSXpRLFFBQVFDLElBQVosQ0FBaUJELE9BQWpCLENBQVg7O0FBRUE7QUFDQSxVQUFJLENBQUN5USxTQUFTbUQsV0FBZCxFQUEyQjtBQUN6Qm5ELGlCQUFTbUQsV0FBVCxHQUF1Qm5ELFNBQVMwN0IsYUFBaEM7QUFDRDtBQUNGLEtBVk0sTUFVQTtBQUNMMTdCLGlCQUFXLElBQUlxN0IsOEJBQUosQ0FBbUM5ckMsT0FBbkMsQ0FBWDtBQUNEO0FBQ0YsR0E5Qk0sTUE4QkEsSUFBSSxPQUFPaEksSUFBUCxLQUFnQixRQUFoQixJQUE0QixPQUFPQSxJQUFQLEtBQWdCLFFBQWhELEVBQTBEO0FBQy9EeVksZUFBV203QixtQkFBbUJRLHFCQUFuQixDQUF5Q3AwQyxJQUF6QyxDQUFYO0FBQ0QsR0FGTSxNQUVBO0FBQ0wsWUFBU3hHLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsMkNBQWpCLFNBQXFFd0MsSUFBckUseUNBQXFFQSxJQUFyRSxFQUF4QyxHQUFxSFosZUFBZSxLQUFmLFNBQTZCWSxJQUE3Qix5Q0FBNkJBLElBQTdCLEVBQTlILEdBQW1LLEtBQUssQ0FBeEs7QUFDRDs7QUFFRCxNQUFJeEcsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM5RCxZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxPQUFPb2EsU0FBUzRDLGNBQWhCLEtBQW1DLFVBQW5DLElBQWlELE9BQU81QyxTQUFTd0QsZ0JBQWhCLEtBQXFDLFVBQXRGLElBQW9HLE9BQU94RCxTQUFTbUQsV0FBaEIsS0FBZ0MsVUFBcEksSUFBa0osT0FBT25ELFNBQVNvRCxnQkFBaEIsS0FBcUMsVUFBL0wsRUFBMk0sdUNBQTNNLENBQXhDLEdBQThSLEtBQUssQ0FBblM7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQXBELFdBQVM0N0IsV0FBVCxHQUF1QixDQUF2QjtBQUNBNTdCLFdBQVM2N0IsV0FBVCxHQUF1QixJQUF2Qjs7QUFFQSxNQUFJOTZDLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDbWIsYUFBU3hPLFFBQVQsR0FBb0JncUMsb0JBQW9CSixnQkFBcEIsR0FBdUMsQ0FBM0Q7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSXI2QyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxRQUFJZ0YsT0FBT2l5QyxpQkFBWCxFQUE4QjtBQUM1Qmp5QyxhQUFPaXlDLGlCQUFQLENBQXlCOTdCLFFBQXpCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPQSxRQUFQO0FBQ0Q7O0FBRUR4TSxRQUFRNm5DLCtCQUErQm40QyxTQUF2QyxFQUFrRCszQyx1QkFBbEQsRUFBMkU7QUFDekVjLDhCQUE0QlI7QUFENkMsQ0FBM0U7O0FBSUF2NkMsT0FBT0MsT0FBUCxHQUFpQnM2Qyx5QkFBakIsQzs7Ozs7Ozs7QUMvSEE7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUEsSUFBSTUwQyxpQkFBaUIsbUJBQUFoQixDQUFRLENBQVIsQ0FBckI7O0FBRUEsSUFBSWtjLFFBQVEsbUJBQUFsYyxDQUFRLEVBQVIsQ0FBWjs7QUFFQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7O0FBRUEsSUFBSXEyQyxpQkFBaUI7QUFDbkJDLFFBQU0sQ0FEYTtBQUVuQkMsYUFBVyxDQUZRO0FBR25CQyxTQUFPLENBSFk7O0FBS25CQyxXQUFTLGlCQUFVNzBDLElBQVYsRUFBZ0I7QUFDdkIsUUFBSUEsU0FBUyxJQUFULElBQWlCQSxTQUFTLEtBQTlCLEVBQXFDO0FBQ25DLGFBQU95MEMsZUFBZUcsS0FBdEI7QUFDRCxLQUZELE1BRU8sSUFBSXQ2QixNQUFNek8sY0FBTixDQUFxQjdMLElBQXJCLENBQUosRUFBZ0M7QUFDckMsVUFBSSxPQUFPQSxLQUFLaUksSUFBWixLQUFxQixVQUF6QixFQUFxQztBQUNuQyxlQUFPd3NDLGVBQWVFLFNBQXRCO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBT0YsZUFBZUMsSUFBdEI7QUFDRDtBQUNGO0FBQ0QsWUFBU2w3QyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHFCQUFqQixFQUF3Q3dDLElBQXhDLENBQXhDLEdBQXdGWixlQUFlLElBQWYsRUFBcUJZLElBQXJCLENBQWpHLEdBQThILEtBQUssQ0FBbkk7QUFDRDtBQWhCa0IsQ0FBckI7O0FBbUJBdkcsT0FBT0MsT0FBUCxHQUFpQis2QyxjQUFqQixDOzs7Ozs7OztBQ3RDQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlLLHFCQUFKOztBQUVBLElBQUlDLCtCQUErQjtBQUNqQ0MsK0JBQTZCLHFDQUFVbDlCLE9BQVYsRUFBbUI7QUFDOUNnOUIsNEJBQXdCaDlCLE9BQXhCO0FBQ0Q7QUFIZ0MsQ0FBbkM7O0FBTUEsSUFBSTY3QixzQkFBc0I7QUFDeEJqaEMsVUFBUSxnQkFBVXVpQyxXQUFWLEVBQXVCO0FBQzdCLFdBQU9ILHNCQUFzQkcsV0FBdEIsQ0FBUDtBQUNEO0FBSHVCLENBQTFCOztBQU1BdEIsb0JBQW9CdGpDLFNBQXBCLEdBQWdDMGtDLDRCQUFoQzs7QUFFQXQ3QyxPQUFPQyxPQUFQLEdBQWlCaTZDLG1CQUFqQixDOzs7Ozs7O0FDNUJBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSXYwQyxpQkFBaUIsbUJBQUFoQixDQUFRLENBQVIsQ0FBckI7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCOztBQUVBLElBQUk4MkMsd0JBQXdCLElBQTVCO0FBQ0EsSUFBSUMscUJBQXFCLElBQXpCOztBQUVBLElBQUlDLDhCQUE4QjtBQUNoQztBQUNBO0FBQ0FDLCtCQUE2QixxQ0FBVWpRLGNBQVYsRUFBMEI7QUFDckQ4UCw0QkFBd0I5UCxjQUF4QjtBQUNELEdBTCtCO0FBTWhDO0FBQ0E7QUFDQWtRLDRCQUEwQixrQ0FBVWxRLGNBQVYsRUFBMEI7QUFDbEQrUCx5QkFBcUIvUCxjQUFyQjtBQUNEO0FBVitCLENBQWxDOztBQWFBOzs7Ozs7QUFNQSxTQUFTOE8sdUJBQVQsQ0FBaUNsc0MsT0FBakMsRUFBMEM7QUFDeEMsR0FBQ2t0QyxxQkFBRCxHQUF5QjE3QyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLGlEQUFqQixFQUFvRXdLLFFBQVFDLElBQTVFLENBQXhDLEdBQTRIN0ksZUFBZSxLQUFmLEVBQXNCNEksUUFBUUMsSUFBOUIsQ0FBckosR0FBMkwsS0FBSyxDQUFoTTtBQUNBLFNBQU8sSUFBSWl0QyxxQkFBSixDQUEwQmx0QyxPQUExQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxTQUFTb3NDLHFCQUFULENBQStCcHJDLElBQS9CLEVBQXFDO0FBQ25DLFNBQU8sSUFBSW1zQyxrQkFBSixDQUF1Qm5zQyxJQUF2QixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFJQSxTQUFTdXNDLGVBQVQsQ0FBeUJoMUMsU0FBekIsRUFBb0M7QUFDbEMsU0FBT0EscUJBQXFCNDBDLGtCQUE1QjtBQUNEOztBQUVELElBQUl2QixxQkFBcUI7QUFDdkJNLDJCQUF5QkEsdUJBREY7QUFFdkJFLHlCQUF1QkEscUJBRkE7QUFHdkJtQixtQkFBaUJBLGVBSE07QUFJdkJsbEMsYUFBVytrQztBQUpZLENBQXpCOztBQU9BMzdDLE9BQU9DLE9BQVAsR0FBaUJrNkMsa0JBQWpCLEM7Ozs7Ozs7O0FDbEVBOzs7Ozs7Ozs7O0FBVUE7Ozs7QUFFQSxJQUFJeDBDLGlCQUFpQixtQkFBQWhCLENBQVEsQ0FBUixDQUFyQjs7QUFFQSxJQUFJcUgsb0JBQW9CLG1CQUFBckgsQ0FBUSxFQUFSLENBQXhCO0FBQ0EsSUFBSXNOLHFCQUFxQixtQkFBQXROLENBQVEsR0FBUixDQUF6Qjs7QUFFQSxJQUFJMmxDLGdCQUFnQixtQkFBQTNsQyxDQUFRLEdBQVIsQ0FBcEI7QUFDQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJKzZCLGlCQUFpQixtQkFBQS82QixDQUFRLEVBQVIsQ0FBckI7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJbzNDLFlBQVksR0FBaEI7QUFDQSxJQUFJQyxlQUFlLEdBQW5COztBQUVBOzs7Ozs7QUFNQTs7Ozs7QUFLQSxJQUFJQyxtQkFBbUIsS0FBdkI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTQyxlQUFULENBQXlCcDFDLFNBQXpCLEVBQW9DOG9CLEtBQXBDLEVBQTJDO0FBQ3pDO0FBQ0E7QUFDQSxNQUFJOW9CLGFBQWEsUUFBT0EsU0FBUCx5Q0FBT0EsU0FBUCxPQUFxQixRQUFsQyxJQUE4Q0EsVUFBVTJELEdBQVYsSUFBaUIsSUFBbkUsRUFBeUU7QUFDdkU7QUFDQSxXQUFPaTFCLGVBQWUvUCxNQUFmLENBQXNCN29CLFVBQVUyRCxHQUFoQyxDQUFQO0FBQ0Q7QUFDRDtBQUNBLFNBQU9tbEIsTUFBTXhwQixRQUFOLENBQWUsRUFBZixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBUysxQyx1QkFBVCxDQUFpQzEwQyxRQUFqQyxFQUEyQzIwQyxTQUEzQyxFQUFzRHZuQyxRQUF0RCxFQUFnRXduQyxlQUFoRSxFQUFpRjtBQUMvRSxNQUFJN3RDLGNBQWMvRyxRQUFkLHlDQUFjQSxRQUFkLENBQUo7O0FBRUEsTUFBSStHLFNBQVMsV0FBVCxJQUF3QkEsU0FBUyxTQUFyQyxFQUFnRDtBQUM5QztBQUNBL0csZUFBVyxJQUFYO0FBQ0Q7O0FBRUQsTUFBSUEsYUFBYSxJQUFiLElBQXFCK0csU0FBUyxRQUE5QixJQUEwQ0EsU0FBUyxRQUFuRDtBQUNKO0FBQ0E7QUFDQUEsV0FBUyxRQUFULElBQXFCL0csU0FBUzZLLFFBQVQsS0FBc0JMLGtCQUgzQyxFQUcrRDtBQUM3RDRDLGFBQVN3bkMsZUFBVCxFQUEwQjUwQyxRQUExQjtBQUNBO0FBQ0E7QUFDQTIwQyxrQkFBYyxFQUFkLEdBQW1CTCxZQUFZRyxnQkFBZ0J6MEMsUUFBaEIsRUFBMEIsQ0FBMUIsQ0FBL0IsR0FBOEQyMEMsU0FIOUQ7QUFJQSxXQUFPLENBQVA7QUFDRDs7QUFFRCxNQUFJL1EsS0FBSjtBQUNBLE1BQUlpUixRQUFKO0FBQ0EsTUFBSUMsZUFBZSxDQUFuQixDQXJCK0UsQ0FxQnpEO0FBQ3RCLE1BQUlDLGlCQUFpQkosY0FBYyxFQUFkLEdBQW1CTCxTQUFuQixHQUErQkssWUFBWUosWUFBaEU7O0FBRUEsTUFBSXA2QyxNQUFNdTFCLE9BQU4sQ0FBYzF2QixRQUFkLENBQUosRUFBNkI7QUFDM0IsU0FBSyxJQUFJM0YsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMkYsU0FBU3JHLE1BQTdCLEVBQXFDVSxHQUFyQyxFQUEwQztBQUN4Q3VwQyxjQUFRNWpDLFNBQVMzRixDQUFULENBQVI7QUFDQXc2QyxpQkFBV0UsaUJBQWlCTixnQkFBZ0I3USxLQUFoQixFQUF1QnZwQyxDQUF2QixDQUE1QjtBQUNBeTZDLHNCQUFnQkosd0JBQXdCOVEsS0FBeEIsRUFBK0JpUixRQUEvQixFQUF5Q3puQyxRQUF6QyxFQUFtRHduQyxlQUFuRCxDQUFoQjtBQUNEO0FBQ0YsR0FORCxNQU1PO0FBQ0wsUUFBSTdSLGFBQWFGLGNBQWM3aUMsUUFBZCxDQUFqQjtBQUNBLFFBQUkraUMsVUFBSixFQUFnQjtBQUNkLFVBQUlKLFdBQVdJLFdBQVc1cEMsSUFBWCxDQUFnQjZHLFFBQWhCLENBQWY7QUFDQSxVQUFJOGpDLElBQUo7QUFDQSxVQUFJZixlQUFlL2lDLFNBQVM2akMsT0FBNUIsRUFBcUM7QUFDbkMsWUFBSW1SLEtBQUssQ0FBVDtBQUNBLGVBQU8sQ0FBQyxDQUFDbFIsT0FBT25CLFNBQVNvQixJQUFULEVBQVIsRUFBeUJDLElBQWpDLEVBQXVDO0FBQ3JDSixrQkFBUUUsS0FBS255QixLQUFiO0FBQ0FrakMscUJBQVdFLGlCQUFpQk4sZ0JBQWdCN1EsS0FBaEIsRUFBdUJvUixJQUF2QixDQUE1QjtBQUNBRiwwQkFBZ0JKLHdCQUF3QjlRLEtBQXhCLEVBQStCaVIsUUFBL0IsRUFBeUN6bkMsUUFBekMsRUFBbUR3bkMsZUFBbkQsQ0FBaEI7QUFDRDtBQUNGLE9BUEQsTUFPTztBQUNMLFlBQUl0OEMsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsY0FBSTY0Qyx5QkFBeUIsRUFBN0I7QUFDQSxjQUFJMXdDLGtCQUFrQnVFLE9BQXRCLEVBQStCO0FBQzdCLGdCQUFJb3NDLDBCQUEwQjN3QyxrQkFBa0J1RSxPQUFsQixDQUEwQkYsT0FBMUIsRUFBOUI7QUFDQSxnQkFBSXNzQyx1QkFBSixFQUE2QjtBQUMzQkQsdUNBQXlCLGtDQUFrQ0MsdUJBQWxDLEdBQTRELElBQXJGO0FBQ0Q7QUFDRjtBQUNENThDLGtCQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUXEzQyxnQkFBUixFQUEwQixpRUFBaUUsOERBQWpFLEdBQWtJLHVEQUE1SixFQUFxTlMsc0JBQXJOLENBQXhDLEdBQXVSLEtBQUssQ0FBNVI7QUFDQVQsNkJBQW1CLElBQW5CO0FBQ0Q7QUFDRDtBQUNBLGVBQU8sQ0FBQyxDQUFDMVEsT0FBT25CLFNBQVNvQixJQUFULEVBQVIsRUFBeUJDLElBQWpDLEVBQXVDO0FBQ3JDLGNBQUkyRCxRQUFRN0QsS0FBS255QixLQUFqQjtBQUNBLGNBQUlnMkIsS0FBSixFQUFXO0FBQ1QvRCxvQkFBUStELE1BQU0sQ0FBTixDQUFSO0FBQ0FrTix1QkFBV0UsaUJBQWlCOWMsZUFBZS9QLE1BQWYsQ0FBc0J5ZixNQUFNLENBQU4sQ0FBdEIsQ0FBakIsR0FBbUQ0TSxZQUFuRCxHQUFrRUUsZ0JBQWdCN1EsS0FBaEIsRUFBdUIsQ0FBdkIsQ0FBN0U7QUFDQWtSLDRCQUFnQkosd0JBQXdCOVEsS0FBeEIsRUFBK0JpUixRQUEvQixFQUF5Q3puQyxRQUF6QyxFQUFtRHduQyxlQUFuRCxDQUFoQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEtBaENELE1BZ0NPLElBQUk3dEMsU0FBUyxRQUFiLEVBQXVCO0FBQzVCLFVBQUlvdkIsV0FBVyxFQUFmO0FBQ0EsVUFBSTc5QixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Qys1QixtQkFBVyxvRUFBb0UsbUVBQXBFLEdBQTBJLGdCQUFySjtBQUNBLFlBQUluMkIsU0FBU20xQyxlQUFiLEVBQThCO0FBQzVCaGYscUJBQVcsbUVBQW1FLDREQUE5RTtBQUNEO0FBQ0QsWUFBSTV4QixrQkFBa0J1RSxPQUF0QixFQUErQjtBQUM3QixjQUFJbE4sT0FBTzJJLGtCQUFrQnVFLE9BQWxCLENBQTBCRixPQUExQixFQUFYO0FBQ0EsY0FBSWhOLElBQUosRUFBVTtBQUNSdTZCLHdCQUFZLGtDQUFrQ3Y2QixJQUFsQyxHQUF5QyxJQUFyRDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFVBQUl3NUMsaUJBQWlCbDJDLE9BQU9jLFFBQVAsQ0FBckI7QUFDQSxjQUFTMUgsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQix1REFBakIsRUFBMEU4NEMsbUJBQW1CLGlCQUFuQixHQUF1Qyx1QkFBdUJoMEMsT0FBT29CLElBQVAsQ0FBWXhDLFFBQVosRUFBc0JtQyxJQUF0QixDQUEyQixJQUEzQixDQUF2QixHQUEwRCxHQUFqRyxHQUF1R2l6QyxjQUFqTCxFQUFpTWpmLFFBQWpNLENBQXhDLEdBQXFQajRCLGVBQWUsSUFBZixFQUFxQmszQyxtQkFBbUIsaUJBQW5CLEdBQXVDLHVCQUF1QmgwQyxPQUFPb0IsSUFBUCxDQUFZeEMsUUFBWixFQUFzQm1DLElBQXRCLENBQTJCLElBQTNCLENBQXZCLEdBQTBELEdBQWpHLEdBQXVHaXpDLGNBQTVILEVBQTRJamYsUUFBNUksQ0FBOVAsR0FBc1osS0FBSyxDQUEzWjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTzJlLFlBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxTQUFTTyxtQkFBVCxDQUE2QnIxQyxRQUE3QixFQUF1Q29OLFFBQXZDLEVBQWlEd25DLGVBQWpELEVBQWtFO0FBQ2hFLE1BQUk1MEMsWUFBWSxJQUFoQixFQUFzQjtBQUNwQixXQUFPLENBQVA7QUFDRDs7QUFFRCxTQUFPMDBDLHdCQUF3QjEwQyxRQUF4QixFQUFrQyxFQUFsQyxFQUFzQ29OLFFBQXRDLEVBQWdEd25DLGVBQWhELENBQVA7QUFDRDs7QUFFRHI4QyxPQUFPQyxPQUFQLEdBQWlCNjhDLG1CQUFqQixDOzs7Ozs7OzsrQ0M5S0E7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0EsSUFBSXA0QyxnQkFBZ0IsbUJBQUFDLENBQVEsRUFBUixDQUFwQjs7QUFFQTs7OztBQUlBLElBQUlvNEMsZ0JBQWdCO0FBQ2xCOzs7Ozs7OztBQVFBelYsVUFBUSxTQUFTQSxNQUFULENBQWdCbjlCLE1BQWhCLEVBQXdCNnlDLFNBQXhCLEVBQW1Dbm9DLFFBQW5DLEVBQTZDO0FBQ25ELFFBQUkxSyxPQUFPZSxnQkFBWCxFQUE2QjtBQUMzQmYsYUFBT2UsZ0JBQVAsQ0FBd0I4eEMsU0FBeEIsRUFBbUNub0MsUUFBbkMsRUFBNkMsS0FBN0M7QUFDQSxhQUFPO0FBQ0w0VSxnQkFBUSxTQUFTQSxNQUFULEdBQWtCO0FBQ3hCdGYsaUJBQU93dUIsbUJBQVAsQ0FBMkJxa0IsU0FBM0IsRUFBc0Nub0MsUUFBdEMsRUFBZ0QsS0FBaEQ7QUFDRDtBQUhJLE9BQVA7QUFLRCxLQVBELE1BT08sSUFBSTFLLE9BQU9nQixXQUFYLEVBQXdCO0FBQzdCaEIsYUFBT2dCLFdBQVAsQ0FBbUIsT0FBTzZ4QyxTQUExQixFQUFxQ25vQyxRQUFyQztBQUNBLGFBQU87QUFDTDRVLGdCQUFRLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEJ0ZixpQkFBTzh5QyxXQUFQLENBQW1CLE9BQU9ELFNBQTFCLEVBQXFDbm9DLFFBQXJDO0FBQ0Q7QUFISSxPQUFQO0FBS0Q7QUFDRixHQXpCaUI7O0FBMkJsQjs7Ozs7Ozs7QUFRQW9rQixXQUFTLFNBQVNBLE9BQVQsQ0FBaUI5dUIsTUFBakIsRUFBeUI2eUMsU0FBekIsRUFBb0Nub0MsUUFBcEMsRUFBOEM7QUFDckQsUUFBSTFLLE9BQU9lLGdCQUFYLEVBQTZCO0FBQzNCZixhQUFPZSxnQkFBUCxDQUF3Qjh4QyxTQUF4QixFQUFtQ25vQyxRQUFuQyxFQUE2QyxJQUE3QztBQUNBLGFBQU87QUFDTDRVLGdCQUFRLFNBQVNBLE1BQVQsR0FBa0I7QUFDeEJ0ZixpQkFBT3d1QixtQkFBUCxDQUEyQnFrQixTQUEzQixFQUFzQ25vQyxRQUF0QyxFQUFnRCxJQUFoRDtBQUNEO0FBSEksT0FBUDtBQUtELEtBUEQsTUFPTztBQUNMLFVBQUk5VSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q29CLGdCQUFRWCxLQUFSLENBQWMsaUVBQWlFLG9FQUFqRSxHQUF3SSwrQkFBdEo7QUFDRDtBQUNELGFBQU87QUFDTG1sQixnQkFBUS9rQjtBQURILE9BQVA7QUFHRDtBQUNGLEdBbkRpQjs7QUFxRGxCdzRDLG1CQUFpQixTQUFTQSxlQUFULEdBQTJCLENBQUU7QUFyRDVCLENBQXBCOztBQXdEQWw5QyxPQUFPQyxPQUFQLEdBQWlCODhDLGFBQWpCLEM7Ozs7Ozs7O0FDM0VBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSUksb0JBQW9CLG1CQUFBeDRDLENBQVEsR0FBUixDQUF4Qjs7QUFFQSxJQUFJeTRDLGVBQWUsbUJBQUF6NEMsQ0FBUSxHQUFSLENBQW5CO0FBQ0EsSUFBSXd0QyxZQUFZLG1CQUFBeHRDLENBQVEsRUFBUixDQUFoQjtBQUNBLElBQUkwNEMsbUJBQW1CLG1CQUFBMTRDLENBQVEsRUFBUixDQUF2Qjs7QUFFQSxTQUFTMjRDLFlBQVQsQ0FBc0IvMkMsSUFBdEIsRUFBNEI7QUFDMUIsU0FBTzYyQyxhQUFheHlDLFNBQVM4a0MsZUFBdEIsRUFBdUNucEMsSUFBdkMsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxJQUFJZzNDLHNCQUFzQjtBQUN4QkMsNEJBQTBCLGtDQUFVdE4sSUFBVixFQUFnQjtBQUN4QyxRQUFJcnNCLFdBQVdxc0IsUUFBUUEsS0FBS3JzQixRQUFiLElBQXlCcXNCLEtBQUtyc0IsUUFBTCxDQUFjeEksV0FBZCxFQUF4QztBQUNBLFdBQU93SSxhQUFhQSxhQUFhLE9BQWIsSUFBd0Jxc0IsS0FBSzFoQyxJQUFMLEtBQWMsTUFBdEMsSUFBZ0RxVixhQUFhLFVBQTdELElBQTJFcXNCLEtBQUt1TixlQUFMLEtBQXlCLE1BQWpILENBQVA7QUFDRCxHQUp1Qjs7QUFNeEJDLDJCQUF5QixtQ0FBWTtBQUNuQyxRQUFJQyxjQUFjTixrQkFBbEI7QUFDQSxXQUFPO0FBQ0xNLG1CQUFhQSxXQURSO0FBRUxDLHNCQUFnQkwsb0JBQW9CQyx3QkFBcEIsQ0FBNkNHLFdBQTdDLElBQTRESixvQkFBb0JNLFlBQXBCLENBQWlDRixXQUFqQyxDQUE1RCxHQUE0RztBQUZ2SCxLQUFQO0FBSUQsR0FadUI7O0FBY3hCOzs7OztBQUtBRyxvQkFBa0IsMEJBQVVDLHlCQUFWLEVBQXFDO0FBQ3JELFFBQUlDLGlCQUFpQlgsa0JBQXJCO0FBQ0EsUUFBSVksbUJBQW1CRiwwQkFBMEJKLFdBQWpEO0FBQ0EsUUFBSU8sc0JBQXNCSCwwQkFBMEJILGNBQXBEO0FBQ0EsUUFBSUksbUJBQW1CQyxnQkFBbkIsSUFBdUNYLGFBQWFXLGdCQUFiLENBQTNDLEVBQTJFO0FBQ3pFLFVBQUlWLG9CQUFvQkMsd0JBQXBCLENBQTZDUyxnQkFBN0MsQ0FBSixFQUFvRTtBQUNsRVYsNEJBQW9CWSxZQUFwQixDQUFpQ0YsZ0JBQWpDLEVBQW1EQyxtQkFBbkQ7QUFDRDtBQUNEL0wsZ0JBQVU4TCxnQkFBVjtBQUNEO0FBQ0YsR0E3QnVCOztBQStCeEI7Ozs7OztBQU1BSixnQkFBYyxzQkFBVU8sS0FBVixFQUFpQjtBQUM3QixRQUFJQyxTQUFKOztBQUVBLFFBQUksb0JBQW9CRCxLQUF4QixFQUErQjtBQUM3QjtBQUNBQyxrQkFBWTtBQUNWQyxlQUFPRixNQUFNRyxjQURIO0FBRVZqVyxhQUFLOFYsTUFBTUk7QUFGRCxPQUFaO0FBSUQsS0FORCxNQU1PLElBQUk1ekMsU0FBU3l6QyxTQUFULElBQXNCRCxNQUFNdjZCLFFBQTVCLElBQXdDdTZCLE1BQU12NkIsUUFBTixDQUFleEksV0FBZixPQUFpQyxPQUE3RSxFQUFzRjtBQUMzRjtBQUNBLFVBQUl1MkIsUUFBUWhuQyxTQUFTeXpDLFNBQVQsQ0FBbUJJLFdBQW5CLEVBQVo7QUFDQTtBQUNBO0FBQ0EsVUFBSTdNLE1BQU04TSxhQUFOLE9BQTBCTixLQUE5QixFQUFxQztBQUNuQ0Msb0JBQVk7QUFDVkMsaUJBQU8sQ0FBQzFNLE1BQU0rTSxTQUFOLENBQWdCLFdBQWhCLEVBQTZCLENBQUNQLE1BQU1obEMsS0FBTixDQUFZaFksTUFBMUMsQ0FERTtBQUVWa25DLGVBQUssQ0FBQ3NKLE1BQU1nTixPQUFOLENBQWMsV0FBZCxFQUEyQixDQUFDUixNQUFNaGxDLEtBQU4sQ0FBWWhZLE1BQXhDO0FBRkksU0FBWjtBQUlEO0FBQ0YsS0FYTSxNQVdBO0FBQ0w7QUFDQWk5QyxrQkFBWWxCLGtCQUFrQjBCLFVBQWxCLENBQTZCVCxLQUE3QixDQUFaO0FBQ0Q7O0FBRUQsV0FBT0MsYUFBYSxFQUFFQyxPQUFPLENBQVQsRUFBWWhXLEtBQUssQ0FBakIsRUFBcEI7QUFDRCxHQS9EdUI7O0FBaUV4Qjs7Ozs7O0FBTUE2VixnQkFBYyxzQkFBVUMsS0FBVixFQUFpQlUsT0FBakIsRUFBMEI7QUFDdEMsUUFBSVIsUUFBUVEsUUFBUVIsS0FBcEI7QUFDQSxRQUFJaFcsTUFBTXdXLFFBQVF4VyxHQUFsQjtBQUNBLFFBQUlBLFFBQVF4a0MsU0FBWixFQUF1QjtBQUNyQndrQyxZQUFNZ1csS0FBTjtBQUNEOztBQUVELFFBQUksb0JBQW9CRixLQUF4QixFQUErQjtBQUM3QkEsWUFBTUcsY0FBTixHQUF1QkQsS0FBdkI7QUFDQUYsWUFBTUksWUFBTixHQUFxQnQ0QyxLQUFLbTlCLEdBQUwsQ0FBU2lGLEdBQVQsRUFBYzhWLE1BQU1obEMsS0FBTixDQUFZaFksTUFBMUIsQ0FBckI7QUFDRCxLQUhELE1BR08sSUFBSXdKLFNBQVN5ekMsU0FBVCxJQUFzQkQsTUFBTXY2QixRQUE1QixJQUF3Q3U2QixNQUFNdjZCLFFBQU4sQ0FBZXhJLFdBQWYsT0FBaUMsT0FBN0UsRUFBc0Y7QUFDM0YsVUFBSXUyQixRQUFRd00sTUFBTVcsZUFBTixFQUFaO0FBQ0FuTixZQUFNb04sUUFBTixDQUFlLElBQWY7QUFDQXBOLFlBQU0rTSxTQUFOLENBQWdCLFdBQWhCLEVBQTZCTCxLQUE3QjtBQUNBMU0sWUFBTWdOLE9BQU4sQ0FBYyxXQUFkLEVBQTJCdFcsTUFBTWdXLEtBQWpDO0FBQ0ExTSxZQUFNcU4sTUFBTjtBQUNELEtBTk0sTUFNQTtBQUNMOUIsd0JBQWtCK0IsVUFBbEIsQ0FBNkJkLEtBQTdCLEVBQW9DVSxPQUFwQztBQUNEO0FBQ0Y7QUExRnVCLENBQTFCOztBQTZGQTkrQyxPQUFPQyxPQUFQLEdBQWlCczlDLG1CQUFqQixDOzs7Ozs7O0FDekhBOztBQUVBOzs7Ozs7Ozs7OztBQVdBOztBQUVBOzs7Ozs7Ozs7OztBQVVBLFNBQVNGLGdCQUFULENBQTBCcDBCLEdBQTFCLEVBQStCLGVBQWU7QUFDNUNBLFFBQU1BLFFBQVEsT0FBT3JlLFFBQVAsS0FBb0IsV0FBcEIsR0FBa0NBLFFBQWxDLEdBQTZDOUcsU0FBckQsQ0FBTjtBQUNBLE1BQUksT0FBT21sQixHQUFQLEtBQWUsV0FBbkIsRUFBZ0M7QUFDOUIsV0FBTyxJQUFQO0FBQ0Q7QUFDRCxNQUFJO0FBQ0YsV0FBT0EsSUFBSWsyQixhQUFKLElBQXFCbDJCLElBQUltMkIsSUFBaEM7QUFDRCxHQUZELENBRUUsT0FBTzUrQyxDQUFQLEVBQVU7QUFDVixXQUFPeW9CLElBQUltMkIsSUFBWDtBQUNEO0FBQ0Y7O0FBRURwL0MsT0FBT0MsT0FBUCxHQUFpQm85QyxnQkFBakIsQzs7Ozs7OztBQ3JDQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUkxM0MsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCOztBQUVBLElBQUkrZixjQUFjLG1CQUFBL2YsQ0FBUSxFQUFSLENBQWxCO0FBQ0EsSUFBSWlCLGNBQWMsbUJBQUFqQixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJa2MsUUFBUSxtQkFBQWxjLENBQVEsRUFBUixDQUFaO0FBQ0EsSUFBSWl3QiwyQkFBMkIsbUJBQUFqd0IsQ0FBUSxFQUFSLENBQS9CO0FBQ0EsSUFBSXFILG9CQUFvQixtQkFBQXJILENBQVEsRUFBUixDQUF4QjtBQUNBLElBQUlnRSx3QkFBd0IsbUJBQUFoRSxDQUFRLENBQVIsQ0FBNUI7QUFDQSxJQUFJMDZDLHdCQUF3QixtQkFBQTE2QyxDQUFRLEdBQVIsQ0FBNUI7QUFDQSxJQUFJMjZDLHVCQUF1QixtQkFBQTM2QyxDQUFRLEdBQVIsQ0FBM0I7QUFDQSxJQUFJZ08sb0JBQW9CLG1CQUFBaE8sQ0FBUSxFQUFSLENBQXhCO0FBQ0EsSUFBSTZrQixtQkFBbUIsbUJBQUE3a0IsQ0FBUSxFQUFSLENBQXZCO0FBQ0EsSUFBSStjLHVCQUF1QixtQkFBQS9jLENBQVEsRUFBUixDQUEzQjtBQUNBLElBQUk0NkMsc0JBQXNCLG1CQUFBNTZDLENBQVEsR0FBUixDQUExQjtBQUNBLElBQUlpTyxrQkFBa0IsbUJBQUFqTyxDQUFRLEVBQVIsQ0FBdEI7QUFDQSxJQUFJcTdCLG1CQUFtQixtQkFBQXI3QixDQUFRLEVBQVIsQ0FBdkI7QUFDQSxJQUFJME8sZUFBZSxtQkFBQTFPLENBQVEsRUFBUixDQUFuQjs7QUFFQSxJQUFJa21CLGNBQWMsbUJBQUFsbUIsQ0FBUSxFQUFSLENBQWxCO0FBQ0EsSUFBSTQxQyw0QkFBNEIsbUJBQUE1MUMsQ0FBUSxFQUFSLENBQWhDO0FBQ0EsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCO0FBQ0EsSUFBSW9lLGVBQWUsbUJBQUFwZSxDQUFRLEVBQVIsQ0FBbkI7QUFDQSxJQUFJbTZCLDZCQUE2QixtQkFBQW42QixDQUFRLEVBQVIsQ0FBakM7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJbUIsWUFBWUYsWUFBWUcsaUJBQTVCO0FBQ0EsSUFBSXk1QyxpQkFBaUI1NUMsWUFBWXVXLG1CQUFqQzs7QUFFQSxJQUFJK0csb0JBQW9CLENBQXhCO0FBQ0EsSUFBSXU4QixnQkFBZ0IsQ0FBcEI7QUFDQSxJQUFJdDhCLDhCQUE4QixFQUFsQzs7QUFFQSxJQUFJdThCLHlCQUF5QixFQUE3Qjs7QUFFQTs7Ozs7O0FBTUEsU0FBU0Msb0JBQVQsQ0FBOEJDLE9BQTlCLEVBQXVDQyxPQUF2QyxFQUFnRDtBQUM5QyxNQUFJQyxTQUFTNTVDLEtBQUttOUIsR0FBTCxDQUFTdWMsUUFBUXgrQyxNQUFqQixFQUF5QnkrQyxRQUFReitDLE1BQWpDLENBQWI7QUFDQSxPQUFLLElBQUlVLElBQUksQ0FBYixFQUFnQkEsSUFBSWcrQyxNQUFwQixFQUE0QmgrQyxHQUE1QixFQUFpQztBQUMvQixRQUFJODlDLFFBQVE3MUIsTUFBUixDQUFlam9CLENBQWYsTUFBc0IrOUMsUUFBUTkxQixNQUFSLENBQWVqb0IsQ0FBZixDQUExQixFQUE2QztBQUMzQyxhQUFPQSxDQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU84OUMsUUFBUXgrQyxNQUFSLEtBQW1CeStDLFFBQVF6K0MsTUFBM0IsR0FBb0MsQ0FBQyxDQUFyQyxHQUF5QzArQyxNQUFoRDtBQUNEOztBQUVEOzs7OztBQUtBLFNBQVNDLDhCQUFULENBQXdDQyxTQUF4QyxFQUFtRDtBQUNqRCxNQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFDZCxXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFJQSxVQUFVdjVDLFFBQVYsS0FBdUJnNUMsYUFBM0IsRUFBMEM7QUFDeEMsV0FBT08sVUFBVXRRLGVBQWpCO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT3NRLFVBQVVwNEMsVUFBakI7QUFDRDtBQUNGOztBQUVELFNBQVNxNEMsYUFBVCxDQUF1QjE1QyxJQUF2QixFQUE2QjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxTQUFPQSxLQUFLRyxZQUFMLElBQXFCSCxLQUFLRyxZQUFMLENBQWtCWixTQUFsQixDQUFyQixJQUFxRCxFQUE1RDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNvNkMsc0JBQVQsQ0FBZ0NDLGVBQWhDLEVBQWlESCxTQUFqRCxFQUE0RDdxQyxXQUE1RCxFQUF5RWlyQyxpQkFBekUsRUFBNEY5cEMsT0FBNUYsRUFBcUc7QUFDbkcsTUFBSWYsVUFBSjtBQUNBLE1BQUk1QyxrQkFBa0I2QyxrQkFBdEIsRUFBMEM7QUFDeEMsUUFBSTZxQyxpQkFBaUJGLGdCQUFnQnpxQyxlQUFoQixDQUFnQzJILEtBQWhDLENBQXNDZ3VCLEtBQTNEO0FBQ0EsUUFBSTc4QixPQUFPNnhDLGVBQWU3eEMsSUFBMUI7QUFDQStHLGlCQUFhLG1CQUFtQixPQUFPL0csSUFBUCxLQUFnQixRQUFoQixHQUEyQkEsSUFBM0IsR0FBa0NBLEtBQUtDLFdBQUwsSUFBb0JELEtBQUtuTCxJQUE5RSxDQUFiO0FBQ0E0QixZQUFRMlEsSUFBUixDQUFhTCxVQUFiO0FBQ0Q7O0FBRUQsTUFBSTBNLFNBQVNyUCxnQkFBZ0JnUCxjQUFoQixDQUErQnUrQixlQUEvQixFQUFnRGhyQyxXQUFoRCxFQUE2RCxJQUE3RCxFQUFtRWtxQyxzQkFBc0JjLGVBQXRCLEVBQXVDSCxTQUF2QyxDQUFuRSxFQUFzSDFwQyxPQUF0SCxFQUErSCxDQUEvSCxDQUFpSTtBQUFqSSxHQUFiOztBQUdBLE1BQUlmLFVBQUosRUFBZ0I7QUFDZHRRLFlBQVE2USxPQUFSLENBQWdCUCxVQUFoQjtBQUNEOztBQUVENHFDLGtCQUFnQm41QyxrQkFBaEIsQ0FBbUNzNUMsZ0JBQW5DLEdBQXNESCxlQUF0RDtBQUNBSSxhQUFXQyxtQkFBWCxDQUErQnYrQixNQUEvQixFQUF1Qys5QixTQUF2QyxFQUFrREcsZUFBbEQsRUFBbUVDLGlCQUFuRSxFQUFzRmpyQyxXQUF0RjtBQUNEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU3NyQyw2QkFBVCxDQUF1Q0MsaUJBQXZDLEVBQTBEVixTQUExRCxFQUFxRUksaUJBQXJFLEVBQXdGOXBDLE9BQXhGLEVBQWlHO0FBQy9GLE1BQUluQixjQUFjOUIsYUFBYUMseUJBQWIsQ0FBdUNMLFNBQXZDO0FBQ2xCO0FBQ0EsR0FBQ210QyxpQkFBRCxJQUFzQmQscUJBQXFCcUIsZ0JBRnpCLENBQWxCO0FBR0F4ckMsY0FBWVgsT0FBWixDQUFvQjByQyxzQkFBcEIsRUFBNEMsSUFBNUMsRUFBa0RRLGlCQUFsRCxFQUFxRVYsU0FBckUsRUFBZ0Y3cUMsV0FBaEYsRUFBNkZpckMsaUJBQTdGLEVBQWdIOXBDLE9BQWhIO0FBQ0FqRCxlQUFhQyx5QkFBYixDQUF1Q2lCLE9BQXZDLENBQStDWSxXQUEvQztBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTeXJDLHdCQUFULENBQWtDNWhDLFFBQWxDLEVBQTRDZ2hDLFNBQTVDLEVBQXVEMzlCLE1BQXZELEVBQStEO0FBQzdELE1BQUl0aUIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM2ZCx5QkFBcUIzUCxTQUFyQixDQUErQjh1QyxZQUEvQjtBQUNEO0FBQ0RqdUMsa0JBQWdCd1AsZ0JBQWhCLENBQWlDcEQsUUFBakMsRUFBMkNxRCxNQUEzQztBQUNBLE1BQUl0aUIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM2ZCx5QkFBcUIzUCxTQUFyQixDQUErQit1QyxVQUEvQjtBQUNEOztBQUVELE1BQUlkLFVBQVV2NUMsUUFBVixLQUF1Qmc1QyxhQUEzQixFQUEwQztBQUN4Q08sZ0JBQVlBLFVBQVV0USxlQUF0QjtBQUNEOztBQUVEO0FBQ0EsU0FBT3NRLFVBQVUvTixTQUFqQixFQUE0QjtBQUMxQitOLGNBQVU3d0IsV0FBVixDQUFzQjZ3QixVQUFVL04sU0FBaEM7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7O0FBVUEsU0FBUzhPLG9CQUFULENBQThCZixTQUE5QixFQUF5QztBQUN2QyxNQUFJZ0IsU0FBU2pCLCtCQUErQkMsU0FBL0IsQ0FBYjtBQUNBLE1BQUlnQixNQUFKLEVBQVk7QUFDVixRQUFJOTVDLE9BQU95QixzQkFBc0JILG1CQUF0QixDQUEwQ3c0QyxNQUExQyxDQUFYO0FBQ0EsV0FBTyxDQUFDLEVBQUU5NUMsUUFBUUEsS0FBS3dCLFdBQWYsQ0FBUjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU3U0Qyw2QkFBVCxDQUF1Q2pCLFNBQXZDLEVBQWtEO0FBQ2hELE1BQUlnQixTQUFTakIsK0JBQStCQyxTQUEvQixDQUFiO0FBQ0EsU0FBTyxDQUFDLEVBQUVnQixVQUFVRSxZQUFZRixNQUFaLENBQVYsSUFBaUMsQ0FBQ3I0QyxzQkFBc0JILG1CQUF0QixDQUEwQ3c0QyxNQUExQyxDQUFwQyxDQUFSO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTRyxnQkFBVCxDQUEwQjU2QyxJQUExQixFQUFnQztBQUM5QixTQUFPLENBQUMsRUFBRUEsU0FBU0EsS0FBS0UsUUFBTCxLQUFrQnljLGlCQUFsQixJQUF1QzNjLEtBQUtFLFFBQUwsS0FBa0JnNUMsYUFBekQsSUFBMEVsNUMsS0FBS0UsUUFBTCxLQUFrQjBjLDJCQUFyRyxDQUFGLENBQVI7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVMrOUIsV0FBVCxDQUFxQjM2QyxJQUFyQixFQUEyQjtBQUN6QixTQUFPNDZDLGlCQUFpQjU2QyxJQUFqQixNQUEyQkEsS0FBSzY2QyxZQUFMLENBQWtCNUIsY0FBbEIsS0FBcUNqNUMsS0FBSzY2QyxZQUFMLENBQWtCdDdDLFNBQWxCLENBQWhFLENBQVA7QUFDRDs7QUFFRCxTQUFTdTdDLDhCQUFULENBQXdDckIsU0FBeEMsRUFBbUQ7QUFDakQsTUFBSWdCLFNBQVNqQiwrQkFBK0JDLFNBQS9CLENBQWI7QUFDQSxNQUFJc0IsbUJBQW1CTixVQUFVcjRDLHNCQUFzQkgsbUJBQXRCLENBQTBDdzRDLE1BQTFDLENBQWpDO0FBQ0EsU0FBT00sb0JBQW9CLENBQUNBLGlCQUFpQjU0QyxXQUF0QyxHQUFvRDQ0QyxnQkFBcEQsR0FBdUUsSUFBOUU7QUFDRDs7QUFFRCxTQUFTQyw2QkFBVCxDQUF1Q3ZCLFNBQXZDLEVBQWtEO0FBQ2hELE1BQUl3QixPQUFPSCwrQkFBK0JyQixTQUEvQixDQUFYO0FBQ0EsU0FBT3dCLE9BQU9BLEtBQUtDLGtCQUFMLENBQXdCbkIsZ0JBQS9CLEdBQWtELElBQXpEO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsSUFBSW9CLHNCQUFzQixDQUExQjtBQUNBLElBQUlDLGtCQUFrQixTQUFsQkEsZUFBa0IsR0FBWTtBQUNoQyxPQUFLQyxNQUFMLEdBQWNGLHFCQUFkO0FBQ0QsQ0FGRDtBQUdBQyxnQkFBZ0J6L0MsU0FBaEIsQ0FBMEJzbkMsZ0JBQTFCLEdBQTZDLEVBQTdDO0FBQ0EsSUFBSXpwQyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Qzg5QyxrQkFBZ0JsekMsV0FBaEIsR0FBOEIsaUJBQTlCO0FBQ0Q7QUFDRGt6QyxnQkFBZ0J6L0MsU0FBaEIsQ0FBMEJ5bEMsTUFBMUIsR0FBbUMsWUFBWTtBQUM3QyxTQUFPLEtBQUt0cUIsS0FBTCxDQUFXZ3VCLEtBQWxCO0FBQ0QsQ0FGRDtBQUdBc1csZ0JBQWdCaHNDLHNCQUFoQixHQUF5QyxJQUF6Qzs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBLElBQUk0cUMsYUFBYTtBQUNmb0IsbUJBQWlCQSxlQURGOztBQUdmOzs7QUFHQUUsMkJBQXlCbkMsc0JBTlY7O0FBUWY7Ozs7Ozs7O0FBUUFvQyxpQkFBZSx1QkFBVTlCLFNBQVYsRUFBcUIrQixjQUFyQixFQUFxQztBQUNsREE7QUFDRCxHQWxCYzs7QUFvQmY7Ozs7Ozs7QUFPQUMsd0JBQXNCLDhCQUFVQyxhQUFWLEVBQXlCeC9CLFdBQXpCLEVBQXNDc2UsV0FBdEMsRUFBbURpZixTQUFuRCxFQUE4RG5yQyxRQUE5RCxFQUF3RTtBQUM1RjByQyxlQUFXdUIsYUFBWCxDQUF5QjlCLFNBQXpCLEVBQW9DLFlBQVk7QUFDOUNoZ0IsdUJBQWlCYyxzQkFBakIsQ0FBd0NtaEIsYUFBeEMsRUFBdUR4L0IsV0FBdkQsRUFBb0VzZSxXQUFwRTtBQUNBLFVBQUlsc0IsUUFBSixFQUFjO0FBQ1ptckIseUJBQWlCSSx1QkFBakIsQ0FBeUM2aEIsYUFBekMsRUFBd0RwdEMsUUFBeEQ7QUFDRDtBQUNGLEtBTEQ7O0FBT0EsV0FBT290QyxhQUFQO0FBQ0QsR0FwQ2M7O0FBc0NmOzs7Ozs7OztBQVFBQywyQkFBeUIsaUNBQVV6L0IsV0FBVixFQUF1QnU5QixTQUF2QixFQUFrQ0ksaUJBQWxDLEVBQXFEOXBDLE9BQXJELEVBQThEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBdlcsWUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVFvSCxrQkFBa0J1RSxPQUFsQixJQUE2QixJQUFyQyxFQUEyQyx5RUFBeUUsK0RBQXpFLEdBQTJJLGlFQUEzSSxHQUErTSxvREFBMVAsRUFBZ1R2RSxrQkFBa0J1RSxPQUFsQixJQUE2QnZFLGtCQUFrQnVFLE9BQWxCLENBQTBCRixPQUExQixFQUE3QixJQUFvRSx5QkFBcFgsQ0FBeEMsR0FBeWIsS0FBSyxDQUE5Yjs7QUFFQSxLQUFDOHdDLGlCQUFpQm5CLFNBQWpCLENBQUQsR0FBK0JqZ0QsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixpRUFBakIsQ0FBeEMsR0FBOEg0QixlQUFlLElBQWYsQ0FBN0osR0FBb0wsS0FBSyxDQUF6TDs7QUFFQWl2Qiw2QkFBeUJvQiwyQkFBekI7QUFDQSxRQUFJMHFCLG9CQUFvQm5HLDBCQUEwQjkzQixXQUExQixFQUF1QyxLQUF2QyxDQUF4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUFwUCxpQkFBYXVCLGNBQWIsQ0FBNEI2ckMsNkJBQTVCLEVBQTJEQyxpQkFBM0QsRUFBOEVWLFNBQTlFLEVBQXlGSSxpQkFBekYsRUFBNEc5cEMsT0FBNUc7O0FBRUEsUUFBSTZyQyxZQUFZekIsa0JBQWtCMEIsU0FBbEIsQ0FBNEJSLE1BQTVDO0FBQ0FsQywyQkFBdUJ5QyxTQUF2QixJQUFvQ3pCLGlCQUFwQzs7QUFFQSxXQUFPQSxpQkFBUDtBQUNELEdBbkVjOztBQXFFZjs7Ozs7Ozs7Ozs7OztBQWFBMkIsOEJBQTRCLG9DQUFVQyxlQUFWLEVBQTJCNy9CLFdBQTNCLEVBQXdDdTlCLFNBQXhDLEVBQW1EbnJDLFFBQW5ELEVBQTZEO0FBQ3ZGLE1BQUV5dEMsbUJBQW1CLElBQW5CLElBQTJCOTRCLGlCQUFpQkcsR0FBakIsQ0FBcUIyNEIsZUFBckIsQ0FBN0IsSUFBc0V2aUQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixpREFBakIsQ0FBeEMsR0FBOEc0QixlQUFlLElBQWYsQ0FBcEwsR0FBMk0sS0FBSyxDQUFoTjtBQUNBLFdBQU80NkMsV0FBV2dDLDJCQUFYLENBQXVDRCxlQUF2QyxFQUF3RDcvQixXQUF4RCxFQUFxRXU5QixTQUFyRSxFQUFnRm5yQyxRQUFoRixDQUFQO0FBQ0QsR0FyRmM7O0FBdUZmMHRDLCtCQUE2QixxQ0FBVUQsZUFBVixFQUEyQjcvQixXQUEzQixFQUF3Q3U5QixTQUF4QyxFQUFtRG5yQyxRQUFuRCxFQUE2RDtBQUN4Rm1yQixxQkFBaUJHLGdCQUFqQixDQUFrQ3RyQixRQUFsQyxFQUE0QyxpQkFBNUM7QUFDQSxLQUFDZ00sTUFBTXpPLGNBQU4sQ0FBcUJxUSxXQUFyQixDQUFELEdBQXFDMWlCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsaURBQWpCLEVBQW9FLE9BQU8wZSxXQUFQLEtBQXVCLFFBQXZCLEdBQWtDLG1EQUFtRCx3Q0FBckYsR0FBZ0ksT0FBT0EsV0FBUCxLQUF1QixVQUF2QixHQUFvQyxnREFBZ0Qsc0NBQXBGLEdBQTZIO0FBQzlZQSxtQkFBZSxJQUFmLElBQXVCQSxZQUFZcEYsS0FBWixLQUFzQnZaLFNBQTdDLEdBQXlELG9FQUFvRSxrQkFBN0gsR0FBa0osRUFEckUsQ0FBeEMsR0FDbUg2QixlQUFlLElBQWYsRUFBcUIsT0FBTzhjLFdBQVAsS0FBdUIsUUFBdkIsR0FBa0MsbURBQW1ELHdDQUFyRixHQUFnSSxPQUFPQSxXQUFQLEtBQXVCLFVBQXZCLEdBQW9DLGdEQUFnRCxzQ0FBcEYsR0FBNkhBLGVBQWUsSUFBZixJQUF1QkEsWUFBWXBGLEtBQVosS0FBc0J2WixTQUE3QyxHQUF5RCxvRUFBb0Usa0JBQTdILEdBQWtKLEVBQXBhLENBRHhKLEdBQ2trQixLQUFLLENBRHZrQjs7QUFHQS9ELFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLENBQUNvN0MsU0FBRCxJQUFjLENBQUNBLFVBQVVyaUIsT0FBekIsSUFBb0NxaUIsVUFBVXJpQixPQUFWLENBQWtCb1gsV0FBbEIsT0FBb0MsTUFBaEYsRUFBd0YsbUVBQW1FLHVFQUFuRSxHQUE2SSwwREFBN0ksR0FBME0sd0VBQTFNLEdBQXFSLGVBQTdXLENBQXhDLEdBQXdhLEtBQUssQ0FBN2E7O0FBRUEsUUFBSXlOLHFCQUFxQjNoQyxNQUFNaFcsYUFBTixDQUFvQjgyQyxlQUFwQixFQUFxQztBQUM1RHRXLGFBQU81b0I7QUFEcUQsS0FBckMsQ0FBekI7O0FBSUEsUUFBSXNlLFdBQUo7QUFDQSxRQUFJdWhCLGVBQUosRUFBcUI7QUFDbkIsVUFBSTE4QixhQUFhNEQsaUJBQWlCamMsR0FBakIsQ0FBcUIrMEMsZUFBckIsQ0FBakI7QUFDQXZoQixvQkFBY25iLFdBQVc2OEIsb0JBQVgsQ0FBZ0M3OEIsV0FBV2pELFFBQTNDLENBQWQ7QUFDRCxLQUhELE1BR087QUFDTG9lLG9CQUFjbFcsV0FBZDtBQUNEOztBQUVELFFBQUlvM0IsZ0JBQWdCViw4QkFBOEJ2QixTQUE5QixDQUFwQjs7QUFFQSxRQUFJaUMsYUFBSixFQUFtQjtBQUNqQixVQUFJUyxxQkFBcUJULGNBQWN2c0MsZUFBdkM7QUFDQSxVQUFJZ04sY0FBY2dnQyxtQkFBbUJybEMsS0FBbkIsQ0FBeUJndUIsS0FBM0M7QUFDQSxVQUFJdk0sMkJBQTJCcGMsV0FBM0IsRUFBd0NELFdBQXhDLENBQUosRUFBMEQ7QUFDeEQsWUFBSWtnQyxhQUFhVixjQUFjajdDLGtCQUFkLENBQWlDaVAsaUJBQWpDLEVBQWpCO0FBQ0EsWUFBSTJzQyxrQkFBa0IvdEMsWUFBWSxZQUFZO0FBQzVDQSxtQkFBU2pVLElBQVQsQ0FBYytoRCxVQUFkO0FBQ0QsU0FGRDtBQUdBcEMsbUJBQVd5QixvQkFBWCxDQUFnQ0MsYUFBaEMsRUFBK0NPLGtCQUEvQyxFQUFtRXpoQixXQUFuRSxFQUFnRmlmLFNBQWhGLEVBQTJGNEMsZUFBM0Y7QUFDQSxlQUFPRCxVQUFQO0FBQ0QsT0FQRCxNQU9PO0FBQ0xwQyxtQkFBV3NDLHNCQUFYLENBQWtDN0MsU0FBbEM7QUFDRDtBQUNGOztBQUVELFFBQUk4QyxtQkFBbUIvQywrQkFBK0JDLFNBQS9CLENBQXZCO0FBQ0EsUUFBSStDLDBCQUEwQkQsb0JBQW9CLENBQUMsQ0FBQzdDLGNBQWM2QyxnQkFBZCxDQUFwRDtBQUNBLFFBQUlFLGdDQUFnQ2pDLHFCQUFxQmYsU0FBckIsQ0FBcEM7O0FBRUEsUUFBSWpnRCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzlELGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLENBQUNvK0MsNkJBQVQsRUFBd0Msb0VBQW9FLGtFQUFwRSxHQUF5SSxtRUFBekksR0FBK00sbUVBQXZQLENBQXhDLEdBQXNXLEtBQUssQ0FBM1c7O0FBRUEsVUFBSSxDQUFDRCx1QkFBRCxJQUE0QkQsaUJBQWlCNTZDLFdBQWpELEVBQThEO0FBQzVELFlBQUkrNkMscUJBQXFCSCxnQkFBekI7QUFDQSxlQUFPRyxrQkFBUCxFQUEyQjtBQUN6QixjQUFJaEQsY0FBY2dELGtCQUFkLENBQUosRUFBdUM7QUFDckNsakQsb0JBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxtRUFBbUUsK0RBQW5FLEdBQXFJLHFEQUFwSixDQUF4QyxHQUFxUCxLQUFLLENBQTFQO0FBQ0E7QUFDRDtBQUNEcStDLCtCQUFxQkEsbUJBQW1CLzZDLFdBQXhDO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFFBQUlrNEMsb0JBQW9CMkMsMkJBQTJCLENBQUNkLGFBQTVCLElBQTZDLENBQUNlLDZCQUF0RTtBQUNBLFFBQUlsOEMsWUFBWXk1QyxXQUFXMkIsdUJBQVgsQ0FBbUNNLGtCQUFuQyxFQUF1RHhDLFNBQXZELEVBQWtFSSxpQkFBbEUsRUFBcUZyZixXQUFyRixFQUFrRy81QixrQkFBbEcsQ0FBcUhpUCxpQkFBckgsRUFBaEI7QUFDQSxRQUFJcEIsUUFBSixFQUFjO0FBQ1pBLGVBQVNqVSxJQUFULENBQWNrRyxTQUFkO0FBQ0Q7QUFDRCxXQUFPQSxTQUFQO0FBQ0QsR0FwSmM7O0FBc0pmOzs7Ozs7Ozs7Ozs7O0FBYUE2Z0MsVUFBUSxnQkFBVWxsQixXQUFWLEVBQXVCdTlCLFNBQXZCLEVBQWtDbnJDLFFBQWxDLEVBQTRDO0FBQ2xELFdBQU8wckMsV0FBV2dDLDJCQUFYLENBQXVDLElBQXZDLEVBQTZDOS9CLFdBQTdDLEVBQTBEdTlCLFNBQTFELEVBQXFFbnJDLFFBQXJFLENBQVA7QUFDRCxHQXJLYzs7QUF1S2Y7Ozs7Ozs7O0FBUUFndUMsMEJBQXdCLGdDQUFVN0MsU0FBVixFQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBamdELFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRb0gsa0JBQWtCdUUsT0FBbEIsSUFBNkIsSUFBckMsRUFBMkMsd0VBQXdFLHNFQUF4RSxHQUFpSiwwREFBakosR0FBOE0sb0RBQXpQLEVBQStTdkUsa0JBQWtCdUUsT0FBbEIsSUFBNkJ2RSxrQkFBa0J1RSxPQUFsQixDQUEwQkYsT0FBMUIsRUFBN0IsSUFBb0UseUJBQW5YLENBQXhDLEdBQXdiLEtBQUssQ0FBN2I7O0FBRUEsS0FBQzh3QyxpQkFBaUJuQixTQUFqQixDQUFELEdBQStCamdELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIscUVBQWpCLENBQXhDLEdBQWtJNEIsZUFBZSxJQUFmLENBQWpLLEdBQXdMLEtBQUssQ0FBN0w7O0FBRUEsUUFBSTVGLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDOUQsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsQ0FBQ3E4Qyw4QkFBOEJqQixTQUE5QixDQUFULEVBQW1ELHFFQUFxRSx3Q0FBeEgsQ0FBeEMsR0FBNE0sS0FBSyxDQUFqTjtBQUNEOztBQUVELFFBQUlpQyxnQkFBZ0JWLDhCQUE4QnZCLFNBQTlCLENBQXBCO0FBQ0EsUUFBSSxDQUFDaUMsYUFBTCxFQUFvQjtBQUNsQjtBQUNBO0FBQ0EsVUFBSWUsZ0NBQWdDakMscUJBQXFCZixTQUFyQixDQUFwQzs7QUFFQTtBQUNBLFVBQUlrRCx1QkFBdUJsRCxVQUFVdjVDLFFBQVYsS0FBdUIsQ0FBdkIsSUFBNEJ1NUMsVUFBVW9CLFlBQVYsQ0FBdUI1QixjQUF2QixDQUF2RDs7QUFFQSxVQUFJei9DLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDOUQsZ0JBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLENBQUNvK0MsNkJBQVQsRUFBd0MscUVBQXFFLDREQUE3RyxFQUEyS0UsdUJBQXVCLG1FQUFtRSxtQkFBMUYsR0FBZ0gsNkRBQTZELDZDQUF4VixDQUF4QyxHQUFpYixLQUFLLENBQXRiO0FBQ0Q7O0FBRUQsYUFBTyxLQUFQO0FBQ0Q7QUFDRCxXQUFPeEQsdUJBQXVCdUMsY0FBY0csU0FBZCxDQUF3QlIsTUFBL0MsQ0FBUDtBQUNBdnVDLGlCQUFhdUIsY0FBYixDQUE0QmdzQyx3QkFBNUIsRUFBc0RxQixhQUF0RCxFQUFxRWpDLFNBQXJFLEVBQWdGLEtBQWhGO0FBQ0EsV0FBTyxJQUFQO0FBQ0QsR0E5TWM7O0FBZ05mUSx1QkFBcUIsNkJBQVV2K0IsTUFBVixFQUFrQis5QixTQUFsQixFQUE2QmhoQyxRQUE3QixFQUF1Q29oQyxpQkFBdkMsRUFBMERqckMsV0FBMUQsRUFBdUU7QUFDMUYsS0FBQ2dzQyxpQkFBaUJuQixTQUFqQixDQUFELEdBQStCamdELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsNkRBQWpCLENBQXhDLEdBQTBINEIsZUFBZSxJQUFmLENBQXpKLEdBQWdMLEtBQUssQ0FBckw7O0FBRUEsUUFBSXk2QyxpQkFBSixFQUF1QjtBQUNyQixVQUFJK0MsY0FBY3BELCtCQUErQkMsU0FBL0IsQ0FBbEI7QUFDQSxVQUFJVCxvQkFBb0I2RCxjQUFwQixDQUFtQ25oQyxNQUFuQyxFQUEyQ2toQyxXQUEzQyxDQUFKLEVBQTZEO0FBQzNEeDZDLDhCQUFzQjFCLFlBQXRCLENBQW1DK1gsUUFBbkMsRUFBNkNta0MsV0FBN0M7QUFDQTtBQUNELE9BSEQsTUFHTztBQUNMLFlBQUlFLFdBQVdGLFlBQVl6OEMsWUFBWixDQUF5QjY0QyxvQkFBb0IrRCxrQkFBN0MsQ0FBZjtBQUNBSCxvQkFBWXhLLGVBQVosQ0FBNEI0RyxvQkFBb0IrRCxrQkFBaEQ7O0FBRUEsWUFBSUMsYUFBYUosWUFBWUssU0FBN0I7QUFDQUwsb0JBQVlocUIsWUFBWixDQUF5Qm9tQixvQkFBb0IrRCxrQkFBN0MsRUFBaUVELFFBQWpFOztBQUVBLFlBQUlJLG1CQUFtQnhoQyxNQUF2QjtBQUNBLFlBQUlsaUIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFJNi9DLFVBQUo7QUFDQSxjQUFJMUQsVUFBVXY1QyxRQUFWLEtBQXVCeWMsaUJBQTNCLEVBQThDO0FBQzVDd2dDLHlCQUFhOTRDLFNBQVNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBYjtBQUNBNjRDLHVCQUFXNTBCLFNBQVgsR0FBdUI3TSxNQUF2QjtBQUNBd2hDLCtCQUFtQkMsV0FBVzUwQixTQUE5QjtBQUNELFdBSkQsTUFJTztBQUNMNDBCLHlCQUFhOTRDLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBYjtBQUNBRCxxQkFBU3cwQyxJQUFULENBQWM3NkIsV0FBZCxDQUEwQm0vQixVQUExQjtBQUNBQSx1QkFBV0MsZUFBWCxDQUEyQkMsS0FBM0IsQ0FBaUMzaEMsTUFBakM7QUFDQXdoQywrQkFBbUJDLFdBQVdDLGVBQVgsQ0FBMkJqVSxlQUEzQixDQUEyQzhULFNBQTlEO0FBQ0E1NEMscUJBQVN3MEMsSUFBVCxDQUFjandCLFdBQWQsQ0FBMEJ1MEIsVUFBMUI7QUFDRDtBQUNGOztBQUVELFlBQUlHLFlBQVlsRSxxQkFBcUI4RCxnQkFBckIsRUFBdUNGLFVBQXZDLENBQWhCO0FBQ0EsWUFBSU8sYUFBYSxlQUFlTCxpQkFBaUIxekIsU0FBakIsQ0FBMkI4ekIsWUFBWSxFQUF2QyxFQUEyQ0EsWUFBWSxFQUF2RCxDQUFmLEdBQTRFLGNBQTVFLEdBQTZGTixXQUFXeHpCLFNBQVgsQ0FBcUI4ekIsWUFBWSxFQUFqQyxFQUFxQ0EsWUFBWSxFQUFqRCxDQUE5Rzs7QUFFQSxVQUFFN0QsVUFBVXY1QyxRQUFWLEtBQXVCZzVDLGFBQXpCLElBQTBDMS9DLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsMmRBQWpCLEVBQThlKy9DLFVBQTllLENBQXhDLEdBQW9pQm4rQyxlQUFlLElBQWYsRUFBcUJtK0MsVUFBckIsQ0FBOWtCLEdBQWluQixLQUFLLENBQXRuQjs7QUFFQSxZQUFJL2pELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDOUQsa0JBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSw0REFBNEQsMERBQTVELEdBQXlILHlEQUF6SCxHQUFxTCwrREFBckwsR0FBdVAsOERBQXZQLEdBQXdULDJEQUF4VCxHQUFzWCw0REFBdFgsR0FBcWIsZ0JBQXBjLEVBQXNkay9DLFVBQXRkLENBQXhDLEdBQTRnQixLQUFLLENBQWpoQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxNQUFFOUQsVUFBVXY1QyxRQUFWLEtBQXVCZzVDLGFBQXpCLElBQTBDMS9DLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsb09BQWpCLENBQXhDLEdBQWlTNEIsZUFBZSxJQUFmLENBQTNVLEdBQWtXLEtBQUssQ0FBdlc7O0FBRUEsUUFBSXdQLFlBQVl3ckMsZ0JBQWhCLEVBQWtDO0FBQ2hDLGFBQU9YLFVBQVUvTixTQUFqQixFQUE0QjtBQUMxQitOLGtCQUFVN3dCLFdBQVYsQ0FBc0I2d0IsVUFBVS9OLFNBQWhDO0FBQ0Q7QUFDRHZ0QixrQkFBWWhCLGdCQUFaLENBQTZCczhCLFNBQTdCLEVBQXdDLzlCLE1BQXhDLEVBQWdELElBQWhEO0FBQ0QsS0FMRCxNQUtPO0FBQ0xjLG1CQUFhaTlCLFNBQWIsRUFBd0IvOUIsTUFBeEI7QUFDQXRaLDRCQUFzQjFCLFlBQXRCLENBQW1DK1gsUUFBbkMsRUFBNkNnaEMsVUFBVXA0QyxVQUF2RDtBQUNEOztBQUVELFFBQUk3SCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJa2dELFdBQVdwN0Msc0JBQXNCSCxtQkFBdEIsQ0FBMEN3M0MsVUFBVXA0QyxVQUFwRCxDQUFmO0FBQ0EsVUFBSW04QyxTQUFTdnpDLFFBQVQsS0FBc0IsQ0FBMUIsRUFBNkI7QUFDM0JrUiw2QkFBcUIzUCxTQUFyQixDQUErQjZvQixlQUEvQixDQUErQztBQUM3Q0Msc0JBQVlrcEIsU0FBU3Z6QyxRQUR3QjtBQUU3Q2hDLGdCQUFNLE9BRnVDO0FBRzdDc3NCLG1CQUFTN1ksT0FBTzdiLFFBQVA7QUFIb0MsU0FBL0M7QUFLRDtBQUNGO0FBQ0Y7QUFwUmMsQ0FBakI7O0FBdVJBcEcsT0FBT0MsT0FBUCxHQUFpQnNnRCxVQUFqQixDOzs7Ozs7OztBQ3hoQkE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJdkYsaUJBQWlCLG1CQUFBcjJDLENBQVEsRUFBUixDQUFyQjs7QUFFQSxTQUFTcS9DLDZCQUFULENBQXVDOThDLElBQXZDLEVBQTZDO0FBQzNDLE1BQUlzSCxJQUFKOztBQUVBLFNBQU8sQ0FBQ0EsT0FBT3RILEtBQUsrOEMsaUJBQWIsTUFBb0NqSixlQUFlRSxTQUExRCxFQUFxRTtBQUNuRWgwQyxXQUFPQSxLQUFLRixrQkFBWjtBQUNEOztBQUVELE1BQUl3SCxTQUFTd3NDLGVBQWVDLElBQTVCLEVBQWtDO0FBQ2hDLFdBQU8vekMsS0FBS0Ysa0JBQVo7QUFDRCxHQUZELE1BRU8sSUFBSXdILFNBQVN3c0MsZUFBZUcsS0FBNUIsRUFBbUM7QUFDeEMsV0FBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRG43QyxPQUFPQyxPQUFQLEdBQWlCK2pELDZCQUFqQixDOzs7Ozs7Ozs7Ozs7Ozs7QUNwQkE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQVhBLElBQUk1ZixXQUFXdjdCLE9BQU9PLE1BQVAsSUFBaUIsVUFBVWUsTUFBVixFQUFrQjtBQUFFLE9BQUssSUFBSXJJLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsVUFBVVQsTUFBOUIsRUFBc0NVLEdBQXRDLEVBQTJDO0FBQUUsUUFBSXNJLFNBQVN2SSxVQUFVQyxDQUFWLENBQWIsQ0FBMkIsS0FBSyxJQUFJMkksR0FBVCxJQUFnQkwsTUFBaEIsRUFBd0I7QUFBRSxVQUFJdkIsT0FBTzNHLFNBQVAsQ0FBaUI0RixjQUFqQixDQUFnQ2xILElBQWhDLENBQXFDd0osTUFBckMsRUFBNkNLLEdBQTdDLENBQUosRUFBdUQ7QUFBRU4sZUFBT00sR0FBUCxJQUFjTCxPQUFPSyxHQUFQLENBQWQ7QUFBNEI7QUFBRTtBQUFFLEdBQUMsT0FBT04sTUFBUDtBQUFnQixDQUFoUTs7QUFFQSxTQUFTMDdCLGVBQVQsQ0FBeUI3bUIsUUFBekIsRUFBbUM4bUIsV0FBbkMsRUFBZ0Q7QUFBRSxNQUFJLEVBQUU5bUIsb0JBQW9COG1CLFdBQXRCLENBQUosRUFBd0M7QUFBRSxVQUFNLElBQUk1OEIsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosU0FBUzY4QiwwQkFBVCxDQUFvQ3JvQixJQUFwQyxFQUEwQzljLElBQTFDLEVBQWdEO0FBQUUsTUFBSSxDQUFDOGMsSUFBTCxFQUFXO0FBQUUsVUFBTSxJQUFJc29CLGNBQUosQ0FBbUIsMkRBQW5CLENBQU47QUFBd0YsR0FBQyxPQUFPcGxDLFNBQVMsUUFBT0EsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUFoQixJQUE0QixPQUFPQSxJQUFQLEtBQWdCLFVBQXJELElBQW1FQSxJQUFuRSxHQUEwRThjLElBQWpGO0FBQXdGOztBQUVoUCxTQUFTdW9CLFNBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCQyxVQUE3QixFQUF5QztBQUFFLE1BQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsZUFBZSxJQUF2RCxFQUE2RDtBQUFFLFVBQU0sSUFBSWo5QixTQUFKLENBQWMscUVBQW9FaTlCLFVBQXBFLHlDQUFvRUEsVUFBcEUsRUFBZCxDQUFOO0FBQXNHLEdBQUNELFNBQVNoa0MsU0FBVCxHQUFxQjJHLE9BQU9vUSxNQUFQLENBQWNrdEIsY0FBY0EsV0FBV2prQyxTQUF2QyxFQUFrRCxFQUFFbVcsYUFBYSxFQUFFZSxPQUFPOHNCLFFBQVQsRUFBbUJ0b0IsWUFBWSxLQUEvQixFQUFzQ0MsVUFBVSxJQUFoRCxFQUFzRGpFLGNBQWMsSUFBcEUsRUFBZixFQUFsRCxDQUFyQixDQUFxSyxJQUFJdXNCLFVBQUosRUFBZ0J0OUIsT0FBT3U5QixjQUFQLEdBQXdCdjlCLE9BQU91OUIsY0FBUCxDQUFzQkYsUUFBdEIsRUFBZ0NDLFVBQWhDLENBQXhCLEdBQXNFRCxTQUFTRyxTQUFULEdBQXFCRixVQUEzRjtBQUF3Rzs7QUFPOWU7Ozs7QUFJQSxJQUFJejZCLFFBQVEsVUFBVTQ2QixnQkFBVixFQUE0QjtBQUN0Q0wsWUFBVXY2QixLQUFWLEVBQWlCNDZCLGdCQUFqQjs7QUFFQSxXQUFTNTZCLEtBQVQsR0FBaUI7QUFDZixRQUFJNjZCLEtBQUosRUFBV0MsS0FBWCxFQUFrQkMsSUFBbEI7O0FBRUFaLG9CQUFnQixJQUFoQixFQUFzQm42QixLQUF0Qjs7QUFFQSxTQUFLLElBQUk1RyxPQUFPakQsVUFBVVQsTUFBckIsRUFBNkJPLE9BQU9DLE1BQU1rRCxJQUFOLENBQXBDLEVBQWlEQyxPQUFPLENBQTdELEVBQWdFQSxPQUFPRCxJQUF2RSxFQUE2RUMsTUFBN0UsRUFBcUY7QUFDbkZwRCxXQUFLb0QsSUFBTCxJQUFhbEQsVUFBVWtELElBQVYsQ0FBYjtBQUNEOztBQUVELFdBQU8waEMsUUFBUUYsU0FBU0MsUUFBUVQsMkJBQTJCLElBQTNCLEVBQWlDTyxpQkFBaUIxbEMsSUFBakIsQ0FBc0J1QixLQUF0QixDQUE0Qm1rQyxnQkFBNUIsRUFBOEMsQ0FBQyxJQUFELEVBQU9qbEMsTUFBUCxDQUFjTSxJQUFkLENBQTlDLENBQWpDLENBQVIsRUFBOEc2a0MsS0FBdkgsR0FBK0hBLE1BQU0zQixLQUFOLEdBQWM7QUFDMUpwVixhQUFPK1csTUFBTUUsWUFBTixDQUFtQkYsTUFBTW5wQixLQUF6QixFQUFnQ21wQixNQUFNbHdCLE9BQU4sQ0FBY3V3QixNQUE5QztBQURtSixLQUE3SSxFQUVaTixLQUZJLEdBRUlSLDJCQUEyQlMsS0FBM0IsRUFBa0NDLElBQWxDLENBRlg7QUFHRDs7QUFFRC82QixRQUFNeEosU0FBTixDQUFnQjBrQyxlQUFoQixHQUFrQyxTQUFTQSxlQUFULEdBQTJCO0FBQzNELFdBQU87QUFDTEMsY0FBUXpDLFNBQVMsRUFBVCxFQUFhLEtBQUs5dEIsT0FBTCxDQUFhdXdCLE1BQTFCLEVBQWtDO0FBQ3hDQyxlQUFPO0FBQ0xsYyxvQkFBVSxLQUFLdk4sS0FBTCxDQUFXdU4sUUFBWCxJQUF1QixLQUFLdFUsT0FBTCxDQUFhdXdCLE1BQWIsQ0FBb0JDLEtBQXBCLENBQTBCbGMsUUFEdEQ7QUFFTDZFLGlCQUFPLEtBQUtvVixLQUFMLENBQVdwVjtBQUZiO0FBRGlDLE9BQWxDO0FBREgsS0FBUDtBQVFELEdBVEQ7O0FBV0EvakIsUUFBTXhKLFNBQU4sQ0FBZ0J3a0MsWUFBaEIsR0FBK0IsU0FBU0EsWUFBVCxDQUFzQndkLElBQXRCLEVBQTRCQyxLQUE1QixFQUFtQztBQUNoRSxRQUFJQyxnQkFBZ0JGLEtBQUtFLGFBQXpCO0FBQUEsUUFDSXg1QixXQUFXczVCLEtBQUt0NUIsUUFEcEI7QUFBQSxRQUVJZCxPQUFPbzZCLEtBQUtwNkIsSUFGaEI7QUFBQSxRQUdJeWUsU0FBUzJiLEtBQUszYixNQUhsQjtBQUFBLFFBSUlPLFFBQVFvYixLQUFLcGIsS0FKakI7QUFLQSxRQUFJaEMsUUFBUXFkLE1BQU1yZCxLQUFsQjs7QUFFQSxRQUFJc2QsYUFBSixFQUFtQixPQUFPQSxhQUFQLENBUjZDLENBUXZCOztBQUV6QyxRQUFJOTVCLFdBQVcsQ0FBQ00sWUFBWWtjLE1BQU1sYyxRQUFuQixFQUE2Qk4sUUFBNUM7O0FBRUEsV0FBT1IsT0FBTyx5QkFBVVEsUUFBVixFQUFvQixFQUFFUixNQUFNQSxJQUFSLEVBQWN5ZSxRQUFRQSxNQUF0QixFQUE4Qk8sT0FBT0EsS0FBckMsRUFBcEIsQ0FBUCxHQUEyRWhDLE1BQU1yWCxLQUF4RjtBQUNELEdBYkQ7O0FBZUEvakIsUUFBTXhKLFNBQU4sQ0FBZ0JnbEMsa0JBQWhCLEdBQXFDLFNBQVNBLGtCQUFULEdBQThCO0FBQ2pFLFFBQUlFLFNBQVMsS0FBSy9wQixLQUFsQjtBQUFBLFFBQ0l2VyxZQUFZc2dDLE9BQU90Z0MsU0FEdkI7QUFBQSxRQUVJNmdDLFNBQVNQLE9BQU9PLE1BRnBCO0FBQUEsUUFHSWxnQyxXQUFXMi9CLE9BQU8zL0IsUUFIdEI7O0FBTUEsMkJBQVEsRUFBRVgsYUFBYTZnQyxNQUFmLENBQVIsRUFBZ0MsMkdBQWhDOztBQUVBLDJCQUFRLEVBQUU3Z0MsYUFBYVcsUUFBZixDQUFSLEVBQWtDLCtHQUFsQzs7QUFFQSwyQkFBUSxFQUFFa2dDLFVBQVVsZ0MsUUFBWixDQUFSLEVBQStCLDRHQUEvQjtBQUNELEdBWkQ7O0FBY0FpRSxRQUFNeEosU0FBTixDQUFnQnNsQyx5QkFBaEIsR0FBNEMsU0FBU0EseUJBQVQsQ0FBbUNDLFNBQW5DLEVBQThDMUcsV0FBOUMsRUFBMkQ7QUFDckcsMkJBQVEsRUFBRTBHLFVBQVU3YyxRQUFWLElBQXNCLENBQUMsS0FBS3ZOLEtBQUwsQ0FBV3VOLFFBQXBDLENBQVIsRUFBdUQseUtBQXZEOztBQUVBLDJCQUFRLEVBQUUsQ0FBQzZjLFVBQVU3YyxRQUFYLElBQXVCLEtBQUt2TixLQUFMLENBQVd1TixRQUFwQyxDQUFSLEVBQXVELHFLQUF2RDs7QUFFQSxTQUFLMmMsUUFBTCxDQUFjO0FBQ1o5WCxhQUFPLEtBQUtpWCxZQUFMLENBQWtCZSxTQUFsQixFQUE2QjFHLFlBQVk4RixNQUF6QztBQURLLEtBQWQ7QUFHRCxHQVJEOztBQVVBbjdCLFFBQU14SixTQUFOLENBQWdCeWxDLE1BQWhCLEdBQXlCLFNBQVNBLE1BQVQsR0FBa0I7QUFDekMsUUFBSWxZLFFBQVEsS0FBS29WLEtBQUwsQ0FBV3BWLEtBQXZCO0FBQ0EsUUFBSTQwQixVQUFVLEtBQUtobkMsS0FBbkI7QUFBQSxRQUNJNVYsV0FBVzQ4QyxRQUFRNThDLFFBRHZCO0FBQUEsUUFFSVgsWUFBWXU5QyxRQUFRdjlDLFNBRnhCO0FBQUEsUUFHSTZnQyxTQUFTMGMsUUFBUTFjLE1BSHJCO0FBSUEsUUFBSTJjLGtCQUFrQixLQUFLaHVDLE9BQUwsQ0FBYXV3QixNQUFuQztBQUFBLFFBQ0lGLFVBQVUyZCxnQkFBZ0IzZCxPQUQ5QjtBQUFBLFFBRUlHLFFBQVF3ZCxnQkFBZ0J4ZCxLQUY1QjtBQUFBLFFBR0l5ZCxnQkFBZ0JELGdCQUFnQkMsYUFIcEM7O0FBS0EsUUFBSTM1QixXQUFXLEtBQUt2TixLQUFMLENBQVd1TixRQUFYLElBQXVCa2MsTUFBTWxjLFFBQTVDO0FBQ0EsUUFBSXZOLFFBQVEsRUFBRW9TLE9BQU9BLEtBQVQsRUFBZ0I3RSxVQUFVQSxRQUExQixFQUFvQytiLFNBQVNBLE9BQTdDLEVBQXNENGQsZUFBZUEsYUFBckUsRUFBWjs7QUFFQSxXQUFPejlDLFlBQVk7QUFDbkIyb0IsWUFBUSxnQkFBTTVrQixhQUFOLENBQW9CL0QsU0FBcEIsRUFBK0J1VyxLQUEvQixDQUFSLEdBQWdELElBRHpDLEdBQ2dEc3FCLFNBQVM7QUFDaEVsWSxZQUFRa1ksT0FBT3RxQixLQUFQLENBQVIsR0FBd0IsSUFEK0IsR0FDeEI1VixXQUFXO0FBQzFDLFdBQU9BLFFBQVAsS0FBb0IsVUFBcEIsR0FBaUNBLFNBQVM0VixLQUFULENBQWpDLEdBQW1ELENBQUN6YixNQUFNdTFCLE9BQU4sQ0FBYzF2QixRQUFkLENBQUQsSUFBNEJBLFNBQVNyRyxNQUFyQyxHQUE4QztBQUNqRyxvQkFBTTBmLFFBQU4sQ0FBZUcsSUFBZixDQUFvQnhaLFFBQXBCLENBRG1ELEdBQ25CLElBRkQsR0FFUSxJQUp2QztBQUtELEdBbkJEOztBQXFCQSxTQUFPaUUsS0FBUDtBQUNELENBekZXLENBeUZWLGdCQUFNd1YsU0F6RkksQ0FBWjs7QUEyRkF4VixNQUFNMHhCLFNBQU4sR0FBa0I7QUFDaEJnbkIsaUJBQWUsb0JBQVUveEMsTUFEVCxFQUNpQjtBQUNqQ3lYLFFBQU0sb0JBQVV5RixNQUZBO0FBR2hCdVosU0FBTyxvQkFBVXFELElBSEQ7QUFJaEI1RCxVQUFRLG9CQUFVNEQsSUFKRjtBQUtoQnJsQyxhQUFXLG9CQUFVc3hCLElBTEw7QUFNaEJ1UCxVQUFRLG9CQUFVdlAsSUFORjtBQU9oQjN3QixZQUFVLG9CQUFVeWxDLFNBQVYsQ0FBb0IsQ0FBQyxvQkFBVTlVLElBQVgsRUFBaUIsb0JBQVU3eEIsSUFBM0IsQ0FBcEIsQ0FQTTtBQVFoQnFrQixZQUFVLG9CQUFVdlk7QUFSSixDQUFsQjtBQVVBM0csTUFBTW04QixZQUFOLEdBQXFCO0FBQ25CaEIsVUFBUSxvQkFBVXVHLEtBQVYsQ0FBZ0I7QUFDdEJ6RyxhQUFTLG9CQUFVdDBCLE1BQVYsQ0FBaUJ1MUIsVUFESjtBQUV0QmQsV0FBTyxvQkFBVXowQixNQUFWLENBQWlCdTFCLFVBRkY7QUFHdEIyYyxtQkFBZSxvQkFBVWx5QztBQUhILEdBQWhCO0FBRFcsQ0FBckI7QUFPQTNHLE1BQU1vOEIsaUJBQU4sR0FBMEI7QUFDeEJqQixVQUFRLG9CQUFVeDBCLE1BQVYsQ0FBaUJ1MUI7QUFERCxDQUExQjs7a0JBS2VsOEIsSzs7Ozs7OztBQ2xJZjs7OztBQUVBekwsUUFBUTJwQixVQUFSLEdBQXFCLElBQXJCOztBQUVBLElBQUk0NkIsVUFBVSxPQUFPdHlDLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsU0FBT0EsT0FBT2s0QixRQUFkLE1BQTJCLFFBQTNELEdBQXNFLFVBQVV6RixHQUFWLEVBQWU7QUFBRSxnQkFBY0EsR0FBZCwwQ0FBY0EsR0FBZDtBQUFvQixDQUEzRyxHQUE4RyxVQUFVQSxHQUFWLEVBQWU7QUFBRSxTQUFPQSxPQUFPLE9BQU96eUIsTUFBUCxLQUFrQixVQUF6QixJQUF1Q3l5QixJQUFJdHNCLFdBQUosS0FBb0JuRyxNQUEzRCxJQUFxRXl5QixRQUFRenlCLE9BQU9oUSxTQUFwRixHQUFnRyxRQUFoRyxVQUFrSHlpQyxHQUFsSCwwQ0FBa0hBLEdBQWxILENBQVA7QUFBK0gsQ0FBNVE7O0FBRUEsSUFBSVAsV0FBV3Y3QixPQUFPTyxNQUFQLElBQWlCLFVBQVVlLE1BQVYsRUFBa0I7QUFBRSxPQUFLLElBQUlySSxJQUFJLENBQWIsRUFBZ0JBLElBQUlELFVBQVVULE1BQTlCLEVBQXNDVSxHQUF0QyxFQUEyQztBQUFFLFFBQUlzSSxTQUFTdkksVUFBVUMsQ0FBVixDQUFiLENBQTJCLEtBQUssSUFBSTJJLEdBQVQsSUFBZ0JMLE1BQWhCLEVBQXdCO0FBQUUsVUFBSXZCLE9BQU8zRyxTQUFQLENBQWlCNEYsY0FBakIsQ0FBZ0NsSCxJQUFoQyxDQUFxQ3dKLE1BQXJDLEVBQTZDSyxHQUE3QyxDQUFKLEVBQXVEO0FBQUVOLGVBQU9NLEdBQVAsSUFBY0wsT0FBT0ssR0FBUCxDQUFkO0FBQTRCO0FBQUU7QUFBRSxHQUFDLE9BQU9OLE1BQVA7QUFBZ0IsQ0FBaFE7O0FBRUEsSUFBSTg2QixXQUFXLG1CQUFBdGdDLENBQVEsRUFBUixDQUFmOztBQUVBLElBQUl1Z0MsWUFBWVgsdUJBQXVCVSxRQUF2QixDQUFoQjs7QUFFQSxJQUFJd2YsYUFBYSxtQkFBQTkvQyxDQUFRLEVBQVIsQ0FBakI7O0FBRUEsSUFBSSsvQyxjQUFjbmdCLHVCQUF1QmtnQixVQUF2QixDQUFsQjs7QUFFQSxJQUFJRSxpQkFBaUIsbUJBQUFoZ0QsQ0FBUSxFQUFSLENBQXJCOztBQUVBLElBQUkrL0IsYUFBYSxtQkFBQS8vQixDQUFRLEVBQVIsQ0FBakI7O0FBRUEsSUFBSWlnRCwyQkFBMkIsbUJBQUFqZ0QsQ0FBUSxFQUFSLENBQS9COztBQUVBLElBQUlrZ0QsNEJBQTRCdGdCLHVCQUF1QnFnQix3QkFBdkIsQ0FBaEM7O0FBRUEsSUFBSUUsWUFBWSxtQkFBQW5nRCxDQUFRLEVBQVIsQ0FBaEI7O0FBRUEsU0FBUzQvQixzQkFBVCxDQUFnQ0ksR0FBaEMsRUFBcUM7QUFBRSxTQUFPQSxPQUFPQSxJQUFJL2EsVUFBWCxHQUF3QithLEdBQXhCLEdBQThCLEVBQUVDLFNBQVNELEdBQVgsRUFBckM7QUFBd0Q7O0FBRS9GLElBQUlvZ0IsZ0JBQWdCLFVBQXBCO0FBQ0EsSUFBSUMsa0JBQWtCLFlBQXRCOztBQUVBLElBQUlDLGtCQUFrQixTQUFTQSxlQUFULEdBQTJCO0FBQy9DLE1BQUk7QUFDRixXQUFPdDZDLE9BQU9nOEIsT0FBUCxDQUFlOUIsS0FBZixJQUF3QixFQUEvQjtBQUNELEdBRkQsQ0FFRSxPQUFPcmtDLENBQVAsRUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFPLEVBQVA7QUFDRDtBQUNGLENBUkQ7O0FBVUE7Ozs7QUFJQSxJQUFJMGtELHVCQUF1QixTQUFTQSxvQkFBVCxHQUFnQztBQUN6RCxNQUFJN25DLFFBQVF4YixVQUFVVCxNQUFWLEdBQW1CLENBQW5CLElBQXdCUyxVQUFVLENBQVYsTUFBaUJpQyxTQUF6QyxHQUFxRGpDLFVBQVUsQ0FBVixDQUFyRCxHQUFvRSxFQUFoRjs7QUFFQSxHQUFDLEdBQUc2aUQsWUFBWTlmLE9BQWhCLEVBQXlCa2dCLFVBQVVwNkMsU0FBbkMsRUFBOEMsNkJBQTlDOztBQUVBLE1BQUl5NkMsZ0JBQWdCeDZDLE9BQU9nOEIsT0FBM0I7QUFDQSxNQUFJeWUsZ0JBQWdCLENBQUMsR0FBR04sVUFBVU8sZUFBZCxHQUFwQjtBQUNBLE1BQUlDLDBCQUEwQixDQUFDLENBQUMsR0FBR1IsVUFBVVMsNEJBQWQsR0FBL0I7O0FBRUEsTUFBSUMsc0JBQXNCbm9DLE1BQU1vb0MsWUFBaEM7QUFBQSxNQUNJQSxlQUFlRCx3QkFBd0IxaEQsU0FBeEIsR0FBb0MsS0FBcEMsR0FBNEMwaEQsbUJBRC9EO0FBQUEsTUFFSUUsd0JBQXdCcm9DLE1BQU1tb0IsbUJBRmxDO0FBQUEsTUFHSUEsc0JBQXNCa2dCLDBCQUEwQjVoRCxTQUExQixHQUFzQ2doRCxVQUFVYSxlQUFoRCxHQUFrRUQscUJBSDVGO0FBQUEsTUFJSUUsbUJBQW1Cdm9DLE1BQU13b0MsU0FKN0I7QUFBQSxNQUtJQSxZQUFZRCxxQkFBcUI5aEQsU0FBckIsR0FBaUMsQ0FBakMsR0FBcUM4aEQsZ0JBTHJEOztBQU9BLE1BQUlFLFdBQVd6b0MsTUFBTXlvQyxRQUFOLEdBQWlCLENBQUMsR0FBR3BoQixXQUFXdGEsa0JBQWYsRUFBbUMsQ0FBQyxHQUFHc2EsV0FBVzdhLGVBQWYsRUFBZ0N4TSxNQUFNeW9DLFFBQXRDLENBQW5DLENBQWpCLEdBQXVHLEVBQXRIOztBQUVBLE1BQUlDLGlCQUFpQixTQUFTQSxjQUFULENBQXdCQyxZQUF4QixFQUFzQztBQUN6RCxRQUFJOUIsT0FBTzhCLGdCQUFnQixFQUEzQjtBQUFBLFFBQ0l2N0MsTUFBTXk1QyxLQUFLejVDLEdBRGY7QUFBQSxRQUVJbzZCLFFBQVFxZixLQUFLcmYsS0FGakI7O0FBSUEsUUFBSW9oQixtQkFBbUJ0N0MsT0FBT2lnQixRQUE5QjtBQUFBLFFBQ0lOLFdBQVcyN0IsaUJBQWlCMzdCLFFBRGhDO0FBQUEsUUFFSUMsU0FBUzA3QixpQkFBaUIxN0IsTUFGOUI7QUFBQSxRQUdJQyxPQUFPeTdCLGlCQUFpQno3QixJQUg1Qjs7QUFNQSxRQUFJVixPQUFPUSxXQUFXQyxNQUFYLEdBQW9CQyxJQUEvQjs7QUFFQSxLQUFDLEdBQUcwYSxVQUFVTixPQUFkLEVBQXVCLENBQUNraEIsUUFBRCxJQUFhLENBQUMsR0FBR3BoQixXQUFXemEsV0FBZixFQUE0QkgsSUFBNUIsRUFBa0NnOEIsUUFBbEMsQ0FBcEMsRUFBaUYsa0ZBQWtGLG9DQUFsRixHQUF5SGg4QixJQUF6SCxHQUFnSSxtQkFBaEksR0FBc0pnOEIsUUFBdEosR0FBaUssSUFBbFA7O0FBRUEsUUFBSUEsUUFBSixFQUFjaDhCLE9BQU8sQ0FBQyxHQUFHNGEsV0FBV3ZhLGFBQWYsRUFBOEJMLElBQTlCLEVBQW9DZzhCLFFBQXBDLENBQVA7O0FBRWQsV0FBTyxDQUFDLEdBQUduQixlQUFleGdCLGNBQW5CLEVBQW1DcmEsSUFBbkMsRUFBeUMrYSxLQUF6QyxFQUFnRHA2QixHQUFoRCxDQUFQO0FBQ0QsR0FsQkQ7O0FBb0JBLE1BQUl5N0MsWUFBWSxTQUFTQSxTQUFULEdBQXFCO0FBQ25DLFdBQU9oZ0QsS0FBS0MsTUFBTCxHQUFjQyxRQUFkLENBQXVCLEVBQXZCLEVBQTJCMEgsTUFBM0IsQ0FBa0MsQ0FBbEMsRUFBcUMrM0MsU0FBckMsQ0FBUDtBQUNELEdBRkQ7O0FBSUEsTUFBSU0sb0JBQW9CLENBQUMsR0FBR3RCLDBCQUEwQmpnQixPQUE5QixHQUF4Qjs7QUFFQSxNQUFJMkMsV0FBVyxTQUFTQSxRQUFULENBQWtCNmUsU0FBbEIsRUFBNkI7QUFDMUNoaUIsYUFBU3VDLE9BQVQsRUFBa0J5ZixTQUFsQjs7QUFFQXpmLFlBQVF2bEMsTUFBUixHQUFpQitqRCxjQUFjL2pELE1BQS9COztBQUVBK2tELHNCQUFrQnZnQixlQUFsQixDQUFrQ2UsUUFBUS9iLFFBQTFDLEVBQW9EK2IsUUFBUTlzQixNQUE1RDtBQUNELEdBTkQ7O0FBUUEsTUFBSXdzQyxpQkFBaUIsU0FBU0EsY0FBVCxDQUF3Qjl1QyxLQUF4QixFQUErQjtBQUNsRDtBQUNBLFFBQUksQ0FBQyxHQUFHdXRDLFVBQVV3Qix5QkFBZCxFQUF5Qy91QyxLQUF6QyxDQUFKLEVBQXFEOztBQUVyRGd2QyxjQUFVUixlQUFleHVDLE1BQU1zdEIsS0FBckIsQ0FBVjtBQUNELEdBTEQ7O0FBT0EsTUFBSTJoQixtQkFBbUIsU0FBU0EsZ0JBQVQsR0FBNEI7QUFDakRELGNBQVVSLGVBQWVkLGlCQUFmLENBQVY7QUFDRCxHQUZEOztBQUlBLE1BQUl3QixlQUFlLEtBQW5COztBQUVBLE1BQUlGLFlBQVksU0FBU0EsU0FBVCxDQUFtQjM3QixRQUFuQixFQUE2QjtBQUMzQyxRQUFJNjdCLFlBQUosRUFBa0I7QUFDaEJBLHFCQUFlLEtBQWY7QUFDQWxmO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsVUFBSTF0QixTQUFTLEtBQWI7O0FBRUFzc0Msd0JBQWtCNWdCLG1CQUFsQixDQUFzQzNhLFFBQXRDLEVBQWdEL1EsTUFBaEQsRUFBd0QyckIsbUJBQXhELEVBQTZFLFVBQVVraEIsRUFBVixFQUFjO0FBQ3pGLFlBQUlBLEVBQUosRUFBUTtBQUNObmYsbUJBQVMsRUFBRTF0QixRQUFRQSxNQUFWLEVBQWtCK1EsVUFBVUEsUUFBNUIsRUFBVDtBQUNELFNBRkQsTUFFTztBQUNMKzdCLG9CQUFVLzdCLFFBQVY7QUFDRDtBQUNGLE9BTkQ7QUFPRDtBQUNGLEdBZkQ7O0FBaUJBLE1BQUkrN0IsWUFBWSxTQUFTQSxTQUFULENBQW1CQyxZQUFuQixFQUFpQztBQUMvQyxRQUFJQyxhQUFhbGdCLFFBQVEvYixRQUF6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBSStRLFVBQVVtckIsUUFBUTNoRCxPQUFSLENBQWdCMGhELFdBQVdwOEMsR0FBM0IsQ0FBZDs7QUFFQSxRQUFJa3hCLFlBQVksQ0FBQyxDQUFqQixFQUFvQkEsVUFBVSxDQUFWOztBQUVwQixRQUFJRSxZQUFZaXJCLFFBQVEzaEQsT0FBUixDQUFnQnloRCxhQUFhbjhDLEdBQTdCLENBQWhCOztBQUVBLFFBQUlveEIsY0FBYyxDQUFDLENBQW5CLEVBQXNCQSxZQUFZLENBQVo7O0FBRXRCLFFBQUlrckIsUUFBUXByQixVQUFVRSxTQUF0Qjs7QUFFQSxRQUFJa3JCLEtBQUosRUFBVztBQUNUTixxQkFBZSxJQUFmO0FBQ0FPLFNBQUdELEtBQUg7QUFDRDtBQUNGLEdBckJEOztBQXVCQSxNQUFJRSxrQkFBa0JsQixlQUFlZCxpQkFBZixDQUF0QjtBQUNBLE1BQUk2QixVQUFVLENBQUNHLGdCQUFnQng4QyxHQUFqQixDQUFkOztBQUVBOztBQUVBLE1BQUl5OEMsYUFBYSxTQUFTQSxVQUFULENBQW9CdDhCLFFBQXBCLEVBQThCO0FBQzdDLFdBQU9rN0IsV0FBVyxDQUFDLEdBQUdwaEIsV0FBVy9aLFVBQWYsRUFBMkJDLFFBQTNCLENBQWxCO0FBQ0QsR0FGRDs7QUFJQSxNQUFJN29CLE9BQU8sU0FBU0EsSUFBVCxDQUFjK25CLElBQWQsRUFBb0IrYSxLQUFwQixFQUEyQjtBQUNwQyxLQUFDLEdBQUdLLFVBQVVOLE9BQWQsRUFBdUIsRUFBRSxDQUFDLE9BQU85YSxJQUFQLEtBQWdCLFdBQWhCLEdBQThCLFdBQTlCLEdBQTRDMDZCLFFBQVExNkIsSUFBUixDQUE3QyxNQUFnRSxRQUFoRSxJQUE0RUEsS0FBSythLEtBQUwsS0FBZS9nQyxTQUEzRixJQUF3RytnQyxVQUFVL2dDLFNBQXBILENBQXZCLEVBQXVKLDBFQUEwRSwwRUFBak87O0FBRUEsUUFBSStWLFNBQVMsTUFBYjtBQUNBLFFBQUkrUSxXQUFXLENBQUMsR0FBRys1QixlQUFleGdCLGNBQW5CLEVBQW1DcmEsSUFBbkMsRUFBeUMrYSxLQUF6QyxFQUFnRHFoQixXQUFoRCxFQUE2RHZmLFFBQVEvYixRQUFyRSxDQUFmOztBQUVBdTdCLHNCQUFrQjVnQixtQkFBbEIsQ0FBc0MzYSxRQUF0QyxFQUFnRC9RLE1BQWhELEVBQXdEMnJCLG1CQUF4RCxFQUE2RSxVQUFVa2hCLEVBQVYsRUFBYztBQUN6RixVQUFJLENBQUNBLEVBQUwsRUFBUzs7QUFFVCxVQUFJUyxPQUFPRCxXQUFXdDhCLFFBQVgsQ0FBWDtBQUNBLFVBQUluZ0IsTUFBTW1nQixTQUFTbmdCLEdBQW5CO0FBQUEsVUFDSW82QixRQUFRamEsU0FBU2lhLEtBRHJCOztBQUlBLFVBQUl1Z0IsYUFBSixFQUFtQjtBQUNqQkQsc0JBQWNpQyxTQUFkLENBQXdCLEVBQUUzOEMsS0FBS0EsR0FBUCxFQUFZbzZCLE9BQU9BLEtBQW5CLEVBQXhCLEVBQW9ELElBQXBELEVBQTBEc2lCLElBQTFEOztBQUVBLFlBQUkxQixZQUFKLEVBQWtCO0FBQ2hCOTZDLGlCQUFPaWdCLFFBQVAsQ0FBZ0J1OEIsSUFBaEIsR0FBdUJBLElBQXZCO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsY0FBSUUsWUFBWVAsUUFBUTNoRCxPQUFSLENBQWdCd2hDLFFBQVEvYixRQUFSLENBQWlCbmdCLEdBQWpDLENBQWhCO0FBQ0EsY0FBSTY4QyxXQUFXUixRQUFRemdELEtBQVIsQ0FBYyxDQUFkLEVBQWlCZ2hELGNBQWMsQ0FBQyxDQUFmLEdBQW1CLENBQW5CLEdBQXVCQSxZQUFZLENBQXBELENBQWY7O0FBRUFDLG1CQUFTdmxELElBQVQsQ0FBYzZvQixTQUFTbmdCLEdBQXZCO0FBQ0FxOEMsb0JBQVVRLFFBQVY7O0FBRUEvZixtQkFBUyxFQUFFMXRCLFFBQVFBLE1BQVYsRUFBa0IrUSxVQUFVQSxRQUE1QixFQUFUO0FBQ0Q7QUFDRixPQWRELE1BY087QUFDTCxTQUFDLEdBQUdzYSxVQUFVTixPQUFkLEVBQXVCQyxVQUFVL2dDLFNBQWpDLEVBQTRDLGlGQUE1Qzs7QUFFQTZHLGVBQU9pZ0IsUUFBUCxDQUFnQnU4QixJQUFoQixHQUF1QkEsSUFBdkI7QUFDRDtBQUNGLEtBM0JEO0FBNEJELEdBbENEOztBQW9DQSxNQUFJM2lELFVBQVUsU0FBU0EsT0FBVCxDQUFpQnNsQixJQUFqQixFQUF1QithLEtBQXZCLEVBQThCO0FBQzFDLEtBQUMsR0FBR0ssVUFBVU4sT0FBZCxFQUF1QixFQUFFLENBQUMsT0FBTzlhLElBQVAsS0FBZ0IsV0FBaEIsR0FBOEIsV0FBOUIsR0FBNEMwNkIsUUFBUTE2QixJQUFSLENBQTdDLE1BQWdFLFFBQWhFLElBQTRFQSxLQUFLK2EsS0FBTCxLQUFlL2dDLFNBQTNGLElBQXdHK2dDLFVBQVUvZ0MsU0FBcEgsQ0FBdkIsRUFBdUosNkVBQTZFLDBFQUFwTzs7QUFFQSxRQUFJK1YsU0FBUyxTQUFiO0FBQ0EsUUFBSStRLFdBQVcsQ0FBQyxHQUFHKzVCLGVBQWV4Z0IsY0FBbkIsRUFBbUNyYSxJQUFuQyxFQUF5QythLEtBQXpDLEVBQWdEcWhCLFdBQWhELEVBQTZEdmYsUUFBUS9iLFFBQXJFLENBQWY7O0FBRUF1N0Isc0JBQWtCNWdCLG1CQUFsQixDQUFzQzNhLFFBQXRDLEVBQWdEL1EsTUFBaEQsRUFBd0QyckIsbUJBQXhELEVBQTZFLFVBQVVraEIsRUFBVixFQUFjO0FBQ3pGLFVBQUksQ0FBQ0EsRUFBTCxFQUFTOztBQUVULFVBQUlTLE9BQU9ELFdBQVd0OEIsUUFBWCxDQUFYO0FBQ0EsVUFBSW5nQixNQUFNbWdCLFNBQVNuZ0IsR0FBbkI7QUFBQSxVQUNJbzZCLFFBQVFqYSxTQUFTaWEsS0FEckI7O0FBSUEsVUFBSXVnQixhQUFKLEVBQW1CO0FBQ2pCRCxzQkFBY3hiLFlBQWQsQ0FBMkIsRUFBRWwvQixLQUFLQSxHQUFQLEVBQVlvNkIsT0FBT0EsS0FBbkIsRUFBM0IsRUFBdUQsSUFBdkQsRUFBNkRzaUIsSUFBN0Q7O0FBRUEsWUFBSTFCLFlBQUosRUFBa0I7QUFDaEI5NkMsaUJBQU9pZ0IsUUFBUCxDQUFnQnBtQixPQUFoQixDQUF3QjJpRCxJQUF4QjtBQUNELFNBRkQsTUFFTztBQUNMLGNBQUlFLFlBQVlQLFFBQVEzaEQsT0FBUixDQUFnQndoQyxRQUFRL2IsUUFBUixDQUFpQm5nQixHQUFqQyxDQUFoQjs7QUFFQSxjQUFJNDhDLGNBQWMsQ0FBQyxDQUFuQixFQUFzQlAsUUFBUU8sU0FBUixJQUFxQno4QixTQUFTbmdCLEdBQTlCOztBQUV0Qjg4QixtQkFBUyxFQUFFMXRCLFFBQVFBLE1BQVYsRUFBa0IrUSxVQUFVQSxRQUE1QixFQUFUO0FBQ0Q7QUFDRixPQVpELE1BWU87QUFDTCxTQUFDLEdBQUdzYSxVQUFVTixPQUFkLEVBQXVCQyxVQUFVL2dDLFNBQWpDLEVBQTRDLG9GQUE1Qzs7QUFFQTZHLGVBQU9pZ0IsUUFBUCxDQUFnQnBtQixPQUFoQixDQUF3QjJpRCxJQUF4QjtBQUNEO0FBQ0YsS0F6QkQ7QUEwQkQsR0FoQ0Q7O0FBa0NBLE1BQUlILEtBQUssU0FBU0EsRUFBVCxDQUFZcjlDLENBQVosRUFBZTtBQUN0Qnc3QyxrQkFBYzZCLEVBQWQsQ0FBaUJyOUMsQ0FBakI7QUFDRCxHQUZEOztBQUlBLE1BQUk0OUMsU0FBUyxTQUFTQSxNQUFULEdBQWtCO0FBQzdCLFdBQU9QLEdBQUcsQ0FBQyxDQUFKLENBQVA7QUFDRCxHQUZEOztBQUlBLE1BQUlRLFlBQVksU0FBU0EsU0FBVCxHQUFxQjtBQUNuQyxXQUFPUixHQUFHLENBQUgsQ0FBUDtBQUNELEdBRkQ7O0FBSUEsTUFBSVMsZ0JBQWdCLENBQXBCOztBQUVBLE1BQUlDLG9CQUFvQixTQUFTQSxpQkFBVCxDQUEyQlgsS0FBM0IsRUFBa0M7QUFDeERVLHFCQUFpQlYsS0FBakI7O0FBRUEsUUFBSVUsa0JBQWtCLENBQXRCLEVBQXlCO0FBQ3ZCLE9BQUMsR0FBRzNDLFVBQVU1NUMsZ0JBQWQsRUFBZ0NQLE1BQWhDLEVBQXdDbzZDLGFBQXhDLEVBQXVEc0IsY0FBdkQ7O0FBRUEsVUFBSWYsdUJBQUosRUFBNkIsQ0FBQyxHQUFHUixVQUFVNTVDLGdCQUFkLEVBQWdDUCxNQUFoQyxFQUF3Q3E2QyxlQUF4QyxFQUF5RHdCLGdCQUF6RDtBQUM5QixLQUpELE1BSU8sSUFBSWlCLGtCQUFrQixDQUF0QixFQUF5QjtBQUM5QixPQUFDLEdBQUczQyxVQUFVbnNCLG1CQUFkLEVBQW1DaHVCLE1BQW5DLEVBQTJDbzZDLGFBQTNDLEVBQTBEc0IsY0FBMUQ7O0FBRUEsVUFBSWYsdUJBQUosRUFBNkIsQ0FBQyxHQUFHUixVQUFVbnNCLG1CQUFkLEVBQW1DaHVCLE1BQW5DLEVBQTJDcTZDLGVBQTNDLEVBQTREd0IsZ0JBQTVEO0FBQzlCO0FBQ0YsR0FaRDs7QUFjQSxNQUFJbUIsWUFBWSxLQUFoQjs7QUFFQSxNQUFJQyxRQUFRLFNBQVNBLEtBQVQsR0FBaUI7QUFDM0IsUUFBSXhpQixTQUFTdmpDLFVBQVVULE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JTLFVBQVUsQ0FBVixNQUFpQmlDLFNBQXpDLEdBQXFEakMsVUFBVSxDQUFWLENBQXJELEdBQW9FLEtBQWpGOztBQUVBLFFBQUlnbUQsVUFBVTFCLGtCQUFrQjlnQixTQUFsQixDQUE0QkQsTUFBNUIsQ0FBZDs7QUFFQSxRQUFJLENBQUN1aUIsU0FBTCxFQUFnQjtBQUNkRCx3QkFBa0IsQ0FBbEI7QUFDQUMsa0JBQVksSUFBWjtBQUNEOztBQUVELFdBQU8sWUFBWTtBQUNqQixVQUFJQSxTQUFKLEVBQWU7QUFDYkEsb0JBQVksS0FBWjtBQUNBRCwwQkFBa0IsQ0FBQyxDQUFuQjtBQUNEOztBQUVELGFBQU9HLFNBQVA7QUFDRCxLQVBEO0FBUUQsR0FsQkQ7O0FBb0JBLE1BQUl2Z0IsU0FBUyxTQUFTQSxNQUFULENBQWdCaGlCLFFBQWhCLEVBQTBCO0FBQ3JDLFFBQUkraEIsV0FBVzhlLGtCQUFrQjFnQixjQUFsQixDQUFpQ25nQixRQUFqQyxDQUFmO0FBQ0FvaUMsc0JBQWtCLENBQWxCOztBQUVBLFdBQU8sWUFBWTtBQUNqQkEsd0JBQWtCLENBQUMsQ0FBbkI7QUFDQXJnQjtBQUNELEtBSEQ7QUFJRCxHQVJEOztBQVVBLE1BQUlWLFVBQVU7QUFDWnZsQyxZQUFRK2pELGNBQWMvakQsTUFEVjtBQUVaeVksWUFBUSxLQUZJO0FBR1orUSxjQUFVcThCLGVBSEU7QUFJWkMsZ0JBQVlBLFVBSkE7QUFLWm5sRCxVQUFNQSxJQUxNO0FBTVp5QyxhQUFTQSxPQU5HO0FBT1p3aUQsUUFBSUEsRUFQUTtBQVFaTyxZQUFRQSxNQVJJO0FBU1pDLGVBQVdBLFNBVEM7QUFVWkksV0FBT0EsS0FWSztBQVdadGdCLFlBQVFBO0FBWEksR0FBZDs7QUFjQSxTQUFPWCxPQUFQO0FBQ0QsQ0FuUUQ7O0FBcVFBMW1DLFFBQVEya0MsT0FBUixHQUFrQnNnQixvQkFBbEIsQzs7Ozs7OztBQ2xUQTs7QUFFQWpsRCxRQUFRMnBCLFVBQVIsR0FBcUIsSUFBckI7QUFDQSxJQUFJbGYsWUFBWXpLLFFBQVF5SyxTQUFSLEdBQW9CLENBQUMsRUFBRSxPQUFPQyxNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxPQUFPQyxRQUF4QyxJQUFvREQsT0FBT0MsUUFBUCxDQUFnQkMsYUFBdEUsQ0FBckM7O0FBRUEsSUFBSUssbUJBQW1CakwsUUFBUWlMLGdCQUFSLEdBQTJCLFNBQVNBLGdCQUFULENBQTBCM0UsSUFBMUIsRUFBZ0NnUixLQUFoQyxFQUF1QytOLFFBQXZDLEVBQWlEO0FBQ2pHLFNBQU8vZSxLQUFLMkUsZ0JBQUwsR0FBd0IzRSxLQUFLMkUsZ0JBQUwsQ0FBc0JxTSxLQUF0QixFQUE2QitOLFFBQTdCLEVBQXVDLEtBQXZDLENBQXhCLEdBQXdFL2UsS0FBSzRFLFdBQUwsQ0FBaUIsT0FBT29NLEtBQXhCLEVBQStCK04sUUFBL0IsQ0FBL0U7QUFDRCxDQUZEOztBQUlBLElBQUlxVCxzQkFBc0IxNEIsUUFBUTA0QixtQkFBUixHQUE4QixTQUFTQSxtQkFBVCxDQUE2QnB5QixJQUE3QixFQUFtQ2dSLEtBQW5DLEVBQTBDK04sUUFBMUMsRUFBb0Q7QUFDMUcsU0FBTy9lLEtBQUtveUIsbUJBQUwsR0FBMkJweUIsS0FBS295QixtQkFBTCxDQUF5QnBoQixLQUF6QixFQUFnQytOLFFBQWhDLEVBQTBDLEtBQTFDLENBQTNCLEdBQThFL2UsS0FBSzAyQyxXQUFMLENBQWlCLE9BQU8xbEMsS0FBeEIsRUFBK0IrTixRQUEvQixDQUFyRjtBQUNELENBRkQ7O0FBSUEsSUFBSXFnQyxrQkFBa0IxbEQsUUFBUTBsRCxlQUFSLEdBQTBCLFNBQVNBLGVBQVQsQ0FBeUIzZ0QsT0FBekIsRUFBa0M2UCxRQUFsQyxFQUE0QztBQUMxRixTQUFPQSxTQUFTbEssT0FBT205QyxPQUFQLENBQWU5aUQsT0FBZixDQUFULENBQVA7QUFDRCxDQUZELEMsQ0FFRzs7QUFFSDs7Ozs7OztBQU9BLElBQUlxZ0Qsa0JBQWtCcGxELFFBQVFvbEQsZUFBUixHQUEwQixTQUFTQSxlQUFULEdBQTJCO0FBQ3pFLE1BQUkwQyxLQUFLcDlDLE9BQU8yWSxTQUFQLENBQWlCQyxTQUExQjs7QUFFQSxNQUFJLENBQUN3a0MsR0FBRzVpRCxPQUFILENBQVcsWUFBWCxNQUE2QixDQUFDLENBQTlCLElBQW1DNGlELEdBQUc1aUQsT0FBSCxDQUFXLGFBQVgsTUFBOEIsQ0FBQyxDQUFuRSxLQUF5RTRpRCxHQUFHNWlELE9BQUgsQ0FBVyxlQUFYLE1BQWdDLENBQUMsQ0FBMUcsSUFBK0c0aUQsR0FBRzVpRCxPQUFILENBQVcsUUFBWCxNQUF5QixDQUFDLENBQXpJLElBQThJNGlELEdBQUc1aUQsT0FBSCxDQUFXLGVBQVgsTUFBZ0MsQ0FBQyxDQUFuTCxFQUFzTCxPQUFPLEtBQVA7O0FBRXRMLFNBQU93RixPQUFPZzhCLE9BQVAsSUFBa0IsZUFBZWg4QixPQUFPZzhCLE9BQS9DO0FBQ0QsQ0FORDs7QUFRQTs7OztBQUlBLElBQUk0ZSwrQkFBK0J0bEQsUUFBUXNsRCw0QkFBUixHQUF1QyxTQUFTQSw0QkFBVCxHQUF3QztBQUNoSCxTQUFPNTZDLE9BQU8yWSxTQUFQLENBQWlCQyxTQUFqQixDQUEyQnBlLE9BQTNCLENBQW1DLFNBQW5DLE1BQWtELENBQUMsQ0FBMUQ7QUFDRCxDQUZEOztBQUlBOzs7QUFHQSxJQUFJNmlELG1DQUFtQy9uRCxRQUFRK25ELGdDQUFSLEdBQTJDLFNBQVNBLGdDQUFULEdBQTRDO0FBQzVILFNBQU9yOUMsT0FBTzJZLFNBQVAsQ0FBaUJDLFNBQWpCLENBQTJCcGUsT0FBM0IsQ0FBbUMsU0FBbkMsTUFBa0QsQ0FBQyxDQUExRDtBQUNELENBRkQ7O0FBSUE7Ozs7O0FBS0EsSUFBSW1oRCw0QkFBNEJybUQsUUFBUXFtRCx5QkFBUixHQUFvQyxTQUFTQSx5QkFBVCxDQUFtQy91QyxLQUFuQyxFQUEwQztBQUM1RyxTQUFPQSxNQUFNc3RCLEtBQU4sS0FBZ0IvZ0MsU0FBaEIsSUFBNkJ3ZixVQUFVQyxTQUFWLENBQW9CcGUsT0FBcEIsQ0FBNEIsT0FBNUIsTUFBeUMsQ0FBQyxDQUE5RTtBQUNELENBRkQsQzs7Ozs7O0FDcERBLGtCQUFrQixxREFBcUQsNkRBQTZELEVBQUUsd0NBQXdDLEVBQUUsa0JBQWtCLGFBQWEscURBQXFELGdCQUFnQixxRUFBcUUsV0FBVyxvS0FBb0ssRUFBRSw4SkFBOEosRTs7Ozs7Ozs7Ozs7Ozs7QUNBeHFCOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUVBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUVBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUVBOzs7O0FBRUE7Ozs7QUFFQTs7OztBQUVBOzs7Ozs7UUF2QjJCOGlELGE7UUFFSEMsVTtRQUVOQyxJO1FBRVE1OEMsWTtRQUVMNjhDLE87UUFFRDU4QyxNO1FBRUVDLFE7UUFFSEMsSztRQUVDQyxNO1FBRU1DLFk7UUFFTkMsTTtRQUVHQyxTO1FBRUNDLFU7Ozs7Ozs7Ozs7Ozs7OztBQ2Z4Qjs7OztBQUNBOzs7Ozs7QUFYQSxJQUFJcTRCLFdBQVd2N0IsT0FBT08sTUFBUCxJQUFpQixVQUFVZSxNQUFWLEVBQWtCO0FBQUUsT0FBSyxJQUFJckksSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxVQUFVVCxNQUE5QixFQUFzQ1UsR0FBdEMsRUFBMkM7QUFBRSxRQUFJc0ksU0FBU3ZJLFVBQVVDLENBQVYsQ0FBYixDQUEyQixLQUFLLElBQUkySSxHQUFULElBQWdCTCxNQUFoQixFQUF3QjtBQUFFLFVBQUl2QixPQUFPM0csU0FBUCxDQUFpQjRGLGNBQWpCLENBQWdDbEgsSUFBaEMsQ0FBcUN3SixNQUFyQyxFQUE2Q0ssR0FBN0MsQ0FBSixFQUF1RDtBQUFFTixlQUFPTSxHQUFQLElBQWNMLE9BQU9LLEdBQVAsQ0FBZDtBQUE0QjtBQUFFO0FBQUUsR0FBQyxPQUFPTixNQUFQO0FBQWdCLENBQWhROztBQUVBLFNBQVNrK0Msd0JBQVQsQ0FBa0MxakIsR0FBbEMsRUFBdUMxNkIsSUFBdkMsRUFBNkM7QUFBRSxNQUFJRSxTQUFTLEVBQWIsQ0FBaUIsS0FBSyxJQUFJckksQ0FBVCxJQUFjNmlDLEdBQWQsRUFBbUI7QUFBRSxRQUFJMTZCLEtBQUs5RSxPQUFMLENBQWFyRCxDQUFiLEtBQW1CLENBQXZCLEVBQTBCLFNBQVUsSUFBSSxDQUFDK0csT0FBTzNHLFNBQVAsQ0FBaUI0RixjQUFqQixDQUFnQ2xILElBQWhDLENBQXFDK2pDLEdBQXJDLEVBQTBDN2lDLENBQTFDLENBQUwsRUFBbUQsU0FBVXFJLE9BQU9ySSxDQUFQLElBQVk2aUMsSUFBSTdpQyxDQUFKLENBQVo7QUFBcUIsR0FBQyxPQUFPcUksTUFBUDtBQUFnQjs7QUFFNU4sU0FBUzA3QixlQUFULENBQXlCN21CLFFBQXpCLEVBQW1DOG1CLFdBQW5DLEVBQWdEO0FBQUUsTUFBSSxFQUFFOW1CLG9CQUFvQjhtQixXQUF0QixDQUFKLEVBQXdDO0FBQUUsVUFBTSxJQUFJNThCLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQTJEO0FBQUU7O0FBRXpKLFNBQVM2OEIsMEJBQVQsQ0FBb0Nyb0IsSUFBcEMsRUFBMEM5YyxJQUExQyxFQUFnRDtBQUFFLE1BQUksQ0FBQzhjLElBQUwsRUFBVztBQUFFLFVBQU0sSUFBSXNvQixjQUFKLENBQW1CLDJEQUFuQixDQUFOO0FBQXdGLEdBQUMsT0FBT3BsQyxTQUFTLFFBQU9BLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFBNEIsT0FBT0EsSUFBUCxLQUFnQixVQUFyRCxJQUFtRUEsSUFBbkUsR0FBMEU4YyxJQUFqRjtBQUF3Rjs7QUFFaFAsU0FBU3VvQixTQUFULENBQW1CQyxRQUFuQixFQUE2QkMsVUFBN0IsRUFBeUM7QUFBRSxNQUFJLE9BQU9BLFVBQVAsS0FBc0IsVUFBdEIsSUFBb0NBLGVBQWUsSUFBdkQsRUFBNkQ7QUFBRSxVQUFNLElBQUlqOUIsU0FBSixDQUFjLHFFQUFvRWk5QixVQUFwRSx5Q0FBb0VBLFVBQXBFLEVBQWQsQ0FBTjtBQUFzRyxHQUFDRCxTQUFTaGtDLFNBQVQsR0FBcUIyRyxPQUFPb1EsTUFBUCxDQUFja3RCLGNBQWNBLFdBQVdqa0MsU0FBdkMsRUFBa0QsRUFBRW1XLGFBQWEsRUFBRWUsT0FBTzhzQixRQUFULEVBQW1CdG9CLFlBQVksS0FBL0IsRUFBc0NDLFVBQVUsSUFBaEQsRUFBc0RqRSxjQUFjLElBQXBFLEVBQWYsRUFBbEQsQ0FBckIsQ0FBcUssSUFBSXVzQixVQUFKLEVBQWdCdDlCLE9BQU91OUIsY0FBUCxHQUF3QnY5QixPQUFPdTlCLGNBQVAsQ0FBc0JGLFFBQXRCLEVBQWdDQyxVQUFoQyxDQUF4QixHQUFzRUQsU0FBU0csU0FBVCxHQUFxQkYsVUFBM0Y7QUFBd0c7O0FBSzllLElBQUltaUIsa0JBQWtCLFNBQVNBLGVBQVQsQ0FBeUIvd0MsS0FBekIsRUFBZ0M7QUFDcEQsU0FBTyxDQUFDLEVBQUVBLE1BQU1zVyxPQUFOLElBQWlCdFcsTUFBTXFXLE1BQXZCLElBQWlDclcsTUFBTW1XLE9BQXZDLElBQWtEblcsTUFBTW9XLFFBQTFELENBQVI7QUFDRCxDQUZEOztBQUlBOzs7O0FBSUEsSUFBSXc2QixPQUFPLFVBQVU3aEIsZ0JBQVYsRUFBNEI7QUFDckNMLFlBQVVraUIsSUFBVixFQUFnQjdoQixnQkFBaEI7O0FBRUEsV0FBUzZoQixJQUFULEdBQWdCO0FBQ2QsUUFBSTVoQixLQUFKLEVBQVdDLEtBQVgsRUFBa0JDLElBQWxCOztBQUVBWixvQkFBZ0IsSUFBaEIsRUFBc0JzaUIsSUFBdEI7O0FBRUEsU0FBSyxJQUFJcmpELE9BQU9qRCxVQUFVVCxNQUFyQixFQUE2Qk8sT0FBT0MsTUFBTWtELElBQU4sQ0FBcEMsRUFBaURDLE9BQU8sQ0FBN0QsRUFBZ0VBLE9BQU9ELElBQXZFLEVBQTZFQyxNQUE3RSxFQUFxRjtBQUNuRnBELFdBQUtvRCxJQUFMLElBQWFsRCxVQUFVa0QsSUFBVixDQUFiO0FBQ0Q7O0FBRUQsV0FBTzBoQyxRQUFRRixTQUFTQyxRQUFRVCwyQkFBMkIsSUFBM0IsRUFBaUNPLGlCQUFpQjFsQyxJQUFqQixDQUFzQnVCLEtBQXRCLENBQTRCbWtDLGdCQUE1QixFQUE4QyxDQUFDLElBQUQsRUFBT2psQyxNQUFQLENBQWNNLElBQWQsQ0FBOUMsQ0FBakMsQ0FBUixFQUE4RzZrQyxLQUF2SCxHQUErSEEsTUFBTStoQixXQUFOLEdBQW9CLFVBQVVoeEMsS0FBVixFQUFpQjtBQUNqTCxVQUFJaXZCLE1BQU1ucEIsS0FBTixDQUFZbXJDLE9BQWhCLEVBQXlCaGlCLE1BQU1ucEIsS0FBTixDQUFZbXJDLE9BQVosQ0FBb0JqeEMsS0FBcEI7O0FBRXpCLFVBQUksQ0FBQ0EsTUFBTUcsZ0JBQVAsSUFBMkI7QUFDL0JILFlBQU13VyxNQUFOLEtBQWlCLENBRGIsSUFDa0I7QUFDdEIsT0FBQ3lZLE1BQU1ucEIsS0FBTixDQUFZbFQsTUFGVCxJQUVtQjtBQUN2QixPQUFDbStDLGdCQUFnQi93QyxLQUFoQixDQUhELENBR3dCO0FBSHhCLFFBSUU7QUFDRUEsZ0JBQU1VLGNBQU47O0FBRUEsY0FBSTB1QixVQUFVSCxNQUFNbHdCLE9BQU4sQ0FBY3V3QixNQUFkLENBQXFCRixPQUFuQztBQUNBLGNBQUk4aEIsY0FBY2ppQixNQUFNbnBCLEtBQXhCO0FBQUEsY0FDSTdZLFVBQVVpa0QsWUFBWWprRCxPQUQxQjtBQUFBLGNBRUk4RixLQUFLbStDLFlBQVluK0MsRUFGckI7O0FBS0EsY0FBSTlGLE9BQUosRUFBYTtBQUNYbWlDLG9CQUFRbmlDLE9BQVIsQ0FBZ0I4RixFQUFoQjtBQUNELFdBRkQsTUFFTztBQUNMcThCLG9CQUFRNWtDLElBQVIsQ0FBYXVJLEVBQWI7QUFDRDtBQUNGO0FBQ0osS0F0QmMsRUFzQlppOEIsS0F0QkksR0FzQklSLDJCQUEyQlMsS0FBM0IsRUFBa0NDLElBQWxDLENBdEJYO0FBdUJEOztBQUVEMGhCLE9BQUtqbUQsU0FBTCxDQUFleWxDLE1BQWYsR0FBd0IsU0FBU0EsTUFBVCxHQUFrQjtBQUN4QyxRQUFJUCxTQUFTLEtBQUsvcEIsS0FBbEI7QUFBQSxRQUNJN1ksVUFBVTRpQyxPQUFPNWlDLE9BRHJCO0FBQUEsUUFFSThGLEtBQUs4OEIsT0FBTzk4QixFQUZoQjtBQUFBLFFBR0krUyxRQUFRZ3JDLHlCQUF5QmpoQixNQUF6QixFQUFpQyxDQUFDLFNBQUQsRUFBWSxJQUFaLENBQWpDLENBSFosQ0FEd0MsQ0FJeUI7O0FBRWpFLFFBQUkrZixPQUFPLEtBQUs3d0MsT0FBTCxDQUFhdXdCLE1BQWIsQ0FBb0JGLE9BQXBCLENBQTRCdWdCLFVBQTVCLENBQXVDLE9BQU81OEMsRUFBUCxLQUFjLFFBQWQsR0FBeUIsRUFBRWdnQixVQUFVaGdCLEVBQVosRUFBekIsR0FBNENBLEVBQW5GLENBQVg7O0FBRUEsV0FBTyxnQkFBTU8sYUFBTixDQUFvQixHQUFwQixFQUF5QnU1QixTQUFTLEVBQVQsRUFBYS9tQixLQUFiLEVBQW9CLEVBQUVtckMsU0FBUyxLQUFLRCxXQUFoQixFQUE2QnBCLE1BQU1BLElBQW5DLEVBQXBCLENBQXpCLENBQVA7QUFDRCxHQVREOztBQVdBLFNBQU9nQixJQUFQO0FBQ0QsQ0FqRFUsQ0FpRFQsZ0JBQU1qbkMsU0FqREcsQ0FBWDs7QUFtREFpbkMsS0FBSy9xQixTQUFMLEdBQWlCO0FBQ2ZvckIsV0FBUyxvQkFBVXB3QixJQURKO0FBRWZqdUIsVUFBUSxvQkFBVW9sQixNQUZIO0FBR2YvcUIsV0FBUyxvQkFBVTJuQyxJQUhKO0FBSWY3aEMsTUFBSSxvQkFBVTRpQyxTQUFWLENBQW9CLENBQUMsb0JBQVUzZCxNQUFYLEVBQW1CLG9CQUFVbGQsTUFBN0IsQ0FBcEIsRUFBMER1MUI7QUFKL0MsQ0FBakI7QUFNQXVnQixLQUFLaHFDLFlBQUwsR0FBb0I7QUFDbEIzWixXQUFTO0FBRFMsQ0FBcEI7QUFHQTJqRCxLQUFLdGdCLFlBQUwsR0FBb0I7QUFDbEJoQixVQUFRLG9CQUFVdUcsS0FBVixDQUFnQjtBQUN0QnpHLGFBQVMsb0JBQVV5RyxLQUFWLENBQWdCO0FBQ3ZCcnJDLFlBQU0sb0JBQVVxMkIsSUFBVixDQUFld1AsVUFERTtBQUV2QnBqQyxlQUFTLG9CQUFVNHpCLElBQVYsQ0FBZXdQLFVBRkQ7QUFHdkJzZixrQkFBWSxvQkFBVTl1QixJQUFWLENBQWV3UDtBQUhKLEtBQWhCLEVBSU5BO0FBTG1CLEdBQWhCLEVBTUxBO0FBUGUsQ0FBcEI7O2tCQVdldWdCLEk7Ozs7Ozs7OztBQzVGZjs7OztBQUlBO0FBQ0Fub0QsT0FBT0MsT0FBUCxHQUFpQixVQUFTeW9ELFlBQVQsRUFBdUI7QUFDdkMsS0FBSUMsT0FBTyxFQUFYOztBQUVBO0FBQ0FBLE1BQUt2aUQsUUFBTCxHQUFnQixTQUFTQSxRQUFULEdBQW9CO0FBQ25DLFNBQU8sS0FBS3NELEdBQUwsQ0FBUyxVQUFVMkQsSUFBVixFQUFnQjtBQUMvQixPQUFJb3VCLFVBQVVtdEIsdUJBQXVCdjdDLElBQXZCLEVBQTZCcTdDLFlBQTdCLENBQWQ7QUFDQSxPQUFHcjdDLEtBQUssQ0FBTCxDQUFILEVBQVk7QUFDWCxXQUFPLFlBQVlBLEtBQUssQ0FBTCxDQUFaLEdBQXNCLEdBQXRCLEdBQTRCb3VCLE9BQTVCLEdBQXNDLEdBQTdDO0FBQ0EsSUFGRCxNQUVPO0FBQ04sV0FBT0EsT0FBUDtBQUNBO0FBQ0QsR0FQTSxFQU9KN3hCLElBUEksQ0FPQyxFQVBELENBQVA7QUFRQSxFQVREOztBQVdBO0FBQ0ErK0MsTUFBSzdtRCxDQUFMLEdBQVMsVUFBUyttRCxPQUFULEVBQWtCQyxVQUFsQixFQUE4QjtBQUN0QyxNQUFHLE9BQU9ELE9BQVAsS0FBbUIsUUFBdEIsRUFDQ0EsVUFBVSxDQUFDLENBQUMsSUFBRCxFQUFPQSxPQUFQLEVBQWdCLEVBQWhCLENBQUQsQ0FBVjtBQUNELE1BQUlFLHlCQUF5QixFQUE3QjtBQUNBLE9BQUksSUFBSWpuRCxJQUFJLENBQVosRUFBZUEsSUFBSSxLQUFLVixNQUF4QixFQUFnQ1UsR0FBaEMsRUFBcUM7QUFDcEMsT0FBSXNMLEtBQUssS0FBS3RMLENBQUwsRUFBUSxDQUFSLENBQVQ7QUFDQSxPQUFHLE9BQU9zTCxFQUFQLEtBQWMsUUFBakIsRUFDQzI3Qyx1QkFBdUIzN0MsRUFBdkIsSUFBNkIsSUFBN0I7QUFDRDtBQUNELE9BQUl0TCxJQUFJLENBQVIsRUFBV0EsSUFBSSttRCxRQUFRem5ELE1BQXZCLEVBQStCVSxHQUEvQixFQUFvQztBQUNuQyxPQUFJdUwsT0FBT3c3QyxRQUFRL21ELENBQVIsQ0FBWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBRyxPQUFPdUwsS0FBSyxDQUFMLENBQVAsS0FBbUIsUUFBbkIsSUFBK0IsQ0FBQzA3Qyx1QkFBdUIxN0MsS0FBSyxDQUFMLENBQXZCLENBQW5DLEVBQW9FO0FBQ25FLFFBQUd5N0MsY0FBYyxDQUFDejdDLEtBQUssQ0FBTCxDQUFsQixFQUEyQjtBQUMxQkEsVUFBSyxDQUFMLElBQVV5N0MsVUFBVjtBQUNBLEtBRkQsTUFFTyxJQUFHQSxVQUFILEVBQWU7QUFDckJ6N0MsVUFBSyxDQUFMLElBQVUsTUFBTUEsS0FBSyxDQUFMLENBQU4sR0FBZ0IsU0FBaEIsR0FBNEJ5N0MsVUFBNUIsR0FBeUMsR0FBbkQ7QUFDQTtBQUNESCxTQUFLNW1ELElBQUwsQ0FBVXNMLElBQVY7QUFDQTtBQUNEO0FBQ0QsRUF4QkQ7QUF5QkEsUUFBT3M3QyxJQUFQO0FBQ0EsQ0ExQ0Q7O0FBNENBLFNBQVNDLHNCQUFULENBQWdDdjdDLElBQWhDLEVBQXNDcTdDLFlBQXRDLEVBQW9EO0FBQ25ELEtBQUlqdEIsVUFBVXB1QixLQUFLLENBQUwsS0FBVyxFQUF6QjtBQUNBLEtBQUkyN0MsYUFBYTM3QyxLQUFLLENBQUwsQ0FBakI7QUFDQSxLQUFJLENBQUMyN0MsVUFBTCxFQUFpQjtBQUNoQixTQUFPdnRCLE9BQVA7QUFDQTs7QUFFRCxLQUFJaXRCLGdCQUFnQixPQUFPTyxJQUFQLEtBQWdCLFVBQXBDLEVBQWdEO0FBQy9DLE1BQUlDLGdCQUFnQkMsVUFBVUgsVUFBVixDQUFwQjtBQUNBLE1BQUlJLGFBQWFKLFdBQVdLLE9BQVgsQ0FBbUIzL0MsR0FBbkIsQ0FBdUIsVUFBVVUsTUFBVixFQUFrQjtBQUN6RCxVQUFPLG1CQUFtQjQrQyxXQUFXTSxVQUE5QixHQUEyQ2wvQyxNQUEzQyxHQUFvRCxLQUEzRDtBQUNBLEdBRmdCLENBQWpCOztBQUlBLFNBQU8sQ0FBQ3F4QixPQUFELEVBQVVwNkIsTUFBVixDQUFpQituRCxVQUFqQixFQUE2Qi9uRCxNQUE3QixDQUFvQyxDQUFDNm5ELGFBQUQsQ0FBcEMsRUFBcUR0L0MsSUFBckQsQ0FBMEQsSUFBMUQsQ0FBUDtBQUNBOztBQUVELFFBQU8sQ0FBQzZ4QixPQUFELEVBQVU3eEIsSUFBVixDQUFlLElBQWYsQ0FBUDtBQUNBOztBQUVEO0FBQ0EsU0FBU3UvQyxTQUFULENBQW1CSSxTQUFuQixFQUE4QjtBQUM3QjtBQUNBLEtBQUlDLFNBQVNQLEtBQUszcEIsU0FBUzU1QixtQkFBbUJrcEMsS0FBS0MsU0FBTCxDQUFlMGEsU0FBZixDQUFuQixDQUFULENBQUwsQ0FBYjtBQUNBLEtBQUlyNkIsT0FBTyxpRUFBaUVzNkIsTUFBNUU7O0FBRUEsUUFBTyxTQUFTdDZCLElBQVQsR0FBZ0IsS0FBdkI7QUFDQSxDOzs7Ozs7QUMzRUQscURBQXFELGd3OEU7Ozs7OztBQ0FyRCxxREFBcUQsZ3M4RDs7Ozs7Ozs7O0FDQXJEOzs7O0FBQ0E7Ozs7QUFDQTs7QUFFQTs7OztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7QUFOQSxJQUFNdTZCLGdCQUFnQixxQ0FBdEI7O0FBUUEsbUJBQUE5a0QsQ0FBUSxHQUFSOztBQUVBLElBQU0ra0QsTUFBTTkrQyxTQUFTKytDLGNBQVQsQ0FBd0IsS0FBeEIsQ0FBWjtBQUNBLG1CQUFTaGlCLE1BQVQsQ0FDRTtBQUFBO0FBQUEsSUFBUSxTQUFTOGhCLGFBQWpCO0FBQ0U7QUFBQTtBQUFBO0FBQ0Usd0RBQU8sV0FBUCxFQUFhLE1BQUssR0FBbEIsRUFBc0IsUUFBUTtBQUFBLGVBQU8sZ0RBQU0sd0JBQU4sRUFBc0IsOEJBQXRCLEVBQTRDLDBCQUE1QyxHQUFQO0FBQUEsT0FBOUIsR0FERjtBQUVFLHdEQUFPLE1BQUsscUJBQVosRUFBa0MsUUFBUTtBQUFBLGVBQU8sZ0RBQU0sd0JBQU4sRUFBc0IsOEJBQXRCLEVBQTRDLDBCQUE1QyxFQUE4RCxNQUFLLFNBQW5FLEdBQVA7QUFBQSxPQUExQyxHQUZGO0FBR0Usd0RBQU8sTUFBSyxZQUFaLEVBQXlCLFFBQVE7QUFBQSxlQUFPLGdEQUFNLHdCQUFOLEVBQXNCLDhCQUF0QixFQUE0QywwQkFBNUMsRUFBOEQsTUFBSyxXQUFuRSxHQUFQO0FBQUEsT0FBakMsR0FIRjtBQUlFLHdEQUFPLFFBQVE7QUFBQSxlQUFPLGdEQUFNLHdCQUFOLEVBQXNCLDhCQUF0QixFQUE0QywwQkFBNUMsR0FBUDtBQUFBLE9BQWY7QUFKRjtBQURGLENBREYsRUFTQUMsR0FUQSxFOzs7Ozs7O0FDaEJBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSWgzQyxjQUFjLG1CQUFBL04sQ0FBUSxHQUFSLENBQWxCO0FBQ0EsSUFBSThZLGVBQWUsbUJBQUE5WSxDQUFRLEVBQVIsQ0FBbkI7O0FBRUEsSUFBSUQsZ0JBQWdCLG1CQUFBQyxDQUFRLEVBQVIsQ0FBcEI7QUFDQSxJQUFJbTRDLHNCQUFzQixtQkFBQW40QyxDQUFRLEdBQVIsQ0FBMUI7O0FBRUEsSUFBSXNhLG9CQUFvQnZNLFlBQVl1TSxpQkFBcEM7QUFDQSxJQUFJeEYscUJBQXFCL0csWUFBWStHLGtCQUFyQzs7QUFFQSxJQUFJbXdDLDZCQUE2QixNQUFqQztBQUNBLFNBQVNDLHFCQUFULENBQStCdDZDLElBQS9CLEVBQXFDO0FBQ25DLFNBQU8sQ0FBQyxLQUFLQSxJQUFOLEVBQVkvSyxPQUFaLENBQW9Cb2xELDBCQUFwQixFQUFnRCxLQUFoRCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU0Usa0JBQVQsQ0FBNEJDLGVBQTVCLEVBQTZDQyxjQUE3QyxFQUE2RDtBQUMzRCxPQUFLNXhCLElBQUwsR0FBWTJ4QixlQUFaO0FBQ0EsT0FBS3p6QyxPQUFMLEdBQWUwekMsY0FBZjtBQUNBLE9BQUtqcEMsS0FBTCxHQUFhLENBQWI7QUFDRDtBQUNEK29DLG1CQUFtQjVuRCxTQUFuQixDQUE2Qm9TLFVBQTdCLEdBQTBDLFlBQVk7QUFDcEQsT0FBSzhqQixJQUFMLEdBQVksSUFBWjtBQUNBLE9BQUs5aEIsT0FBTCxHQUFlLElBQWY7QUFDQSxPQUFLeUssS0FBTCxHQUFhLENBQWI7QUFDRCxDQUpEO0FBS0FyTyxZQUFZaUMsWUFBWixDQUF5Qm0xQyxrQkFBekIsRUFBNkM3cUMsaUJBQTdDOztBQUVBLFNBQVNnckMsa0JBQVQsQ0FBNEJDLFdBQTVCLEVBQXlDN2UsS0FBekMsRUFBZ0Rob0MsSUFBaEQsRUFBc0Q7QUFDcEQsTUFBSSswQixPQUFPOHhCLFlBQVk5eEIsSUFBdkI7QUFBQSxNQUNJOWhCLFVBQVU0ekMsWUFBWTV6QyxPQUQxQjs7QUFHQThoQixPQUFLeDNCLElBQUwsQ0FBVTBWLE9BQVYsRUFBbUIrMEIsS0FBbkIsRUFBMEI2ZSxZQUFZbnBDLEtBQVosRUFBMUI7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBWUEsU0FBU29wQyxlQUFULENBQXlCMWlELFFBQXpCLEVBQW1DMmlELFdBQW5DLEVBQWdESixjQUFoRCxFQUFnRTtBQUM5RCxNQUFJdmlELFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsV0FBT0EsUUFBUDtBQUNEO0FBQ0QsTUFBSTQwQyxrQkFBa0J5TixtQkFBbUI3MkMsU0FBbkIsQ0FBNkJtM0MsV0FBN0IsRUFBMENKLGNBQTFDLENBQXRCO0FBQ0FsTixzQkFBb0JyMUMsUUFBcEIsRUFBOEJ3aUQsa0JBQTlCLEVBQWtENU4sZUFBbEQ7QUFDQXlOLHFCQUFtQnYxQyxPQUFuQixDQUEyQjhuQyxlQUEzQjtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFTZ08sY0FBVCxDQUF3QkMsU0FBeEIsRUFBbUNDLFNBQW5DLEVBQThDQyxXQUE5QyxFQUEyREMsVUFBM0QsRUFBdUU7QUFDckUsT0FBSzF3QyxNQUFMLEdBQWN1d0MsU0FBZDtBQUNBLE9BQUtDLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0EsT0FBS255QixJQUFMLEdBQVlveUIsV0FBWjtBQUNBLE9BQUtsMEMsT0FBTCxHQUFlbTBDLFVBQWY7QUFDQSxPQUFLMXBDLEtBQUwsR0FBYSxDQUFiO0FBQ0Q7QUFDRHNwQyxlQUFlbm9ELFNBQWYsQ0FBeUJvUyxVQUF6QixHQUFzQyxZQUFZO0FBQ2hELE9BQUt5RixNQUFMLEdBQWMsSUFBZDtBQUNBLE9BQUt3d0MsU0FBTCxHQUFpQixJQUFqQjtBQUNBLE9BQUtueUIsSUFBTCxHQUFZLElBQVo7QUFDQSxPQUFLOWhCLE9BQUwsR0FBZSxJQUFmO0FBQ0EsT0FBS3lLLEtBQUwsR0FBYSxDQUFiO0FBQ0QsQ0FORDtBQU9Bck8sWUFBWWlDLFlBQVosQ0FBeUIwMUMsY0FBekIsRUFBeUM1d0Msa0JBQXpDOztBQUVBLFNBQVNpeEMseUJBQVQsQ0FBbUNSLFdBQW5DLEVBQWdEN2UsS0FBaEQsRUFBdURzZixRQUF2RCxFQUFpRTtBQUMvRCxNQUFJNXdDLFNBQVNtd0MsWUFBWW53QyxNQUF6QjtBQUFBLE1BQ0l3d0MsWUFBWUwsWUFBWUssU0FENUI7QUFBQSxNQUVJbnlCLE9BQU84eEIsWUFBWTl4QixJQUZ2QjtBQUFBLE1BR0k5aEIsVUFBVTR6QyxZQUFZNXpDLE9BSDFCOztBQU1BLE1BQUlzMEMsY0FBY3h5QixLQUFLeDNCLElBQUwsQ0FBVTBWLE9BQVYsRUFBbUIrMEIsS0FBbkIsRUFBMEI2ZSxZQUFZbnBDLEtBQVosRUFBMUIsQ0FBbEI7QUFDQSxNQUFJbmYsTUFBTXUxQixPQUFOLENBQWN5ekIsV0FBZCxDQUFKLEVBQWdDO0FBQzlCQyxpQ0FBNkJELFdBQTdCLEVBQTBDN3dDLE1BQTFDLEVBQWtENHdDLFFBQWxELEVBQTREam1ELGNBQWNvTixtQkFBMUU7QUFDRCxHQUZELE1BRU8sSUFBSTg0QyxlQUFlLElBQW5CLEVBQXlCO0FBQzlCLFFBQUludEMsYUFBYXJMLGNBQWIsQ0FBNEJ3NEMsV0FBNUIsQ0FBSixFQUE4QztBQUM1Q0Esb0JBQWNudEMsYUFBYWMsa0JBQWIsQ0FBZ0Nxc0MsV0FBaEM7QUFDZDtBQUNBO0FBQ0FMLG1CQUFhSyxZQUFZbmdELEdBQVosS0FBb0IsQ0FBQzRnQyxLQUFELElBQVVBLE1BQU01Z0MsR0FBTixLQUFjbWdELFlBQVluZ0QsR0FBeEQsSUFBK0RvL0Msc0JBQXNCZSxZQUFZbmdELEdBQWxDLElBQXlDLEdBQXhHLEdBQThHLEVBQTNILElBQWlJa2dELFFBSG5ILENBQWQ7QUFJRDtBQUNENXdDLFdBQU9oWSxJQUFQLENBQVk2b0QsV0FBWjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0MsNEJBQVQsQ0FBc0NwakQsUUFBdEMsRUFBZ0R4RixLQUFoRCxFQUF1RGlvQixNQUF2RCxFQUErRGtPLElBQS9ELEVBQXFFOWhCLE9BQXJFLEVBQThFO0FBQzVFLE1BQUl3MEMsZ0JBQWdCLEVBQXBCO0FBQ0EsTUFBSTVnQyxVQUFVLElBQWQsRUFBb0I7QUFDbEI0Z0Msb0JBQWdCakIsc0JBQXNCMy9CLE1BQXRCLElBQWdDLEdBQWhEO0FBQ0Q7QUFDRCxNQUFJbXlCLGtCQUFrQmdPLGVBQWVwM0MsU0FBZixDQUF5QmhSLEtBQXpCLEVBQWdDNm9ELGFBQWhDLEVBQStDMXlCLElBQS9DLEVBQXFEOWhCLE9BQXJELENBQXRCO0FBQ0F3bUMsc0JBQW9CcjFDLFFBQXBCLEVBQThCaWpELHlCQUE5QixFQUF5RHJPLGVBQXpEO0FBQ0FnTyxpQkFBZTkxQyxPQUFmLENBQXVCOG5DLGVBQXZCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFhQSxTQUFTME8sV0FBVCxDQUFxQnRqRCxRQUFyQixFQUErQjJ3QixJQUEvQixFQUFxQzloQixPQUFyQyxFQUE4QztBQUM1QyxNQUFJN08sWUFBWSxJQUFoQixFQUFzQjtBQUNwQixXQUFPQSxRQUFQO0FBQ0Q7QUFDRCxNQUFJc1MsU0FBUyxFQUFiO0FBQ0E4d0MsK0JBQTZCcGpELFFBQTdCLEVBQXVDc1MsTUFBdkMsRUFBK0MsSUFBL0MsRUFBcURxZSxJQUFyRCxFQUEyRDloQixPQUEzRDtBQUNBLFNBQU95RCxNQUFQO0FBQ0Q7O0FBRUQsU0FBU2l4Qyx1QkFBVCxDQUFpQzNPLGVBQWpDLEVBQWtEaFIsS0FBbEQsRUFBeURob0MsSUFBekQsRUFBK0Q7QUFDN0QsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBLFNBQVM0bkQsYUFBVCxDQUF1QnhqRCxRQUF2QixFQUFpQzZPLE9BQWpDLEVBQTBDO0FBQ3hDLFNBQU93bUMsb0JBQW9CcjFDLFFBQXBCLEVBQThCdWpELHVCQUE5QixFQUF1RCxJQUF2RCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVNocUMsT0FBVCxDQUFpQnZaLFFBQWpCLEVBQTJCO0FBQ3pCLE1BQUlzUyxTQUFTLEVBQWI7QUFDQTh3QywrQkFBNkJwakQsUUFBN0IsRUFBdUNzUyxNQUF2QyxFQUErQyxJQUEvQyxFQUFxRHJWLGNBQWNvTixtQkFBbkU7QUFDQSxTQUFPaUksTUFBUDtBQUNEOztBQUVELElBQUlnRyxnQkFBZ0I7QUFDbEJoVyxXQUFTb2dELGVBRFM7QUFFbEJ6Z0QsT0FBS3FoRCxXQUZhO0FBR2xCRixnQ0FBOEJBLDRCQUhaO0FBSWxCOXBDLFNBQU9rcUMsYUFKVztBQUtsQmpxQyxXQUFTQTtBQUxTLENBQXBCOztBQVFBaGhCLE9BQU9DLE9BQVAsR0FBaUI4ZixhQUFqQixDOzs7Ozs7O0FDN0xBOzs7Ozs7Ozs7OztBQVdBOztBQUVBLElBQUlwYSxpQkFBaUIsbUJBQUFoQixDQUFRLEVBQVIsQ0FBckI7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCOztBQUVBOzs7Ozs7O0FBT0EsSUFBSWlhLG9CQUFvQixTQUFwQkEsaUJBQW9CLENBQVVDLGNBQVYsRUFBMEI7QUFDaEQsTUFBSUMsUUFBUSxJQUFaO0FBQ0EsTUFBSUEsTUFBTUMsWUFBTixDQUFtQjNkLE1BQXZCLEVBQStCO0FBQzdCLFFBQUk0ZCxXQUFXRixNQUFNQyxZQUFOLENBQW1CeFcsR0FBbkIsRUFBZjtBQUNBdVcsVUFBTWxlLElBQU4sQ0FBV29lLFFBQVgsRUFBcUJILGNBQXJCO0FBQ0EsV0FBT0csUUFBUDtBQUNELEdBSkQsTUFJTztBQUNMLFdBQU8sSUFBSUYsS0FBSixDQUFVRCxjQUFWLENBQVA7QUFDRDtBQUNGLENBVEQ7O0FBV0EsSUFBSUksb0JBQW9CLFNBQXBCQSxpQkFBb0IsQ0FBVUMsRUFBVixFQUFjQyxFQUFkLEVBQWtCO0FBQ3hDLE1BQUlMLFFBQVEsSUFBWjtBQUNBLE1BQUlBLE1BQU1DLFlBQU4sQ0FBbUIzZCxNQUF2QixFQUErQjtBQUM3QixRQUFJNGQsV0FBV0YsTUFBTUMsWUFBTixDQUFtQnhXLEdBQW5CLEVBQWY7QUFDQXVXLFVBQU1sZSxJQUFOLENBQVdvZSxRQUFYLEVBQXFCRSxFQUFyQixFQUF5QkMsRUFBekI7QUFDQSxXQUFPSCxRQUFQO0FBQ0QsR0FKRCxNQUlPO0FBQ0wsV0FBTyxJQUFJRixLQUFKLENBQVVJLEVBQVYsRUFBY0MsRUFBZCxDQUFQO0FBQ0Q7QUFDRixDQVREOztBQVdBLElBQUlDLHNCQUFzQixTQUF0QkEsbUJBQXNCLENBQVVGLEVBQVYsRUFBY0MsRUFBZCxFQUFrQkUsRUFBbEIsRUFBc0I7QUFDOUMsTUFBSVAsUUFBUSxJQUFaO0FBQ0EsTUFBSUEsTUFBTUMsWUFBTixDQUFtQjNkLE1BQXZCLEVBQStCO0FBQzdCLFFBQUk0ZCxXQUFXRixNQUFNQyxZQUFOLENBQW1CeFcsR0FBbkIsRUFBZjtBQUNBdVcsVUFBTWxlLElBQU4sQ0FBV29lLFFBQVgsRUFBcUJFLEVBQXJCLEVBQXlCQyxFQUF6QixFQUE2QkUsRUFBN0I7QUFDQSxXQUFPTCxRQUFQO0FBQ0QsR0FKRCxNQUlPO0FBQ0wsV0FBTyxJQUFJRixLQUFKLENBQVVJLEVBQVYsRUFBY0MsRUFBZCxFQUFrQkUsRUFBbEIsQ0FBUDtBQUNEO0FBQ0YsQ0FURDs7QUFXQSxJQUFJNUYscUJBQXFCLFNBQXJCQSxrQkFBcUIsQ0FBVXlGLEVBQVYsRUFBY0MsRUFBZCxFQUFrQkUsRUFBbEIsRUFBc0JDLEVBQXRCLEVBQTBCO0FBQ2pELE1BQUlSLFFBQVEsSUFBWjtBQUNBLE1BQUlBLE1BQU1DLFlBQU4sQ0FBbUIzZCxNQUF2QixFQUErQjtBQUM3QixRQUFJNGQsV0FBV0YsTUFBTUMsWUFBTixDQUFtQnhXLEdBQW5CLEVBQWY7QUFDQXVXLFVBQU1sZSxJQUFOLENBQVdvZSxRQUFYLEVBQXFCRSxFQUFyQixFQUF5QkMsRUFBekIsRUFBNkJFLEVBQTdCLEVBQWlDQyxFQUFqQztBQUNBLFdBQU9OLFFBQVA7QUFDRCxHQUpELE1BSU87QUFDTCxXQUFPLElBQUlGLEtBQUosQ0FBVUksRUFBVixFQUFjQyxFQUFkLEVBQWtCRSxFQUFsQixFQUFzQkMsRUFBdEIsQ0FBUDtBQUNEO0FBQ0YsQ0FURDs7QUFXQSxJQUFJQyxtQkFBbUIsU0FBbkJBLGdCQUFtQixDQUFVUCxRQUFWLEVBQW9CO0FBQ3pDLE1BQUlGLFFBQVEsSUFBWjtBQUNBLElBQUVFLG9CQUFvQkYsS0FBdEIsSUFBK0IvZSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLGdFQUFqQixDQUF4QyxHQUE2SDRCLGVBQWUsSUFBZixDQUE1SixHQUFtTCxLQUFLLENBQXhMO0FBQ0FxWixXQUFTMUssVUFBVDtBQUNBLE1BQUl3SyxNQUFNQyxZQUFOLENBQW1CM2QsTUFBbkIsR0FBNEIwZCxNQUFNVSxRQUF0QyxFQUFnRDtBQUM5Q1YsVUFBTUMsWUFBTixDQUFtQmhkLElBQW5CLENBQXdCaWQsUUFBeEI7QUFDRDtBQUNGLENBUEQ7O0FBU0EsSUFBSVMsb0JBQW9CLEVBQXhCO0FBQ0EsSUFBSUMsaUJBQWlCZCxpQkFBckI7O0FBRUE7Ozs7Ozs7OztBQVNBLElBQUlqSyxlQUFlLFNBQWZBLFlBQWUsQ0FBVWdMLGVBQVYsRUFBMkJDLE1BQTNCLEVBQW1DO0FBQ3BEO0FBQ0E7QUFDQSxNQUFJQyxXQUFXRixlQUFmO0FBQ0FFLFdBQVNkLFlBQVQsR0FBd0IsRUFBeEI7QUFDQWMsV0FBUzVNLFNBQVQsR0FBcUIyTSxVQUFVRixjQUEvQjtBQUNBLE1BQUksQ0FBQ0csU0FBU0wsUUFBZCxFQUF3QjtBQUN0QkssYUFBU0wsUUFBVCxHQUFvQkMsaUJBQXBCO0FBQ0Q7QUFDREksV0FBU3RMLE9BQVQsR0FBbUJnTCxnQkFBbkI7QUFDQSxTQUFPTSxRQUFQO0FBQ0QsQ0FYRDs7QUFhQSxJQUFJbk4sY0FBYztBQUNoQmlDLGdCQUFjQSxZQURFO0FBRWhCaUsscUJBQW1CQSxpQkFGSDtBQUdoQksscUJBQW1CQSxpQkFISDtBQUloQkcsdUJBQXFCQSxtQkFKTDtBQUtoQjNGLHNCQUFvQkE7QUFMSixDQUFsQjs7QUFRQXpaLE9BQU9DLE9BQVAsR0FBaUJ5UyxXQUFqQixDOzs7Ozs7OztBQzlHQTs7Ozs7Ozs7OztBQVVBOzs7O0FBRUEsSUFBSS9NLGlCQUFpQixtQkFBQWhCLENBQVEsRUFBUixDQUFyQjs7QUFFQSxJQUFJcUgsb0JBQW9CLG1CQUFBckgsQ0FBUSxFQUFSLENBQXhCO0FBQ0EsSUFBSXNOLHFCQUFxQixtQkFBQXROLENBQVEsRUFBUixDQUF6Qjs7QUFFQSxJQUFJMmxDLGdCQUFnQixtQkFBQTNsQyxDQUFRLEVBQVIsQ0FBcEI7QUFDQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJKzZCLGlCQUFpQixtQkFBQS82QixDQUFRLEdBQVIsQ0FBckI7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJbzNDLFlBQVksR0FBaEI7QUFDQSxJQUFJQyxlQUFlLEdBQW5COztBQUVBOzs7Ozs7QUFNQTs7Ozs7QUFLQSxJQUFJQyxtQkFBbUIsS0FBdkI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTQyxlQUFULENBQXlCcDFDLFNBQXpCLEVBQW9DOG9CLEtBQXBDLEVBQTJDO0FBQ3pDO0FBQ0E7QUFDQSxNQUFJOW9CLGFBQWEsUUFBT0EsU0FBUCx5Q0FBT0EsU0FBUCxPQUFxQixRQUFsQyxJQUE4Q0EsVUFBVTJELEdBQVYsSUFBaUIsSUFBbkUsRUFBeUU7QUFDdkU7QUFDQSxXQUFPaTFCLGVBQWUvUCxNQUFmLENBQXNCN29CLFVBQVUyRCxHQUFoQyxDQUFQO0FBQ0Q7QUFDRDtBQUNBLFNBQU9tbEIsTUFBTXhwQixRQUFOLENBQWUsRUFBZixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBUysxQyx1QkFBVCxDQUFpQzEwQyxRQUFqQyxFQUEyQzIwQyxTQUEzQyxFQUFzRHZuQyxRQUF0RCxFQUFnRXduQyxlQUFoRSxFQUFpRjtBQUMvRSxNQUFJN3RDLGNBQWMvRyxRQUFkLHlDQUFjQSxRQUFkLENBQUo7O0FBRUEsTUFBSStHLFNBQVMsV0FBVCxJQUF3QkEsU0FBUyxTQUFyQyxFQUFnRDtBQUM5QztBQUNBL0csZUFBVyxJQUFYO0FBQ0Q7O0FBRUQsTUFBSUEsYUFBYSxJQUFiLElBQXFCK0csU0FBUyxRQUE5QixJQUEwQ0EsU0FBUyxRQUFuRDtBQUNKO0FBQ0E7QUFDQUEsV0FBUyxRQUFULElBQXFCL0csU0FBUzZLLFFBQVQsS0FBc0JMLGtCQUgzQyxFQUcrRDtBQUM3RDRDLGFBQVN3bkMsZUFBVCxFQUEwQjUwQyxRQUExQjtBQUNBO0FBQ0E7QUFDQTIwQyxrQkFBYyxFQUFkLEdBQW1CTCxZQUFZRyxnQkFBZ0J6MEMsUUFBaEIsRUFBMEIsQ0FBMUIsQ0FBL0IsR0FBOEQyMEMsU0FIOUQ7QUFJQSxXQUFPLENBQVA7QUFDRDs7QUFFRCxNQUFJL1EsS0FBSjtBQUNBLE1BQUlpUixRQUFKO0FBQ0EsTUFBSUMsZUFBZSxDQUFuQixDQXJCK0UsQ0FxQnpEO0FBQ3RCLE1BQUlDLGlCQUFpQkosY0FBYyxFQUFkLEdBQW1CTCxTQUFuQixHQUErQkssWUFBWUosWUFBaEU7O0FBRUEsTUFBSXA2QyxNQUFNdTFCLE9BQU4sQ0FBYzF2QixRQUFkLENBQUosRUFBNkI7QUFDM0IsU0FBSyxJQUFJM0YsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMkYsU0FBU3JHLE1BQTdCLEVBQXFDVSxHQUFyQyxFQUEwQztBQUN4Q3VwQyxjQUFRNWpDLFNBQVMzRixDQUFULENBQVI7QUFDQXc2QyxpQkFBV0UsaUJBQWlCTixnQkFBZ0I3USxLQUFoQixFQUF1QnZwQyxDQUF2QixDQUE1QjtBQUNBeTZDLHNCQUFnQkosd0JBQXdCOVEsS0FBeEIsRUFBK0JpUixRQUEvQixFQUF5Q3puQyxRQUF6QyxFQUFtRHduQyxlQUFuRCxDQUFoQjtBQUNEO0FBQ0YsR0FORCxNQU1PO0FBQ0wsUUFBSTdSLGFBQWFGLGNBQWM3aUMsUUFBZCxDQUFqQjtBQUNBLFFBQUkraUMsVUFBSixFQUFnQjtBQUNkLFVBQUlKLFdBQVdJLFdBQVc1cEMsSUFBWCxDQUFnQjZHLFFBQWhCLENBQWY7QUFDQSxVQUFJOGpDLElBQUo7QUFDQSxVQUFJZixlQUFlL2lDLFNBQVM2akMsT0FBNUIsRUFBcUM7QUFDbkMsWUFBSW1SLEtBQUssQ0FBVDtBQUNBLGVBQU8sQ0FBQyxDQUFDbFIsT0FBT25CLFNBQVNvQixJQUFULEVBQVIsRUFBeUJDLElBQWpDLEVBQXVDO0FBQ3JDSixrQkFBUUUsS0FBS255QixLQUFiO0FBQ0FrakMscUJBQVdFLGlCQUFpQk4sZ0JBQWdCN1EsS0FBaEIsRUFBdUJvUixJQUF2QixDQUE1QjtBQUNBRiwwQkFBZ0JKLHdCQUF3QjlRLEtBQXhCLEVBQStCaVIsUUFBL0IsRUFBeUN6bkMsUUFBekMsRUFBbUR3bkMsZUFBbkQsQ0FBaEI7QUFDRDtBQUNGLE9BUEQsTUFPTztBQUNMLFlBQUl0OEMsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsY0FBSTY0Qyx5QkFBeUIsRUFBN0I7QUFDQSxjQUFJMXdDLGtCQUFrQnVFLE9BQXRCLEVBQStCO0FBQzdCLGdCQUFJb3NDLDBCQUEwQjN3QyxrQkFBa0J1RSxPQUFsQixDQUEwQkYsT0FBMUIsRUFBOUI7QUFDQSxnQkFBSXNzQyx1QkFBSixFQUE2QjtBQUMzQkQsdUNBQXlCLGtDQUFrQ0MsdUJBQWxDLEdBQTRELElBQXJGO0FBQ0Q7QUFDRjtBQUNENThDLGtCQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUXEzQyxnQkFBUixFQUEwQixpRUFBaUUsOERBQWpFLEdBQWtJLHVEQUE1SixFQUFxTlMsc0JBQXJOLENBQXhDLEdBQXVSLEtBQUssQ0FBNVI7QUFDQVQsNkJBQW1CLElBQW5CO0FBQ0Q7QUFDRDtBQUNBLGVBQU8sQ0FBQyxDQUFDMVEsT0FBT25CLFNBQVNvQixJQUFULEVBQVIsRUFBeUJDLElBQWpDLEVBQXVDO0FBQ3JDLGNBQUkyRCxRQUFRN0QsS0FBS255QixLQUFqQjtBQUNBLGNBQUlnMkIsS0FBSixFQUFXO0FBQ1QvRCxvQkFBUStELE1BQU0sQ0FBTixDQUFSO0FBQ0FrTix1QkFBV0UsaUJBQWlCOWMsZUFBZS9QLE1BQWYsQ0FBc0J5ZixNQUFNLENBQU4sQ0FBdEIsQ0FBakIsR0FBbUQ0TSxZQUFuRCxHQUFrRUUsZ0JBQWdCN1EsS0FBaEIsRUFBdUIsQ0FBdkIsQ0FBN0U7QUFDQWtSLDRCQUFnQkosd0JBQXdCOVEsS0FBeEIsRUFBK0JpUixRQUEvQixFQUF5Q3puQyxRQUF6QyxFQUFtRHduQyxlQUFuRCxDQUFoQjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEtBaENELE1BZ0NPLElBQUk3dEMsU0FBUyxRQUFiLEVBQXVCO0FBQzVCLFVBQUlvdkIsV0FBVyxFQUFmO0FBQ0EsVUFBSTc5QixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Qys1QixtQkFBVyxvRUFBb0UsbUVBQXBFLEdBQTBJLGdCQUFySjtBQUNBLFlBQUluMkIsU0FBU20xQyxlQUFiLEVBQThCO0FBQzVCaGYscUJBQVcsbUVBQW1FLDREQUE5RTtBQUNEO0FBQ0QsWUFBSTV4QixrQkFBa0J1RSxPQUF0QixFQUErQjtBQUM3QixjQUFJbE4sT0FBTzJJLGtCQUFrQnVFLE9BQWxCLENBQTBCRixPQUExQixFQUFYO0FBQ0EsY0FBSWhOLElBQUosRUFBVTtBQUNSdTZCLHdCQUFZLGtDQUFrQ3Y2QixJQUFsQyxHQUF5QyxJQUFyRDtBQUNEO0FBQ0Y7QUFDRjtBQUNELFVBQUl3NUMsaUJBQWlCbDJDLE9BQU9jLFFBQVAsQ0FBckI7QUFDQSxjQUFTMUgsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQix1REFBakIsRUFBMEU4NEMsbUJBQW1CLGlCQUFuQixHQUF1Qyx1QkFBdUJoMEMsT0FBT29CLElBQVAsQ0FBWXhDLFFBQVosRUFBc0JtQyxJQUF0QixDQUEyQixJQUEzQixDQUF2QixHQUEwRCxHQUFqRyxHQUF1R2l6QyxjQUFqTCxFQUFpTWpmLFFBQWpNLENBQXhDLEdBQXFQajRCLGVBQWUsSUFBZixFQUFxQmszQyxtQkFBbUIsaUJBQW5CLEdBQXVDLHVCQUF1QmgwQyxPQUFPb0IsSUFBUCxDQUFZeEMsUUFBWixFQUFzQm1DLElBQXRCLENBQTJCLElBQTNCLENBQXZCLEdBQTBELEdBQWpHLEdBQXVHaXpDLGNBQTVILEVBQTRJamYsUUFBNUksQ0FBOVAsR0FBc1osS0FBSyxDQUEzWjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTzJlLFlBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxTQUFTTyxtQkFBVCxDQUE2QnIxQyxRQUE3QixFQUF1Q29OLFFBQXZDLEVBQWlEd25DLGVBQWpELEVBQWtFO0FBQ2hFLE1BQUk1MEMsWUFBWSxJQUFoQixFQUFzQjtBQUNwQixXQUFPLENBQVA7QUFDRDs7QUFFRCxTQUFPMDBDLHdCQUF3QjEwQyxRQUF4QixFQUFrQyxFQUFsQyxFQUFzQ29OLFFBQXRDLEVBQWdEd25DLGVBQWhELENBQVA7QUFDRDs7QUFFRHI4QyxPQUFPQyxPQUFQLEdBQWlCNjhDLG1CQUFqQixDOzs7Ozs7OztBQzlLQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQTs7Ozs7OztBQU9BLFNBQVNudEIsTUFBVCxDQUFnQmxsQixHQUFoQixFQUFxQjtBQUNuQixNQUFJMDBCLGNBQWMsT0FBbEI7QUFDQSxNQUFJQyxnQkFBZ0I7QUFDbEIsU0FBSyxJQURhO0FBRWxCLFNBQUs7QUFGYSxHQUFwQjtBQUlBLE1BQUlDLGdCQUFnQixDQUFDLEtBQUs1MEIsR0FBTixFQUFXakcsT0FBWCxDQUFtQjI2QixXQUFuQixFQUFnQyxVQUFVMVAsS0FBVixFQUFpQjtBQUNuRSxXQUFPMlAsY0FBYzNQLEtBQWQsQ0FBUDtBQUNELEdBRm1CLENBQXBCOztBQUlBLFNBQU8sTUFBTTRQLGFBQWI7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU0MsUUFBVCxDQUFrQjcwQixHQUFsQixFQUF1QjtBQUNyQixNQUFJODBCLGdCQUFnQixVQUFwQjtBQUNBLE1BQUlDLGtCQUFrQjtBQUNwQixVQUFNLEdBRGM7QUFFcEIsVUFBTTtBQUZjLEdBQXRCO0FBSUEsTUFBSUMsZUFBZWgxQixJQUFJLENBQUosTUFBVyxHQUFYLElBQWtCQSxJQUFJLENBQUosTUFBVyxHQUE3QixHQUFtQ0EsSUFBSXNsQixTQUFKLENBQWMsQ0FBZCxDQUFuQyxHQUFzRHRsQixJQUFJc2xCLFNBQUosQ0FBYyxDQUFkLENBQXpFOztBQUVBLFNBQU8sQ0FBQyxLQUFLMFAsWUFBTixFQUFvQmo3QixPQUFwQixDQUE0Qis2QixhQUE1QixFQUEyQyxVQUFVOVAsS0FBVixFQUFpQjtBQUNqRSxXQUFPK1AsZ0JBQWdCL1AsS0FBaEIsQ0FBUDtBQUNELEdBRk0sQ0FBUDtBQUdEOztBQUVELElBQUlpUSxpQkFBaUI7QUFDbkIvUCxVQUFRQSxNQURXO0FBRW5CMlAsWUFBVUE7QUFGUyxDQUFyQjs7QUFLQXQvQixPQUFPQyxPQUFQLEdBQWlCeS9CLGNBQWpCLEM7Ozs7Ozs7QUN6REE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJamlCLGVBQWUsbUJBQUE5WSxDQUFRLEVBQVIsQ0FBbkI7O0FBRUE7Ozs7O0FBS0EsSUFBSXVtRCxtQkFBbUJ6dEMsYUFBYVcsYUFBcEM7QUFDQSxJQUFJcmUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSXljLHdCQUF3QixtQkFBQTNiLENBQVEsRUFBUixDQUE1QjtBQUNBdW1ELHFCQUFtQjVxQyxzQkFBc0JsQyxhQUF6QztBQUNEOztBQUVEOzs7OztBQUtBLElBQUk0QixvQkFBb0I7QUFDdEIvYixLQUFHaW5ELGlCQUFpQixHQUFqQixDQURtQjtBQUV0QkMsUUFBTUQsaUJBQWlCLE1BQWpCLENBRmdCO0FBR3RCRSxXQUFTRixpQkFBaUIsU0FBakIsQ0FIYTtBQUl0QkcsUUFBTUgsaUJBQWlCLE1BQWpCLENBSmdCO0FBS3RCSSxXQUFTSixpQkFBaUIsU0FBakIsQ0FMYTtBQU10QkssU0FBT0wsaUJBQWlCLE9BQWpCLENBTmU7QUFPdEJNLFNBQU9OLGlCQUFpQixPQUFqQixDQVBlO0FBUXRCaG5ELEtBQUdnbkQsaUJBQWlCLEdBQWpCLENBUm1CO0FBU3RCTyxRQUFNUCxpQkFBaUIsTUFBakIsQ0FUZ0I7QUFVdEJRLE9BQUtSLGlCQUFpQixLQUFqQixDQVZpQjtBQVd0QlMsT0FBS1QsaUJBQWlCLEtBQWpCLENBWGlCO0FBWXRCVSxPQUFLVixpQkFBaUIsS0FBakIsQ0FaaUI7QUFhdEJXLGNBQVlYLGlCQUFpQixZQUFqQixDQWJVO0FBY3RCOUwsUUFBTThMLGlCQUFpQixNQUFqQixDQWRnQjtBQWV0QlksTUFBSVosaUJBQWlCLElBQWpCLENBZmtCO0FBZ0J0Qm45QixVQUFRbTlCLGlCQUFpQixRQUFqQixDQWhCYztBQWlCdEJhLFVBQVFiLGlCQUFpQixRQUFqQixDQWpCYztBQWtCdEJjLFdBQVNkLGlCQUFpQixTQUFqQixDQWxCYTtBQW1CdEJlLFFBQU1mLGlCQUFpQixNQUFqQixDQW5CZ0I7QUFvQnRCM2xELFFBQU0ybEQsaUJBQWlCLE1BQWpCLENBcEJnQjtBQXFCdEJnQixPQUFLaEIsaUJBQWlCLEtBQWpCLENBckJpQjtBQXNCdEJpQixZQUFVakIsaUJBQWlCLFVBQWpCLENBdEJZO0FBdUJ0Qmg4QixRQUFNZzhCLGlCQUFpQixNQUFqQixDQXZCZ0I7QUF3QnRCa0IsWUFBVWxCLGlCQUFpQixVQUFqQixDQXhCWTtBQXlCdEJtQixNQUFJbkIsaUJBQWlCLElBQWpCLENBekJrQjtBQTBCdEJvQixPQUFLcEIsaUJBQWlCLEtBQWpCLENBMUJpQjtBQTJCdEJxQixXQUFTckIsaUJBQWlCLFNBQWpCLENBM0JhO0FBNEJ0QnNCLE9BQUt0QixpQkFBaUIsS0FBakIsQ0E1QmlCO0FBNkJ0QnVCLFVBQVF2QixpQkFBaUIsUUFBakIsQ0E3QmM7QUE4QnRCd0IsT0FBS3hCLGlCQUFpQixLQUFqQixDQTlCaUI7QUErQnRCeUIsTUFBSXpCLGlCQUFpQixJQUFqQixDQS9Ca0I7QUFnQ3RCMEIsTUFBSTFCLGlCQUFpQixJQUFqQixDQWhDa0I7QUFpQ3RCMkIsTUFBSTNCLGlCQUFpQixJQUFqQixDQWpDa0I7QUFrQ3RCNEIsU0FBTzVCLGlCQUFpQixPQUFqQixDQWxDZTtBQW1DdEI2QixZQUFVN0IsaUJBQWlCLFVBQWpCLENBbkNZO0FBb0N0QjhCLGNBQVk5QixpQkFBaUIsWUFBakIsQ0FwQ1U7QUFxQ3RCK0IsVUFBUS9CLGlCQUFpQixRQUFqQixDQXJDYztBQXNDdEJnQyxVQUFRaEMsaUJBQWlCLFFBQWpCLENBdENjO0FBdUN0QmlDLFFBQU1qQyxpQkFBaUIsTUFBakIsQ0F2Q2dCO0FBd0N0QmtDLE1BQUlsQyxpQkFBaUIsSUFBakIsQ0F4Q2tCO0FBeUN0Qm1DLE1BQUluQyxpQkFBaUIsSUFBakIsQ0F6Q2tCO0FBMEN0Qm9DLE1BQUlwQyxpQkFBaUIsSUFBakIsQ0ExQ2tCO0FBMkN0QnFDLE1BQUlyQyxpQkFBaUIsSUFBakIsQ0EzQ2tCO0FBNEN0QnNDLE1BQUl0QyxpQkFBaUIsSUFBakIsQ0E1Q2tCO0FBNkN0QnVDLE1BQUl2QyxpQkFBaUIsSUFBakIsQ0E3Q2tCO0FBOEN0QndDLFFBQU14QyxpQkFBaUIsTUFBakIsQ0E5Q2dCO0FBK0N0QnlDLFVBQVF6QyxpQkFBaUIsUUFBakIsQ0EvQ2M7QUFnRHRCMEMsVUFBUTFDLGlCQUFpQixRQUFqQixDQWhEYztBQWlEdEIyQyxNQUFJM0MsaUJBQWlCLElBQWpCLENBakRrQjtBQWtEdEJ2bkMsUUFBTXVuQyxpQkFBaUIsTUFBakIsQ0FsRGdCO0FBbUR0QnBwRCxLQUFHb3BELGlCQUFpQixHQUFqQixDQW5EbUI7QUFvRHRCNEMsVUFBUTVDLGlCQUFpQixRQUFqQixDQXBEYztBQXFEdEI2QyxPQUFLN0MsaUJBQWlCLEtBQWpCLENBckRpQjtBQXNEdEI5TSxTQUFPOE0saUJBQWlCLE9BQWpCLENBdERlO0FBdUR0QjhDLE9BQUs5QyxpQkFBaUIsS0FBakIsQ0F2RGlCO0FBd0R0QitDLE9BQUsvQyxpQkFBaUIsS0FBakIsQ0F4RGlCO0FBeUR0QmdELFVBQVFoRCxpQkFBaUIsUUFBakIsQ0F6RGM7QUEwRHRCaUQsU0FBT2pELGlCQUFpQixPQUFqQixDQTFEZTtBQTJEdEJrRCxVQUFRbEQsaUJBQWlCLFFBQWpCLENBM0RjO0FBNER0Qm1ELE1BQUluRCxpQkFBaUIsSUFBakIsQ0E1RGtCO0FBNkR0Qm9ELFFBQU1wRCxpQkFBaUIsTUFBakIsQ0E3RGdCO0FBOER0QnFELFFBQU1yRCxpQkFBaUIsTUFBakIsQ0E5RGdCO0FBK0R0QnhoRCxPQUFLd2hELGlCQUFpQixLQUFqQixDQS9EaUI7QUFnRXRCc0QsUUFBTXRELGlCQUFpQixNQUFqQixDQWhFZ0I7QUFpRXRCdUQsUUFBTXZELGlCQUFpQixNQUFqQixDQWpFZ0I7QUFrRXRCd0QsWUFBVXhELGlCQUFpQixVQUFqQixDQWxFWTtBQW1FdEJ5RCxRQUFNekQsaUJBQWlCLE1BQWpCLENBbkVnQjtBQW9FdEIwRCxTQUFPMUQsaUJBQWlCLE9BQWpCLENBcEVlO0FBcUV0QjJELE9BQUszRCxpQkFBaUIsS0FBakIsQ0FyRWlCO0FBc0V0QjRELFlBQVU1RCxpQkFBaUIsVUFBakIsQ0F0RVk7QUF1RXRCNzRDLFVBQVE2NEMsaUJBQWlCLFFBQWpCLENBdkVjO0FBd0V0QjZELE1BQUk3RCxpQkFBaUIsSUFBakIsQ0F4RWtCO0FBeUV0QjhELFlBQVU5RCxpQkFBaUIsVUFBakIsQ0F6RVk7QUEwRXRCK0QsVUFBUS9ELGlCQUFpQixRQUFqQixDQTFFYztBQTJFdEJnRSxVQUFRaEUsaUJBQWlCLFFBQWpCLENBM0VjO0FBNEV0QmlFLEtBQUdqRSxpQkFBaUIsR0FBakIsQ0E1RW1CO0FBNkV0QmtFLFNBQU9sRSxpQkFBaUIsT0FBakIsQ0E3RWU7QUE4RXRCbUUsV0FBU25FLGlCQUFpQixTQUFqQixDQTlFYTtBQStFdEJvRSxPQUFLcEUsaUJBQWlCLEtBQWpCLENBL0VpQjtBQWdGdEJxRSxZQUFVckUsaUJBQWlCLFVBQWpCLENBaEZZO0FBaUZ0QnNFLEtBQUd0RSxpQkFBaUIsR0FBakIsQ0FqRm1CO0FBa0Z0QnVFLE1BQUl2RSxpQkFBaUIsSUFBakIsQ0FsRmtCO0FBbUZ0QndFLE1BQUl4RSxpQkFBaUIsSUFBakIsQ0FuRmtCO0FBb0Z0QnlFLFFBQU16RSxpQkFBaUIsTUFBakIsQ0FwRmdCO0FBcUZ0QjFnRCxLQUFHMGdELGlCQUFpQixHQUFqQixDQXJGbUI7QUFzRnRCMEUsUUFBTTFFLGlCQUFpQixNQUFqQixDQXRGZ0I7QUF1RnRCMkUsVUFBUTNFLGlCQUFpQixRQUFqQixDQXZGYztBQXdGdEI0RSxXQUFTNUUsaUJBQWlCLFNBQWpCLENBeEZhO0FBeUZ0QmpNLFVBQVFpTSxpQkFBaUIsUUFBakIsQ0F6RmM7QUEwRnRCNkUsU0FBTzdFLGlCQUFpQixPQUFqQixDQTFGZTtBQTJGdEI5Z0QsVUFBUThnRCxpQkFBaUIsUUFBakIsQ0EzRmM7QUE0RnRCOEUsUUFBTTlFLGlCQUFpQixNQUFqQixDQTVGZ0I7QUE2RnRCK0UsVUFBUS9FLGlCQUFpQixRQUFqQixDQTdGYztBQThGdEJnRixTQUFPaEYsaUJBQWlCLE9BQWpCLENBOUZlO0FBK0Z0QmlGLE9BQUtqRixpQkFBaUIsS0FBakIsQ0EvRmlCO0FBZ0d0QmtGLFdBQVNsRixpQkFBaUIsU0FBakIsQ0FoR2E7QUFpR3RCbUYsT0FBS25GLGlCQUFpQixLQUFqQixDQWpHaUI7QUFrR3RCb0YsU0FBT3BGLGlCQUFpQixPQUFqQixDQWxHZTtBQW1HdEJxRixTQUFPckYsaUJBQWlCLE9BQWpCLENBbkdlO0FBb0d0QnNGLE1BQUl0RixpQkFBaUIsSUFBakIsQ0FwR2tCO0FBcUd0QnVGLFlBQVV2RixpQkFBaUIsVUFBakIsQ0FyR1k7QUFzR3RCd0YsU0FBT3hGLGlCQUFpQixPQUFqQixDQXRHZTtBQXVHdEJ5RixNQUFJekYsaUJBQWlCLElBQWpCLENBdkdrQjtBQXdHdEIwRixTQUFPMUYsaUJBQWlCLE9BQWpCLENBeEdlO0FBeUd0QnQxQyxRQUFNczFDLGlCQUFpQixNQUFqQixDQXpHZ0I7QUEwR3RCOW9ELFNBQU84b0QsaUJBQWlCLE9BQWpCLENBMUdlO0FBMkd0QjJGLE1BQUkzRixpQkFBaUIsSUFBakIsQ0EzR2tCO0FBNEd0QnRhLFNBQU9zYSxpQkFBaUIsT0FBakIsQ0E1R2U7QUE2R3RCNEYsS0FBRzVGLGlCQUFpQixHQUFqQixDQTdHbUI7QUE4R3RCNkYsTUFBSTdGLGlCQUFpQixJQUFqQixDQTlHa0I7QUErR3RCLFNBQU9BLGlCQUFpQixLQUFqQixDQS9HZTtBQWdIdEI4RixTQUFPOUYsaUJBQWlCLE9BQWpCLENBaEhlO0FBaUh0QitGLE9BQUsvRixpQkFBaUIsS0FBakIsQ0FqSGlCOztBQW1IdEI7QUFDQWdHLFVBQVFoRyxpQkFBaUIsUUFBakIsQ0FwSGM7QUFxSHRCaUcsWUFBVWpHLGlCQUFpQixVQUFqQixDQXJIWTtBQXNIdEJrRyxRQUFNbEcsaUJBQWlCLE1BQWpCLENBdEhnQjtBQXVIdEJtRyxXQUFTbkcsaUJBQWlCLFNBQWpCLENBdkhhO0FBd0h0Qm9HLEtBQUdwRyxpQkFBaUIsR0FBakIsQ0F4SG1CO0FBeUh0QjF1QixTQUFPMHVCLGlCQUFpQixPQUFqQixDQXpIZTtBQTBIdEJxRyxRQUFNckcsaUJBQWlCLE1BQWpCLENBMUhnQjtBQTJIdEJzRyxrQkFBZ0J0RyxpQkFBaUIsZ0JBQWpCLENBM0hNO0FBNEh0QnVHLFFBQU12RyxpQkFBaUIsTUFBakIsQ0E1SGdCO0FBNkh0QnBoQyxRQUFNb2hDLGlCQUFpQixNQUFqQixDQTdIZ0I7QUE4SHRCL2lCLFdBQVMraUIsaUJBQWlCLFNBQWpCLENBOUhhO0FBK0h0QndHLFdBQVN4RyxpQkFBaUIsU0FBakIsQ0EvSGE7QUFnSXRCeUcsWUFBVXpHLGlCQUFpQixVQUFqQixDQWhJWTtBQWlJdEIwRyxrQkFBZ0IxRyxpQkFBaUIsZ0JBQWpCLENBaklNO0FBa0l0QjJHLFFBQU0zRyxpQkFBaUIsTUFBakIsQ0FsSWdCO0FBbUl0QjRHLFFBQU01RyxpQkFBaUIsTUFBakIsQ0FuSWdCO0FBb0l0QnI4QixPQUFLcThCLGlCQUFpQixLQUFqQixDQXBJaUI7QUFxSXRCMzdDLFFBQU0yN0MsaUJBQWlCLE1BQWpCLENBcklnQjtBQXNJdEI2RyxTQUFPN0csaUJBQWlCLE9BQWpCO0FBdEllLENBQXhCOztBQXlJQWxyRCxPQUFPQyxPQUFQLEdBQWlCK2YsaUJBQWpCLEM7Ozs7Ozs7O0FDdktBOzs7Ozs7Ozs7O0FBVUE7Ozs7QUFFQSxJQUFJcmEsaUJBQWlCLG1CQUFBaEIsQ0FBUSxFQUFSLENBQXJCOztBQUVBLElBQUlxdEQsNkJBQTZCLG1CQUFBcnRELENBQVEsR0FBUixDQUFqQztBQUNBLElBQUl5eEIsdUJBQXVCLG1CQUFBenhCLENBQVEsR0FBUixDQUEzQjs7QUFFQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJZ0ssc0JBQUo7O0FBRUEsSUFBSSxPQUFPNU8sT0FBUCxLQUFtQixXQUFuQixJQUFrQ0EsUUFBUXVDLEdBQTFDLElBQWlEdkMsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsTUFBOUUsRUFBc0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOEssMkJBQXlCLG1CQUFBaEssQ0FBUSxDQUFSLENBQXpCO0FBQ0Q7O0FBRUQsSUFBSTQ0QixxQkFBcUIsRUFBekI7O0FBRUE7Ozs7Ozs7Ozs7OztBQVlBLFNBQVNrTixrQkFBVCxDQUE0QnduQixTQUE1QixFQUF1Q2hwQixNQUF2QyxFQUErQ3JlLFFBQS9DLEVBQXlEeVMsYUFBekQsRUFBd0U5dUIsT0FBeEUsRUFBaUYyakQsT0FBakYsRUFBMEY7QUFDeEYsT0FBSyxJQUFJQyxZQUFULElBQXlCRixTQUF6QixFQUFvQztBQUNsQyxRQUFJQSxVQUFVbnFELGNBQVYsQ0FBeUJxcUQsWUFBekIsQ0FBSixFQUE0QztBQUMxQyxVQUFJN3RELEtBQUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJO0FBQ0Y7QUFDQTtBQUNBLFVBQUUsT0FBTzJ0RCxVQUFVRSxZQUFWLENBQVAsS0FBbUMsVUFBckMsSUFBbURweUQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixtRkFBakIsRUFBc0dzNUIsaUJBQWlCLGFBQXZILEVBQXNJMjBCLDJCQUEyQnBuQyxRQUEzQixDQUF0SSxFQUE0S3VuQyxZQUE1SyxDQUF4QyxHQUFvT3hzRCxlQUFlLElBQWYsRUFBcUIwM0IsaUJBQWlCLGFBQXRDLEVBQXFEMjBCLDJCQUEyQnBuQyxRQUEzQixDQUFyRCxFQUEyRnVuQyxZQUEzRixDQUF2UixHQUFrWSxLQUFLLENBQXZZO0FBQ0E3dEQsZ0JBQVEydEQsVUFBVUUsWUFBVixFQUF3QmxwQixNQUF4QixFQUFnQ2twQixZQUFoQyxFQUE4QzkwQixhQUE5QyxFQUE2RHpTLFFBQTdELEVBQXVFLElBQXZFLEVBQTZFd0wsb0JBQTdFLENBQVI7QUFDRCxPQUxELENBS0UsT0FBT2c4QixFQUFQLEVBQVc7QUFDWDl0RCxnQkFBUTh0RCxFQUFSO0FBQ0Q7QUFDRHJ5RCxjQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxDQUFDTixLQUFELElBQVVBLGlCQUFpQmpFLEtBQW5DLEVBQTBDLG9FQUFvRSwrREFBcEUsR0FBc0ksaUVBQXRJLEdBQTBNLGdFQUExTSxHQUE2USxpQ0FBdlQsRUFBMFZnOUIsaUJBQWlCLGFBQTNXLEVBQTBYMjBCLDJCQUEyQnBuQyxRQUEzQixDQUExWCxFQUFnYXVuQyxZQUFoYSxTQUFxYjd0RCxLQUFyYix5Q0FBcWJBLEtBQXJiLEVBQXhDLEdBQXNlLEtBQUssQ0FBM2U7QUFDQSxVQUFJQSxpQkFBaUJqRSxLQUFqQixJQUEwQixFQUFFaUUsTUFBTVUsT0FBTixJQUFpQnU0QixrQkFBbkIsQ0FBOUIsRUFBc0U7QUFDcEU7QUFDQTtBQUNBQSwyQkFBbUJqNUIsTUFBTVUsT0FBekIsSUFBb0MsSUFBcEM7O0FBRUEsWUFBSXF0RCxxQkFBcUIsRUFBekI7O0FBRUEsWUFBSXR5RCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxjQUFJLENBQUM4SyxzQkFBTCxFQUE2QjtBQUMzQkEscUNBQXlCLG1CQUFBaEssQ0FBUSxDQUFSLENBQXpCO0FBQ0Q7QUFDRCxjQUFJdXRELFlBQVksSUFBaEIsRUFBc0I7QUFDcEJHLGlDQUFxQjFqRCx1QkFBdUI4QixvQkFBdkIsQ0FBNEN5aEQsT0FBNUMsQ0FBckI7QUFDRCxXQUZELE1BRU8sSUFBSTNqRCxZQUFZLElBQWhCLEVBQXNCO0FBQzNCOGpELGlDQUFxQjFqRCx1QkFBdUJxQix1QkFBdkIsQ0FBK0N6QixPQUEvQyxDQUFyQjtBQUNEO0FBQ0Y7O0FBRUR4TyxnQkFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLHNCQUFmLEVBQXVDZ21CLFFBQXZDLEVBQWlEdG1CLE1BQU1VLE9BQXZELEVBQWdFcXRELGtCQUFoRSxDQUF4QyxHQUE4SCxLQUFLLENBQW5JO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRURyeUQsT0FBT0MsT0FBUCxHQUFpQndxQyxrQkFBakIsQzs7Ozs7Ozs7QUNyRkE7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUEsSUFBSXVuQiw2QkFBNkIsRUFBakM7O0FBRUEsSUFBSWp5RCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q211RCwrQkFBNkI7QUFDM0I3NEMsVUFBTSxNQURxQjtBQUUzQjdDLGFBQVMsU0FGa0I7QUFHM0JnOEMsa0JBQWM7QUFIYSxHQUE3QjtBQUtEOztBQUVEdHlELE9BQU9DLE9BQVAsR0FBaUIreEQsMEJBQWpCLEM7Ozs7Ozs7O0FDdkJBOzs7Ozs7Ozs7OztBQVdBOztBQUVBLElBQUk1N0IsdUJBQXVCLDhDQUEzQjs7QUFFQXAyQixPQUFPQyxPQUFQLEdBQWlCbTJCLG9CQUFqQixDOzs7Ozs7O0FDZkE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJbThCLFdBQVcsbUJBQUE1dEQsQ0FBUSxFQUFSLENBQWY7QUFBQSxJQUNJeU4saUJBQWlCbWdELFNBQVNuZ0QsY0FEOUI7O0FBR0EsSUFBSWlNLFVBQVUsbUJBQUExWixDQUFRLEVBQVIsQ0FBZDs7QUFFQTNFLE9BQU9DLE9BQVAsR0FBaUJvZSxRQUFRak0sY0FBUixDQUFqQixDOzs7Ozs7O0FDakJBOzs7Ozs7Ozs7QUFTQTs7OztBQUVBLElBQUlyUyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJRSxZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7QUFDQSxNQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDtBQUNBLE1BQUl5eEIsdUJBQXVCLG1CQUFBenhCLENBQVEsRUFBUixDQUEzQjtBQUNBLE1BQUk0NEIscUJBQXFCLEVBQXpCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7O0FBV0EsU0FBU0csY0FBVCxDQUF3QnUwQixTQUF4QixFQUFtQ2hwQixNQUFuQyxFQUEyQ3JlLFFBQTNDLEVBQXFEeVMsYUFBckQsRUFBb0VtMUIsUUFBcEUsRUFBOEU7QUFDNUUsTUFBSXp5RCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxTQUFLLElBQUlzdUQsWUFBVCxJQUF5QkYsU0FBekIsRUFBb0M7QUFDbEMsVUFBSUEsVUFBVW5xRCxjQUFWLENBQXlCcXFELFlBQXpCLENBQUosRUFBNEM7QUFDMUMsWUFBSTd0RCxLQUFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNGO0FBQ0E7QUFDQVAsb0JBQVUsT0FBT2t1RCxVQUFVRSxZQUFWLENBQVAsS0FBbUMsVUFBN0MsRUFBeUQsc0VBQXNFLGtCQUEvSCxFQUFtSjkwQixpQkFBaUIsYUFBcEssRUFBbUx6UyxRQUFuTCxFQUE2THVuQyxZQUE3TDtBQUNBN3RELGtCQUFRMnRELFVBQVVFLFlBQVYsRUFBd0JscEIsTUFBeEIsRUFBZ0NrcEIsWUFBaEMsRUFBOEM5MEIsYUFBOUMsRUFBNkR6UyxRQUE3RCxFQUF1RSxJQUF2RSxFQUE2RXdMLG9CQUE3RSxDQUFSO0FBQ0QsU0FMRCxDQUtFLE9BQU9nOEIsRUFBUCxFQUFXO0FBQ1g5dEQsa0JBQVE4dEQsRUFBUjtBQUNEO0FBQ0R4dEQsZ0JBQVEsQ0FBQ04sS0FBRCxJQUFVQSxpQkFBaUJqRSxLQUFuQyxFQUEwQyxvRUFBb0UsK0RBQXBFLEdBQXNJLGlFQUF0SSxHQUEwTSxnRUFBMU0sR0FBNlEsaUNBQXZULEVBQTBWZzlCLGlCQUFpQixhQUEzVyxFQUEwWHpTLFFBQTFYLEVBQW9ZdW5DLFlBQXBZLFNBQXlaN3RELEtBQXpaLHlDQUF5WkEsS0FBelo7QUFDQSxZQUFJQSxpQkFBaUJqRSxLQUFqQixJQUEwQixFQUFFaUUsTUFBTVUsT0FBTixJQUFpQnU0QixrQkFBbkIsQ0FBOUIsRUFBc0U7QUFDcEU7QUFDQTtBQUNBQSw2QkFBbUJqNUIsTUFBTVUsT0FBekIsSUFBb0MsSUFBcEM7O0FBRUEsY0FBSW9NLFFBQVFvaEQsV0FBV0EsVUFBWCxHQUF3QixFQUFwQzs7QUFFQTV0RCxrQkFBUSxLQUFSLEVBQWUsc0JBQWYsRUFBdUNnbUIsUUFBdkMsRUFBaUR0bUIsTUFBTVUsT0FBdkQsRUFBZ0VvTSxTQUFTLElBQVQsR0FBZ0JBLEtBQWhCLEdBQXdCLEVBQXhGO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRjs7QUFFRHBSLE9BQU9DLE9BQVAsR0FBaUJ5OUIsY0FBakIsQzs7Ozs7Ozs7QUM1REE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQTE5QixPQUFPQyxPQUFQLEdBQWlCLFFBQWpCLEM7Ozs7Ozs7QUNaQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlzeUQsV0FBVyxtQkFBQTV0RCxDQUFRLEVBQVIsQ0FBZjtBQUFBLElBQ0l1YyxZQUFZcXhDLFNBQVNyeEMsU0FEekI7O0FBR0EsSUFBSXV4QyxZQUFZLG1CQUFBOXRELENBQVEsRUFBUixDQUFoQjtBQUFBLElBQ0l5TixpQkFBaUJxZ0QsVUFBVXJnRCxjQUQvQjs7QUFHQSxJQUFJZzNCLHVCQUF1QixtQkFBQXprQyxDQUFRLEVBQVIsQ0FBM0I7QUFDQSxJQUFJMFosVUFBVSxtQkFBQTFaLENBQVEsR0FBUixDQUFkOztBQUVBM0UsT0FBT0MsT0FBUCxHQUFpQm9lLFFBQVE2QyxTQUFSLEVBQW1COU8sY0FBbkIsRUFBbUNnM0Isb0JBQW5DLENBQWpCLEM7Ozs7Ozs7QUNyQkE7Ozs7Ozs7Ozs7QUFVQTs7OztBQUVBLElBQUk1MkIsVUFBVSxtQkFBQTdOLENBQVEsR0FBUixDQUFkOztBQUVBLElBQUlrbUIsY0FBYyxtQkFBQWxtQixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJOC9DLGFBQWEsbUJBQUE5L0MsQ0FBUSxDQUFSLENBQWpCOztBQUVBLElBQUk1RSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJZSxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDtBQUNEOztBQUVELElBQUkrdEQsYUFBYSxRQUFqQjs7QUFFQTtBQUNBO0FBQ0EsU0FBU0MsUUFBVCxDQUFrQnptRCxFQUFsQixFQUFzQjtBQUNwQixTQUFPQSxFQUFQO0FBQ0Q7O0FBRUQsSUFBSThsRCwwQkFBSjtBQUNBLElBQUlqeUQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNtdUQsK0JBQTZCO0FBQzNCNzRDLFVBQU0sTUFEcUI7QUFFM0I3QyxhQUFTLFNBRmtCO0FBRzNCZzhDLGtCQUFjO0FBSGEsR0FBN0I7QUFLRCxDQU5ELE1BTU87QUFDTE4sK0JBQTZCLEVBQTdCO0FBQ0Q7O0FBRUQsU0FBUzN6QyxPQUFULENBQWlCZ3JCLGNBQWpCLEVBQWlDajNCLGNBQWpDLEVBQWlEZzNCLG9CQUFqRCxFQUF1RTtBQUNyRTs7OztBQUlBLE1BQUl3cEIsaUJBQWlCLEVBQXJCOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBLE1BQUlDLHNCQUFzQjtBQUN4Qjs7Ozs7O0FBTUFDLFlBQVEsYUFQZ0I7O0FBU3hCOzs7Ozs7O0FBT0FDLGFBQVMsYUFoQmU7O0FBa0J4Qjs7Ozs7O0FBTUEzMUIsZUFBVyxhQXhCYTs7QUEwQnhCOzs7Ozs7QUFNQXlLLGtCQUFjLGFBaENVOztBQWtDeEI7Ozs7OztBQU1BQyx1QkFBbUIsYUF4Q0s7O0FBMEN4Qjs7QUFFQTs7Ozs7Ozs7OztBQVVBOEQscUJBQWlCLG9CQXRETzs7QUF3RHhCOzs7Ozs7Ozs7Ozs7OztBQWNBb25CLHFCQUFpQixvQkF0RU87O0FBd0V4Qjs7OztBQUlBcHNCLHFCQUFpQixvQkE1RU87O0FBOEV4Qjs7Ozs7Ozs7Ozs7Ozs7O0FBZUFlLFlBQVEsYUE3RmdCOztBQStGeEI7O0FBRUE7Ozs7Ozs7QUFPQVQsd0JBQW9CLGFBeEdJOztBQTBHeEI7Ozs7Ozs7Ozs7QUFVQStyQix1QkFBbUIsYUFwSEs7O0FBc0h4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQXpyQiwrQkFBMkIsYUF6SUg7O0FBMkl4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkEwckIsMkJBQXVCLGFBL0pDOztBQWlLeEI7Ozs7Ozs7Ozs7Ozs7OztBQWVBQyx5QkFBcUIsYUFoTEc7O0FBa0x4Qjs7Ozs7Ozs7Ozs7O0FBWUFDLHdCQUFvQixhQTlMSTs7QUFnTXhCOzs7Ozs7Ozs7OztBQVdBMXJCLDBCQUFzQixhQTNNRTs7QUE2TXhCOztBQUVBOzs7Ozs7Ozs7O0FBVUEyckIscUJBQWlCO0FBek5PLEdBQTFCOztBQTROQTs7Ozs7Ozs7O0FBU0EsTUFBSUMscUJBQXFCO0FBQ3ZCN2tELGlCQUFhLHFCQUFTcTNCLFdBQVQsRUFBc0JyM0IsWUFBdEIsRUFBbUM7QUFDOUNxM0Isa0JBQVlyM0IsV0FBWixHQUEwQkEsWUFBMUI7QUFDRCxLQUhzQjtBQUl2QnFrRCxZQUFRLGdCQUFTaHRCLFdBQVQsRUFBc0JndEIsT0FBdEIsRUFBOEI7QUFDcEMsVUFBSUEsT0FBSixFQUFZO0FBQ1YsYUFBSyxJQUFJaHhELElBQUksQ0FBYixFQUFnQkEsSUFBSWd4RCxRQUFPMXhELE1BQTNCLEVBQW1DVSxHQUFuQyxFQUF3QztBQUN0Q3l4RCwrQkFBcUJ6dEIsV0FBckIsRUFBa0NndEIsUUFBT2h4RCxDQUFQLENBQWxDO0FBQ0Q7QUFDRjtBQUNGLEtBVnNCO0FBV3ZCZ21DLHVCQUFtQiwyQkFBU2hDLFdBQVQsRUFBc0JnQyxrQkFBdEIsRUFBeUM7QUFDMUQsVUFBSS9uQyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzJ2RCx3QkFBZ0IxdEIsV0FBaEIsRUFBNkJnQyxrQkFBN0IsRUFBZ0QsY0FBaEQ7QUFDRDtBQUNEaEMsa0JBQVlnQyxpQkFBWixHQUFnQ3QxQixRQUM5QixFQUQ4QixFQUU5QnN6QixZQUFZZ0MsaUJBRmtCLEVBRzlCQSxrQkFIOEIsQ0FBaEM7QUFLRCxLQXBCc0I7QUFxQnZCRCxrQkFBYyxzQkFBUy9CLFdBQVQsRUFBc0IrQixhQUF0QixFQUFvQztBQUNoRCxVQUFJOW5DLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDMnZELHdCQUFnQjF0QixXQUFoQixFQUE2QitCLGFBQTdCLEVBQTJDLFNBQTNDO0FBQ0Q7QUFDRC9CLGtCQUFZK0IsWUFBWixHQUEyQnIxQixRQUN6QixFQUR5QixFQUV6QnN6QixZQUFZK0IsWUFGYSxFQUd6QkEsYUFIeUIsQ0FBM0I7QUFLRCxLQTlCc0I7QUErQnZCOzs7O0FBSUErRCxxQkFBaUIseUJBQVM5RixXQUFULEVBQXNCOEYsZ0JBQXRCLEVBQXVDO0FBQ3RELFVBQUk5RixZQUFZOEYsZUFBaEIsRUFBaUM7QUFDL0I5RixvQkFBWThGLGVBQVosR0FBOEI2bkIsMkJBQzVCM3RCLFlBQVk4RixlQURnQixFQUU1QkEsZ0JBRjRCLENBQTlCO0FBSUQsT0FMRCxNQUtPO0FBQ0w5RixvQkFBWThGLGVBQVosR0FBOEJBLGdCQUE5QjtBQUNEO0FBQ0YsS0E1Q3NCO0FBNkN2QnhPLGVBQVcsbUJBQVMwSSxXQUFULEVBQXNCMUksVUFBdEIsRUFBaUM7QUFDMUMsVUFBSXI5QixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzJ2RCx3QkFBZ0IxdEIsV0FBaEIsRUFBNkIxSSxVQUE3QixFQUF3QyxNQUF4QztBQUNEO0FBQ0QwSSxrQkFBWTFJLFNBQVosR0FBd0I1cUIsUUFBUSxFQUFSLEVBQVlzekIsWUFBWTFJLFNBQXhCLEVBQW1DQSxVQUFuQyxDQUF4QjtBQUNELEtBbERzQjtBQW1EdkIyMUIsYUFBUyxpQkFBU2p0QixXQUFULEVBQXNCaXRCLFFBQXRCLEVBQStCO0FBQ3RDVyxpQ0FBMkI1dEIsV0FBM0IsRUFBd0NpdEIsUUFBeEM7QUFDRCxLQXJEc0I7QUFzRHZCWSxjQUFVLG9CQUFXLENBQUU7QUF0REEsR0FBekI7O0FBeURBLFdBQVNILGVBQVQsQ0FBeUIxdEIsV0FBekIsRUFBc0M4dEIsT0FBdEMsRUFBK0NocEMsUUFBL0MsRUFBeUQ7QUFDdkQsU0FBSyxJQUFJdFMsUUFBVCxJQUFxQnM3QyxPQUFyQixFQUE4QjtBQUM1QixVQUFJQSxRQUFROXJELGNBQVIsQ0FBdUJ3USxRQUF2QixDQUFKLEVBQXNDO0FBQ3BDO0FBQ0E7QUFDQSxZQUFJdlksUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNlLGtCQUNFLE9BQU9ndkQsUUFBUXQ3QyxRQUFSLENBQVAsS0FBNkIsVUFEL0IsRUFFRSxzRUFDRSxrQkFISixFQUlFd3RCLFlBQVlyM0IsV0FBWixJQUEyQixZQUo3QixFQUtFdWpELDJCQUEyQnBuQyxRQUEzQixDQUxGLEVBTUV0UyxRQU5GO0FBUUQ7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsV0FBU3U3QyxzQkFBVCxDQUFnQ0MsZ0JBQWhDLEVBQWtEendELElBQWxELEVBQXdEO0FBQ3RELFFBQUkwd0QsYUFBYWxCLG9CQUFvQi9xRCxjQUFwQixDQUFtQ3pFLElBQW5DLElBQ2J3dkQsb0JBQW9CeHZELElBQXBCLENBRGEsR0FFYixJQUZKOztBQUlBO0FBQ0EsUUFBSTJ3RCxnQkFBZ0Jsc0QsY0FBaEIsQ0FBK0J6RSxJQUEvQixDQUFKLEVBQTBDO0FBQ3hDb2hELGlCQUNFc1AsZUFBZSxlQURqQixFQUVFLHlEQUNFLG9FQURGLEdBRUUsb0NBSkosRUFLRTF3RCxJQUxGO0FBT0Q7O0FBRUQ7QUFDQSxRQUFJeXdELGdCQUFKLEVBQXNCO0FBQ3BCclAsaUJBQ0VzUCxlQUFlLGFBQWYsSUFBZ0NBLGVBQWUsb0JBRGpELEVBRUUsdURBQ0Usa0VBREYsR0FFRSxhQUpKLEVBS0Uxd0QsSUFMRjtBQU9EO0FBQ0Y7O0FBRUQ7Ozs7QUFJQSxXQUFTa3dELG9CQUFULENBQThCenRCLFdBQTlCLEVBQTJDbXVCLElBQTNDLEVBQWlEO0FBQy9DLFFBQUksQ0FBQ0EsSUFBTCxFQUFXO0FBQ1QsVUFBSWwwRCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxZQUFJcXdELG9CQUFvQkQsSUFBcEIseUNBQW9CQSxJQUFwQixDQUFKO0FBQ0EsWUFBSUUsZUFBZUQsZUFBZSxRQUFmLElBQTJCRCxTQUFTLElBQXZEOztBQUVBLFlBQUlsMEQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNlLGtCQUNFdXZELFlBREYsRUFFRSxrRUFDRSxnRUFERixHQUVFLGlEQUZGLEdBR0UsNkJBTEosRUFNRXJ1QixZQUFZcjNCLFdBQVosSUFBMkIsWUFON0IsRUFPRXdsRCxTQUFTLElBQVQsR0FBZ0IsSUFBaEIsR0FBdUJDLFVBUHpCO0FBU0Q7QUFDRjs7QUFFRDtBQUNEOztBQUVEelAsZUFDRSxPQUFPd1AsSUFBUCxLQUFnQixVQURsQixFQUVFLHNDQUNFLG9FQURGLEdBRUUsaUJBSko7QUFNQXhQLGVBQ0UsQ0FBQ3J5QyxlQUFlNmhELElBQWYsQ0FESCxFQUVFLHNDQUNFLGlFQUhKOztBQU1BLFFBQUlHLFFBQVF0dUIsWUFBWTVqQyxTQUF4QjtBQUNBLFFBQUlteUQsZ0JBQWdCRCxNQUFNRSxvQkFBMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBSUwsS0FBS25zRCxjQUFMLENBQW9CNHFELFVBQXBCLENBQUosRUFBcUM7QUFDbkNZLHlCQUFtQlIsTUFBbkIsQ0FBMEJodEIsV0FBMUIsRUFBdUNtdUIsS0FBS25CLE1BQTVDO0FBQ0Q7O0FBRUQsU0FBSyxJQUFJenZELElBQVQsSUFBaUI0d0QsSUFBakIsRUFBdUI7QUFDckIsVUFBSSxDQUFDQSxLQUFLbnNELGNBQUwsQ0FBb0J6RSxJQUFwQixDQUFMLEVBQWdDO0FBQzlCO0FBQ0Q7O0FBRUQsVUFBSUEsU0FBU3F2RCxVQUFiLEVBQXlCO0FBQ3ZCO0FBQ0E7QUFDRDs7QUFFRCxVQUFJNkIsV0FBV04sS0FBSzV3RCxJQUFMLENBQWY7QUFDQSxVQUFJeXdELG1CQUFtQk0sTUFBTXRzRCxjQUFOLENBQXFCekUsSUFBckIsQ0FBdkI7QUFDQXd3RCw2QkFBdUJDLGdCQUF2QixFQUF5Q3p3RCxJQUF6Qzs7QUFFQSxVQUFJaXdELG1CQUFtQnhyRCxjQUFuQixDQUFrQ3pFLElBQWxDLENBQUosRUFBNkM7QUFDM0Npd0QsMkJBQW1CandELElBQW5CLEVBQXlCeWlDLFdBQXpCLEVBQXNDeXVCLFFBQXRDO0FBQ0QsT0FGRCxNQUVPO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJQyxxQkFBcUIzQixvQkFBb0IvcUQsY0FBcEIsQ0FBbUN6RSxJQUFuQyxDQUF6QjtBQUNBLFlBQUlzVyxhQUFhLE9BQU80NkMsUUFBUCxLQUFvQixVQUFyQztBQUNBLFlBQUlFLGlCQUNGOTZDLGNBQ0EsQ0FBQzY2QyxrQkFERCxJQUVBLENBQUNWLGdCQUZELElBR0FHLEtBQUtOLFFBQUwsS0FBa0IsS0FKcEI7O0FBTUEsWUFBSWMsY0FBSixFQUFvQjtBQUNsQkosd0JBQWN0eUQsSUFBZCxDQUFtQnNCLElBQW5CLEVBQXlCa3hELFFBQXpCO0FBQ0FILGdCQUFNL3dELElBQU4sSUFBY2t4RCxRQUFkO0FBQ0QsU0FIRCxNQUdPO0FBQ0wsY0FBSVQsZ0JBQUosRUFBc0I7QUFDcEIsZ0JBQUlDLGFBQWFsQixvQkFBb0J4dkQsSUFBcEIsQ0FBakI7O0FBRUE7QUFDQW9oRCx1QkFDRStQLHVCQUNHVCxlQUFlLG9CQUFmLElBQ0NBLGVBQWUsYUFGbkIsQ0FERixFQUlFLHNEQUNFLGlDQUxKLEVBTUVBLFVBTkYsRUFPRTF3RCxJQVBGOztBQVVBO0FBQ0E7QUFDQSxnQkFBSTB3RCxlQUFlLG9CQUFuQixFQUF5QztBQUN2Q0ssb0JBQU0vd0QsSUFBTixJQUFjb3dELDJCQUEyQlcsTUFBTS93RCxJQUFOLENBQTNCLEVBQXdDa3hELFFBQXhDLENBQWQ7QUFDRCxhQUZELE1BRU8sSUFBSVIsZUFBZSxhQUFuQixFQUFrQztBQUN2Q0ssb0JBQU0vd0QsSUFBTixJQUFjcXhELHNCQUFzQk4sTUFBTS93RCxJQUFOLENBQXRCLEVBQW1Da3hELFFBQW5DLENBQWQ7QUFDRDtBQUNGLFdBckJELE1BcUJPO0FBQ0xILGtCQUFNL3dELElBQU4sSUFBY2t4RCxRQUFkO0FBQ0EsZ0JBQUl4MEQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM7QUFDQTtBQUNBLGtCQUFJLE9BQU8wd0QsUUFBUCxLQUFvQixVQUFwQixJQUFrQ04sS0FBS3hsRCxXQUEzQyxFQUF3RDtBQUN0RDJsRCxzQkFBTS93RCxJQUFOLEVBQVlvTCxXQUFaLEdBQTBCd2xELEtBQUt4bEQsV0FBTCxHQUFtQixHQUFuQixHQUF5QnBMLElBQW5EO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsV0FBU3F3RCwwQkFBVCxDQUFvQzV0QixXQUFwQyxFQUFpRGl0QixPQUFqRCxFQUEwRDtBQUN4RCxRQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaO0FBQ0Q7QUFDRCxTQUFLLElBQUkxdkQsSUFBVCxJQUFpQjB2RCxPQUFqQixFQUEwQjtBQUN4QixVQUFJd0IsV0FBV3hCLFFBQVExdkQsSUFBUixDQUFmO0FBQ0EsVUFBSSxDQUFDMHZELFFBQVFqckQsY0FBUixDQUF1QnpFLElBQXZCLENBQUwsRUFBbUM7QUFDakM7QUFDRDs7QUFFRCxVQUFJc3hELGFBQWF0eEQsUUFBUWl3RCxrQkFBekI7QUFDQTdPLGlCQUNFLENBQUNrUSxVQURILEVBRUUseURBQ0UscUVBREYsR0FFRSxzRUFGRixHQUdFLGNBTEosRUFNRXR4RCxJQU5GOztBQVNBLFVBQUl1eEQsY0FBY3Z4RCxRQUFReWlDLFdBQTFCO0FBQ0EyZSxpQkFDRSxDQUFDbVEsV0FESCxFQUVFLDhDQUNFLDhEQURGLEdBRUUsaUJBSkosRUFLRXZ4RCxJQUxGO0FBT0F5aUMsa0JBQVl6aUMsSUFBWixJQUFvQmt4RCxRQUFwQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQSxXQUFTTSw0QkFBVCxDQUFzQ0MsR0FBdEMsRUFBMkNDLEdBQTNDLEVBQWdEO0FBQzlDdFEsZUFDRXFRLE9BQU9DLEdBQVAsSUFBYyxRQUFPRCxHQUFQLHlDQUFPQSxHQUFQLE9BQWUsUUFBN0IsSUFBeUMsUUFBT0MsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBRDFELEVBRUUsMkRBRkY7O0FBS0EsU0FBSyxJQUFJdHFELEdBQVQsSUFBZ0JzcUQsR0FBaEIsRUFBcUI7QUFDbkIsVUFBSUEsSUFBSWp0RCxjQUFKLENBQW1CMkMsR0FBbkIsQ0FBSixFQUE2QjtBQUMzQmc2QyxtQkFDRXFRLElBQUlycUQsR0FBSixNQUFhM0csU0FEZixFQUVFLHFDQUNFLG9FQURGLEdBRUUsa0VBRkYsR0FHRSxtRUFIRixHQUlFLHFCQU5KLEVBT0UyRyxHQVBGO0FBU0FxcUQsWUFBSXJxRCxHQUFKLElBQVdzcUQsSUFBSXRxRCxHQUFKLENBQVg7QUFDRDtBQUNGO0FBQ0QsV0FBT3FxRCxHQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsV0FBU3JCLDBCQUFULENBQW9DcUIsR0FBcEMsRUFBeUNDLEdBQXpDLEVBQThDO0FBQzVDLFdBQU8sU0FBU0MsWUFBVCxHQUF3QjtBQUM3QixVQUFJL3dELElBQUk2d0QsSUFBSTN5RCxLQUFKLENBQVUsSUFBVixFQUFnQk4sU0FBaEIsQ0FBUjtBQUNBLFVBQUlxQyxJQUFJNndELElBQUk1eUQsS0FBSixDQUFVLElBQVYsRUFBZ0JOLFNBQWhCLENBQVI7QUFDQSxVQUFJb0MsS0FBSyxJQUFULEVBQWU7QUFDYixlQUFPQyxDQUFQO0FBQ0QsT0FGRCxNQUVPLElBQUlBLEtBQUssSUFBVCxFQUFlO0FBQ3BCLGVBQU9ELENBQVA7QUFDRDtBQUNELFVBQUlFLElBQUksRUFBUjtBQUNBMHdELG1DQUE2QjF3RCxDQUE3QixFQUFnQ0YsQ0FBaEM7QUFDQTR3RCxtQ0FBNkIxd0QsQ0FBN0IsRUFBZ0NELENBQWhDO0FBQ0EsYUFBT0MsQ0FBUDtBQUNELEtBWkQ7QUFhRDs7QUFFRDs7Ozs7Ozs7QUFRQSxXQUFTdXdELHFCQUFULENBQStCSSxHQUEvQixFQUFvQ0MsR0FBcEMsRUFBeUM7QUFDdkMsV0FBTyxTQUFTRSxlQUFULEdBQTJCO0FBQ2hDSCxVQUFJM3lELEtBQUosQ0FBVSxJQUFWLEVBQWdCTixTQUFoQjtBQUNBa3pELFVBQUk1eUQsS0FBSixDQUFVLElBQVYsRUFBZ0JOLFNBQWhCO0FBQ0QsS0FIRDtBQUlEOztBQUVEOzs7Ozs7O0FBT0EsV0FBU3F6RCxrQkFBVCxDQUE0QnB1RCxTQUE1QixFQUF1QzJOLE1BQXZDLEVBQStDO0FBQzdDLFFBQUkwZ0QsY0FBYzFnRCxPQUFPNkosSUFBUCxDQUFZeFgsU0FBWixDQUFsQjtBQUNBLFFBQUkvRyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3N4RCxrQkFBWUMsbUJBQVosR0FBa0N0dUQsU0FBbEM7QUFDQXF1RCxrQkFBWUUsa0JBQVosR0FBaUM1Z0QsTUFBakM7QUFDQTBnRCxrQkFBWUcscUJBQVosR0FBb0MsSUFBcEM7QUFDQSxVQUFJajRCLGdCQUFnQnYyQixVQUFVdVIsV0FBVixDQUFzQjVKLFdBQTFDO0FBQ0EsVUFBSThtRCxRQUFRSixZQUFZNzJDLElBQXhCO0FBQ0E2MkMsa0JBQVk3MkMsSUFBWixHQUFtQixVQUFTazNDLE9BQVQsRUFBa0I7QUFDbkMsYUFDRSxJQUFJMXdELE9BQU9qRCxVQUFVVCxNQUFyQixFQUNFTyxPQUFPQyxNQUFNa0QsT0FBTyxDQUFQLEdBQVdBLE9BQU8sQ0FBbEIsR0FBc0IsQ0FBNUIsQ0FEVCxFQUVFQyxPQUFPLENBSFgsRUFJRUEsT0FBT0QsSUFKVCxFQUtFQyxNQUxGLEVBTUU7QUFDQXBELGVBQUtvRCxPQUFPLENBQVosSUFBaUJsRCxVQUFVa0QsSUFBVixDQUFqQjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFlBQUl5d0QsWUFBWTF1RCxTQUFaLElBQXlCMHVELFlBQVksSUFBekMsRUFBK0M7QUFDN0MsY0FBSXoxRCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q2Usb0JBQ0UsS0FERixFQUVFLDhEQUNFLDRCQUhKLEVBSUV5NEIsYUFKRjtBQU1EO0FBQ0YsU0FURCxNQVNPLElBQUksQ0FBQzE3QixLQUFLUCxNQUFWLEVBQWtCO0FBQ3ZCLGNBQUlyQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q2Usb0JBQ0UsS0FERixFQUVFLGtFQUNFLDhEQURGLEdBRUUsaURBSkosRUFLRXk0QixhQUxGO0FBT0Q7QUFDRCxpQkFBTzgzQixXQUFQO0FBQ0Q7QUFDRCxZQUFJTSxnQkFBZ0JGLE1BQU1wekQsS0FBTixDQUFZZ3pELFdBQVosRUFBeUJ0ekQsU0FBekIsQ0FBcEI7QUFDQTR6RCxzQkFBY0wsbUJBQWQsR0FBb0N0dUQsU0FBcEM7QUFDQTJ1RCxzQkFBY0osa0JBQWQsR0FBbUM1Z0QsTUFBbkM7QUFDQWdoRCxzQkFBY0gscUJBQWQsR0FBc0MzekQsSUFBdEM7QUFDQSxlQUFPOHpELGFBQVA7QUFDRCxPQXhDRDtBQXlDRDtBQUNELFdBQU9OLFdBQVA7QUFDRDs7QUFFRDs7Ozs7QUFLQSxXQUFTTyxtQkFBVCxDQUE2QjV1RCxTQUE3QixFQUF3QztBQUN0QyxRQUFJNnVELFFBQVE3dUQsVUFBVXd0RCxvQkFBdEI7QUFDQSxTQUFLLElBQUl4eUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNnpELE1BQU12MEQsTUFBMUIsRUFBa0NVLEtBQUssQ0FBdkMsRUFBMEM7QUFDeEMsVUFBSTh6RCxjQUFjRCxNQUFNN3pELENBQU4sQ0FBbEI7QUFDQSxVQUFJMlMsU0FBU2toRCxNQUFNN3pELElBQUksQ0FBVixDQUFiO0FBQ0FnRixnQkFBVTh1RCxXQUFWLElBQXlCVixtQkFBbUJwdUQsU0FBbkIsRUFBOEIyTixNQUE5QixDQUF6QjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSW9oRCxvQkFBb0I7QUFDdEI1Qyx1QkFBbUIsNkJBQVc7QUFDNUIsV0FBSzZDLFdBQUwsR0FBbUIsSUFBbkI7QUFDRDtBQUhxQixHQUF4Qjs7QUFNQSxNQUFJQyxxQkFBcUI7QUFDdkJydUIsMEJBQXNCLGdDQUFXO0FBQy9CLFdBQUtvdUIsV0FBTCxHQUFtQixLQUFuQjtBQUNEO0FBSHNCLEdBQXpCOztBQU1BOzs7O0FBSUEsTUFBSTlCLGtCQUFrQjtBQUNwQjs7OztBQUlBcnFCLGtCQUFjLHNCQUFTcXNCLFFBQVQsRUFBbUJuaEQsUUFBbkIsRUFBNkI7QUFDekMsV0FBS3kwQixPQUFMLENBQWEvSSxtQkFBYixDQUFpQyxJQUFqQyxFQUF1Q3kxQixRQUF2QyxFQUFpRG5oRCxRQUFqRDtBQUNELEtBUG1COztBQVNwQjs7Ozs7O0FBTUF6RixlQUFXLHFCQUFXO0FBQ3BCLFVBQUlyUCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q2UsZ0JBQ0UsS0FBS3F4RCxrQkFEUCxFQUVFLGlFQUNFLGdFQURGLEdBRUUsdUJBSkosRUFLRyxLQUFLNTlDLFdBQUwsSUFBb0IsS0FBS0EsV0FBTCxDQUFpQjVKLFdBQXRDLElBQ0UsS0FBS3BMLElBRFAsSUFFRSxXQVBKO0FBU0EsYUFBSzR5RCxrQkFBTCxHQUEwQixJQUExQjtBQUNEO0FBQ0QsYUFBTyxDQUFDLENBQUMsS0FBS0gsV0FBZDtBQUNEO0FBN0JtQixHQUF0Qjs7QUFnQ0EsTUFBSUksc0JBQXNCLFNBQXRCQSxtQkFBc0IsR0FBVyxDQUFFLENBQXZDO0FBQ0ExakQsVUFDRTBqRCxvQkFBb0JoMEQsU0FEdEIsRUFFRW1uQyxlQUFlbm5DLFNBRmpCLEVBR0U4eEQsZUFIRjs7QUFNQTs7Ozs7Ozs7QUFRQSxXQUFTM3lDLFdBQVQsQ0FBcUI0eUMsSUFBckIsRUFBMkI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBSW51QixjQUFjNnNCLFNBQVMsVUFBU3QxQyxLQUFULEVBQWdCL0csT0FBaEIsRUFBeUJnekIsT0FBekIsRUFBa0M7QUFDM0Q7QUFDQTs7QUFFQSxVQUFJdnBDLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDZSxnQkFDRSxnQkFBZ0JraEMsV0FEbEIsRUFFRSx1RUFDRSxxREFISjtBQUtEOztBQUVEO0FBQ0EsVUFBSSxLQUFLd3VCLG9CQUFMLENBQTBCbHpELE1BQTlCLEVBQXNDO0FBQ3BDczBELDRCQUFvQixJQUFwQjtBQUNEOztBQUVELFdBQUtyNEMsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsV0FBSy9HLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFdBQUtpekIsSUFBTCxHQUFZMWUsV0FBWjtBQUNBLFdBQUt5ZSxPQUFMLEdBQWVBLFdBQVdGLG9CQUExQjs7QUFFQSxXQUFLdkUsS0FBTCxHQUFhLElBQWI7O0FBRUE7QUFDQTs7QUFFQSxVQUFJc3hCLGVBQWUsS0FBS25ELGVBQUwsR0FBdUIsS0FBS0EsZUFBTCxFQUF2QixHQUFnRCxJQUFuRTtBQUNBLFVBQUlqekQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM7QUFDQSxZQUNFc3lELGlCQUFpQnJ5RCxTQUFqQixJQUNBLEtBQUtrdkQsZUFBTCxDQUFxQm9ELGVBRnZCLEVBR0U7QUFDQTtBQUNBO0FBQ0FELHlCQUFlLElBQWY7QUFDRDtBQUNGO0FBQ0QxUixpQkFDRSxRQUFPMFIsWUFBUCx5Q0FBT0EsWUFBUCxPQUF3QixRQUF4QixJQUFvQyxDQUFDdjBELE1BQU11MUIsT0FBTixDQUFjZy9CLFlBQWQsQ0FEdkMsRUFFRSxxREFGRixFQUdFcndCLFlBQVlyM0IsV0FBWixJQUEyQix5QkFIN0I7O0FBTUEsV0FBS28yQixLQUFMLEdBQWFzeEIsWUFBYjtBQUNELEtBOUNpQixDQUFsQjtBQStDQXJ3QixnQkFBWTVqQyxTQUFaLEdBQXdCLElBQUlnMEQsbUJBQUosRUFBeEI7QUFDQXB3QixnQkFBWTVqQyxTQUFaLENBQXNCbVcsV0FBdEIsR0FBb0N5dEIsV0FBcEM7QUFDQUEsZ0JBQVk1akMsU0FBWixDQUFzQm95RCxvQkFBdEIsR0FBNkMsRUFBN0M7O0FBRUExQixtQkFBZTdvRCxPQUFmLENBQXVCd3BELHFCQUFxQmoxQyxJQUFyQixDQUEwQixJQUExQixFQUFnQ3duQixXQUFoQyxDQUF2Qjs7QUFFQXl0Qix5QkFBcUJ6dEIsV0FBckIsRUFBa0MrdkIsaUJBQWxDO0FBQ0F0Qyx5QkFBcUJ6dEIsV0FBckIsRUFBa0NtdUIsSUFBbEM7QUFDQVYseUJBQXFCenRCLFdBQXJCLEVBQWtDaXdCLGtCQUFsQzs7QUFFQTtBQUNBLFFBQUlqd0IsWUFBWThGLGVBQWhCLEVBQWlDO0FBQy9COUYsa0JBQVkzbkIsWUFBWixHQUEyQjJuQixZQUFZOEYsZUFBWixFQUEzQjtBQUNEOztBQUVELFFBQUk3ckMsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJaWlDLFlBQVk4RixlQUFoQixFQUFpQztBQUMvQjlGLG9CQUFZOEYsZUFBWixDQUE0QkMsb0JBQTVCLEdBQW1ELEVBQW5EO0FBQ0Q7QUFDRCxVQUFJL0YsWUFBWTVqQyxTQUFaLENBQXNCOHdELGVBQTFCLEVBQTJDO0FBQ3pDbHRCLG9CQUFZNWpDLFNBQVosQ0FBc0I4d0QsZUFBdEIsQ0FBc0NubkIsb0JBQXRDLEdBQTZELEVBQTdEO0FBQ0Q7QUFDRjs7QUFFRDRZLGVBQ0UzZSxZQUFZNWpDLFNBQVosQ0FBc0J5bEMsTUFEeEIsRUFFRSx5RUFGRjs7QUFLQSxRQUFJNW5DLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDZSxjQUNFLENBQUNraEMsWUFBWTVqQyxTQUFaLENBQXNCbTBELHFCQUR6QixFQUVFLDRCQUNFLGlFQURGLEdBRUUsNERBRkYsR0FHRSw2QkFMSixFQU1FcEMsS0FBS3hsRCxXQUFMLElBQW9CLGFBTnRCO0FBUUE3SixjQUNFLENBQUNraEMsWUFBWTVqQyxTQUFaLENBQXNCbzBELHlCQUR6QixFQUVFLDRCQUNFLHdFQUhKLEVBSUVyQyxLQUFLeGxELFdBQUwsSUFBb0IsYUFKdEI7QUFNRDs7QUFFRDtBQUNBLFNBQUssSUFBSW83QixVQUFULElBQXVCZ3BCLG1CQUF2QixFQUE0QztBQUMxQyxVQUFJLENBQUMvc0IsWUFBWTVqQyxTQUFaLENBQXNCMm5DLFVBQXRCLENBQUwsRUFBd0M7QUFDdEMvRCxvQkFBWTVqQyxTQUFaLENBQXNCMm5DLFVBQXRCLElBQW9DLElBQXBDO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPL0QsV0FBUDtBQUNEOztBQUVELFNBQU96a0IsV0FBUDtBQUNEOztBQUVEcmhCLE9BQU9DLE9BQVAsR0FBaUJvZSxPQUFqQixDOzs7Ozs7OztBQ3YyQkE7Ozs7OztBQU1BO0FBQ0E7O0FBQ0EsSUFBSXpWLHdCQUF3QkMsT0FBT0QscUJBQW5DO0FBQ0EsSUFBSWQsaUJBQWlCZSxPQUFPM0csU0FBUCxDQUFpQjRGLGNBQXRDO0FBQ0EsSUFBSWdCLG1CQUFtQkQsT0FBTzNHLFNBQVAsQ0FBaUI2RyxvQkFBeEM7O0FBRUEsU0FBU0MsUUFBVCxDQUFrQkMsR0FBbEIsRUFBdUI7QUFDdEIsS0FBSUEsUUFBUSxJQUFSLElBQWdCQSxRQUFRbkYsU0FBNUIsRUFBdUM7QUFDdEMsUUFBTSxJQUFJb0YsU0FBSixDQUFjLHVEQUFkLENBQU47QUFDQTs7QUFFRCxRQUFPTCxPQUFPSSxHQUFQLENBQVA7QUFDQTs7QUFFRCxTQUFTRSxlQUFULEdBQTJCO0FBQzFCLEtBQUk7QUFDSCxNQUFJLENBQUNOLE9BQU9PLE1BQVosRUFBb0I7QUFDbkIsVUFBTyxLQUFQO0FBQ0E7O0FBRUQ7O0FBRUE7QUFDQSxNQUFJQyxRQUFRLElBQUkxQyxNQUFKLENBQVcsS0FBWCxDQUFaLENBUkcsQ0FRNkI7QUFDaEMwQyxRQUFNLENBQU4sSUFBVyxJQUFYO0FBQ0EsTUFBSVIsT0FBT1MsbUJBQVAsQ0FBMkJELEtBQTNCLEVBQWtDLENBQWxDLE1BQXlDLEdBQTdDLEVBQWtEO0FBQ2pELFVBQU8sS0FBUDtBQUNBOztBQUVEO0FBQ0EsTUFBSUUsUUFBUSxFQUFaO0FBQ0EsT0FBSyxJQUFJekgsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEVBQXBCLEVBQXdCQSxHQUF4QixFQUE2QjtBQUM1QnlILFNBQU0sTUFBTTVDLE9BQU82QyxZQUFQLENBQW9CMUgsQ0FBcEIsQ0FBWixJQUFzQ0EsQ0FBdEM7QUFDQTtBQUNELE1BQUkySCxTQUFTWixPQUFPUyxtQkFBUCxDQUEyQkMsS0FBM0IsRUFBa0NHLEdBQWxDLENBQXNDLFVBQVVDLENBQVYsRUFBYTtBQUMvRCxVQUFPSixNQUFNSSxDQUFOLENBQVA7QUFDQSxHQUZZLENBQWI7QUFHQSxNQUFJRixPQUFPRyxJQUFQLENBQVksRUFBWixNQUFvQixZQUF4QixFQUFzQztBQUNyQyxVQUFPLEtBQVA7QUFDQTs7QUFFRDtBQUNBLE1BQUlDLFFBQVEsRUFBWjtBQUNBLHlCQUF1QkMsS0FBdkIsQ0FBNkIsRUFBN0IsRUFBaUNDLE9BQWpDLENBQXlDLFVBQVVDLE1BQVYsRUFBa0I7QUFDMURILFNBQU1HLE1BQU4sSUFBZ0JBLE1BQWhCO0FBQ0EsR0FGRDtBQUdBLE1BQUluQixPQUFPb0IsSUFBUCxDQUFZcEIsT0FBT08sTUFBUCxDQUFjLEVBQWQsRUFBa0JTLEtBQWxCLENBQVosRUFBc0NELElBQXRDLENBQTJDLEVBQTNDLE1BQ0Ysc0JBREYsRUFDMEI7QUFDekIsVUFBTyxLQUFQO0FBQ0E7O0FBRUQsU0FBTyxJQUFQO0FBQ0EsRUFyQ0QsQ0FxQ0UsT0FBT00sR0FBUCxFQUFZO0FBQ2I7QUFDQSxTQUFPLEtBQVA7QUFDQTtBQUNEOztBQUVEbEssT0FBT0MsT0FBUCxHQUFpQmtKLG9CQUFvQk4sT0FBT08sTUFBM0IsR0FBb0MsVUFBVWUsTUFBVixFQUFrQkMsTUFBbEIsRUFBMEI7QUFDOUUsS0FBSUMsSUFBSjtBQUNBLEtBQUlDLEtBQUt0QixTQUFTbUIsTUFBVCxDQUFUO0FBQ0EsS0FBSUksT0FBSjs7QUFFQSxNQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSTNJLFVBQVVULE1BQTlCLEVBQXNDb0osR0FBdEMsRUFBMkM7QUFDMUNILFNBQU94QixPQUFPaEgsVUFBVTJJLENBQVYsQ0FBUCxDQUFQOztBQUVBLE9BQUssSUFBSUMsR0FBVCxJQUFnQkosSUFBaEIsRUFBc0I7QUFDckIsT0FBSXZDLGVBQWVsSCxJQUFmLENBQW9CeUosSUFBcEIsRUFBMEJJLEdBQTFCLENBQUosRUFBb0M7QUFDbkNILE9BQUdHLEdBQUgsSUFBVUosS0FBS0ksR0FBTCxDQUFWO0FBQ0E7QUFDRDs7QUFFRCxNQUFJN0IscUJBQUosRUFBMkI7QUFDMUIyQixhQUFVM0Isc0JBQXNCeUIsSUFBdEIsQ0FBVjtBQUNBLFFBQUssSUFBSXZJLElBQUksQ0FBYixFQUFnQkEsSUFBSXlJLFFBQVFuSixNQUE1QixFQUFvQ1UsR0FBcEMsRUFBeUM7QUFDeEMsUUFBSWdILGlCQUFpQmxJLElBQWpCLENBQXNCeUosSUFBdEIsRUFBNEJFLFFBQVF6SSxDQUFSLENBQTVCLENBQUosRUFBNkM7QUFDNUN3SSxRQUFHQyxRQUFRekksQ0FBUixDQUFILElBQWlCdUksS0FBS0UsUUFBUXpJLENBQVIsQ0FBTCxDQUFqQjtBQUNBO0FBQ0Q7QUFDRDtBQUNEOztBQUVELFFBQU93SSxFQUFQO0FBQ0EsQ0F6QkQsQzs7Ozs7OztBQ2hFQTs7Ozs7Ozs7O0FBU0E7O0FBRUEsSUFBSTNFLGlCQUFpQixtQkFBQWhCLENBQVEsRUFBUixDQUFyQjs7QUFFQSxJQUFJOFksZUFBZSxtQkFBQTlZLENBQVEsRUFBUixDQUFuQjs7QUFFQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FBY0EsU0FBU3liLFNBQVQsQ0FBbUIzWSxRQUFuQixFQUE2QjtBQUMzQixHQUFDZ1csYUFBYXJMLGNBQWIsQ0FBNEIzSyxRQUE1QixDQUFELEdBQXlDMUgsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQix1RUFBakIsQ0FBeEMsR0FBb0k0QixlQUFlLEtBQWYsQ0FBN0ssR0FBcU0sS0FBSyxDQUExTTtBQUNBLFNBQU84QixRQUFQO0FBQ0Q7O0FBRUR6SCxPQUFPQyxPQUFQLEdBQWlCbWdCLFNBQWpCLEM7Ozs7Ozs7O0FDcENBOztBQUVBcGdCLE9BQU9DLE9BQVAsR0FBaUIsbUJBQUEwRSxDQUFRLEdBQVIsQ0FBakIsQzs7Ozs7OztBQ0ZBOzs7Ozs7Ozs7O0FBVUE7O0FBRUE7O0FBRUEsSUFBSWdFLHdCQUF3QixtQkFBQWhFLENBQVEsQ0FBUixDQUE1QjtBQUNBLElBQUk0eEQsd0JBQXdCLG1CQUFBNXhELENBQVEsR0FBUixDQUE1QjtBQUNBLElBQUk0N0MsYUFBYSxtQkFBQTU3QyxDQUFRLEVBQVIsQ0FBakI7QUFDQSxJQUFJaU8sa0JBQWtCLG1CQUFBak8sQ0FBUSxFQUFSLENBQXRCO0FBQ0EsSUFBSTBPLGVBQWUsbUJBQUExTyxDQUFRLEVBQVIsQ0FBbkI7QUFDQSxJQUFJdWIsZUFBZSxtQkFBQXZiLENBQVEsR0FBUixDQUFuQjs7QUFFQSxJQUFJNnhELGNBQWMsbUJBQUE3eEQsQ0FBUSxHQUFSLENBQWxCO0FBQ0EsSUFBSXEvQyxnQ0FBZ0MsbUJBQUFyL0MsQ0FBUSxFQUFSLENBQXBDO0FBQ0EsSUFBSTA5Qyw2QkFBNkIsbUJBQUExOUMsQ0FBUSxHQUFSLENBQWpDO0FBQ0EsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUE0eEQsc0JBQXNCRSxNQUF0Qjs7QUFFQSxJQUFJQyxXQUFXO0FBQ2JGLGVBQWFBLFdBREE7QUFFYjd1QixVQUFRNFksV0FBVzVZLE1BRk47QUFHYmtiLDBCQUF3QnRDLFdBQVdzQyxzQkFIdEI7QUFJYnJnRCxXQUFTMGQsWUFKSTs7QUFNYjtBQUNBeTJDLDJCQUF5QnRqRCxhQUFhdUIsY0FQekI7QUFRYmdpRCx1Q0FBcUN2VTtBQUNyQztBQVRhLENBQWY7O0FBWUE7QUFDQTtBQUNBLElBQUksT0FBT3dVLDhCQUFQLEtBQTBDLFdBQTFDLElBQXlELE9BQU9BLCtCQUErQkosTUFBdEMsS0FBaUQsVUFBOUcsRUFBMEg7QUFDeEhJLGlDQUErQkosTUFBL0IsQ0FBc0M7QUFDcENwZ0MsbUJBQWU7QUFDYmx1QixrQ0FBNEJRLHNCQUFzQlIsMEJBRHJDO0FBRWJNLDJCQUFxQiw2QkFBVXZCLElBQVYsRUFBZ0I7QUFDbkM7QUFDQSxZQUFJQSxLQUFLRixrQkFBVCxFQUE2QjtBQUMzQkUsaUJBQU84OEMsOEJBQThCOThDLElBQTlCLENBQVA7QUFDRDtBQUNELFlBQUlBLElBQUosRUFBVTtBQUNSLGlCQUFPeUIsc0JBQXNCRixtQkFBdEIsQ0FBMEN2QixJQUExQyxDQUFQO0FBQ0QsU0FGRCxNQUVPO0FBQ0wsaUJBQU8sSUFBUDtBQUNEO0FBQ0Y7QUFaWSxLQURxQjtBQWVwQzR2RCxXQUFPdlcsVUFmNkI7QUFnQnBDd1csZ0JBQVlua0Q7QUFoQndCLEdBQXRDO0FBa0JEOztBQUVELElBQUk3UyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJaUgsdUJBQXVCLG1CQUFBbkcsQ0FBUSxDQUFSLENBQTNCO0FBQ0EsTUFBSW1HLHFCQUFxQkosU0FBckIsSUFBa0NDLE9BQU9xc0QsR0FBUCxLQUFlcnNELE9BQU8rUyxJQUE1RCxFQUFrRTtBQUNoRTtBQUNBLFFBQUksT0FBT201Qyw4QkFBUCxLQUEwQyxXQUE5QyxFQUEyRDtBQUN6RDtBQUNBLFVBQUl2ekMsVUFBVUMsU0FBVixDQUFvQnBlLE9BQXBCLENBQTRCLFFBQTVCLElBQXdDLENBQUMsQ0FBekMsSUFBOENtZSxVQUFVQyxTQUFWLENBQW9CcGUsT0FBcEIsQ0FBNEIsTUFBNUIsTUFBd0MsQ0FBQyxDQUF2RixJQUE0Rm1lLFVBQVVDLFNBQVYsQ0FBb0JwZSxPQUFwQixDQUE0QixTQUE1QixJQUF5QyxDQUFDLENBQTFJLEVBQTZJO0FBQzNJO0FBQ0EsWUFBSTh4RCxxQkFBcUJ0c0QsT0FBT2lnQixRQUFQLENBQWdCc3NDLFFBQWhCLENBQXlCL3hELE9BQXpCLENBQWlDLE1BQWpDLE1BQTZDLENBQUMsQ0FBOUMsSUFBbURtZSxVQUFVQyxTQUFWLENBQW9CcGUsT0FBcEIsQ0FBNEIsU0FBNUIsTUFBMkMsQ0FBQyxDQUF4SDtBQUNBRixnQkFBUWt5RCxLQUFSLENBQWMsa0NBQWtDRixxQkFBcUIsa0RBQXJCLEdBQTBFLEVBQTVHLElBQWtILHVDQUFsSCxHQUE0Siw4QkFBMUs7QUFDRDtBQUNGOztBQUVELFFBQUlHLFdBQVcsU0FBU0MsTUFBVCxHQUFrQixDQUFFLENBQW5DO0FBQ0F0M0QsWUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsQ0FBQ3d5RCxTQUFTL3pELElBQVQsSUFBaUIrekQsU0FBU2h4RCxRQUFULEVBQWxCLEVBQXVDakIsT0FBdkMsQ0FBK0MsUUFBL0MsTUFBNkQsQ0FBQyxDQUF0RSxFQUF5RSx5RUFBeUUsc0VBQXpFLEdBQWtKLHVFQUFsSixHQUE0Tix3REFBclMsQ0FBeEMsR0FBeVksS0FBSyxDQUE5WTs7QUFFQTtBQUNBO0FBQ0EsUUFBSW15RCxzQkFBc0Ixc0QsU0FBU3lZLFlBQVQsSUFBeUJ6WSxTQUFTeVksWUFBVCxHQUF3QixDQUEzRTs7QUFFQXRqQixZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxDQUFDMHlELG1CQUFULEVBQThCLHdFQUF3RSw2REFBeEUsR0FBd0kseURBQXRLLENBQXhDLEdBQTJRLEtBQUssQ0FBaFI7O0FBRUEsUUFBSUMsbUJBQW1CO0FBQ3ZCO0FBQ0EzMUQsVUFBTXUxQixPQUZpQixFQUVSdjFCLE1BQU1NLFNBQU4sQ0FBZ0JpdEMsS0FGUixFQUVldnRDLE1BQU1NLFNBQU4sQ0FBZ0I2SCxPQUYvQixFQUV3Q25JLE1BQU1NLFNBQU4sQ0FBZ0JpRCxPQUZ4RCxFQUVpRXZELE1BQU1NLFNBQU4sQ0FBZ0J3SCxHQUZqRixFQUVzRjhOLEtBQUtDLEdBRjNGLEVBRWdHckwsU0FBU2xLLFNBQVQsQ0FBbUJvYyxJQUZuSCxFQUV5SHpWLE9BQU9vQixJQUZoSSxFQUVzSXRELE9BQU96RSxTQUFQLENBQWlCczFELElBRnZKLENBQXZCOztBQUlBLFNBQUssSUFBSTExRCxJQUFJLENBQWIsRUFBZ0JBLElBQUl5MUQsaUJBQWlCbjJELE1BQXJDLEVBQTZDVSxHQUE3QyxFQUFrRDtBQUNoRCxVQUFJLENBQUN5MUQsaUJBQWlCejFELENBQWpCLENBQUwsRUFBMEI7QUFDeEIvQixnQkFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLGdFQUFnRSx1Q0FBL0UsQ0FBeEMsR0FBa0ssS0FBSyxDQUF2SztBQUNBO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsSUFBSTdFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLE1BQUk2ZCx1QkFBdUIsbUJBQUEvYyxDQUFRLEVBQVIsQ0FBM0I7QUFDQSxNQUFJOHlELDhCQUE4QixtQkFBQTl5RCxDQUFRLEdBQVIsQ0FBbEM7QUFDQSxNQUFJK3lELGlDQUFpQyxtQkFBQS95RCxDQUFRLEdBQVIsQ0FBckM7QUFDQSxNQUFJZ3pELDBCQUEwQixtQkFBQWh6RCxDQUFRLEdBQVIsQ0FBOUI7O0FBRUErYyx1QkFBcUIzUCxTQUFyQixDQUErQjZsRCxPQUEvQixDQUF1Q0gsMkJBQXZDO0FBQ0EvMUMsdUJBQXFCM1AsU0FBckIsQ0FBK0I2bEQsT0FBL0IsQ0FBdUNGLDhCQUF2QztBQUNBaDJDLHVCQUFxQjNQLFNBQXJCLENBQStCNmxELE9BQS9CLENBQXVDRCx1QkFBdkM7QUFDRDs7QUFFRDMzRCxPQUFPQyxPQUFQLEdBQWlCeTJELFFBQWpCLEM7Ozs7Ozs7O0FDN0dBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSW1CLHdCQUF3QixtQkFBQWx6RCxDQUFRLEdBQVIsQ0FBNUI7QUFDQSxJQUFJbXpELHlCQUF5QixtQkFBQW56RCxDQUFRLEdBQVIsQ0FBN0I7QUFDQSxJQUFJb3pELG9CQUFvQixtQkFBQXB6RCxDQUFRLEdBQVIsQ0FBeEI7QUFDQSxJQUFJcXpELDBCQUEwQixtQkFBQXJ6RCxDQUFRLEdBQVIsQ0FBOUI7QUFDQSxJQUFJc3pELHdCQUF3QixtQkFBQXR6RCxDQUFRLEdBQVIsQ0FBNUI7QUFDQSxJQUFJdXpELHdCQUF3QixtQkFBQXZ6RCxDQUFRLEdBQVIsQ0FBNUI7QUFDQSxJQUFJd3pELG1DQUFtQyxtQkFBQXh6RCxDQUFRLEdBQVIsQ0FBdkM7QUFDQSxJQUFJeXpELG9CQUFvQixtQkFBQXp6RCxDQUFRLEdBQVIsQ0FBeEI7QUFDQSxJQUFJZ0Usd0JBQXdCLG1CQUFBaEUsQ0FBUSxDQUFSLENBQTVCO0FBQ0EsSUFBSTB6RCx5QkFBeUIsbUJBQUExekQsQ0FBUSxHQUFSLENBQTdCO0FBQ0EsSUFBSTJ6RCx3QkFBd0IsbUJBQUEzekQsQ0FBUSxHQUFSLENBQTVCO0FBQ0EsSUFBSTR6RCx3QkFBd0IsbUJBQUE1ekQsQ0FBUSxHQUFSLENBQTVCO0FBQ0EsSUFBSTZ6RCwrQkFBK0IsbUJBQUE3ekQsQ0FBUSxHQUFSLENBQW5DO0FBQ0EsSUFBSWt3QixxQkFBcUIsbUJBQUFsd0IsQ0FBUSxHQUFSLENBQXpCO0FBQ0EsSUFBSTh6RCxpQkFBaUIsbUJBQUE5ekQsQ0FBUSxHQUFSLENBQXJCO0FBQ0EsSUFBSTJPLDRCQUE0QixtQkFBQTNPLENBQVEsR0FBUixDQUFoQztBQUNBLElBQUkrekQsdUJBQXVCLG1CQUFBL3pELENBQVEsR0FBUixDQUEzQjtBQUNBLElBQUlnMEQsb0JBQW9CLG1CQUFBaDBELENBQVEsR0FBUixDQUF4QjtBQUNBLElBQUlpMEQsb0JBQW9CLG1CQUFBajBELENBQVEsR0FBUixDQUF4Qjs7QUFFQSxJQUFJazBELGtCQUFrQixLQUF0Qjs7QUFFQSxTQUFTcEMsTUFBVCxHQUFrQjtBQUNoQixNQUFJb0MsZUFBSixFQUFxQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0RBLG9CQUFrQixJQUFsQjs7QUFFQUosaUJBQWVLLFlBQWYsQ0FBNEJoa0Msd0JBQTVCLENBQXFERCxrQkFBckQ7O0FBRUE7OztBQUdBNGpDLGlCQUFlOXpDLGNBQWYsQ0FBOEI4QyxzQkFBOUIsQ0FBcUR1d0MsdUJBQXJEO0FBQ0FTLGlCQUFlN3pDLGdCQUFmLENBQWdDMlIsbUJBQWhDLENBQW9ENXRCLHFCQUFwRDtBQUNBOHZELGlCQUFlN3pDLGdCQUFmLENBQWdDNlIsbUJBQWhDLENBQW9ENmhDLHFCQUFwRDs7QUFFQTs7OztBQUlBRyxpQkFBZTl6QyxjQUFmLENBQThCK0Msd0JBQTlCLENBQXVEO0FBQ3JEa3hDLHVCQUFtQkEsaUJBRGtDO0FBRXJEWCwyQkFBdUJBLHFCQUY4QjtBQUdyREYsdUJBQW1CQSxpQkFIa0M7QUFJckRZLHVCQUFtQkEsaUJBSmtDO0FBS3JEYiw0QkFBd0JBO0FBTDZCLEdBQXZEOztBQVFBVyxpQkFBZU0sYUFBZixDQUE2Qm5kLDJCQUE3QixDQUF5RHdjLGlCQUF6RDs7QUFFQUssaUJBQWVNLGFBQWYsQ0FBNkJsZCx3QkFBN0IsQ0FBc0QwYyxxQkFBdEQ7O0FBRUFFLGlCQUFlN3lELFdBQWYsQ0FBMkI2VSx1QkFBM0IsQ0FBbURvOUMscUJBQW5EO0FBQ0FZLGlCQUFlN3lELFdBQWYsQ0FBMkI2VSx1QkFBM0IsQ0FBbUR5OUMscUJBQW5EO0FBQ0FPLGlCQUFlN3lELFdBQWYsQ0FBMkI2VSx1QkFBM0IsQ0FBbURpK0Msb0JBQW5EOztBQUVBRCxpQkFBZU8sY0FBZixDQUE4QnpkLDJCQUE5QixDQUEwRCxVQUFVQyxXQUFWLEVBQXVCO0FBQy9FLFdBQU8sSUFBSTZjLHNCQUFKLENBQTJCN2MsV0FBM0IsQ0FBUDtBQUNELEdBRkQ7O0FBSUFpZCxpQkFBZVEsT0FBZixDQUF1QnppRCwwQkFBdkIsQ0FBa0RsRCx5QkFBbEQ7QUFDQW1sRCxpQkFBZVEsT0FBZixDQUF1QnZpRCxzQkFBdkIsQ0FBOEM4aEQsNEJBQTlDOztBQUVBQyxpQkFBZXYzQyxTQUFmLENBQXlCbWQsaUJBQXpCLENBQTJDODVCLGdDQUEzQztBQUNEOztBQUVEbjRELE9BQU9DLE9BQVAsR0FBaUI7QUFDZncyRCxVQUFRQTtBQURPLENBQWpCLEM7Ozs7Ozs7QUNsRkE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJb0Isd0JBQXdCO0FBQzFCajlDLGNBQVk7QUFDVjtBQUNBLG9CQUFnQixDQUZOLEVBRVM7QUFDbkIsb0JBQWdCLENBSE47QUFJVixxQkFBaUIsQ0FKUCxFQUlVO0FBQ3BCLG1CQUFlLENBTEwsRUFLUTtBQUNsQixvQkFBZ0IsQ0FOTixFQU1TO0FBQ25CLHlCQUFxQixDQVBYO0FBUVYsa0JBQWMsQ0FSSjtBQVNWLDRCQUF3QixDQVRkO0FBVVY7QUFDQSx5QkFBcUIsQ0FYWDtBQVlWLG9CQUFnQixDQVpOO0FBYVYscUJBQWlCLENBYlA7QUFjVixxQkFBaUIsQ0FkUDtBQWVWLGtCQUFjLENBZko7QUFnQlYsa0JBQWMsQ0FoQko7QUFpQlYsc0JBQWtCLENBakJSO0FBa0JWLDRCQUF3QixDQWxCZDtBQW1CVix3QkFBb0IsQ0FuQlY7QUFvQlYsd0JBQW9CLENBcEJWO0FBcUJWLG9CQUFnQixDQXJCTjtBQXNCVixxQkFBaUIsQ0F0QlA7QUF1QlYscUJBQWlCLENBdkJQO0FBd0JWLHFCQUFpQixDQXhCUDtBQXlCVixpQkFBYSxDQXpCSDtBQTBCVixxQkFBaUIsQ0ExQlA7QUEyQlYscUJBQWlCLENBM0JQO0FBNEJWLHFCQUFpQixDQTVCUDtBQTZCVixzQkFBa0IsQ0E3QlI7QUE4QlY7QUFDQSxtQkFBZSxDQS9CTDtBQWdDVixpQkFBYSxDQWhDSDtBQWlDVixpQkFBYSxDQWpDSDtBQWtDVixxQkFBaUIsQ0FsQ1A7QUFtQ1Y7QUFDQSx1QkFBbUIsQ0FwQ1Q7QUFxQ1Ysb0JBQWdCLENBckNOO0FBc0NWO0FBQ0EsNkJBQXlCLENBdkNmO0FBd0NWLHFCQUFpQixDQXhDUDtBQXlDVixxQkFBaUIsQ0F6Q1A7QUEwQ1Ysb0JBQWdCLENBMUNOO0FBMkNWLHFCQUFpQixDQTNDUDtBQTRDVix3QkFBb0IsQ0E1Q1Y7QUE2Q1YseUJBQXFCLENBN0NYO0FBOENWLG1CQUFlLENBOUNMO0FBK0NWLHVCQUFtQixDQS9DVDtBQWdEVixpQkFBYSxDQWhESDtBQWlEVixxQkFBaUIsQ0FqRFA7QUFrRFYscUJBQWlCLENBbERQO0FBbURWLHFCQUFpQixDQW5EUDtBQW9EVixvQkFBZ0IsQ0FwRE47QUFxRFYsb0JBQWdCO0FBckROLEdBRGM7QUF3RDFCRSxxQkFBbUIsRUF4RE87QUF5RDFCQyxvQkFBa0I7QUF6RFEsQ0FBNUI7O0FBNERBL2EsT0FBT0MsT0FBUCxHQUFpQjQzRCxxQkFBakIsQzs7Ozs7OztBQ3hFQTs7Ozs7Ozs7OztBQVVBOzs7O0FBRUEsSUFBSXB4QyxtQkFBbUIsbUJBQUE5aEIsQ0FBUSxFQUFSLENBQXZCO0FBQ0EsSUFBSW1HLHVCQUF1QixtQkFBQW5HLENBQVEsQ0FBUixDQUEzQjtBQUNBLElBQUl1MEQsMkJBQTJCLG1CQUFBdjBELENBQVEsR0FBUixDQUEvQjtBQUNBLElBQUl3MEQsNEJBQTRCLG1CQUFBeDBELENBQVEsR0FBUixDQUFoQztBQUNBLElBQUl5MEQsc0JBQXNCLG1CQUFBejBELENBQVEsR0FBUixDQUExQjs7QUFFQSxJQUFJMDBELGVBQWUsQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLEVBQVIsRUFBWSxFQUFaLENBQW5CLEMsQ0FBb0M7QUFDcEMsSUFBSUMsZ0JBQWdCLEdBQXBCOztBQUVBLElBQUlDLHlCQUF5Qnp1RCxxQkFBcUJKLFNBQXJCLElBQWtDLHNCQUFzQkMsTUFBckY7O0FBRUEsSUFBSTBZLGVBQWUsSUFBbkI7QUFDQSxJQUFJdlkscUJBQXFCSixTQUFyQixJQUFrQyxrQkFBa0JFLFFBQXhELEVBQWtFO0FBQ2hFeVksaUJBQWV6WSxTQUFTeVksWUFBeEI7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxJQUFJbTJDLHVCQUF1QjF1RCxxQkFBcUJKLFNBQXJCLElBQWtDLGVBQWVDLE1BQWpELElBQTJELENBQUMwWSxZQUE1RCxJQUE0RSxDQUFDbzJDLFVBQXhHOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUlDLDZCQUE2QjV1RCxxQkFBcUJKLFNBQXJCLEtBQW1DLENBQUM2dUQsc0JBQUQsSUFBMkJsMkMsZ0JBQWdCQSxlQUFlLENBQS9CLElBQW9DQSxnQkFBZ0IsRUFBbEgsQ0FBakM7O0FBRUE7Ozs7QUFJQSxTQUFTbzJDLFFBQVQsR0FBb0I7QUFDbEIsTUFBSUUsUUFBUWh2RCxPQUFPZ3ZELEtBQW5CO0FBQ0EsU0FBTyxRQUFPQSxLQUFQLHlDQUFPQSxLQUFQLE9BQWlCLFFBQWpCLElBQTZCLE9BQU9BLE1BQU1uM0QsT0FBYixLQUF5QixVQUF0RCxJQUFvRXFMLFNBQVM4ckQsTUFBTW4zRCxPQUFOLEVBQVQsRUFBMEIsRUFBMUIsS0FBaUMsRUFBNUc7QUFDRDs7QUFFRCxJQUFJbzNELGdCQUFnQixFQUFwQjtBQUNBLElBQUlDLGdCQUFnQmx6RCxPQUFPNkMsWUFBUCxDQUFvQm93RCxhQUFwQixDQUFwQjs7QUFFQTtBQUNBLElBQUl2dUMsYUFBYTtBQUNmeXVDLGVBQWE7QUFDWDMwQyw2QkFBeUI7QUFDdkI0MEMsZUFBUyxlQURjO0FBRXZCQyxnQkFBVTtBQUZhLEtBRGQ7QUFLWG51QyxrQkFBYyxDQUFDLG1CQUFELEVBQXNCLGFBQXRCLEVBQXFDLGNBQXJDLEVBQXFELFVBQXJEO0FBTEgsR0FERTtBQVFmb3VDLGtCQUFnQjtBQUNkOTBDLDZCQUF5QjtBQUN2QjQwQyxlQUFTLGtCQURjO0FBRXZCQyxnQkFBVTtBQUZhLEtBRFg7QUFLZG51QyxrQkFBYyxDQUFDLFNBQUQsRUFBWSxtQkFBWixFQUFpQyxZQUFqQyxFQUErQyxhQUEvQyxFQUE4RCxVQUE5RCxFQUEwRSxjQUExRTtBQUxBLEdBUkQ7QUFlZnF1QyxvQkFBa0I7QUFDaEIvMEMsNkJBQXlCO0FBQ3ZCNDBDLGVBQVMsb0JBRGM7QUFFdkJDLGdCQUFVO0FBRmEsS0FEVDtBQUtoQm51QyxrQkFBYyxDQUFDLFNBQUQsRUFBWSxxQkFBWixFQUFtQyxZQUFuQyxFQUFpRCxhQUFqRCxFQUFnRSxVQUFoRSxFQUE0RSxjQUE1RTtBQUxFLEdBZkg7QUFzQmZzdUMscUJBQW1CO0FBQ2pCaDFDLDZCQUF5QjtBQUN2QjQwQyxlQUFTLHFCQURjO0FBRXZCQyxnQkFBVTtBQUZhLEtBRFI7QUFLakJudUMsa0JBQWMsQ0FBQyxTQUFELEVBQVksc0JBQVosRUFBb0MsWUFBcEMsRUFBa0QsYUFBbEQsRUFBaUUsVUFBakUsRUFBNkUsY0FBN0U7QUFMRztBQXRCSixDQUFqQjs7QUErQkE7QUFDQSxJQUFJdXVDLG1CQUFtQixLQUF2Qjs7QUFFQTs7Ozs7QUFLQSxTQUFTQyxpQkFBVCxDQUEyQnRpRCxXQUEzQixFQUF3QztBQUN0QyxTQUFPLENBQUNBLFlBQVkyVixPQUFaLElBQXVCM1YsWUFBWTZWLE1BQW5DLElBQTZDN1YsWUFBWThWLE9BQTFEO0FBQ1A7QUFDQSxJQUFFOVYsWUFBWTJWLE9BQVosSUFBdUIzVixZQUFZNlYsTUFBckMsQ0FGQTtBQUdEOztBQUVEOzs7Ozs7QUFNQSxTQUFTMHNDLHVCQUFULENBQWlDbHlDLFlBQWpDLEVBQStDO0FBQzdDLFVBQVFBLFlBQVI7QUFDRSxTQUFLLHFCQUFMO0FBQ0UsYUFBT2lELFdBQVc2dUMsZ0JBQWxCO0FBQ0YsU0FBSyxtQkFBTDtBQUNFLGFBQU83dUMsV0FBVzR1QyxjQUFsQjtBQUNGLFNBQUssc0JBQUw7QUFDRSxhQUFPNXVDLFdBQVc4dUMsaUJBQWxCO0FBTko7QUFRRDs7QUFFRDs7Ozs7Ozs7QUFRQSxTQUFTSSwwQkFBVCxDQUFvQ255QyxZQUFwQyxFQUFrRHJRLFdBQWxELEVBQStEO0FBQzdELFNBQU9xUSxpQkFBaUIsWUFBakIsSUFBaUNyUSxZQUFZa3NCLE9BQVosS0FBd0JxMUIsYUFBaEU7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVNrQix3QkFBVCxDQUFrQ3B5QyxZQUFsQyxFQUFnRHJRLFdBQWhELEVBQTZEO0FBQzNELFVBQVFxUSxZQUFSO0FBQ0UsU0FBSyxVQUFMO0FBQ0U7QUFDQSxhQUFPaXhDLGFBQWFsMEQsT0FBYixDQUFxQjRTLFlBQVlrc0IsT0FBakMsTUFBOEMsQ0FBQyxDQUF0RDtBQUNGLFNBQUssWUFBTDtBQUNFO0FBQ0E7QUFDQSxhQUFPbHNCLFlBQVlrc0IsT0FBWixLQUF3QnExQixhQUEvQjtBQUNGLFNBQUssYUFBTDtBQUNBLFNBQUssY0FBTDtBQUNBLFNBQUssU0FBTDtBQUNFO0FBQ0EsYUFBTyxJQUFQO0FBQ0Y7QUFDRSxhQUFPLEtBQVA7QUFkSjtBQWdCRDs7QUFFRDs7Ozs7Ozs7O0FBU0EsU0FBU21CLHNCQUFULENBQWdDMWlELFdBQWhDLEVBQTZDO0FBQzNDLE1BQUlzUixTQUFTdFIsWUFBWXNSLE1BQXpCO0FBQ0EsTUFBSSxRQUFPQSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCLFVBQVVBLE1BQTVDLEVBQW9EO0FBQ2xELFdBQU9BLE9BQU82RixJQUFkO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFRDtBQUNBLElBQUl3ckMscUJBQXFCLElBQXpCOztBQUVBOzs7QUFHQSxTQUFTQyx1QkFBVCxDQUFpQ3Z5QyxZQUFqQyxFQUErQ3RRLFVBQS9DLEVBQTJEQyxXQUEzRCxFQUF3RUMsaUJBQXhFLEVBQTJGO0FBQ3pGLE1BQUlnbEMsU0FBSjtBQUNBLE1BQUk0ZCxZQUFKOztBQUVBLE1BQUlyQixzQkFBSixFQUE0QjtBQUMxQnZjLGdCQUFZc2Qsd0JBQXdCbHlDLFlBQXhCLENBQVo7QUFDRCxHQUZELE1BRU8sSUFBSSxDQUFDc3lDLGtCQUFMLEVBQXlCO0FBQzlCLFFBQUlILDJCQUEyQm55QyxZQUEzQixFQUF5Q3JRLFdBQXpDLENBQUosRUFBMkQ7QUFDekRpbEMsa0JBQVkzeEIsV0FBVzZ1QyxnQkFBdkI7QUFDRDtBQUNGLEdBSk0sTUFJQSxJQUFJTSx5QkFBeUJweUMsWUFBekIsRUFBdUNyUSxXQUF2QyxDQUFKLEVBQXlEO0FBQzlEaWxDLGdCQUFZM3hCLFdBQVc0dUMsY0FBdkI7QUFDRDs7QUFFRCxNQUFJLENBQUNqZCxTQUFMLEVBQWdCO0FBQ2QsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSTBjLDBCQUFKLEVBQWdDO0FBQzlCO0FBQ0E7QUFDQSxRQUFJLENBQUNnQixrQkFBRCxJQUF1QjFkLGNBQWMzeEIsV0FBVzZ1QyxnQkFBcEQsRUFBc0U7QUFDcEVRLDJCQUFxQnhCLHlCQUF5QmptRCxTQUF6QixDQUFtQytFLGlCQUFuQyxDQUFyQjtBQUNELEtBRkQsTUFFTyxJQUFJZ2xDLGNBQWMzeEIsV0FBVzR1QyxjQUE3QixFQUE2QztBQUNsRCxVQUFJUyxrQkFBSixFQUF3QjtBQUN0QkUsdUJBQWVGLG1CQUFtQkcsT0FBbkIsRUFBZjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxNQUFJdGpELFFBQVE0aEQsMEJBQTBCbG1ELFNBQTFCLENBQW9DK3BDLFNBQXBDLEVBQStDbGxDLFVBQS9DLEVBQTJEQyxXQUEzRCxFQUF3RUMsaUJBQXhFLENBQVo7O0FBRUEsTUFBSTRpRCxZQUFKLEVBQWtCO0FBQ2hCO0FBQ0E7QUFDQXJqRCxVQUFNMlgsSUFBTixHQUFhMHJDLFlBQWI7QUFDRCxHQUpELE1BSU87QUFDTCxRQUFJRSxhQUFhTCx1QkFBdUIxaUQsV0FBdkIsQ0FBakI7QUFDQSxRQUFJK2lELGVBQWUsSUFBbkIsRUFBeUI7QUFDdkJ2akQsWUFBTTJYLElBQU4sR0FBYTRyQyxVQUFiO0FBQ0Q7QUFDRjs7QUFFRHIwQyxtQkFBaUJSLDRCQUFqQixDQUE4QzFPLEtBQTlDO0FBQ0EsU0FBT0EsS0FBUDtBQUNEOztBQUVEOzs7OztBQUtBLFNBQVN3akQseUJBQVQsQ0FBbUMzeUMsWUFBbkMsRUFBaURyUSxXQUFqRCxFQUE4RDtBQUM1RCxVQUFRcVEsWUFBUjtBQUNFLFNBQUssbUJBQUw7QUFDRSxhQUFPcXlDLHVCQUF1QjFpRCxXQUF2QixDQUFQO0FBQ0YsU0FBSyxhQUFMO0FBQ0U7Ozs7Ozs7Ozs7Ozs7O0FBY0EsVUFBSWlqRCxRQUFRampELFlBQVlpakQsS0FBeEI7QUFDQSxVQUFJQSxVQUFVcEIsYUFBZCxFQUE2QjtBQUMzQixlQUFPLElBQVA7QUFDRDs7QUFFRFEseUJBQW1CLElBQW5CO0FBQ0EsYUFBT1AsYUFBUDs7QUFFRixTQUFLLGNBQUw7QUFDRTtBQUNBLFVBQUlvQixRQUFRbGpELFlBQVltWCxJQUF4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFJK3JDLFVBQVVwQixhQUFWLElBQTJCTyxnQkFBL0IsRUFBaUQ7QUFDL0MsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQsYUFBT2EsS0FBUDs7QUFFRjtBQUNFO0FBQ0EsYUFBTyxJQUFQO0FBekNKO0FBMkNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNDLDJCQUFULENBQXFDOXlDLFlBQXJDLEVBQW1EclEsV0FBbkQsRUFBZ0U7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJMmlELGtCQUFKLEVBQXdCO0FBQ3RCLFFBQUl0eUMsaUJBQWlCLG1CQUFqQixJQUF3QyxDQUFDbXhDLHNCQUFELElBQTJCaUIseUJBQXlCcHlDLFlBQXpCLEVBQXVDclEsV0FBdkMsQ0FBdkUsRUFBNEg7QUFDMUgsVUFBSWtqRCxRQUFRUCxtQkFBbUJHLE9BQW5CLEVBQVo7QUFDQTNCLCtCQUF5QjNrRCxPQUF6QixDQUFpQ21tRCxrQkFBakM7QUFDQUEsMkJBQXFCLElBQXJCO0FBQ0EsYUFBT08sS0FBUDtBQUNEO0FBQ0QsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsVUFBUTd5QyxZQUFSO0FBQ0UsU0FBSyxVQUFMO0FBQ0U7QUFDQTtBQUNBLGFBQU8sSUFBUDtBQUNGLFNBQUssYUFBTDtBQUNFOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLFVBQUlyUSxZQUFZaWpELEtBQVosSUFBcUIsQ0FBQ1gsa0JBQWtCdGlELFdBQWxCLENBQTFCLEVBQTBEO0FBQ3hELGVBQU9wUixPQUFPNkMsWUFBUCxDQUFvQnVPLFlBQVlpakQsS0FBaEMsQ0FBUDtBQUNEO0FBQ0QsYUFBTyxJQUFQO0FBQ0YsU0FBSyxtQkFBTDtBQUNFLGFBQU90Qiw2QkFBNkIsSUFBN0IsR0FBb0MzaEQsWUFBWW1YLElBQXZEO0FBQ0Y7QUFDRSxhQUFPLElBQVA7QUE3Qko7QUErQkQ7O0FBRUQ7Ozs7OztBQU1BLFNBQVNpc0MsdUJBQVQsQ0FBaUMveUMsWUFBakMsRUFBK0N0USxVQUEvQyxFQUEyREMsV0FBM0QsRUFBd0VDLGlCQUF4RSxFQUEyRjtBQUN6RixNQUFJaWpELEtBQUo7O0FBRUEsTUFBSXpCLG9CQUFKLEVBQTBCO0FBQ3hCeUIsWUFBUUYsMEJBQTBCM3lDLFlBQTFCLEVBQXdDclEsV0FBeEMsQ0FBUjtBQUNELEdBRkQsTUFFTztBQUNMa2pELFlBQVFDLDRCQUE0Qjl5QyxZQUE1QixFQUEwQ3JRLFdBQTFDLENBQVI7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsTUFBSSxDQUFDa2pELEtBQUwsRUFBWTtBQUNWLFdBQU8sSUFBUDtBQUNEOztBQUVELE1BQUkxakQsUUFBUTZoRCxvQkFBb0JubUQsU0FBcEIsQ0FBOEJvWSxXQUFXeXVDLFdBQXpDLEVBQXNEaGlELFVBQXRELEVBQWtFQyxXQUFsRSxFQUErRUMsaUJBQS9FLENBQVo7O0FBRUFULFFBQU0yWCxJQUFOLEdBQWErckMsS0FBYjtBQUNBeDBDLG1CQUFpQlIsNEJBQWpCLENBQThDMU8sS0FBOUM7QUFDQSxTQUFPQSxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxJQUFJdWdELHlCQUF5QjtBQUMzQnpzQyxjQUFZQSxVQURlOztBQUczQmxELGlCQUFlLHVCQUFVQyxZQUFWLEVBQXdCdFEsVUFBeEIsRUFBb0NDLFdBQXBDLEVBQWlEQyxpQkFBakQsRUFBb0U7QUFDakYsV0FBTyxDQUFDMmlELHdCQUF3QnZ5QyxZQUF4QixFQUFzQ3RRLFVBQXRDLEVBQWtEQyxXQUFsRCxFQUErREMsaUJBQS9ELENBQUQsRUFBb0ZtakQsd0JBQXdCL3lDLFlBQXhCLEVBQXNDdFEsVUFBdEMsRUFBa0RDLFdBQWxELEVBQStEQyxpQkFBL0QsQ0FBcEYsQ0FBUDtBQUNEO0FBTDBCLENBQTdCOztBQVFBaFksT0FBT0MsT0FBUCxHQUFpQjYzRCxzQkFBakIsQzs7Ozs7OztBQzlYQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl0bEQsVUFBVSxtQkFBQTdOLENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUkrTixjQUFjLG1CQUFBL04sQ0FBUSxFQUFSLENBQWxCOztBQUVBLElBQUk4cUMseUJBQXlCLG1CQUFBOXFDLENBQVEsRUFBUixDQUE3Qjs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxTQUFTdTBELHdCQUFULENBQWtDMVgsSUFBbEMsRUFBd0M7QUFDdEMsT0FBSzRaLEtBQUwsR0FBYTVaLElBQWI7QUFDQSxPQUFLNlosVUFBTCxHQUFrQixLQUFLeHFELE9BQUwsRUFBbEI7QUFDQSxPQUFLeXFELGFBQUwsR0FBcUIsSUFBckI7QUFDRDs7QUFFRDlvRCxRQUFRMG1ELHlCQUF5QmgzRCxTQUFqQyxFQUE0QztBQUMxQ29TLGNBQVksc0JBQVk7QUFDdEIsU0FBSzhtRCxLQUFMLEdBQWEsSUFBYjtBQUNBLFNBQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxTQUFLQyxhQUFMLEdBQXFCLElBQXJCO0FBQ0QsR0FMeUM7O0FBTzFDOzs7OztBQUtBenFELFdBQVMsbUJBQVk7QUFDbkIsUUFBSSxXQUFXLEtBQUt1cUQsS0FBcEIsRUFBMkI7QUFDekIsYUFBTyxLQUFLQSxLQUFMLENBQVdoaUQsS0FBbEI7QUFDRDtBQUNELFdBQU8sS0FBS2dpRCxLQUFMLENBQVczckIsd0JBQVgsQ0FBUDtBQUNELEdBakJ5Qzs7QUFtQjFDOzs7Ozs7QUFNQW9yQixXQUFTLG1CQUFZO0FBQ25CLFFBQUksS0FBS1MsYUFBVCxFQUF3QjtBQUN0QixhQUFPLEtBQUtBLGFBQVo7QUFDRDs7QUFFRCxRQUFJaGQsS0FBSjtBQUNBLFFBQUlpZCxhQUFhLEtBQUtGLFVBQXRCO0FBQ0EsUUFBSUcsY0FBY0QsV0FBV242RCxNQUE3QjtBQUNBLFFBQUlrbkMsR0FBSjtBQUNBLFFBQUltekIsV0FBVyxLQUFLNXFELE9BQUwsRUFBZjtBQUNBLFFBQUk2cUQsWUFBWUQsU0FBU3I2RCxNQUF6Qjs7QUFFQSxTQUFLazlDLFFBQVEsQ0FBYixFQUFnQkEsUUFBUWtkLFdBQXhCLEVBQXFDbGQsT0FBckMsRUFBOEM7QUFDNUMsVUFBSWlkLFdBQVdqZCxLQUFYLE1BQXNCbWQsU0FBU25kLEtBQVQsQ0FBMUIsRUFBMkM7QUFDekM7QUFDRDtBQUNGOztBQUVELFFBQUlxZCxTQUFTSCxjQUFjbGQsS0FBM0I7QUFDQSxTQUFLaFcsTUFBTSxDQUFYLEVBQWNBLE9BQU9xekIsTUFBckIsRUFBNkJyekIsS0FBN0IsRUFBb0M7QUFDbEMsVUFBSWl6QixXQUFXQyxjQUFjbHpCLEdBQXpCLE1BQWtDbXpCLFNBQVNDLFlBQVlwekIsR0FBckIsQ0FBdEMsRUFBaUU7QUFDL0Q7QUFDRDtBQUNGOztBQUVELFFBQUlzekIsWUFBWXR6QixNQUFNLENBQU4sR0FBVSxJQUFJQSxHQUFkLEdBQW9CeGtDLFNBQXBDO0FBQ0EsU0FBS3czRCxhQUFMLEdBQXFCRyxTQUFTcDFELEtBQVQsQ0FBZWk0QyxLQUFmLEVBQXNCc2QsU0FBdEIsQ0FBckI7QUFDQSxXQUFPLEtBQUtOLGFBQVo7QUFDRDtBQXJEeUMsQ0FBNUM7O0FBd0RBNW9ELFlBQVlpQyxZQUFaLENBQXlCdWtELHdCQUF6Qjs7QUFFQWw1RCxPQUFPQyxPQUFQLEdBQWlCaTVELHdCQUFqQixDOzs7Ozs7O0FDN0ZBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSXRoRCxpQkFBaUIsbUJBQUFqVCxDQUFRLEVBQVIsQ0FBckI7O0FBRUE7Ozs7QUFJQSxJQUFJazNELDRCQUE0QjtBQUM5QjNzQyxRQUFNO0FBRHdCLENBQWhDOztBQUlBOzs7Ozs7QUFNQSxTQUFTaXFDLHlCQUFULENBQW1DdGhELGNBQW5DLEVBQW1EMFIsY0FBbkQsRUFBbUV4UixXQUFuRSxFQUFnRkMsaUJBQWhGLEVBQW1HO0FBQ2pHLFNBQU9KLGVBQWVoWCxJQUFmLENBQW9CLElBQXBCLEVBQTBCaVgsY0FBMUIsRUFBMEMwUixjQUExQyxFQUEwRHhSLFdBQTFELEVBQXVFQyxpQkFBdkUsQ0FBUDtBQUNEOztBQUVESixlQUFleUIsWUFBZixDQUE0QjgvQyx5QkFBNUIsRUFBdUQwQyx5QkFBdkQ7O0FBRUE3N0QsT0FBT0MsT0FBUCxHQUFpQms1RCx5QkFBakIsQzs7Ozs7OztBQ2xDQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl2aEQsaUJBQWlCLG1CQUFBalQsQ0FBUSxFQUFSLENBQXJCOztBQUVBOzs7OztBQUtBLElBQUltM0Qsc0JBQXNCO0FBQ3hCNXNDLFFBQU07QUFEa0IsQ0FBMUI7O0FBSUE7Ozs7OztBQU1BLFNBQVNrcUMsbUJBQVQsQ0FBNkJ2aEQsY0FBN0IsRUFBNkMwUixjQUE3QyxFQUE2RHhSLFdBQTdELEVBQTBFQyxpQkFBMUUsRUFBNkY7QUFDM0YsU0FBT0osZUFBZWhYLElBQWYsQ0FBb0IsSUFBcEIsRUFBMEJpWCxjQUExQixFQUEwQzBSLGNBQTFDLEVBQTBEeFIsV0FBMUQsRUFBdUVDLGlCQUF2RSxDQUFQO0FBQ0Q7O0FBRURKLGVBQWV5QixZQUFmLENBQTRCKy9DLG1CQUE1QixFQUFpRDBDLG1CQUFqRDs7QUFFQTk3RCxPQUFPQyxPQUFQLEdBQWlCbTVELG1CQUFqQixDOzs7Ozs7O0FDbkNBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSXowQyxpQkFBaUIsbUJBQUFoZ0IsQ0FBUSxFQUFSLENBQXJCO0FBQ0EsSUFBSThoQixtQkFBbUIsbUJBQUE5aEIsQ0FBUSxFQUFSLENBQXZCO0FBQ0EsSUFBSW1HLHVCQUF1QixtQkFBQW5HLENBQVEsQ0FBUixDQUEzQjtBQUNBLElBQUlnRSx3QkFBd0IsbUJBQUFoRSxDQUFRLENBQVIsQ0FBNUI7QUFDQSxJQUFJME8sZUFBZSxtQkFBQTFPLENBQVEsRUFBUixDQUFuQjtBQUNBLElBQUlpVCxpQkFBaUIsbUJBQUFqVCxDQUFRLEVBQVIsQ0FBckI7O0FBRUEsSUFBSStyQyxxQkFBcUIsbUJBQUEvckMsQ0FBUSxFQUFSLENBQXpCO0FBQ0EsSUFBSW1rQixpQkFBaUIsbUJBQUFua0IsQ0FBUSxFQUFSLENBQXJCO0FBQ0EsSUFBSXdyQixtQkFBbUIsbUJBQUF4ckIsQ0FBUSxFQUFSLENBQXZCO0FBQ0EsSUFBSW90QyxxQkFBcUIsbUJBQUFwdEMsQ0FBUSxFQUFSLENBQXpCOztBQUVBLElBQUkwbUIsYUFBYTtBQUNmMHdDLFVBQVE7QUFDTjUyQyw2QkFBeUI7QUFDdkI0MEMsZUFBUyxVQURjO0FBRXZCQyxnQkFBVTtBQUZhLEtBRG5CO0FBS05udUMsa0JBQWMsQ0FBQyxTQUFELEVBQVksV0FBWixFQUF5QixVQUF6QixFQUFxQyxVQUFyQyxFQUFpRCxVQUFqRCxFQUE2RCxZQUE3RCxFQUEyRSxVQUEzRSxFQUF1RixvQkFBdkY7QUFMUjtBQURPLENBQWpCOztBQVVBLFNBQVNtd0MsOEJBQVQsQ0FBd0M5MEQsSUFBeEMsRUFBOEM2USxXQUE5QyxFQUEyRDVOLE1BQTNELEVBQW1FO0FBQ2pFLE1BQUlvTixRQUFRSyxlQUFlM0UsU0FBZixDQUF5Qm9ZLFdBQVcwd0MsTUFBcEMsRUFBNEM3MEQsSUFBNUMsRUFBa0Q2USxXQUFsRCxFQUErRDVOLE1BQS9ELENBQVo7QUFDQW9OLFFBQU0vSSxJQUFOLEdBQWEsUUFBYjtBQUNBaVksbUJBQWlCUiw0QkFBakIsQ0FBOEMxTyxLQUE5QztBQUNBLFNBQU9BLEtBQVA7QUFDRDtBQUNEOzs7QUFHQSxJQUFJNG5DLGdCQUFnQixJQUFwQjtBQUNBLElBQUk4YyxvQkFBb0IsSUFBeEI7O0FBRUE7OztBQUdBLFNBQVNDLG9CQUFULENBQThCaHNCLElBQTlCLEVBQW9DO0FBQ2xDLE1BQUlyc0IsV0FBV3FzQixLQUFLcnNCLFFBQUwsSUFBaUJxc0IsS0FBS3JzQixRQUFMLENBQWN4SSxXQUFkLEVBQWhDO0FBQ0EsU0FBT3dJLGFBQWEsUUFBYixJQUF5QkEsYUFBYSxPQUFiLElBQXdCcXNCLEtBQUsxaEMsSUFBTCxLQUFjLE1BQXRFO0FBQ0Q7O0FBRUQsSUFBSTJ0RCx3QkFBd0IsS0FBNUI7QUFDQSxJQUFJcnhELHFCQUFxQkosU0FBekIsRUFBb0M7QUFDbEM7QUFDQXl4RCwwQkFBd0Joc0MsaUJBQWlCLFFBQWpCLE1BQStCLENBQUN2bEIsU0FBU3lZLFlBQVYsSUFBMEJ6WSxTQUFTeVksWUFBVCxHQUF3QixDQUFqRixDQUF4QjtBQUNEOztBQUVELFNBQVMrNEMseUJBQVQsQ0FBbUNya0QsV0FBbkMsRUFBZ0Q7QUFDOUMsTUFBSVIsUUFBUXlrRCwrQkFBK0JDLGlCQUEvQixFQUFrRGxrRCxXQUFsRCxFQUErRCtRLGVBQWUvUSxXQUFmLENBQS9ELENBQVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBMUUsZUFBYXVCLGNBQWIsQ0FBNEJ5bkQsZUFBNUIsRUFBNkM5a0QsS0FBN0M7QUFDRDs7QUFFRCxTQUFTOGtELGVBQVQsQ0FBeUI5a0QsS0FBekIsRUFBZ0M7QUFDOUJvTixpQkFBZTZELGFBQWYsQ0FBNkJqUixLQUE3QjtBQUNBb04saUJBQWU4RCxpQkFBZixDQUFpQyxLQUFqQztBQUNEOztBQUVELFNBQVM2ekMsOEJBQVQsQ0FBd0NueUQsTUFBeEMsRUFBZ0QyTixVQUFoRCxFQUE0RDtBQUMxRHFuQyxrQkFBZ0JoMUMsTUFBaEI7QUFDQTh4RCxzQkFBb0Jua0QsVUFBcEI7QUFDQXFuQyxnQkFBY2gwQyxXQUFkLENBQTBCLFVBQTFCLEVBQXNDaXhELHlCQUF0QztBQUNEOztBQUVELFNBQVNHLDZCQUFULEdBQXlDO0FBQ3ZDLE1BQUksQ0FBQ3BkLGFBQUwsRUFBb0I7QUFDbEI7QUFDRDtBQUNEQSxnQkFBY2xDLFdBQWQsQ0FBMEIsVUFBMUIsRUFBc0NtZix5QkFBdEM7QUFDQWpkLGtCQUFnQixJQUFoQjtBQUNBOGMsc0JBQW9CLElBQXBCO0FBQ0Q7O0FBRUQsU0FBU08scUJBQVQsQ0FBK0Ixa0QsVUFBL0IsRUFBMkNDLFdBQTNDLEVBQXdEO0FBQ3RELE1BQUkwa0QsVUFBVS9yQixtQkFBbUJRLG9CQUFuQixDQUF3Q3A1QixVQUF4QyxDQUFkO0FBQ0EsTUFBSWlQLFlBQVloUCxZQUFZZ1AsU0FBWixLQUEwQixJQUExQixJQUFrQ2d4QyxrQkFBa0IyRSwwQkFBcEU7O0FBRUEsTUFBSUQsV0FBVzExQyxTQUFmLEVBQTBCO0FBQ3hCLFdBQU9qUCxVQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNmtELDJCQUFULENBQXFDdjBDLFlBQXJDLEVBQW1EdFEsVUFBbkQsRUFBK0Q7QUFDN0QsTUFBSXNRLGlCQUFpQixXQUFyQixFQUFrQztBQUNoQyxXQUFPdFEsVUFBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBUzhrRCw2QkFBVCxDQUF1Q3gwQyxZQUF2QyxFQUFxRGplLE1BQXJELEVBQTZEMk4sVUFBN0QsRUFBeUU7QUFDdkUsTUFBSXNRLGlCQUFpQixVQUFyQixFQUFpQztBQUMvQjtBQUNBO0FBQ0FtMEM7QUFDQUQsbUNBQStCbnlELE1BQS9CLEVBQXVDMk4sVUFBdkM7QUFDRCxHQUxELE1BS08sSUFBSXNRLGlCQUFpQixTQUFyQixFQUFnQztBQUNyQ20wQztBQUNEO0FBQ0Y7O0FBRUQ7OztBQUdBLElBQUlNLHdCQUF3QixLQUE1QjtBQUNBLElBQUkveEQscUJBQXFCSixTQUF6QixFQUFvQztBQUNsQztBQUNBOztBQUVBbXlELDBCQUF3QjFzQyxpQkFBaUIsT0FBakIsTUFBOEIsRUFBRSxrQkFBa0J2bEIsUUFBcEIsS0FBaUNBLFNBQVN5WSxZQUFULEdBQXdCLENBQXZGLENBQXhCO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsU0FBU3k1QywyQkFBVCxDQUFxQzN5RCxNQUFyQyxFQUE2QzJOLFVBQTdDLEVBQXlEO0FBQ3ZEcW5DLGtCQUFnQmgxQyxNQUFoQjtBQUNBOHhELHNCQUFvQm5rRCxVQUFwQjtBQUNBcW5DLGdCQUFjaDBDLFdBQWQsQ0FBMEIsa0JBQTFCLEVBQThDNHhELG9CQUE5QztBQUNEOztBQUVEOzs7O0FBSUEsU0FBU0MsMEJBQVQsR0FBc0M7QUFDcEMsTUFBSSxDQUFDN2QsYUFBTCxFQUFvQjtBQUNsQjtBQUNEO0FBQ0RBLGdCQUFjbEMsV0FBZCxDQUEwQixrQkFBMUIsRUFBOEM4ZixvQkFBOUM7O0FBRUE1ZCxrQkFBZ0IsSUFBaEI7QUFDQThjLHNCQUFvQixJQUFwQjtBQUNEOztBQUVEOzs7O0FBSUEsU0FBU2Msb0JBQVQsQ0FBOEJobEQsV0FBOUIsRUFBMkM7QUFDekMsTUFBSUEsWUFBWTJELFlBQVosS0FBNkIsT0FBakMsRUFBMEM7QUFDeEM7QUFDRDtBQUNELE1BQUk4Z0Qsc0JBQXNCUCxpQkFBdEIsRUFBeUNsa0QsV0FBekMsQ0FBSixFQUEyRDtBQUN6RHFrRCw4QkFBMEJya0QsV0FBMUI7QUFDRDtBQUNGOztBQUVELFNBQVNrbEQsaUNBQVQsQ0FBMkM3MEMsWUFBM0MsRUFBeURqZSxNQUF6RCxFQUFpRTJOLFVBQWpFLEVBQTZFO0FBQzNFLE1BQUlzUSxpQkFBaUIsVUFBckIsRUFBaUM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTQwQztBQUNBRixnQ0FBNEIzeUQsTUFBNUIsRUFBb0MyTixVQUFwQztBQUNELEdBaEJELE1BZ0JPLElBQUlzUSxpQkFBaUIsU0FBckIsRUFBZ0M7QUFDckM0MEM7QUFDRDtBQUNGOztBQUVEO0FBQ0EsU0FBU0Usa0NBQVQsQ0FBNEM5MEMsWUFBNUMsRUFBMER0USxVQUExRCxFQUFzRUMsV0FBdEUsRUFBbUY7QUFDakYsTUFBSXFRLGlCQUFpQixvQkFBakIsSUFBeUNBLGlCQUFpQixVQUExRCxJQUF3RUEsaUJBQWlCLFlBQTdGLEVBQTJHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBT28wQyxzQkFBc0JQLGlCQUF0QixFQUF5Q2xrRCxXQUF6QyxDQUFQO0FBQ0Q7QUFDRjs7QUFFRDs7O0FBR0EsU0FBU29sRCxtQkFBVCxDQUE2Qmp0QixJQUE3QixFQUFtQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxNQUFJcnNCLFdBQVdxc0IsS0FBS3JzQixRQUFwQjtBQUNBLFNBQU9BLFlBQVlBLFNBQVN4SSxXQUFULE9BQTJCLE9BQXZDLEtBQW1ENjBCLEtBQUsxaEMsSUFBTCxLQUFjLFVBQWQsSUFBNEIwaEMsS0FBSzFoQyxJQUFMLEtBQWMsT0FBN0YsQ0FBUDtBQUNEOztBQUVELFNBQVM0dUQsMEJBQVQsQ0FBb0NoMUMsWUFBcEMsRUFBa0R0USxVQUFsRCxFQUE4REMsV0FBOUQsRUFBMkU7QUFDekUsTUFBSXFRLGlCQUFpQixVQUFyQixFQUFpQztBQUMvQixXQUFPbzBDLHNCQUFzQjFrRCxVQUF0QixFQUFrQ0MsV0FBbEMsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3NsRCxrQ0FBVCxDQUE0Q2oxQyxZQUE1QyxFQUEwRHRRLFVBQTFELEVBQXNFQyxXQUF0RSxFQUFtRjtBQUNqRixNQUFJcVEsaUJBQWlCLFVBQWpCLElBQStCQSxpQkFBaUIsV0FBcEQsRUFBaUU7QUFDL0QsV0FBT28wQyxzQkFBc0Ixa0QsVUFBdEIsRUFBa0NDLFdBQWxDLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQVN1bEQseUJBQVQsQ0FBbUNwMkQsSUFBbkMsRUFBeUNYLElBQXpDLEVBQStDO0FBQzdDO0FBQ0EsTUFBSVcsUUFBUSxJQUFaLEVBQWtCO0FBQ2hCO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJMjlCLFFBQVEzOUIsS0FBS2twQyxhQUFMLElBQXNCN3BDLEtBQUs2cEMsYUFBdkM7O0FBRUEsTUFBSSxDQUFDdkwsS0FBRCxJQUFVLENBQUNBLE1BQU0wNEIsVUFBakIsSUFBK0JoM0QsS0FBS2lJLElBQUwsS0FBYyxRQUFqRCxFQUEyRDtBQUN6RDtBQUNEOztBQUVEO0FBQ0EsTUFBSTRLLFFBQVEsS0FBSzdTLEtBQUs2UyxLQUF0QjtBQUNBLE1BQUk3UyxLQUFLRyxZQUFMLENBQWtCLE9BQWxCLE1BQStCMFMsS0FBbkMsRUFBMEM7QUFDeEM3UyxTQUFLNHlCLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkIvZixLQUEzQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQSxJQUFJMitDLG9CQUFvQjtBQUN0QjFzQyxjQUFZQSxVQURVOztBQUd0QnF4Qyw4QkFBNEIsSUFITjtBQUl0QmMsMEJBQXdCWCxxQkFKRjs7QUFNdEIxMEMsaUJBQWUsdUJBQVVDLFlBQVYsRUFBd0J0USxVQUF4QixFQUFvQ0MsV0FBcEMsRUFBaURDLGlCQUFqRCxFQUFvRTtBQUNqRixRQUFJeWxELGFBQWEzbEQsYUFBYW5QLHNCQUFzQkYsbUJBQXRCLENBQTBDcVAsVUFBMUMsQ0FBYixHQUFxRW5OLE1BQXRGOztBQUVBLFFBQUkreUQsaUJBQUosRUFBdUJDLGVBQXZCO0FBQ0EsUUFBSXpCLHFCQUFxQnVCLFVBQXJCLENBQUosRUFBc0M7QUFDcEMsVUFBSXRCLHFCQUFKLEVBQTJCO0FBQ3pCdUIsNEJBQW9CZiwyQkFBcEI7QUFDRCxPQUZELE1BRU87QUFDTGdCLDBCQUFrQmYsNkJBQWxCO0FBQ0Q7QUFDRixLQU5ELE1BTU8sSUFBSTdxQixtQkFBbUIwckIsVUFBbkIsQ0FBSixFQUFvQztBQUN6QyxVQUFJWixxQkFBSixFQUEyQjtBQUN6QmEsNEJBQW9CTCxrQ0FBcEI7QUFDRCxPQUZELE1BRU87QUFDTEssNEJBQW9CUixrQ0FBcEI7QUFDQVMsMEJBQWtCVixpQ0FBbEI7QUFDRDtBQUNGLEtBUE0sTUFPQSxJQUFJRSxvQkFBb0JNLFVBQXBCLENBQUosRUFBcUM7QUFDMUNDLDBCQUFvQk4sMEJBQXBCO0FBQ0Q7O0FBRUQsUUFBSU0saUJBQUosRUFBdUI7QUFDckIsVUFBSXgyRCxPQUFPdzJELGtCQUFrQnQxQyxZQUFsQixFQUFnQ3RRLFVBQWhDLEVBQTRDQyxXQUE1QyxDQUFYO0FBQ0EsVUFBSTdRLElBQUosRUFBVTtBQUNSLFlBQUlxUSxRQUFReWtELCtCQUErQjkwRCxJQUEvQixFQUFxQzZRLFdBQXJDLEVBQWtEQyxpQkFBbEQsQ0FBWjtBQUNBLGVBQU9ULEtBQVA7QUFDRDtBQUNGOztBQUVELFFBQUlvbUQsZUFBSixFQUFxQjtBQUNuQkEsc0JBQWdCdjFDLFlBQWhCLEVBQThCcTFDLFVBQTlCLEVBQTBDM2xELFVBQTFDO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJc1EsaUJBQWlCLFNBQXJCLEVBQWdDO0FBQzlCazFDLGdDQUEwQnhsRCxVQUExQixFQUFzQzJsRCxVQUF0QztBQUNEO0FBQ0Y7QUEzQ3FCLENBQXhCOztBQThDQXo5RCxPQUFPQyxPQUFQLEdBQWlCODNELGlCQUFqQixDOzs7Ozs7O0FDdFRBOzs7Ozs7Ozs7OztBQVdBOzs7O0FBRUEsSUFBSTZGLGFBQWEsbUJBQUFqNUQsQ0FBUSxHQUFSLENBQWpCOztBQUVBLElBQUk4YyxXQUFXLEVBQWY7O0FBRUEsU0FBU284QyxTQUFULENBQW1CcGhELEdBQW5CLEVBQXdCM1YsU0FBeEIsRUFBbUNxSixLQUFuQyxFQUEwQztBQUN4QyxNQUFJLE9BQU9zTSxHQUFQLEtBQWUsVUFBbkIsRUFBK0I7QUFDN0JBLFFBQUkzVixVQUFVbVAsaUJBQVYsRUFBSjtBQUNELEdBRkQsTUFFTztBQUNMO0FBQ0EybkQsZUFBV0UsbUJBQVgsQ0FBK0JoM0QsU0FBL0IsRUFBMEMyVixHQUExQyxFQUErQ3RNLEtBQS9DO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNHRELFNBQVQsQ0FBbUJ0aEQsR0FBbkIsRUFBd0IzVixTQUF4QixFQUFtQ3FKLEtBQW5DLEVBQTBDO0FBQ3hDLE1BQUksT0FBT3NNLEdBQVAsS0FBZSxVQUFuQixFQUErQjtBQUM3QkEsUUFBSSxJQUFKO0FBQ0QsR0FGRCxNQUVPO0FBQ0w7QUFDQW1oRCxlQUFXSSx3QkFBWCxDQUFvQ2wzRCxTQUFwQyxFQUErQzJWLEdBQS9DLEVBQW9EdE0sS0FBcEQ7QUFDRDtBQUNGOztBQUVEc1IsU0FBU0UsVUFBVCxHQUFzQixVQUFVM0MsUUFBVixFQUFvQnpRLE9BQXBCLEVBQTZCO0FBQ2pELE1BQUlBLFlBQVksSUFBWixJQUFvQixRQUFPQSxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQTNDLEVBQXFEO0FBQ25EO0FBQ0Q7QUFDRCxNQUFJa08sTUFBTWxPLFFBQVFrTyxHQUFsQjtBQUNBLE1BQUlBLE9BQU8sSUFBWCxFQUFpQjtBQUNmb2hELGNBQVVwaEQsR0FBVixFQUFldUMsUUFBZixFQUF5QnpRLFFBQVE2QixNQUFqQztBQUNEO0FBQ0YsQ0FSRDs7QUFVQXFSLFNBQVNvQixnQkFBVCxHQUE0QixVQUFVSCxXQUFWLEVBQXVCRCxXQUF2QixFQUFvQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSXc3QyxVQUFVLElBQWQ7QUFDQSxNQUFJQyxZQUFZLElBQWhCO0FBQ0EsTUFBSXg3QyxnQkFBZ0IsSUFBaEIsSUFBd0IsUUFBT0EsV0FBUCx5Q0FBT0EsV0FBUCxPQUF1QixRQUFuRCxFQUE2RDtBQUMzRHU3QyxjQUFVdjdDLFlBQVlqRyxHQUF0QjtBQUNBeWhELGdCQUFZeDdDLFlBQVl0UyxNQUF4QjtBQUNEOztBQUVELE1BQUkrdEQsVUFBVSxJQUFkO0FBQ0EsTUFBSUMsWUFBWSxJQUFoQjtBQUNBLE1BQUkzN0MsZ0JBQWdCLElBQWhCLElBQXdCLFFBQU9BLFdBQVAseUNBQU9BLFdBQVAsT0FBdUIsUUFBbkQsRUFBNkQ7QUFDM0QwN0MsY0FBVTE3QyxZQUFZaEcsR0FBdEI7QUFDQTJoRCxnQkFBWTM3QyxZQUFZclMsTUFBeEI7QUFDRDs7QUFFRCxTQUFPNnRELFlBQVlFLE9BQVo7QUFDUDtBQUNBLFNBQU9BLE9BQVAsS0FBbUIsUUFBbkIsSUFBK0JDLGNBQWNGLFNBRjdDO0FBR0QsQ0E5QkQ7O0FBZ0NBejhDLFNBQVNjLFVBQVQsR0FBc0IsVUFBVXZELFFBQVYsRUFBb0J6USxPQUFwQixFQUE2QjtBQUNqRCxNQUFJQSxZQUFZLElBQVosSUFBb0IsUUFBT0EsT0FBUCx5Q0FBT0EsT0FBUCxPQUFtQixRQUEzQyxFQUFxRDtBQUNuRDtBQUNEO0FBQ0QsTUFBSWtPLE1BQU1sTyxRQUFRa08sR0FBbEI7QUFDQSxNQUFJQSxPQUFPLElBQVgsRUFBaUI7QUFDZnNoRCxjQUFVdGhELEdBQVYsRUFBZXVDLFFBQWYsRUFBeUJ6USxRQUFRNkIsTUFBakM7QUFDRDtBQUNGLENBUkQ7O0FBVUFwUSxPQUFPQyxPQUFQLEdBQWlCd2hCLFFBQWpCLEM7Ozs7Ozs7QUN2RkE7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUEsSUFBSTliLGlCQUFpQixtQkFBQWhCLENBQVEsQ0FBUixDQUFyQjs7QUFFQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7O0FBRUE7Ozs7O0FBS0EsU0FBUzA1RCxZQUFULENBQXNCaHNELE1BQXRCLEVBQThCO0FBQzVCLFNBQU8sQ0FBQyxFQUFFQSxVQUFVLE9BQU9BLE9BQU93ckQsU0FBZCxLQUE0QixVQUF0QyxJQUFvRCxPQUFPeHJELE9BQU8wckQsU0FBZCxLQUE0QixVQUFsRixDQUFSO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQSxJQUFJSCxhQUFhO0FBQ2Y7Ozs7Ozs7OztBQVNBRSx1QkFBcUIsNkJBQVVoM0QsU0FBVixFQUFxQjJWLEdBQXJCLEVBQTBCdE0sS0FBMUIsRUFBaUM7QUFDcEQsS0FBQ2t1RCxhQUFhbHVELEtBQWIsQ0FBRCxHQUF1QnBRLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsa1FBQWpCLENBQXhDLEdBQStUNEIsZUFBZSxLQUFmLENBQXRWLEdBQThXLEtBQUssQ0FBblg7QUFDQXdLLFVBQU0wdEQsU0FBTixDQUFnQnBoRCxHQUFoQixFQUFxQjNWLFNBQXJCO0FBQ0QsR0FiYzs7QUFlZjs7Ozs7Ozs7O0FBU0FrM0QsNEJBQTBCLGtDQUFVbDNELFNBQVYsRUFBcUIyVixHQUFyQixFQUEwQnRNLEtBQTFCLEVBQWlDO0FBQ3pELEtBQUNrdUQsYUFBYWx1RCxLQUFiLENBQUQsR0FBdUJwUSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHlRQUFqQixDQUF4QyxHQUFzVTRCLGVBQWUsS0FBZixDQUE3VixHQUFxWCxLQUFLLENBQTFYO0FBQ0EsUUFBSTI0RCxzQkFBc0JudUQsTUFBTThGLGlCQUFOLEVBQTFCO0FBQ0E7QUFDQTtBQUNBLFFBQUlxb0QsdUJBQXVCQSxvQkFBb0IvMEIsSUFBcEIsQ0FBeUI5c0IsR0FBekIsTUFBa0MzVixVQUFVbVAsaUJBQVYsRUFBN0QsRUFBNEY7QUFDMUY5RixZQUFNNHRELFNBQU4sQ0FBZ0J0aEQsR0FBaEI7QUFDRDtBQUNGO0FBaENjLENBQWpCOztBQW1DQXpjLE9BQU9DLE9BQVAsR0FBaUIyOUQsVUFBakIsQzs7Ozs7Ozs7QUMzRkE7Ozs7Ozs7Ozs7O0FBV0E7Ozs7QUFFQSxJQUFJVyxrQ0FBa0MsbUJBQUE1NUQsQ0FBUSxHQUFSLENBQXRDO0FBQ0EsSUFBSTY1RCxnQ0FBZ0MsbUJBQUE3NUQsQ0FBUSxHQUFSLENBQXBDO0FBQ0EsSUFBSWdLLHlCQUF5QixtQkFBQWhLLENBQVEsQ0FBUixDQUE3QjtBQUNBLElBQUltRyx1QkFBdUIsbUJBQUFuRyxDQUFRLENBQVIsQ0FBM0I7O0FBRUEsSUFBSTg1RCxpQkFBaUIsbUJBQUE5NUQsQ0FBUSxHQUFSLENBQXJCO0FBQ0EsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUEsSUFBSSs1RCxRQUFRLEVBQVo7QUFDQSxJQUFJQyx1QkFBdUIsRUFBM0I7O0FBRUEsU0FBU0MsUUFBVCxDQUFrQnJuRCxLQUFsQixFQUF5QnJMLEVBQXpCLEVBQTZCb0ssT0FBN0IsRUFBc0M0bEIsSUFBdEMsRUFBNENDLElBQTVDLEVBQWtEQyxJQUFsRCxFQUF3RHlpQyxJQUF4RCxFQUE4REMsSUFBOUQsRUFBb0U7QUFDbEUsTUFBSTtBQUNGNXlELE9BQUd0TCxJQUFILENBQVEwVixPQUFSLEVBQWlCNGxCLElBQWpCLEVBQXVCQyxJQUF2QixFQUE2QkMsSUFBN0IsRUFBbUN5aUMsSUFBbkMsRUFBeUNDLElBQXpDO0FBQ0QsR0FGRCxDQUVFLE9BQU90K0QsQ0FBUCxFQUFVO0FBQ1ZULFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRKzVELHFCQUFxQnBuRCxLQUFyQixDQUFSLEVBQXFDLGdEQUFyQyxFQUF1RkEsS0FBdkYsRUFBOEYvVyxJQUFJLElBQUosR0FBV0EsRUFBRTRRLEtBQTNHLENBQXhDLEdBQTRKLEtBQUssQ0FBaks7QUFDQXV0RCx5QkFBcUJwbkQsS0FBckIsSUFBOEIsSUFBOUI7QUFDRDtBQUNGOztBQUVELFNBQVN3bkQsU0FBVCxDQUFtQnhuRCxLQUFuQixFQUEwQjJrQixJQUExQixFQUFnQ0MsSUFBaEMsRUFBc0NDLElBQXRDLEVBQTRDeWlDLElBQTVDLEVBQWtEQyxJQUFsRCxFQUF3RDtBQUN0RCxPQUFLLElBQUloOUQsSUFBSSxDQUFiLEVBQWdCQSxJQUFJNDhELE1BQU10OUQsTUFBMUIsRUFBa0NVLEdBQWxDLEVBQXVDO0FBQ3JDLFFBQUlrOUQsT0FBT04sTUFBTTU4RCxDQUFOLENBQVg7QUFDQSxRQUFJb0ssS0FBSzh5RCxLQUFLem5ELEtBQUwsQ0FBVDtBQUNBLFFBQUlyTCxFQUFKLEVBQVE7QUFDTjB5RCxlQUFTcm5ELEtBQVQsRUFBZ0JyTCxFQUFoQixFQUFvQjh5RCxJQUFwQixFQUEwQjlpQyxJQUExQixFQUFnQ0MsSUFBaEMsRUFBc0NDLElBQXRDLEVBQTRDeWlDLElBQTVDLEVBQWtEQyxJQUFsRDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxJQUFJRyxlQUFjLEtBQWxCO0FBQ0EsSUFBSUMsZUFBZSxFQUFuQjtBQUNBLElBQUlDLHNCQUFzQixFQUExQjtBQUNBLElBQUlDLHNCQUFzQixDQUExQjtBQUNBLElBQUlDLDJCQUEyQixFQUEvQjtBQUNBLElBQUlDLHdCQUF3QixDQUE1QjtBQUNBLElBQUlDLHNCQUFzQixJQUExQjtBQUNBLElBQUlDLHdCQUF3QixDQUE1QjtBQUNBLElBQUlDLGtDQUFrQyxDQUF0QztBQUNBLElBQUlDLG1CQUFtQixJQUF2Qjs7QUFFQSxJQUFJQywwQkFBMEIsS0FBOUI7O0FBRUEsU0FBU0MsWUFBVCxHQUF3QjtBQUN0Qmp4RCx5QkFBdUJtQix3QkFBdkI7QUFDQTB1RCxnQ0FBOEJvQixZQUE5QjtBQUNEOztBQUVELFNBQVNDLGVBQVQsQ0FBeUJDLGFBQXpCLEVBQXdDO0FBQ3RDLFNBQU9BLGNBQWM1MkIsTUFBZCxDQUFxQixVQUFVemxCLElBQVYsRUFBZ0JyVyxFQUFoQixFQUFvQjtBQUM5QyxRQUFJeUIsVUFBVUYsdUJBQXVCRyxVQUF2QixDQUFrQzFCLEVBQWxDLENBQWQ7QUFDQSxRQUFJaUMsV0FBV1YsdUJBQXVCK0IsV0FBdkIsQ0FBbUN0RCxFQUFuQyxDQUFmO0FBQ0FxVyxTQUFLclcsRUFBTCxJQUFXO0FBQ1RxQixtQkFBYUUsdUJBQXVCTCxjQUF2QixDQUFzQ2xCLEVBQXRDLENBREo7QUFFVG1DLFlBQU1aLHVCQUF1QmtDLE9BQXZCLENBQStCekQsRUFBL0IsQ0FGRztBQUdUb0MsbUJBQWFiLHVCQUF1Qm1DLGNBQXZCLENBQXNDMUQsRUFBdEMsQ0FISjtBQUlUYSxnQkFBVVUsdUJBQXVCZ0MsV0FBdkIsQ0FBbUN2RCxFQUFuQyxDQUpEO0FBS1Q7QUFDQXlCLGVBQVNBLFdBQVdRLFlBQVlWLHVCQUF1QkcsVUFBdkIsQ0FBa0NPLFFBQWxDLENBQXZCLElBQXNFLENBTnRFO0FBT1RBLGdCQUFVQTtBQVBELEtBQVg7QUFTQSxXQUFPb1UsSUFBUDtBQUNELEdBYk0sRUFhSixFQWJJLENBQVA7QUFjRDs7QUFFRCxTQUFTczhDLGlCQUFULEdBQTZCO0FBQzNCLE1BQUlDLG9CQUFvQlYscUJBQXhCO0FBQ0EsTUFBSVcsdUJBQXVCWix3QkFBM0I7QUFDQSxNQUFJYSxxQkFBcUIxQiw4QkFBOEIyQixVQUE5QixFQUF6Qjs7QUFFQSxNQUFJZix3QkFBd0IsQ0FBNUIsRUFBK0I7QUFDN0JFLDRCQUF3QixDQUF4QjtBQUNBRCwrQkFBMkIsRUFBM0I7QUFDQU87QUFDQTtBQUNEOztBQUVELE1BQUlLLHFCQUFxQjcrRCxNQUFyQixJQUErQjgrRCxtQkFBbUI5K0QsTUFBdEQsRUFBOEQ7QUFDNUQsUUFBSTArRCxnQkFBZ0JueEQsdUJBQXVCb0MsZ0JBQXZCLEVBQXBCO0FBQ0FtdUQsaUJBQWFuOUQsSUFBYixDQUFrQjtBQUNoQnErRCxnQkFBVTNCLG1CQUFtQnVCLGlCQURiO0FBRWhCSyxvQkFBY0osd0JBQXdCLEVBRnRCO0FBR2hCSyxrQkFBWUosc0JBQXNCLEVBSGxCO0FBSWhCSyxvQkFBY1YsZ0JBQWdCQyxhQUFoQjtBQUpFLEtBQWxCO0FBTUQ7O0FBRURGO0FBQ0FOLDBCQUF3QmIsZ0JBQXhCO0FBQ0FZLDZCQUEyQixFQUEzQjtBQUNEOztBQUVELFNBQVNtQixZQUFULENBQXNCdE8sT0FBdEIsRUFBK0I7QUFDN0IsTUFBSXVPLFlBQVk1K0QsVUFBVVQsTUFBVixHQUFtQixDQUFuQixJQUF3QlMsVUFBVSxDQUFWLE1BQWlCaUMsU0FBekMsR0FBcURqQyxVQUFVLENBQVYsQ0FBckQsR0FBb0UsS0FBcEY7O0FBRUEsTUFBSTQrRCxhQUFhdk8sWUFBWSxDQUE3QixFQUFnQztBQUM5QjtBQUNEO0FBQ0QsTUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWm55RCxZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsMkNBQWYsQ0FBeEMsR0FBc0csS0FBSyxDQUEzRztBQUNEO0FBQ0Y7O0FBRUQsU0FBUzg3RCxtQkFBVCxDQUE2QnhPLE9BQTdCLEVBQXNDeU8sU0FBdEMsRUFBaUQ7QUFDL0MsTUFBSXZCLHdCQUF3QixDQUE1QixFQUErQjtBQUM3QjtBQUNEO0FBQ0QsTUFBSU0sb0JBQW9CLENBQUNDLHVCQUF6QixFQUFrRDtBQUNoRDUvRCxZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsMkVBQTJFLDhEQUEzRSxHQUE0SSwyQkFBM0osRUFBd0wrN0QsU0FBeEwsRUFBbU1qQixvQkFBb0IsSUFBdk4sRUFBNk54TixZQUFZcU4sbUJBQVosR0FBa0MsVUFBbEMsR0FBK0MsU0FBNVEsQ0FBeEMsR0FBaVUsS0FBSyxDQUF0VTtBQUNBSSw4QkFBMEIsSUFBMUI7QUFDRDtBQUNESCwwQkFBd0JmLGdCQUF4QjtBQUNBZ0Isb0NBQWtDLENBQWxDO0FBQ0FGLHdCQUFzQnJOLE9BQXRCO0FBQ0F3TixxQkFBbUJpQixTQUFuQjtBQUNEOztBQUVELFNBQVNDLGlCQUFULENBQTJCMU8sT0FBM0IsRUFBb0N5TyxTQUFwQyxFQUErQztBQUM3QyxNQUFJdkIsd0JBQXdCLENBQTVCLEVBQStCO0FBQzdCO0FBQ0Q7QUFDRCxNQUFJTSxxQkFBcUJpQixTQUFyQixJQUFrQyxDQUFDaEIsdUJBQXZDLEVBQWdFO0FBQzlENS9ELFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSwyRUFBMkUsZ0VBQTNFLEdBQThJLGlFQUE3SixFQUFnTys3RCxTQUFoTyxFQUEyT2pCLG9CQUFvQixJQUEvUCxFQUFxUXhOLFlBQVlxTixtQkFBWixHQUFrQyxVQUFsQyxHQUErQyxTQUFwVCxDQUF4QyxHQUF5VyxLQUFLLENBQTlXO0FBQ0FJLDhCQUEwQixJQUExQjtBQUNEO0FBQ0QsTUFBSVYsWUFBSixFQUFpQjtBQUNmSSw2QkFBeUJ0OUQsSUFBekIsQ0FBOEI7QUFDNUI0K0QsaUJBQVdBLFNBRGlCO0FBRTVCOWxDLGtCQUFZcTNCLE9BRmdCO0FBRzVCa08sZ0JBQVUzQixtQkFBbUJlLHFCQUFuQixHQUEyQ0M7QUFIekIsS0FBOUI7QUFLRDtBQUNERCwwQkFBd0IsQ0FBeEI7QUFDQUMsb0NBQWtDLENBQWxDO0FBQ0FGLHdCQUFzQixJQUF0QjtBQUNBRyxxQkFBbUIsSUFBbkI7QUFDRDs7QUFFRCxTQUFTbUIsMEJBQVQsR0FBc0M7QUFDcEMsTUFBSUMsZUFBZTtBQUNqQkMsZUFBV3ZCLHFCQURNO0FBRWpCd0IsMEJBQXNCdkMsZ0JBRkw7QUFHakJ2TSxhQUFTcU4sbUJBSFE7QUFJakJvQixlQUFXakI7QUFKTSxHQUFuQjtBQU1BUCxzQkFBb0JwOUQsSUFBcEIsQ0FBeUIrK0QsWUFBekI7QUFDQXRCLDBCQUF3QixDQUF4QjtBQUNBQyxvQ0FBa0MsQ0FBbEM7QUFDQUYsd0JBQXNCLElBQXRCO0FBQ0FHLHFCQUFtQixJQUFuQjtBQUNEOztBQUVELFNBQVN1QiwyQkFBVCxHQUF1QztBQUNyQyxNQUFJQyx3QkFBd0IvQixvQkFBb0I1MkQsR0FBcEIsRUFBNUI7QUFBQSxNQUNJdzRELFlBQVlHLHNCQUFzQkgsU0FEdEM7QUFBQSxNQUVJQyx1QkFBdUJFLHNCQUFzQkYsb0JBRmpEO0FBQUEsTUFHSTlPLFVBQVVnUCxzQkFBc0JoUCxPQUhwQztBQUFBLE1BSUl5TyxZQUFZTyxzQkFBc0JQLFNBSnRDOztBQU1BLE1BQUlRLHNCQUFzQjFDLG1CQUFtQnVDLG9CQUE3QztBQUNBeEIsMEJBQXdCdUIsU0FBeEI7QUFDQXRCLHFDQUFtQzBCLG1CQUFuQztBQUNBNUIsd0JBQXNCck4sT0FBdEI7QUFDQXdOLHFCQUFtQmlCLFNBQW5CO0FBQ0Q7O0FBRUQsSUFBSVMsb0JBQW9CLENBQXhCO0FBQ0EsSUFBSUMsMkJBQTJCLE9BQU9DLFdBQVAsS0FBdUIsV0FBdkIsSUFBc0MsT0FBT0EsWUFBWTlTLElBQW5CLEtBQTRCLFVBQWxFLElBQWdGLE9BQU84UyxZQUFZQyxVQUFuQixLQUFrQyxVQUFsSCxJQUFnSSxPQUFPRCxZQUFZRSxPQUFuQixLQUErQixVQUEvSixJQUE2SyxPQUFPRixZQUFZRyxhQUFuQixLQUFxQyxVQUFqUDs7QUFFQSxTQUFTQyxVQUFULENBQW9CeFAsT0FBcEIsRUFBNkI7QUFDM0IsTUFBSSxDQUFDK00sWUFBRCxJQUFnQixDQUFDb0Msd0JBQXJCLEVBQStDO0FBQzdDLFdBQU8sS0FBUDtBQUNEO0FBQ0QsTUFBSTl5RCxVQUFVSSx1QkFBdUJDLFVBQXZCLENBQWtDc2pELE9BQWxDLENBQWQ7QUFDQSxNQUFJM2pELFdBQVcsSUFBWCxJQUFtQixRQUFPQSxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQTFDLEVBQW9EO0FBQ2xELFdBQU8sS0FBUDtBQUNEO0FBQ0QsTUFBSW96RCxnQkFBZ0IsT0FBT3B6RCxRQUFRQyxJQUFmLEtBQXdCLFFBQTVDO0FBQ0EsTUFBSW16RCxhQUFKLEVBQW1CO0FBQ2pCLFdBQU8sS0FBUDtBQUNEO0FBQ0QsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQsU0FBU0MsU0FBVCxDQUFtQjFQLE9BQW5CLEVBQTRCMlAsUUFBNUIsRUFBc0M7QUFDcEMsTUFBSSxDQUFDSCxXQUFXeFAsT0FBWCxDQUFMLEVBQTBCO0FBQ3hCO0FBQ0Q7O0FBRUQsTUFBSTRQLFdBQVc1UCxVQUFVLElBQVYsR0FBaUIyUCxRQUFoQztBQUNBVCxzQkFBb0IzQyxnQkFBcEI7QUFDQTZDLGNBQVk5UyxJQUFaLENBQWlCc1QsUUFBakI7QUFDRDs7QUFFRCxTQUFTQyxPQUFULENBQWlCN1AsT0FBakIsRUFBMEIyUCxRQUExQixFQUFvQztBQUNsQyxNQUFJLENBQUNILFdBQVd4UCxPQUFYLENBQUwsRUFBMEI7QUFDeEI7QUFDRDs7QUFFRCxNQUFJNFAsV0FBVzVQLFVBQVUsSUFBVixHQUFpQjJQLFFBQWhDO0FBQ0EsTUFBSXB6RCxjQUFjRSx1QkFBdUJMLGNBQXZCLENBQXNDNGpELE9BQXRDLEtBQWtELFNBQXBFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUk1NkMsWUFBWW1uRCxnQkFBaEI7QUFDQSxNQUFJbm5ELFlBQVk4cEQsaUJBQVosR0FBZ0MsR0FBcEMsRUFBeUM7QUFDdkMsUUFBSVksa0JBQWtCdnpELGNBQWMsSUFBZCxHQUFxQm96RCxRQUFyQixHQUFnQyxHQUF0RDtBQUNBUCxnQkFBWUUsT0FBWixDQUFvQlEsZUFBcEIsRUFBcUNGLFFBQXJDO0FBQ0Q7O0FBRURSLGNBQVlDLFVBQVosQ0FBdUJPLFFBQXZCO0FBQ0EsTUFBSUUsZUFBSixFQUFxQjtBQUNuQlYsZ0JBQVlHLGFBQVosQ0FBMEJPLGVBQTFCO0FBQ0Q7QUFDRjs7QUFFRCxJQUFJaHdELGlCQUFpQjtBQUNuQjRsRCxXQUFTLGlCQUFVb0gsSUFBVixFQUFnQjtBQUN2Qk4sVUFBTTM4RCxJQUFOLENBQVdpOUQsSUFBWDtBQUNELEdBSGtCO0FBSW5CaUQsY0FBWSxvQkFBVWpELElBQVYsRUFBZ0I7QUFDMUIsU0FBSyxJQUFJbDlELElBQUksQ0FBYixFQUFnQkEsSUFBSTQ4RCxNQUFNdDlELE1BQTFCLEVBQWtDVSxHQUFsQyxFQUF1QztBQUNyQyxVQUFJNDhELE1BQU01OEQsQ0FBTixNQUFhazlELElBQWpCLEVBQXVCO0FBQ3JCTixjQUFNL3FELE1BQU4sQ0FBYTdSLENBQWIsRUFBZ0IsQ0FBaEI7QUFDQUE7QUFDRDtBQUNGO0FBQ0YsR0FYa0I7QUFZbkJtOUQsZUFBYSx1QkFBWTtBQUN2QixXQUFPQSxZQUFQO0FBQ0QsR0Fka0I7QUFlbkJpRCxrQkFBZ0IsMEJBQVk7QUFDMUIsUUFBSWpELFlBQUosRUFBaUI7QUFDZjtBQUNEOztBQUVEQSxtQkFBYyxJQUFkO0FBQ0FDLGlCQUFhOTlELE1BQWIsR0FBc0IsQ0FBdEI7QUFDQTIrRDtBQUNBL3RELG1CQUFlNGxELE9BQWYsQ0FBdUI0Ryw2QkFBdkI7QUFDRCxHQXhCa0I7QUF5Qm5CMkQsZ0JBQWMsd0JBQVk7QUFDeEIsUUFBSSxDQUFDbEQsWUFBTCxFQUFrQjtBQUNoQjtBQUNEOztBQUVEQSxtQkFBYyxLQUFkO0FBQ0FjO0FBQ0EvdEQsbUJBQWVpd0QsVUFBZixDQUEwQnpELDZCQUExQjtBQUNELEdBakNrQjtBQWtDbkI0RCxtQkFBaUIsMkJBQVk7QUFDM0IsV0FBT2xELFlBQVA7QUFDRCxHQXBDa0I7QUFxQ25CcmUsZ0JBQWMsd0JBQVk7QUFDeEJ1ZTtBQUNBVztBQUNBYztBQUNBOUIsY0FBVSxjQUFWO0FBQ0QsR0ExQ2tCO0FBMkNuQmplLGNBQVksc0JBQVk7QUFDdEJpZjtBQUNBWDtBQUNBNkI7QUFDQWxDLGNBQVUsWUFBVjtBQUNELEdBaERrQjtBQWlEbkJzRCx5QkFBdUIsK0JBQVVuUSxPQUFWLEVBQW1CeU8sU0FBbkIsRUFBOEI7QUFDbkRILGlCQUFhdE8sT0FBYjtBQUNBNk0sY0FBVSx1QkFBVixFQUFtQzdNLE9BQW5DLEVBQTRDeU8sU0FBNUM7QUFDQWlCLGNBQVUxUCxPQUFWLEVBQW1CeU8sU0FBbkI7QUFDQUQsd0JBQW9CeE8sT0FBcEIsRUFBNkJ5TyxTQUE3QjtBQUNELEdBdERrQjtBQXVEbkIyQix1QkFBcUIsNkJBQVVwUSxPQUFWLEVBQW1CeU8sU0FBbkIsRUFBOEI7QUFDakRILGlCQUFhdE8sT0FBYjtBQUNBME8sc0JBQWtCMU8sT0FBbEIsRUFBMkJ5TyxTQUEzQjtBQUNBb0IsWUFBUTdQLE9BQVIsRUFBaUJ5TyxTQUFqQjtBQUNBNUIsY0FBVSxxQkFBVixFQUFpQzdNLE9BQWpDLEVBQTBDeU8sU0FBMUM7QUFDRCxHQTVEa0I7QUE2RG5CNEIsaUNBQStCLHlDQUFZO0FBQ3pDeEQsY0FBVSwrQkFBVjtBQUNELEdBL0RrQjtBQWdFbkJ5RCwrQkFBNkIsdUNBQVk7QUFDdkN6RCxjQUFVLDZCQUFWO0FBQ0QsR0FsRWtCO0FBbUVuQm5rQyxtQkFBaUIseUJBQVU2bkMsU0FBVixFQUFxQjtBQUNwQ2pDLGlCQUFhaUMsVUFBVTVuQyxVQUF2QjtBQUNBa2tDLGNBQVUsaUJBQVYsRUFBNkIwRCxTQUE3QjtBQUNELEdBdEVrQjtBQXVFbkI1aEMsY0FBWSxzQkFBWTtBQUN0QmsrQixjQUFVLFlBQVY7QUFDRCxHQXpFa0I7QUEwRW5CL3ZELGlCQUFlLHVCQUFVa2pELE9BQVYsRUFBbUJ3USxhQUFuQixFQUFrQztBQUMvQ2xDLGlCQUFhdE8sT0FBYjtBQUNBd1Esa0JBQWMzNEQsT0FBZCxDQUFzQnkyRCxZQUF0QjtBQUNBekIsY0FBVSxlQUFWLEVBQTJCN00sT0FBM0IsRUFBb0N3USxhQUFwQztBQUNELEdBOUVrQjtBQStFbkJwekQsMEJBQXdCLGdDQUFVNGlELE9BQVYsRUFBbUIzakQsT0FBbkIsRUFBNEJ5VCxhQUE1QixFQUEyQztBQUNqRXcrQyxpQkFBYXRPLE9BQWI7QUFDQXNPLGlCQUFheCtDLGFBQWIsRUFBNEIsSUFBNUI7QUFDQSs4QyxjQUFVLHdCQUFWLEVBQW9DN00sT0FBcEMsRUFBNkMzakQsT0FBN0MsRUFBc0R5VCxhQUF0RDtBQUNBNC9DLGNBQVUxUCxPQUFWLEVBQW1CLE9BQW5CO0FBQ0QsR0FwRmtCO0FBcUZuQnhpRCxvQkFBa0IsMEJBQVV3aUQsT0FBVixFQUFtQjtBQUNuQ3NPLGlCQUFhdE8sT0FBYjtBQUNBNlAsWUFBUTdQLE9BQVIsRUFBaUIsT0FBakI7QUFDQTZNLGNBQVUsa0JBQVYsRUFBOEI3TSxPQUE5QjtBQUNELEdBekZrQjtBQTBGbkJ6aUQsMkJBQXlCLGlDQUFVeWlELE9BQVYsRUFBbUIzakQsT0FBbkIsRUFBNEI7QUFDbkRpeUQsaUJBQWF0TyxPQUFiO0FBQ0E2TSxjQUFVLHlCQUFWLEVBQXFDN00sT0FBckMsRUFBOEMzakQsT0FBOUM7QUFDQXF6RCxjQUFVMVAsT0FBVixFQUFtQixRQUFuQjtBQUNELEdBOUZrQjtBQStGbkJ0aUQscUJBQW1CLDJCQUFVc2lELE9BQVYsRUFBbUI7QUFDcENzTyxpQkFBYXRPLE9BQWI7QUFDQTZQLFlBQVE3UCxPQUFSLEVBQWlCLFFBQWpCO0FBQ0E2TSxjQUFVLG1CQUFWLEVBQStCN00sT0FBL0I7QUFDRCxHQW5Ha0I7QUFvR25CNXZDLDRCQUEwQixrQ0FBVTR2QyxPQUFWLEVBQW1CO0FBQzNDc08saUJBQWF0TyxPQUFiO0FBQ0E2TSxjQUFVLDBCQUFWLEVBQXNDN00sT0FBdEM7QUFDQTBQLGNBQVUxUCxPQUFWLEVBQW1CLFNBQW5CO0FBQ0QsR0F4R2tCO0FBeUduQnJpRCxzQkFBb0IsNEJBQVVxaUQsT0FBVixFQUFtQjtBQUNyQ3NPLGlCQUFhdE8sT0FBYjtBQUNBNlAsWUFBUTdQLE9BQVIsRUFBaUIsU0FBakI7QUFDQTZNLGNBQVUsb0JBQVYsRUFBZ0M3TSxPQUFoQztBQUNELEdBN0drQjtBQThHbkJ5USxlQUFhLHVCQUFZO0FBQ3ZCNUQsY0FBVSxhQUFWO0FBQ0Q7QUFoSGtCLENBQXJCOztBQW1IQTtBQUNBL3NELGVBQWU0d0QsVUFBZixHQUE0QjV3RCxlQUFlNGxELE9BQTNDO0FBQ0E1bEQsZUFBZTZ3RCxhQUFmLEdBQStCN3dELGVBQWVpd0QsVUFBOUM7O0FBRUFqd0QsZUFBZTRsRCxPQUFmLENBQXVCMkcsK0JBQXZCO0FBQ0F2c0QsZUFBZTRsRCxPQUFmLENBQXVCanBELHNCQUF2QjtBQUNBLElBQUlvNEIsTUFBTWo4QixxQkFBcUJKLFNBQXJCLElBQWtDQyxPQUFPaWdCLFFBQVAsQ0FBZ0J1OEIsSUFBbEQsSUFBMEQsRUFBcEU7QUFDQSxJQUFJLG1CQUFtQjU2QyxJQUFuQixDQUF3Qnc2QixHQUF4QixDQUFKLEVBQWtDO0FBQ2hDLzBCLGlCQUFla3dELGNBQWY7QUFDRDs7QUFFRGxpRSxPQUFPQyxPQUFQLEdBQWlCK1IsY0FBakIsQzs7Ozs7Ozs7QUN2V0E7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUEsSUFBSXBOLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUk1RSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJaS9ELHlCQUF5QixLQUE3Qjs7QUFFQSxNQUFJQyxzQkFBc0IsU0FBdEJBLG1CQUFzQixHQUFZO0FBQ3BDaGpFLFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLENBQUNrK0Qsc0JBQVQsRUFBaUMsZ0VBQWpDLENBQXhDLEdBQTZJLEtBQUssQ0FBbEo7QUFDRCxHQUZEO0FBR0Q7O0FBRUQsSUFBSXZFLGtDQUFrQztBQUNwQ2dFLGlDQUErQix5Q0FBWTtBQUN6Q08sNkJBQXlCLElBQXpCO0FBQ0QsR0FIbUM7QUFJcENOLCtCQUE2Qix1Q0FBWTtBQUN2Q00sNkJBQXlCLEtBQXpCO0FBQ0QsR0FObUM7QUFPcENqaUMsY0FBWSxzQkFBWTtBQUN0QmtpQztBQUNEO0FBVG1DLENBQXRDOztBQVlBL2lFLE9BQU9DLE9BQVAsR0FBaUJzK0QsK0JBQWpCLEM7Ozs7Ozs7O0FDbkNBOzs7Ozs7Ozs7OztBQVdBOztBQUVBLElBQUk1M0IsVUFBVSxFQUFkOztBQUVBLElBQUk2M0IsZ0NBQWdDO0FBQ2xDNWpDLG1CQUFpQix5QkFBVTZuQyxTQUFWLEVBQXFCO0FBQ3BDOTdCLFlBQVE1a0MsSUFBUixDQUFhMGdFLFNBQWI7QUFDRCxHQUhpQztBQUlsQzdDLGdCQUFjLHdCQUFZO0FBQ3hCLFFBQUlwQiw4QkFBOEJ3RSxnQkFBbEMsRUFBb0Q7QUFDbEQ7QUFDQTtBQUNEOztBQUVEcjhCLGNBQVUsRUFBVjtBQUNELEdBWGlDO0FBWWxDdzVCLGNBQVksc0JBQVk7QUFDdEIsV0FBT3g1QixPQUFQO0FBQ0Q7QUFkaUMsQ0FBcEM7O0FBaUJBM21DLE9BQU9DLE9BQVAsR0FBaUJ1K0QsNkJBQWpCLEM7Ozs7Ozs7QUNoQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0EsSUFBSThDLGNBQWMsbUJBQUEzOEQsQ0FBUSxHQUFSLENBQWxCOztBQUVBLElBQUk4NUQsY0FBSjs7QUFFQTs7Ozs7QUFLQSxJQUFJNkMsWUFBWTdwRCxHQUFoQixFQUFxQjtBQUNuQmduRCxtQkFBaUIsU0FBU0EsY0FBVCxHQUEwQjtBQUN6QyxXQUFPNkMsWUFBWTdwRCxHQUFaLEVBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRCxNQUlPO0FBQ0xnbkQsbUJBQWlCLFNBQVNBLGNBQVQsR0FBMEI7QUFDekMsV0FBT2puRCxLQUFLQyxHQUFMLEVBQVA7QUFDRCxHQUZEO0FBR0Q7O0FBRUR6WCxPQUFPQyxPQUFQLEdBQWlCdytELGNBQWpCLEM7Ozs7Ozs7QUNoQ0E7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUEsSUFBSTN6RCx1QkFBdUIsbUJBQUFuRyxDQUFRLENBQVIsQ0FBM0I7O0FBRUEsSUFBSTI4RCxXQUFKOztBQUVBLElBQUl4MkQscUJBQXFCSixTQUF6QixFQUFvQztBQUNsQzQyRCxnQkFBYzMyRCxPQUFPMjJELFdBQVAsSUFBc0IzMkQsT0FBT3M0RCxhQUE3QixJQUE4Q3Q0RCxPQUFPdTRELGlCQUFuRTtBQUNEOztBQUVEbGpFLE9BQU9DLE9BQVAsR0FBaUJxaEUsZUFBZSxFQUFoQyxDOzs7Ozs7O0FDckJBOzs7Ozs7Ozs7O0FBVUE7O0FBRUE7Ozs7Ozs7Ozs7QUFVQSxJQUFJdEosMEJBQTBCLENBQUMsc0JBQUQsRUFBeUIsbUJBQXpCLEVBQThDLGdCQUE5QyxFQUFnRSx1QkFBaEUsRUFBeUYsbUJBQXpGLEVBQThHLG1CQUE5RyxFQUFtSSx3QkFBbkksQ0FBOUI7O0FBRUFoNEQsT0FBT0MsT0FBUCxHQUFpQiszRCx1QkFBakIsQzs7Ozs7OztBQ3hCQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl2eEMsbUJBQW1CLG1CQUFBOWhCLENBQVEsRUFBUixDQUF2QjtBQUNBLElBQUlnRSx3QkFBd0IsbUJBQUFoRSxDQUFRLENBQVIsQ0FBNUI7QUFDQSxJQUFJOHBCLHNCQUFzQixtQkFBQTlwQixDQUFRLEVBQVIsQ0FBMUI7O0FBRUEsSUFBSTBtQixhQUFhO0FBQ2Y4M0MsY0FBWTtBQUNWaitDLHNCQUFrQixjQURSO0FBRVYyRyxrQkFBYyxDQUFDLGFBQUQsRUFBZ0IsY0FBaEI7QUFGSixHQURHO0FBS2Z1M0MsY0FBWTtBQUNWbCtDLHNCQUFrQixjQURSO0FBRVYyRyxrQkFBYyxDQUFDLGFBQUQsRUFBZ0IsY0FBaEI7QUFGSjtBQUxHLENBQWpCOztBQVdBLElBQUlvc0Msd0JBQXdCO0FBQzFCNXNDLGNBQVlBLFVBRGM7O0FBRzFCOzs7Ozs7O0FBT0FsRCxpQkFBZSx1QkFBVUMsWUFBVixFQUF3QnRRLFVBQXhCLEVBQW9DQyxXQUFwQyxFQUFpREMsaUJBQWpELEVBQW9FO0FBQ2pGLFFBQUlvUSxpQkFBaUIsY0FBakIsS0FBb0NyUSxZQUFZa1csYUFBWixJQUE2QmxXLFlBQVltVyxXQUE3RSxDQUFKLEVBQStGO0FBQzdGLGFBQU8sSUFBUDtBQUNEO0FBQ0QsUUFBSTlGLGlCQUFpQixhQUFqQixJQUFrQ0EsaUJBQWlCLGNBQXZELEVBQXVFO0FBQ3JFO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBSWk3QyxHQUFKO0FBQ0EsUUFBSXJyRCxrQkFBa0JyTixNQUFsQixLQUE2QnFOLGlCQUFqQyxFQUFvRDtBQUNsRDtBQUNBcXJELFlBQU1yckQsaUJBQU47QUFDRCxLQUhELE1BR087QUFDTDtBQUNBLFVBQUlpUixNQUFNalIsa0JBQWtCa1IsYUFBNUI7QUFDQSxVQUFJRCxHQUFKLEVBQVM7QUFDUG82QyxjQUFNcDZDLElBQUlFLFdBQUosSUFBbUJGLElBQUlHLFlBQTdCO0FBQ0QsT0FGRCxNQUVPO0FBQ0xpNkMsY0FBTTE0RCxNQUFOO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJTixJQUFKO0FBQ0EsUUFBSUMsRUFBSjtBQUNBLFFBQUk4ZCxpQkFBaUIsYUFBckIsRUFBb0M7QUFDbEMvZCxhQUFPeU4sVUFBUDtBQUNBLFVBQUl3ckQsVUFBVXZyRCxZQUFZa1csYUFBWixJQUE2QmxXLFlBQVlxVyxTQUF2RDtBQUNBOWpCLFdBQUtnNUQsVUFBVTM2RCxzQkFBc0JSLDBCQUF0QixDQUFpRG03RCxPQUFqRCxDQUFWLEdBQXNFLElBQTNFO0FBQ0QsS0FKRCxNQUlPO0FBQ0w7QUFDQWo1RCxhQUFPLElBQVA7QUFDQUMsV0FBS3dOLFVBQUw7QUFDRDs7QUFFRCxRQUFJek4sU0FBU0MsRUFBYixFQUFpQjtBQUNmO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBSXN4QixXQUFXdnhCLFFBQVEsSUFBUixHQUFlZzVELEdBQWYsR0FBcUIxNkQsc0JBQXNCRixtQkFBdEIsQ0FBMEM0QixJQUExQyxDQUFwQztBQUNBLFFBQUlrNUQsU0FBU2o1RCxNQUFNLElBQU4sR0FBYSs0RCxHQUFiLEdBQW1CMTZELHNCQUFzQkYsbUJBQXRCLENBQTBDNkIsRUFBMUMsQ0FBaEM7O0FBRUEsUUFBSStiLFFBQVFvSSxvQkFBb0J4YixTQUFwQixDQUE4Qm9ZLFdBQVcrM0MsVUFBekMsRUFBcUQvNEQsSUFBckQsRUFBMkQwTixXQUEzRCxFQUF3RUMsaUJBQXhFLENBQVo7QUFDQXFPLFVBQU03WCxJQUFOLEdBQWEsWUFBYjtBQUNBNlgsVUFBTWxjLE1BQU4sR0FBZXl4QixRQUFmO0FBQ0F2VixVQUFNNEgsYUFBTixHQUFzQnMxQyxNQUF0Qjs7QUFFQSxRQUFJajlDLFFBQVFtSSxvQkFBb0J4YixTQUFwQixDQUE4Qm9ZLFdBQVc4M0MsVUFBekMsRUFBcUQ3NEQsRUFBckQsRUFBeUR5TixXQUF6RCxFQUFzRUMsaUJBQXRFLENBQVo7QUFDQXNPLFVBQU05WCxJQUFOLEdBQWEsWUFBYjtBQUNBOFgsVUFBTW5jLE1BQU4sR0FBZW81RCxNQUFmO0FBQ0FqOUMsVUFBTTJILGFBQU4sR0FBc0IyTixRQUF0Qjs7QUFFQW5WLHFCQUFpQkwsOEJBQWpCLENBQWdEQyxLQUFoRCxFQUF1REMsS0FBdkQsRUFBOERqYyxJQUE5RCxFQUFvRUMsRUFBcEU7O0FBRUEsV0FBTyxDQUFDK2IsS0FBRCxFQUFRQyxLQUFSLENBQVA7QUFDRDtBQWxFeUIsQ0FBNUI7O0FBcUVBdG1CLE9BQU9DLE9BQVAsR0FBaUJnNEQscUJBQWpCLEM7Ozs7Ozs7QUNoR0E7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJcnlELGNBQWMsbUJBQUFqQixDQUFRLEVBQVIsQ0FBbEI7O0FBRUEsSUFBSXlWLG9CQUFvQnhVLFlBQVlnUixTQUFaLENBQXNCd0QsaUJBQTlDO0FBQ0EsSUFBSUMsb0JBQW9CelUsWUFBWWdSLFNBQVosQ0FBc0J5RCxpQkFBOUM7QUFDQSxJQUFJQyxvQkFBb0IxVSxZQUFZZ1IsU0FBWixDQUFzQjBELGlCQUE5QztBQUNBLElBQUlDLDZCQUE2QjNVLFlBQVlnUixTQUFaLENBQXNCMkQsMEJBQXZEO0FBQ0EsSUFBSUMsK0JBQStCNVUsWUFBWWdSLFNBQVosQ0FBc0I0RCw0QkFBekQ7O0FBRUEsSUFBSTA5Qyx3QkFBd0I7QUFDMUJqOUMscUJBQW1CM08sT0FBT3BLLFNBQVAsQ0FBaUJxSyxJQUFqQixDQUFzQitSLElBQXRCLENBQTJCLElBQUloUyxNQUFKLENBQVcsbUJBQW1CMUcsWUFBWXdXLG1CQUEvQixHQUFxRCxLQUFoRSxDQUEzQixDQURPO0FBRTFCeEIsY0FBWTtBQUNWOzs7QUFHQTRvRCxZQUFRLENBSkU7QUFLVkMsbUJBQWUsQ0FMTDtBQU1WQyxlQUFXLENBTkQ7QUFPVjdwRCxZQUFRLENBUEU7QUFRVjhwRCxxQkFBaUJ0cEQsaUJBUlA7QUFTVnVwRCx1QkFBbUIsQ0FUVDtBQVVWQyxTQUFLLENBVks7QUFXVjtBQUNBQyxRQUFJLENBWk07QUFhVkMsV0FBTzFwRCxpQkFiRztBQWNWMnBELGtCQUFjLENBZEo7QUFlVjtBQUNBO0FBQ0FDLGNBQVU1cEQsaUJBakJBO0FBa0JWNGUsYUFBUzVlLGlCQWxCQztBQW1CVjZwRCxpQkFBYSxDQW5CSDtBQW9CVkMsaUJBQWEsQ0FwQkg7QUFxQlZDLGFBQVMsQ0FyQkM7QUFzQlZDLGVBQVcsQ0F0QkQ7QUF1QlZsbkMsYUFBUy9pQixvQkFBb0JDLGlCQXZCbkI7QUF3QlY0eEMsVUFBTSxDQXhCSTtBQXlCVnFZLGFBQVMsQ0F6QkM7QUEwQlZDLGVBQVcsQ0ExQkQ7QUEyQlZDLFVBQU1qcUQsMEJBM0JJO0FBNEJWa3FELGFBQVMsQ0E1QkM7QUE2QlZocEMsYUFBUyxDQTdCQztBQThCVmdpQixxQkFBaUIsQ0E5QlA7QUErQlZpbkIsaUJBQWEsQ0EvQkg7QUFnQ1ZDLGNBQVV0cUQsaUJBaENBO0FBaUNWdXFELFlBQVEsQ0FqQ0U7QUFrQ1ZDLGlCQUFhLENBbENIO0FBbUNWMzFDLFVBQU0sQ0FuQ0ksRUFtQ0Q7QUFDVDQxQyxjQUFVLENBcENBO0FBcUNWLGVBQVd6cUQsaUJBckNEO0FBc0NWMHFELFdBQU8xcUQsaUJBdENHO0FBdUNWNVcsU0FBSyxDQXZDSztBQXdDVitqQixjQUFVbk4saUJBeENBO0FBeUNWMnFELGNBQVV4cUQsNEJBekNBO0FBMENWeXFELGVBQVcsQ0ExQ0Q7QUEyQ1ZDLGFBQVMsQ0EzQ0M7QUE0Q1YvWCxVQUFNLENBNUNJO0FBNkNWZ1ksZ0JBQVksQ0E3Q0Y7QUE4Q1ZDLGlCQUFhLENBOUNIO0FBK0NWQyxnQkFBWSxDQS9DRjtBQWdEVkMsb0JBQWdCanJELGlCQWhETjtBQWlEVmtyRCxnQkFBWSxDQWpERjtBQWtEVkMsaUJBQWEsQ0FsREg7QUFtRFZDLGFBQVMsQ0FuREM7QUFvRFZDLFlBQVEsQ0FwREU7QUFxRFZqcEMsWUFBUXBpQixpQkFyREU7QUFzRFZzckQsVUFBTSxDQXRESTtBQXVEVnhlLFVBQU0sQ0F2REk7QUF3RFZ5ZSxjQUFVLENBeERBO0FBeURWQyxhQUFTLENBekRDO0FBMERWQyxlQUFXLENBMUREO0FBMkRWQyxVQUFNLENBM0RJO0FBNERWMzRELFFBQUksQ0E1RE07QUE2RFY0NEQsZUFBVyxDQTdERDtBQThEVkMsZUFBVyxDQTlERDtBQStEVjFuQyxRQUFJLENBL0RNO0FBZ0VWMm5DLGVBQVcsQ0FoRUQ7QUFpRVZDLGFBQVMsQ0FqRUM7QUFrRVZDLFVBQU0sQ0FsRUk7QUFtRVZqWSxXQUFPLENBbkVHO0FBb0VWa1ksVUFBTSxDQXBFSTtBQXFFVjFkLFVBQU0sQ0FyRUk7QUFzRVYyZCxVQUFNanNELGlCQXRFSTtBQXVFVmtzRCxTQUFLLENBdkVLO0FBd0VWQyxjQUFVLENBeEVBO0FBeUVWQyxrQkFBYyxDQXpFSjtBQTBFVkMsaUJBQWEsQ0ExRUg7QUEyRVZDLFNBQUssQ0EzRUs7QUE0RVZDLGVBQVcsQ0E1RUQ7QUE2RVZDLFdBQU8sQ0E3RUc7QUE4RVZDLGdCQUFZLENBOUVGO0FBK0VWcnlELFlBQVEsQ0EvRUU7QUFnRlY0dUIsU0FBSyxDQWhGSztBQWlGVjBqQyxlQUFXLENBakZEO0FBa0ZWO0FBQ0E7QUFDQTV0QixjQUFVLytCLG9CQUFvQkMsaUJBcEZwQjtBQXFGVjJzRCxXQUFPNXNELG9CQUFvQkMsaUJBckZqQjtBQXNGVmhYLFVBQU0sQ0F0Rkk7QUF1RlY0akUsV0FBTyxDQXZGRztBQXdGVkMsZ0JBQVk3c0QsaUJBeEZGO0FBeUZWOHNELFVBQU05c0QsaUJBekZJO0FBMEZWK3NELGFBQVMsQ0ExRkM7QUEyRlZqL0IsYUFBUyxDQTNGQztBQTRGVmsvQixpQkFBYSxDQTVGSDtBQTZGVkMsaUJBQWFqdEQsaUJBN0ZIO0FBOEZWa3RELFlBQVEsQ0E5RkU7QUErRlZDLGFBQVMsQ0EvRkM7QUFnR1ZDLGFBQVMsQ0FoR0M7QUFpR1ZDLGdCQUFZLENBakdGO0FBa0dWcHFDLGNBQVVqakIsaUJBbEdBO0FBbUdWc3RELG9CQUFnQixDQW5HTjtBQW9HVkMsU0FBSyxDQXBHSztBQXFHVkMsY0FBVXh0RCxpQkFyR0E7QUFzR1Z5dEQsY0FBVXp0RCxpQkF0R0E7QUF1R1YwdEQsVUFBTSxDQXZHSTtBQXdHVkMsVUFBTXp0RCwwQkF4R0k7QUF5R1YwdEQsYUFBUzN0RCxpQkF6R0M7QUEwR1Y0dEQsYUFBUyxDQTFHQztBQTJHVnh6RCxXQUFPLENBM0dHO0FBNEdWeXpELFlBQVE5dEQsaUJBNUdFO0FBNkdWK3RELGVBQVcsQ0E3R0Q7QUE4R1ZDLGNBQVVodUQsaUJBOUdBO0FBK0dWay9CLGNBQVVuL0Isb0JBQW9CQyxpQkEvR3BCO0FBZ0hWK3lCLFdBQU8sQ0FoSEc7QUFpSFZrN0IsVUFBTS90RCwwQkFqSEk7QUFrSFZndUQsV0FBTyxDQWxIRztBQW1IVnZZLFVBQU16MUMsMEJBbkhJO0FBb0hWaXVELGdCQUFZLENBcEhGO0FBcUhWQyxTQUFLLENBckhLO0FBc0hWQyxZQUFRLENBdEhFO0FBdUhWQyxhQUFTLENBdkhDO0FBd0hWQyxZQUFRLENBeEhFO0FBeUhWdHFCLFdBQU9oa0MsaUJBekhHO0FBMEhWaXhCLFVBQU0sQ0ExSEk7QUEySFYya0IsV0FBTyxDQTNIRztBQTRIVkUsYUFBUyxDQTVIQztBQTZIVnlZLGNBQVUsQ0E3SEE7QUE4SFYxK0QsWUFBUSxDQTlIRTtBQStIVi9ILFdBQU8sQ0EvSEc7QUFnSVY7QUFDQW9NLFVBQU0sQ0FqSUk7QUFrSVZzNkQsWUFBUSxDQWxJRTtBQW1JVjF2RCxXQUFPLENBbklHO0FBb0lWMnZELFdBQU8sQ0FwSUc7QUFxSVZDLFdBQU8sQ0FySUc7QUFzSVZDLFVBQU0sQ0F0SUk7O0FBd0lWOzs7QUFHQUMsV0FBTyxDQTNJRztBQTRJVkMsY0FBVSxDQTVJQTtBQTZJVkMsWUFBUSxDQTdJRTtBQThJVmwvQyxZQUFRLENBOUlFO0FBK0lWO0FBQ0FxcUMsY0FBVSxDQWhKQTtBQWlKVjhVLGNBQVUsQ0FqSkE7QUFrSlYsY0FBVSxDQWxKQTtBQW1KVkMsV0FBTyxDQW5KRzs7QUFxSlY7OztBQUdBO0FBQ0E7QUFDQUMsb0JBQWdCLENBMUpOO0FBMkpWQyxpQkFBYSxDQTNKSDtBQTRKVjtBQUNBQyxjQUFVLENBN0pBO0FBOEpWO0FBQ0FuNEIsV0FBTyxDQS9KRztBQWdLVjtBQUNBO0FBQ0FvNEIsY0FBVSxDQWxLQTtBQW1LVkMsZUFBV3R2RCxpQkFuS0Q7QUFvS1Z1dkQsY0FBVSxDQXBLQTtBQXFLVjtBQUNBO0FBQ0E7QUFDQUMsWUFBUSxDQXhLRTtBQXlLVkMsYUFBUyxDQXpLQztBQTBLVjtBQUNBO0FBQ0FDLGFBQVMsQ0E1S0M7QUE2S1Y7QUFDQTtBQUNBQyxjQUFVLENBL0tBO0FBZ0xWO0FBQ0FDLGtCQUFjO0FBakxKLEdBRmM7QUFxTDFCbnZELHFCQUFtQjtBQUNqQjJvRCxtQkFBZSxnQkFERTtBQUVqQmMsZUFBVyxPQUZNO0FBR2pCc0IsYUFBUyxLQUhRO0FBSWpCQyxlQUFXO0FBSk0sR0FyTE87QUEyTDFCL3FELG9CQUFrQixFQTNMUTtBQTRMMUJDLHNCQUFvQjtBQUNsQjVCLFdBQU8sZUFBVTdTLElBQVYsRUFBZ0I2UyxNQUFoQixFQUF1QjtBQUM1QixVQUFJQSxVQUFTLElBQWIsRUFBbUI7QUFDakIsZUFBTzdTLEtBQUtveUMsZUFBTCxDQUFxQixPQUFyQixDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsVUFBSXB5QyxLQUFLaUksSUFBTCxLQUFjLFFBQWQsSUFBMEJqSSxLQUFLNjZDLFlBQUwsQ0FBa0IsT0FBbEIsTUFBK0IsS0FBN0QsRUFBb0U7QUFDbEU3NkMsYUFBSzR5QixZQUFMLENBQWtCLE9BQWxCLEVBQTJCLEtBQUsvZixNQUFoQztBQUNELE9BRkQsTUFFTyxJQUFJN1MsS0FBSzJqRSxRQUFMLElBQWlCLENBQUMzakUsS0FBSzJqRSxRQUFMLENBQWNDLFFBQWhDLElBQTRDNWpFLEtBQUsyaUIsYUFBTCxDQUFtQmkyQixhQUFuQixLQUFxQzU0QyxJQUFyRixFQUEyRjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FBLGFBQUs0eUIsWUFBTCxDQUFrQixPQUFsQixFQUEyQixLQUFLL2YsTUFBaEM7QUFDRDtBQUNGO0FBdEJpQjtBQTVMTSxDQUE1Qjs7QUFzTkFwWixPQUFPQyxPQUFQLEdBQWlCaTRELHFCQUFqQixDOzs7Ozs7O0FDMU9BOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSS84Qix3QkFBd0IsbUJBQUF4MkIsQ0FBUSxFQUFSLENBQTVCO0FBQ0EsSUFBSXlsRSx1QkFBdUIsbUJBQUF6bEUsQ0FBUSxHQUFSLENBQTNCOztBQUVBOzs7OztBQUtBLElBQUl3ekQsbUNBQW1DO0FBQ3JDLzVCLDBCQUF3QmdzQyxxQkFBcUJDLGlDQURSOztBQUdyQ2xzQyx5QkFBdUJoRCxzQkFBc0JKO0FBSFIsQ0FBdkM7O0FBTUEvNkIsT0FBT0MsT0FBUCxHQUFpQms0RCxnQ0FBakIsQzs7Ozs7OztBQzFCQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl4eUQsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCOztBQUVBLElBQUkrZixjQUFjLG1CQUFBL2YsQ0FBUSxFQUFSLENBQWxCO0FBQ0EsSUFBSW1HLHVCQUF1QixtQkFBQW5HLENBQVEsQ0FBUixDQUEzQjs7QUFFQSxJQUFJMmxFLHdCQUF3QixtQkFBQTNsRSxDQUFRLEdBQVIsQ0FBNUI7QUFDQSxJQUFJRCxnQkFBZ0IsbUJBQUFDLENBQVEsRUFBUixDQUFwQjtBQUNBLElBQUlaLFlBQVksbUJBQUFZLENBQVEsQ0FBUixDQUFoQjs7QUFFQSxJQUFJazFCLFNBQVM7QUFDWDs7Ozs7Ozs7QUFRQWtCLG9DQUFrQywwQ0FBVUMsUUFBVixFQUFvQi9ZLE1BQXBCLEVBQTRCO0FBQzVELEtBQUNuWCxxQkFBcUJKLFNBQXRCLEdBQWtDM0ssUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixnUEFBakIsQ0FBeEMsR0FBNlM0QixlQUFlLElBQWYsQ0FBL1UsR0FBc1csS0FBSyxDQUEzVztBQUNBLEtBQUNzYyxNQUFELEdBQVVsaUIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQix3REFBakIsQ0FBeEMsR0FBcUg0QixlQUFlLElBQWYsQ0FBL0gsR0FBc0osS0FBSyxDQUEzSjtBQUNBLE1BQUVxMUIsU0FBU25YLFFBQVQsS0FBc0IsTUFBeEIsSUFBa0M5akIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQix5UEFBakIsQ0FBeEMsR0FBc1Q0QixlQUFlLElBQWYsQ0FBeFYsR0FBK1csS0FBSyxDQUFwWDs7QUFFQSxRQUFJLE9BQU9zYyxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCLFVBQUlzb0QsV0FBV0Qsc0JBQXNCcm9ELE1BQXRCLEVBQThCdmQsYUFBOUIsRUFBNkMsQ0FBN0MsQ0FBZjtBQUNBczJCLGVBQVMzeUIsVUFBVCxDQUFvQjhiLFlBQXBCLENBQWlDb21ELFFBQWpDLEVBQTJDdnZDLFFBQTNDO0FBQ0QsS0FIRCxNQUdPO0FBQ0x0VyxrQkFBWVYsb0JBQVosQ0FBaUNnWCxRQUFqQyxFQUEyQy9ZLE1BQTNDO0FBQ0Q7QUFDRjtBQXBCVSxDQUFiOztBQXVCQWppQixPQUFPQyxPQUFQLEdBQWlCNDVCLE1BQWpCLEM7Ozs7Ozs7OytDQzVDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJL3VCLHVCQUF1QixtQkFBQW5HLENBQVEsQ0FBUixDQUEzQjs7QUFFQSxJQUFJNmxFLHVCQUF1QixtQkFBQTdsRSxDQUFRLEdBQVIsQ0FBM0I7QUFDQSxJQUFJOGxFLGdCQUFnQixtQkFBQTlsRSxDQUFRLEdBQVIsQ0FBcEI7QUFDQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7O0FBRUE7OztBQUdBLElBQUkrbEUsWUFBWTUvRCxxQkFBcUJKLFNBQXJCLEdBQWlDRSxTQUFTQyxhQUFULENBQXVCLEtBQXZCLENBQWpDLEdBQWlFLElBQWpGOztBQUVBOzs7QUFHQSxJQUFJOC9ELGtCQUFrQixZQUF0Qjs7QUFFQTs7Ozs7O0FBTUEsU0FBU0MsV0FBVCxDQUFxQjNvRCxNQUFyQixFQUE2QjtBQUMzQixNQUFJNG9ELGdCQUFnQjVvRCxPQUFPd04sS0FBUCxDQUFhazdDLGVBQWIsQ0FBcEI7QUFDQSxTQUFPRSxpQkFBaUJBLGNBQWMsQ0FBZCxFQUFpQnh2RCxXQUFqQixFQUF4QjtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUEsU0FBU2l2RCxxQkFBVCxDQUErQnJvRCxNQUEvQixFQUF1QzZvRCxZQUF2QyxFQUFxRDtBQUNuRCxNQUFJdmtFLE9BQU9ta0UsU0FBWDtBQUNBLEdBQUMsQ0FBQyxDQUFDQSxTQUFILEdBQWUzcUUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiw2Q0FBakIsQ0FBeEMsR0FBMEdBLFVBQVUsS0FBVixDQUF6SCxHQUE0SSxLQUFLLENBQWpKO0FBQ0EsTUFBSThmLFdBQVcrbUQsWUFBWTNvRCxNQUFaLENBQWY7O0FBRUEsTUFBSWduRCxPQUFPcGxELFlBQVk0bUQsY0FBYzVtRCxRQUFkLENBQXZCO0FBQ0EsTUFBSW9sRCxJQUFKLEVBQVU7QUFDUjFpRSxTQUFLdW9CLFNBQUwsR0FBaUJtNkMsS0FBSyxDQUFMLElBQVVobkQsTUFBVixHQUFtQmduRCxLQUFLLENBQUwsQ0FBcEM7O0FBRUEsUUFBSThCLFlBQVk5QixLQUFLLENBQUwsQ0FBaEI7QUFDQSxXQUFPOEIsV0FBUCxFQUFvQjtBQUNsQnhrRSxhQUFPQSxLQUFLMHJDLFNBQVo7QUFDRDtBQUNGLEdBUEQsTUFPTztBQUNMMXJDLFNBQUt1b0IsU0FBTCxHQUFpQjdNLE1BQWpCO0FBQ0Q7O0FBRUQsTUFBSStvRCxVQUFVemtFLEtBQUswa0Usb0JBQUwsQ0FBMEIsUUFBMUIsQ0FBZDtBQUNBLE1BQUlELFFBQVE1cEUsTUFBWixFQUFvQjtBQUNsQixLQUFDMHBFLFlBQUQsR0FBZ0IvcUUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixtRUFBakIsQ0FBeEMsR0FBZ0lBLFVBQVUsS0FBVixDQUFoSixHQUFtSyxLQUFLLENBQXhLO0FBQ0F5bUUseUJBQXFCUSxPQUFyQixFQUE4QmpoRSxPQUE5QixDQUFzQytnRSxZQUF0QztBQUNEOztBQUVELE1BQUlJLFFBQVF0cEUsTUFBTXlJLElBQU4sQ0FBVzlELEtBQUs0a0UsVUFBaEIsQ0FBWjtBQUNBLFNBQU81a0UsS0FBSzByQyxTQUFaLEVBQXVCO0FBQ3JCMXJDLFNBQUs0b0IsV0FBTCxDQUFpQjVvQixLQUFLMHJDLFNBQXRCO0FBQ0Q7QUFDRCxTQUFPaTVCLEtBQVA7QUFDRDs7QUFFRGxyRSxPQUFPQyxPQUFQLEdBQWlCcXFFLHFCQUFqQixDOzs7Ozs7OzsrQ0NsRkE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFXQSxJQUFJdm1FLFlBQVksbUJBQUFZLENBQVEsQ0FBUixDQUFoQjs7QUFFQTs7Ozs7Ozs7O0FBU0EsU0FBU3FjLE9BQVQsQ0FBaUIyakIsR0FBakIsRUFBc0I7QUFDcEIsTUFBSXZqQyxTQUFTdWpDLElBQUl2akMsTUFBakI7O0FBRUE7QUFDQTtBQUNBLElBQUUsQ0FBQ1EsTUFBTXUxQixPQUFOLENBQWN3TixHQUFkLENBQUQsS0FBd0IsUUFBT0EsR0FBUCx5Q0FBT0EsR0FBUCxPQUFlLFFBQWYsSUFBMkIsT0FBT0EsR0FBUCxLQUFlLFVBQWxFLENBQUYsSUFBbUY1a0MsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixxQ0FBakIsQ0FBeEMsR0FBa0dBLFVBQVUsS0FBVixDQUFyTCxHQUF3TSxLQUFLLENBQTdNOztBQUVBLElBQUUsT0FBTzNDLE1BQVAsS0FBa0IsUUFBcEIsSUFBZ0NyQixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHlDQUFqQixDQUF4QyxHQUFzR0EsVUFBVSxLQUFWLENBQXRJLEdBQXlKLEtBQUssQ0FBOUo7O0FBRUEsSUFBRTNDLFdBQVcsQ0FBWCxJQUFnQkEsU0FBUyxDQUFULElBQWN1akMsR0FBaEMsSUFBdUM1a0MsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiw4Q0FBakIsQ0FBeEMsR0FBMkdBLFVBQVUsS0FBVixDQUFsSixHQUFxSyxLQUFLLENBQTFLOztBQUVBLElBQUUsT0FBTzRnQyxJQUFJeW1DLE1BQVgsS0FBc0IsVUFBeEIsSUFBc0NyckUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiw0REFBNEQsaURBQTdFLENBQXhDLEdBQTBLQSxVQUFVLEtBQVYsQ0FBaE4sR0FBbU8sS0FBSyxDQUF4Tzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFJNGdDLElBQUk3OEIsY0FBUixFQUF3QjtBQUN0QixRQUFJO0FBQ0YsYUFBT2xHLE1BQU1NLFNBQU4sQ0FBZ0JtRSxLQUFoQixDQUFzQnpGLElBQXRCLENBQTJCK2pDLEdBQTNCLENBQVA7QUFDRCxLQUZELENBRUUsT0FBT25rQyxDQUFQLEVBQVU7QUFDVjtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBLE1BQUlxc0IsTUFBTWpyQixNQUFNUixNQUFOLENBQVY7QUFDQSxPQUFLLElBQUlxN0MsS0FBSyxDQUFkLEVBQWlCQSxLQUFLcjdDLE1BQXRCLEVBQThCcTdDLElBQTlCLEVBQW9DO0FBQ2xDNXZCLFFBQUk0dkIsRUFBSixJQUFVOVgsSUFBSThYLEVBQUosQ0FBVjtBQUNEO0FBQ0QsU0FBTzV2QixHQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztBQWVBLFNBQVN3K0MsY0FBVCxDQUF3QjFtQyxHQUF4QixFQUE2QjtBQUMzQjtBQUNFO0FBQ0EsS0FBQyxDQUFDQSxHQUFGO0FBQ0E7QUFDQSxZQUFPQSxHQUFQLHlDQUFPQSxHQUFQLE1BQWMsUUFBZCxJQUEwQixPQUFPQSxHQUFQLElBQWMsVUFGeEM7QUFHQTtBQUNBLGdCQUFZQSxHQUpaO0FBS0E7QUFDQSxNQUFFLGlCQUFpQkEsR0FBbkIsQ0FOQTtBQU9BO0FBQ0E7QUFDQSxXQUFPQSxJQUFJbCtCLFFBQVgsSUFBdUIsUUFUdkI7QUFVQTtBQUNBN0UsVUFBTXUxQixPQUFOLENBQWN3TixHQUFkO0FBQ0E7QUFDQSxnQkFBWUEsR0FGWjtBQUdBO0FBQ0EsY0FBVUEsR0FmVjtBQUZGO0FBbUJEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQkEsU0FBUzZsQyxvQkFBVCxDQUE4QjdsQyxHQUE5QixFQUFtQztBQUNqQyxNQUFJLENBQUMwbUMsZUFBZTFtQyxHQUFmLENBQUwsRUFBMEI7QUFDeEIsV0FBTyxDQUFDQSxHQUFELENBQVA7QUFDRCxHQUZELE1BRU8sSUFBSS9pQyxNQUFNdTFCLE9BQU4sQ0FBY3dOLEdBQWQsQ0FBSixFQUF3QjtBQUM3QixXQUFPQSxJQUFJdCtCLEtBQUosRUFBUDtBQUNELEdBRk0sTUFFQTtBQUNMLFdBQU8yYSxRQUFRMmpCLEdBQVIsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQza0MsT0FBT0MsT0FBUCxHQUFpQnVxRSxvQkFBakIsQzs7Ozs7Ozs7K0NDN0hBOztBQUVBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSTEvRCx1QkFBdUIsbUJBQUFuRyxDQUFRLENBQVIsQ0FBM0I7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCOztBQUVBOzs7QUFHQSxJQUFJK2xFLFlBQVk1L0QscUJBQXFCSixTQUFyQixHQUFpQ0UsU0FBU0MsYUFBVCxDQUF1QixLQUF2QixDQUFqQyxHQUFpRSxJQUFqRjs7QUFFQTs7Ozs7OztBQU9BLElBQUl5Z0UsYUFBYSxFQUFqQjs7QUFFQSxJQUFJQyxhQUFhLENBQUMsQ0FBRCxFQUFJLDBCQUFKLEVBQWdDLFdBQWhDLENBQWpCO0FBQ0EsSUFBSUMsWUFBWSxDQUFDLENBQUQsRUFBSSxTQUFKLEVBQWUsVUFBZixDQUFoQjtBQUNBLElBQUlDLFNBQVMsQ0FBQyxDQUFELEVBQUksb0JBQUosRUFBMEIsdUJBQTFCLENBQWI7O0FBRUEsSUFBSUMsVUFBVSxDQUFDLENBQUQsRUFBSSwwQ0FBSixFQUFnRCxRQUFoRCxDQUFkOztBQUVBLElBQUlDLGFBQWE7QUFDZixPQUFLLENBQUMsQ0FBRCxFQUFJLFFBQUosRUFBYyxRQUFkLENBRFU7O0FBR2YsVUFBUSxDQUFDLENBQUQsRUFBSSxPQUFKLEVBQWEsUUFBYixDQUhPO0FBSWYsU0FBTyxDQUFDLENBQUQsRUFBSSxrQ0FBSixFQUF3QyxxQkFBeEMsQ0FKUTtBQUtmLFlBQVUsQ0FBQyxDQUFELEVBQUksWUFBSixFQUFrQixhQUFsQixDQUxLO0FBTWYsV0FBUyxDQUFDLENBQUQsRUFBSSxVQUFKLEVBQWdCLFdBQWhCLENBTk07QUFPZixRQUFNLENBQUMsQ0FBRCxFQUFJLGdCQUFKLEVBQXNCLGtCQUF0QixDQVBTOztBQVNmLGNBQVlKLFVBVEc7QUFVZixZQUFVQSxVQVZLOztBQVlmLGFBQVdDLFNBWkk7QUFhZixjQUFZQSxTQWJHO0FBY2YsV0FBU0EsU0FkTTtBQWVmLFdBQVNBLFNBZk07QUFnQmYsV0FBU0EsU0FoQk07O0FBa0JmLFFBQU1DLE1BbEJTO0FBbUJmLFFBQU1BO0FBbkJTLENBQWpCOztBQXNCQTtBQUNBO0FBQ0E7QUFDQSxJQUFJRyxjQUFjLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsTUFBdkIsRUFBK0IsU0FBL0IsRUFBMEMsR0FBMUMsRUFBK0MsT0FBL0MsRUFBd0QsTUFBeEQsRUFBZ0UsZ0JBQWhFLEVBQWtGLE1BQWxGLEVBQTBGLE1BQTFGLEVBQWtHLFNBQWxHLEVBQTZHLFNBQTdHLEVBQXdILFVBQXhILEVBQW9JLGdCQUFwSSxFQUFzSixNQUF0SixFQUE4SixNQUE5SixFQUFzSyxNQUF0SyxFQUE4SyxPQUE5SyxDQUFsQjtBQUNBQSxZQUFZN2hFLE9BQVosQ0FBb0IsVUFBVThaLFFBQVYsRUFBb0I7QUFDdEM4bkQsYUFBVzluRCxRQUFYLElBQXVCNm5ELE9BQXZCO0FBQ0FKLGFBQVd6bkQsUUFBWCxJQUF1QixJQUF2QjtBQUNELENBSEQ7O0FBS0E7Ozs7Ozs7O0FBUUEsU0FBUzRtRCxhQUFULENBQXVCNW1ELFFBQXZCLEVBQWlDO0FBQy9CLEdBQUMsQ0FBQyxDQUFDNm1ELFNBQUgsR0FBZTNxRSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHNDQUFqQixDQUF4QyxHQUFtR0EsVUFBVSxLQUFWLENBQWxILEdBQXFJLEtBQUssQ0FBMUk7QUFDQSxNQUFJLENBQUM0bkUsV0FBVzdqRSxjQUFYLENBQTBCK2IsUUFBMUIsQ0FBTCxFQUEwQztBQUN4Q0EsZUFBVyxHQUFYO0FBQ0Q7QUFDRCxNQUFJLENBQUN5bkQsV0FBV3hqRSxjQUFYLENBQTBCK2IsUUFBMUIsQ0FBTCxFQUEwQztBQUN4QyxRQUFJQSxhQUFhLEdBQWpCLEVBQXNCO0FBQ3BCNm1ELGdCQUFVNTdDLFNBQVYsR0FBc0IsVUFBdEI7QUFDRCxLQUZELE1BRU87QUFDTDQ3QyxnQkFBVTU3QyxTQUFWLEdBQXNCLE1BQU1qTCxRQUFOLEdBQWlCLEtBQWpCLEdBQXlCQSxRQUF6QixHQUFvQyxHQUExRDtBQUNEO0FBQ0R5bkQsZUFBV3puRCxRQUFYLElBQXVCLENBQUM2bUQsVUFBVTlpRSxVQUFsQztBQUNEO0FBQ0QsU0FBTzBqRSxXQUFXem5ELFFBQVgsSUFBdUI4bkQsV0FBVzluRCxRQUFYLENBQXZCLEdBQThDLElBQXJEO0FBQ0Q7O0FBRUQ3akIsT0FBT0MsT0FBUCxHQUFpQndxRSxhQUFqQixDOzs7Ozs7OztBQzdGQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl0dkMsd0JBQXdCLG1CQUFBeDJCLENBQVEsRUFBUixDQUE1QjtBQUNBLElBQUlnRSx3QkFBd0IsbUJBQUFoRSxDQUFRLENBQVIsQ0FBNUI7O0FBRUE7OztBQUdBLElBQUl5bEUsdUJBQXVCO0FBQ3pCOzs7Ozs7QUFNQUMscUNBQW1DLDJDQUFVemtELFVBQVYsRUFBc0J5VixPQUF0QixFQUErQjtBQUNoRSxRQUFJOTBCLE9BQU9vQyxzQkFBc0JGLG1CQUF0QixDQUEwQ21kLFVBQTFDLENBQVg7QUFDQXVWLDBCQUFzQkMsY0FBdEIsQ0FBcUM3MEIsSUFBckMsRUFBMkM4MEIsT0FBM0M7QUFDRDtBQVZ3QixDQUEzQjs7QUFhQXI3QixPQUFPQyxPQUFQLEdBQWlCbXFFLG9CQUFqQixDOzs7Ozs7O0FDL0JBOzs7Ozs7Ozs7O0FBVUE7O0FBRUE7Ozs7QUFFQSxJQUFJemtFLGlCQUFpQixtQkFBQWhCLENBQVEsQ0FBUixDQUFyQjtBQUFBLElBQ0k2TixVQUFVLG1CQUFBN04sQ0FBUSxDQUFSLENBRGQ7O0FBR0EsSUFBSWtuRSxpQkFBaUIsbUJBQUFsbkUsQ0FBUSxHQUFSLENBQXJCO0FBQ0EsSUFBSW1uRSx3QkFBd0IsbUJBQUFubkUsQ0FBUSxHQUFSLENBQTVCO0FBQ0EsSUFBSStmLGNBQWMsbUJBQUEvZixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJbWUsZ0JBQWdCLG1CQUFBbmUsQ0FBUSxFQUFSLENBQXBCO0FBQ0EsSUFBSWlCLGNBQWMsbUJBQUFqQixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJb3pDLHdCQUF3QixtQkFBQXB6QyxDQUFRLEVBQVIsQ0FBNUI7QUFDQSxJQUFJZ2dCLGlCQUFpQixtQkFBQWhnQixDQUFRLEVBQVIsQ0FBckI7QUFDQSxJQUFJK2hCLHNCQUFzQixtQkFBQS9oQixDQUFRLEVBQVIsQ0FBMUI7QUFDQSxJQUFJaXdCLDJCQUEyQixtQkFBQWp3QixDQUFRLEVBQVIsQ0FBL0I7QUFDQSxJQUFJa0IseUJBQXlCLG1CQUFBbEIsQ0FBUSxFQUFSLENBQTdCO0FBQ0EsSUFBSWdFLHdCQUF3QixtQkFBQWhFLENBQVEsQ0FBUixDQUE1QjtBQUNBLElBQUlvbkUsZ0JBQWdCLG1CQUFBcG5FLENBQVEsR0FBUixDQUFwQjtBQUNBLElBQUlxbkUsaUJBQWlCLG1CQUFBcm5FLENBQVEsR0FBUixDQUFyQjtBQUNBLElBQUk2MEMsaUJBQWlCLG1CQUFBNzBDLENBQVEsRUFBUixDQUFyQjtBQUNBLElBQUlzbkUsbUJBQW1CLG1CQUFBdG5FLENBQVEsR0FBUixDQUF2QjtBQUNBLElBQUkrYyx1QkFBdUIsbUJBQUEvYyxDQUFRLEVBQVIsQ0FBM0I7QUFDQSxJQUFJdW5FLGtCQUFrQixtQkFBQXZuRSxDQUFRLEdBQVIsQ0FBdEI7QUFDQSxJQUFJd25FLGtDQUFrQyxtQkFBQXhuRSxDQUFRLEdBQVIsQ0FBdEM7O0FBRUEsSUFBSUQsZ0JBQWdCLG1CQUFBQyxDQUFRLEVBQVIsQ0FBcEI7QUFDQSxJQUFJcXJCLDhCQUE4QixtQkFBQXJyQixDQUFRLEVBQVIsQ0FBbEM7QUFDQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJd3JCLG1CQUFtQixtQkFBQXhyQixDQUFRLEVBQVIsQ0FBdkI7QUFDQSxJQUFJODVCLGVBQWUsbUJBQUE5NUIsQ0FBUSxFQUFSLENBQW5CO0FBQ0EsSUFBSStyQyxxQkFBcUIsbUJBQUEvckMsQ0FBUSxFQUFSLENBQXpCO0FBQ0EsSUFBSXM4QixxQkFBcUIsbUJBQUF0OEIsQ0FBUSxFQUFSLENBQXpCO0FBQ0EsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUEsSUFBSXFCLFFBQVFILHNCQUFaO0FBQ0EsSUFBSW1pQixpQkFBaUJyRCxlQUFlcUQsY0FBcEM7QUFDQSxJQUFJb2tELFVBQVV6akUsc0JBQXNCRixtQkFBcEM7QUFDQSxJQUFJMnNCLFdBQVdSLHlCQUF5QlEsUUFBeEM7QUFDQSxJQUFJdE4sMEJBQTBCcEIsb0JBQW9Cb0IsdUJBQWxEOztBQUVBO0FBQ0EsSUFBSXVrRCxnQkFBZ0IsRUFBRTk4QyxRQUFRLElBQVYsRUFBZ0I2YyxRQUFRLElBQXhCLEVBQXBCOztBQUVBLElBQUlrZ0MsUUFBUSxPQUFaO0FBQ0EsSUFBSUMsT0FBTyxRQUFYO0FBQ0EsSUFBSS92RCxpQkFBaUI7QUFDbkIvVSxZQUFVLElBRFM7QUFFbkIra0UsMkJBQXlCLElBRk47QUFHbkJDLGtDQUFnQztBQUhiLENBQXJCOztBQU1BO0FBQ0EsSUFBSUMsb0JBQW9CLEVBQXhCOztBQUVBLFNBQVNsdkMsMkJBQVQsQ0FBcUMzYixnQkFBckMsRUFBdUQ7QUFDckQsTUFBSUEsZ0JBQUosRUFBc0I7QUFDcEIsUUFBSTFSLFFBQVEwUixpQkFBaUJuTSxlQUFqQixDQUFpQ3RGLE1BQWpDLElBQTJDLElBQXZEO0FBQ0EsUUFBSUQsS0FBSixFQUFXO0FBQ1QsVUFBSTlNLE9BQU84TSxNQUFNRSxPQUFOLEVBQVg7QUFDQSxVQUFJaE4sSUFBSixFQUFVO0FBQ1IsZUFBTyxxQ0FBcUNBLElBQXJDLEdBQTRDLElBQW5EO0FBQ0Q7QUFDRjtBQUNGO0FBQ0QsU0FBTyxFQUFQO0FBQ0Q7O0FBRUQsU0FBU3NwRSxpQkFBVCxDQUEyQmhvQyxHQUEzQixFQUFnQztBQUM5QixNQUFJLFFBQU9BLEdBQVAseUNBQU9BLEdBQVAsT0FBZSxRQUFuQixFQUE2QjtBQUMzQixRQUFJL2lDLE1BQU11MUIsT0FBTixDQUFjd04sR0FBZCxDQUFKLEVBQXdCO0FBQ3RCLGFBQU8sTUFBTUEsSUFBSWo3QixHQUFKLENBQVFpakUsaUJBQVIsRUFBMkIvaUUsSUFBM0IsQ0FBZ0MsSUFBaEMsQ0FBTixHQUE4QyxHQUFyRDtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUkrckQsUUFBUSxFQUFaO0FBQ0EsV0FBSyxJQUFJbHJELEdBQVQsSUFBZ0JrNkIsR0FBaEIsRUFBcUI7QUFDbkIsWUFBSTk3QixPQUFPM0csU0FBUCxDQUFpQjRGLGNBQWpCLENBQWdDbEgsSUFBaEMsQ0FBcUMrakMsR0FBckMsRUFBMENsNkIsR0FBMUMsQ0FBSixFQUFvRDtBQUNsRCxjQUFJbWlFLGFBQWEsb0JBQW9CcmdFLElBQXBCLENBQXlCOUIsR0FBekIsSUFBZ0NBLEdBQWhDLEdBQXNDbWtDLEtBQUtDLFNBQUwsQ0FBZXBrQyxHQUFmLENBQXZEO0FBQ0FrckQsZ0JBQU01ekQsSUFBTixDQUFXNnFFLGFBQWEsSUFBYixHQUFvQkQsa0JBQWtCaG9DLElBQUlsNkIsR0FBSixDQUFsQixDQUEvQjtBQUNEO0FBQ0Y7QUFDRCxhQUFPLE1BQU1rckQsTUFBTS9yRCxJQUFOLENBQVcsSUFBWCxDQUFOLEdBQXlCLEdBQWhDO0FBQ0Q7QUFDRixHQWJELE1BYU8sSUFBSSxPQUFPKzZCLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNsQyxXQUFPaUssS0FBS0MsU0FBTCxDQUFlbEssR0FBZixDQUFQO0FBQ0QsR0FGTSxNQUVBLElBQUksT0FBT0EsR0FBUCxLQUFlLFVBQW5CLEVBQStCO0FBQ3BDLFdBQU8sbUJBQVA7QUFDRDtBQUNEO0FBQ0E7QUFDQSxTQUFPaCtCLE9BQU9nK0IsR0FBUCxDQUFQO0FBQ0Q7O0FBRUQsSUFBSWtvQyx1QkFBdUIsRUFBM0I7O0FBRUEsU0FBU0MsMkJBQVQsQ0FBcUNDLE1BQXJDLEVBQTZDQyxNQUE3QyxFQUFxRGxtRSxTQUFyRCxFQUFnRTtBQUM5RCxNQUFJaW1FLFVBQVUsSUFBVixJQUFrQkMsVUFBVSxJQUFoQyxFQUFzQztBQUNwQztBQUNEO0FBQ0QsTUFBSXZ1QyxhQUFhc3VDLE1BQWIsRUFBcUJDLE1BQXJCLENBQUosRUFBa0M7QUFDaEM7QUFDRDs7QUFFRCxNQUFJM3ZDLGdCQUFnQnYyQixVQUFVbW1FLElBQTlCO0FBQ0EsTUFBSTk4RCxRQUFRckosVUFBVTRPLGVBQVYsQ0FBMEJ0RixNQUF0QztBQUNBLE1BQUlqQyxTQUFKO0FBQ0EsTUFBSWdDLEtBQUosRUFBVztBQUNUaEMsZ0JBQVlnQyxNQUFNRSxPQUFOLEVBQVo7QUFDRDs7QUFFRCxNQUFJbWEsT0FBT3JjLFlBQVksR0FBWixHQUFrQmt2QixhQUE3Qjs7QUFFQSxNQUFJd3ZDLHFCQUFxQi9rRSxjQUFyQixDQUFvQzBpQixJQUFwQyxDQUFKLEVBQStDO0FBQzdDO0FBQ0Q7O0FBRURxaUQsdUJBQXFCcmlELElBQXJCLElBQTZCLElBQTdCOztBQUVBenFCLFVBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxzRUFBc0Usd0VBQXRFLEdBQWlKLHlEQUFoSyxFQUEyTnk0QixhQUEzTixFQUEwT2x0QixRQUFRLFNBQVNoQyxTQUFULEdBQXFCLEdBQTdCLEdBQW1DLFlBQVlrdkIsYUFBWixHQUE0QixHQUF6UyxFQUE4U3N2QyxrQkFBa0JJLE1BQWxCLENBQTlTLEVBQXlVSixrQkFBa0JLLE1BQWxCLENBQXpVLENBQXhDLEdBQThZLEtBQUssQ0FBblo7QUFDRDs7QUFFRDs7OztBQUlBLFNBQVNFLGdCQUFULENBQTBCcG1FLFNBQTFCLEVBQXFDdVcsS0FBckMsRUFBNEM7QUFDMUMsTUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFDVjtBQUNEO0FBQ0Q7QUFDQSxNQUFJOHZELGdCQUFnQnJtRSxVQUFVbW1FLElBQTFCLENBQUosRUFBcUM7QUFDbkMsTUFBRTV2RCxNQUFNNVYsUUFBTixJQUFrQixJQUFsQixJQUEwQjRWLE1BQU1tdkQsdUJBQU4sSUFBaUMsSUFBN0QsSUFBcUV6c0UsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixnR0FBakIsRUFBbUgrQyxVQUFVbW1FLElBQTdILEVBQW1Jbm1FLFVBQVU0TyxlQUFWLENBQTBCdEYsTUFBMUIsR0FBbUMsaUNBQWlDdEosVUFBVTRPLGVBQVYsQ0FBMEJ0RixNQUExQixDQUFpQ0MsT0FBakMsRUFBakMsR0FBOEUsR0FBakgsR0FBdUgsRUFBMVAsQ0FBeEMsR0FBd1MxSyxlQUFlLEtBQWYsRUFBc0JtQixVQUFVbW1FLElBQWhDLEVBQXNDbm1FLFVBQVU0TyxlQUFWLENBQTBCdEYsTUFBMUIsR0FBbUMsaUNBQWlDdEosVUFBVTRPLGVBQVYsQ0FBMEJ0RixNQUExQixDQUFpQ0MsT0FBakMsRUFBakMsR0FBOEUsR0FBakgsR0FBdUgsRUFBN0osQ0FBN1csR0FBZ2hCLEtBQUssQ0FBcmhCO0FBQ0Q7QUFDRCxNQUFJZ04sTUFBTW12RCx1QkFBTixJQUFpQyxJQUFyQyxFQUEyQztBQUN6QyxNQUFFbnZELE1BQU01VixRQUFOLElBQWtCLElBQXBCLElBQTRCMUgsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixvRUFBakIsQ0FBeEMsR0FBaUk0QixlQUFlLElBQWYsQ0FBN0osR0FBb0wsS0FBSyxDQUF6TDtBQUNBLE1BQUUsUUFBTzBYLE1BQU1tdkQsdUJBQWIsTUFBeUMsUUFBekMsSUFBcURELFFBQVFsdkQsTUFBTW12RCx1QkFBckUsSUFBZ0d6c0UsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixrS0FBakIsQ0FBeEMsR0FBK040QixlQUFlLElBQWYsQ0FBL1QsR0FBc1YsS0FBSyxDQUEzVjtBQUNEO0FBQ0QsTUFBSTVGLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDOUQsWUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVF5WSxNQUFNeVIsU0FBTixJQUFtQixJQUEzQixFQUFpQyw2REFBNkQsMEVBQTlGLENBQXhDLEdBQW9OLEtBQUssQ0FBek47QUFDQS91QixZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUXlZLE1BQU1vdkQsOEJBQU4sSUFBd0MsQ0FBQ3B2RCxNQUFNb2dDLGVBQS9DLElBQWtFcGdDLE1BQU01VixRQUFOLElBQWtCLElBQTVGLEVBQWtHLHlFQUF5RSxpRUFBekUsR0FBNkksK0RBQTdJLEdBQStNLDJCQUFqVCxDQUF4QyxHQUF3WCxLQUFLLENBQTdYO0FBQ0ExSCxZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUXlZLE1BQU0rdkQsU0FBTixJQUFtQixJQUFuQixJQUEyQi92RCxNQUFNZ3dELFVBQU4sSUFBb0IsSUFBdkQsRUFBNkQsd0VBQXdFLHlFQUF4RSxHQUFvSixvQ0FBak4sQ0FBeEMsR0FBaVMsS0FBSyxDQUF0UztBQUNEO0FBQ0QsSUFBRWh3RCxNQUFNNnlDLEtBQU4sSUFBZSxJQUFmLElBQXVCLFFBQU83eUMsTUFBTTZ5QyxLQUFiLE1BQXVCLFFBQWhELElBQTREbndELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsMEpBQWpCLEVBQTZLeTVCLDRCQUE0QjEyQixTQUE1QixDQUE3SyxDQUF4QyxHQUErUG5CLGVBQWUsSUFBZixFQUFxQjYzQiw0QkFBNEIxMkIsU0FBNUIsQ0FBckIsQ0FBM1QsR0FBMFgsS0FBSyxDQUEvWDtBQUNEOztBQUVELFNBQVN3bUUsa0JBQVQsQ0FBNEJwbUUsSUFBNUIsRUFBa0NnZSxnQkFBbEMsRUFBb0RJLFFBQXBELEVBQThEblEsV0FBOUQsRUFBMkU7QUFDekUsTUFBSUEsdUJBQXVCZzNELCtCQUEzQixFQUE0RDtBQUMxRDtBQUNEO0FBQ0QsTUFBSXBzRSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QztBQUNBO0FBQ0E5RCxZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUXNnQixxQkFBcUIsVUFBckIsSUFBbUNpTCxpQkFBaUIsUUFBakIsRUFBMkIsSUFBM0IsQ0FBM0MsRUFBNkUsbURBQTdFLENBQXhDLEdBQTRLLEtBQUssQ0FBakw7QUFDRDtBQUNELE1BQUlvOUMsZ0JBQWdCcm1FLEtBQUt1NkMsa0JBQXpCO0FBQ0EsTUFBSStyQixxQkFBcUJELGNBQWNFLEtBQWQsSUFBdUJGLGNBQWNFLEtBQWQsQ0FBb0JobkUsUUFBcEIsS0FBaUNpbUUsaUJBQWpGO0FBQ0EsTUFBSXpqRCxNQUFNdWtELHFCQUFxQkQsY0FBY0UsS0FBbkMsR0FBMkNGLGNBQWNHLGNBQW5FO0FBQ0F0NEMsV0FBU2xRLGdCQUFULEVBQTJCK0QsR0FBM0I7QUFDQTlULGNBQVkrTSxrQkFBWixHQUFpQ2xNLE9BQWpDLENBQXlDMlIsV0FBekMsRUFBc0Q7QUFDcER6Z0IsVUFBTUEsSUFEOEM7QUFFcERnZSxzQkFBa0JBLGdCQUZrQztBQUdwREksY0FBVUE7QUFIMEMsR0FBdEQ7QUFLRDs7QUFFRCxTQUFTcUMsV0FBVCxHQUF1QjtBQUNyQixNQUFJZ21ELGdCQUFnQixJQUFwQjtBQUNBaHBELGlCQUFlZ0QsV0FBZixDQUEyQmdtRCxjQUFjem1FLElBQXpDLEVBQStDeW1FLGNBQWN6b0QsZ0JBQTdELEVBQStFeW9ELGNBQWNyb0QsUUFBN0Y7QUFDRDs7QUFFRCxTQUFTc29ELGNBQVQsR0FBMEI7QUFDeEIsTUFBSTFtRSxPQUFPLElBQVg7QUFDQTZrRSxnQkFBYzhCLGdCQUFkLENBQStCM21FLElBQS9CO0FBQ0Q7O0FBRUQsU0FBUzRtRSxpQkFBVCxHQUE2QjtBQUMzQixNQUFJNW1FLE9BQU8sSUFBWDtBQUNBK2tFLG1CQUFpQjRCLGdCQUFqQixDQUFrQzNtRSxJQUFsQztBQUNEOztBQUVELFNBQVM2bUUsZUFBVCxHQUEyQjtBQUN6QixNQUFJN21FLE9BQU8sSUFBWDtBQUNBOGtFLGlCQUFlNkIsZ0JBQWYsQ0FBZ0MzbUUsSUFBaEM7QUFDRDs7QUFFRCxJQUFJOG1FLGdDQUFnQ3RwRSxhQUFwQztBQUNBLElBQUkzRSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q21xRSxrQ0FBZ0MsdUNBQVV2eUMsT0FBVixFQUFtQjtBQUNqRCxRQUFJd3lDLHFCQUFxQixLQUFLQyxlQUFMLElBQXdCLElBQWpEO0FBQ0EsUUFBSWhjLFVBQVUsS0FBSzFoRCxRQUFuQjtBQUNBO0FBQ0EsUUFBSTI5RCxpQkFBaUIsQ0FBQ2pjLE9BQXRCOztBQUVBLFFBQUl6MkIsV0FBVyxJQUFmLEVBQXFCO0FBQ25CLFVBQUl3eUMsa0JBQUosRUFBd0I7QUFDdEJ2c0QsNkJBQXFCM1AsU0FBckIsQ0FBK0JsQyxrQkFBL0IsQ0FBa0QsS0FBS3ErRCxlQUF2RDtBQUNEO0FBQ0QsV0FBS0EsZUFBTCxHQUF1QixJQUF2QjtBQUNBO0FBQ0Q7O0FBRURqdEMsdUJBQW1CLElBQW5CLEVBQXlCdDZCLE9BQU84MEIsT0FBUCxDQUF6QixFQUEwQyxJQUExQyxFQUFnRCxLQUFLMnlDLGFBQXJEO0FBQ0EsU0FBS0YsZUFBTCxHQUF1QkMsY0FBdkI7QUFDQSxRQUFJRixrQkFBSixFQUF3QjtBQUN0QnZzRCwyQkFBcUIzUCxTQUFyQixDQUErQnRDLHVCQUEvQixDQUF1RDArRCxjQUF2RCxFQUF1RTF5QyxPQUF2RTtBQUNBL1osMkJBQXFCM1AsU0FBckIsQ0FBK0JuQyxpQkFBL0IsQ0FBaUR1K0QsY0FBakQ7QUFDRCxLQUhELE1BR087QUFDTHpzRCwyQkFBcUIzUCxTQUFyQixDQUErQnpDLHNCQUEvQixDQUFzRDYrRCxjQUF0RCxFQUFzRTF5QyxPQUF0RSxFQUErRXkyQixPQUEvRTtBQUNBeHdDLDJCQUFxQjNQLFNBQXJCLENBQStCckMsZ0JBQS9CLENBQWdEeStELGNBQWhEO0FBQ0F6c0QsMkJBQXFCM1AsU0FBckIsQ0FBK0IvQyxhQUEvQixDQUE2Q2tqRCxPQUE3QyxFQUFzRCxDQUFDaWMsY0FBRCxDQUF0RDtBQUNEO0FBQ0YsR0F4QkQ7QUF5QkQ7O0FBRUQ7QUFDQTtBQUNBLElBQUlFLGNBQWM7QUFDaEI1OUMsWUFBVSxPQURNO0FBRWhCSyxjQUFZLFNBRkk7QUFHaEJDLHFCQUFtQixnQkFISDtBQUloQmtCLHFCQUFtQixnQkFKSDtBQUtoQkMsY0FBWSxTQUxJO0FBTWhCQyxnQkFBYyxXQU5FO0FBT2hCQyxZQUFVLE9BUE07QUFRaEJDLFlBQVUsT0FSTTtBQVNoQk0saUJBQWUsWUFUQztBQVVoQkMscUJBQW1CLGdCQVZIO0FBV2hCQyxnQkFBYyxXQVhFO0FBWWhCTyxZQUFVLE9BWk07QUFhaEJDLFdBQVMsTUFiTztBQWNoQkMsY0FBWSxTQWRJO0FBZWhCQyxlQUFhLFVBZkc7QUFnQmhCQyxpQkFBZSxZQWhCQztBQWlCaEJFLGFBQVcsUUFqQks7QUFrQmhCQyxjQUFZLFNBbEJJO0FBbUJoQkUsY0FBWSxTQW5CSTtBQW9CaEJDLGNBQVksU0FwQkk7QUFxQmhCRSxpQkFBZSxZQXJCQztBQXNCaEJNLG1CQUFpQixjQXRCRDtBQXVCaEJDLGNBQVk7QUF2QkksQ0FBbEI7O0FBMEJBLFNBQVMrNUMsZUFBVCxHQUEyQjtBQUN6QjU5QixxQkFBbUJFLEtBQW5CLENBQXlCLElBQXpCO0FBQ0Q7O0FBRUQsU0FBUzI5QixzQkFBVCxHQUFrQztBQUNoQyxNQUFJcm5FLE9BQU8sSUFBWDtBQUNBO0FBQ0E7QUFDQSxHQUFDQSxLQUFLa2dCLFdBQU4sR0FBb0JybkIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixnQ0FBakIsQ0FBeEMsR0FBNkY0QixlQUFlLElBQWYsQ0FBakgsR0FBd0ksS0FBSyxDQUE3STtBQUNBLE1BQUlZLE9BQU82bEUsUUFBUWxsRSxJQUFSLENBQVg7QUFDQSxHQUFDWCxJQUFELEdBQVF4RyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHNEQUFqQixDQUF4QyxHQUFtSDRCLGVBQWUsSUFBZixDQUEzSCxHQUFrSixLQUFLLENBQXZKOztBQUVBLFVBQVF1QixLQUFLK2xFLElBQWI7QUFDRSxTQUFLLFFBQUw7QUFDQSxTQUFLLFFBQUw7QUFDRS9sRSxXQUFLa3BDLGFBQUwsQ0FBbUJodEMsU0FBbkIsR0FBK0IsQ0FBQ3d4Qix5QkFBeUJZLGdCQUF6QixDQUEwQyxTQUExQyxFQUFxRCxNQUFyRCxFQUE2RGp2QixJQUE3RCxDQUFELENBQS9CO0FBQ0E7QUFDRixTQUFLLE9BQUw7QUFDQSxTQUFLLE9BQUw7QUFDRVcsV0FBS2twQyxhQUFMLENBQW1CaHRDLFNBQW5CLEdBQStCLEVBQS9CO0FBQ0E7QUFDQSxXQUFLLElBQUltVSxLQUFULElBQWtCODJELFdBQWxCLEVBQStCO0FBQzdCLFlBQUlBLFlBQVl2bUUsY0FBWixDQUEyQnlQLEtBQTNCLENBQUosRUFBdUM7QUFDckNyUSxlQUFLa3BDLGFBQUwsQ0FBbUJodEMsU0FBbkIsQ0FBNkJyQixJQUE3QixDQUFrQzZ5Qix5QkFBeUJZLGdCQUF6QixDQUEwQ2plLEtBQTFDLEVBQWlEODJELFlBQVk5MkQsS0FBWixDQUFqRCxFQUFxRWhSLElBQXJFLENBQWxDO0FBQ0Q7QUFDRjtBQUNEO0FBQ0YsU0FBSyxRQUFMO0FBQ0VXLFdBQUtrcEMsYUFBTCxDQUFtQmh0QyxTQUFuQixHQUErQixDQUFDd3hCLHlCQUF5QlksZ0JBQXpCLENBQTBDLFVBQTFDLEVBQXNELE9BQXRELEVBQStEanZCLElBQS9ELENBQUQsQ0FBL0I7QUFDQTtBQUNGLFNBQUssS0FBTDtBQUNFVyxXQUFLa3BDLGFBQUwsQ0FBbUJodEMsU0FBbkIsR0FBK0IsQ0FBQ3d4Qix5QkFBeUJZLGdCQUF6QixDQUEwQyxVQUExQyxFQUFzRCxPQUF0RCxFQUErRGp2QixJQUEvRCxDQUFELEVBQXVFcXVCLHlCQUF5QlksZ0JBQXpCLENBQTBDLFNBQTFDLEVBQXFELE1BQXJELEVBQTZEanZCLElBQTdELENBQXZFLENBQS9CO0FBQ0E7QUFDRixTQUFLLE1BQUw7QUFDRVcsV0FBS2twQyxhQUFMLENBQW1CaHRDLFNBQW5CLEdBQStCLENBQUN3eEIseUJBQXlCWSxnQkFBekIsQ0FBMEMsVUFBMUMsRUFBc0QsT0FBdEQsRUFBK0RqdkIsSUFBL0QsQ0FBRCxFQUF1RXF1Qix5QkFBeUJZLGdCQUF6QixDQUEwQyxXQUExQyxFQUF1RCxRQUF2RCxFQUFpRWp2QixJQUFqRSxDQUF2RSxDQUEvQjtBQUNBO0FBQ0YsU0FBSyxPQUFMO0FBQ0EsU0FBSyxRQUFMO0FBQ0EsU0FBSyxVQUFMO0FBQ0VXLFdBQUtrcEMsYUFBTCxDQUFtQmh0QyxTQUFuQixHQUErQixDQUFDd3hCLHlCQUF5QlksZ0JBQXpCLENBQTBDLFlBQTFDLEVBQXdELFNBQXhELEVBQW1FanZCLElBQW5FLENBQUQsQ0FBL0I7QUFDQTtBQTVCSjtBQThCRDs7QUFFRCxTQUFTaW9FLHVCQUFULEdBQW1DO0FBQ2pDaDFCLGlCQUFlUSxpQkFBZixDQUFpQyxJQUFqQztBQUNEOztBQUVEO0FBQ0E7O0FBRUEsSUFBSXkwQixtQkFBbUI7QUFDckJwakIsUUFBTSxJQURlO0FBRXJCSSxRQUFNLElBRmU7QUFHckJLLE1BQUksSUFIaUI7QUFJckJJLE9BQUssSUFKZ0I7QUFLckJZLFNBQU8sSUFMYztBQU1yQmUsTUFBSSxJQU5pQjtBQU9yQkUsT0FBSyxJQVBnQjtBQVFyQjNQLFNBQU8sSUFSYztBQVNyQjhQLFVBQVEsSUFUYTtBQVVyQkksUUFBTSxJQVZlO0FBV3JCSyxRQUFNLElBWGU7QUFZckJTLFNBQU8sSUFaYztBQWFyQmhsRCxVQUFRLElBYmE7QUFjckJ3bUMsU0FBTyxJQWRjO0FBZXJCcWdCLE9BQUs7QUFDTDtBQWhCcUIsQ0FBdkI7O0FBbUJBLElBQUl5ZCxvQkFBb0I7QUFDdEJDLFdBQVMsSUFEYTtBQUV0QnJmLE9BQUssSUFGaUI7QUFHdEJtQixZQUFVO0FBSFksQ0FBeEI7O0FBTUE7QUFDQTs7QUFFQSxJQUFJMGMsa0JBQWtCMzZELFFBQVE7QUFDNUJrOEMsWUFBVTtBQURrQixDQUFSLEVBRW5CK2YsZ0JBRm1CLENBQXRCOztBQUlBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJRyxrQkFBa0IsNkJBQXRCLEMsQ0FBcUQ7QUFDckQsSUFBSUMsb0JBQW9CLEVBQXhCO0FBQ0EsSUFBSS9tRSxpQkFBaUIsR0FBR0EsY0FBeEI7O0FBRUEsU0FBU2duRSxvQkFBVCxDQUE4QnhuRCxHQUE5QixFQUFtQztBQUNqQyxNQUFJLENBQUN4ZixlQUFlbEgsSUFBZixDQUFvQml1RSxpQkFBcEIsRUFBdUN2bkQsR0FBdkMsQ0FBTCxFQUFrRDtBQUNoRCxLQUFDc25ELGdCQUFnQnJpRSxJQUFoQixDQUFxQithLEdBQXJCLENBQUQsR0FBNkJ2bkIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixpQkFBakIsRUFBb0N1akIsR0FBcEMsQ0FBeEMsR0FBbUYzaEIsZUFBZSxJQUFmLEVBQXFCMmhCLEdBQXJCLENBQWhILEdBQTRJLEtBQUssQ0FBako7QUFDQXVuRCxzQkFBa0J2bkQsR0FBbEIsSUFBeUIsSUFBekI7QUFDRDtBQUNGOztBQUVELFNBQVN5bkQsaUJBQVQsQ0FBMkJweEMsT0FBM0IsRUFBb0N0Z0IsS0FBcEMsRUFBMkM7QUFDekMsU0FBT3NnQixRQUFReDRCLE9BQVIsQ0FBZ0IsR0FBaEIsS0FBd0IsQ0FBeEIsSUFBNkJrWSxNQUFNa2hCLEVBQU4sSUFBWSxJQUFoRDtBQUNEOztBQUVELElBQUl5d0Msa0JBQWtCLENBQXRCOztBQUVBOzs7Ozs7Ozs7Ozs7OztBQWNBLFNBQVM1VyxpQkFBVCxDQUEyQjdwRCxPQUEzQixFQUFvQztBQUNsQyxNQUFJK1ksTUFBTS9ZLFFBQVFDLElBQWxCO0FBQ0FzZ0UsdUJBQXFCeG5ELEdBQXJCO0FBQ0EsT0FBSzVSLGVBQUwsR0FBdUJuSCxPQUF2QjtBQUNBLE9BQUswK0QsSUFBTCxHQUFZM2xELElBQUlqTSxXQUFKLEVBQVo7QUFDQSxPQUFLNHpELGFBQUwsR0FBcUIsSUFBckI7QUFDQSxPQUFLdm5FLGlCQUFMLEdBQXlCLElBQXpCO0FBQ0EsT0FBS3duRSxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsT0FBS0Msa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSxPQUFLL25FLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxPQUFLc0IsV0FBTCxHQUFtQixJQUFuQjtBQUNBLE9BQUswZSxXQUFMLEdBQW1CLENBQW5CO0FBQ0EsT0FBS25mLE1BQUwsR0FBYyxDQUFkO0FBQ0EsT0FBS3c1QyxrQkFBTCxHQUEwQixJQUExQjtBQUNBLE9BQUtyUixhQUFMLEdBQXFCLElBQXJCO0FBQ0EsT0FBS2tRLGdCQUFMLEdBQXdCLElBQXhCO0FBQ0EsT0FBSy80QyxNQUFMLEdBQWMsQ0FBZDtBQUNBLE1BQUl4SCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxTQUFLdXFFLGFBQUwsR0FBcUIsSUFBckI7QUFDQUosa0NBQThCcHRFLElBQTlCLENBQW1DLElBQW5DLEVBQXlDLElBQXpDO0FBQ0Q7QUFDRjs7QUFFRHczRCxrQkFBa0IzcEQsV0FBbEIsR0FBZ0MsbUJBQWhDOztBQUVBMnBELGtCQUFrQmdYLEtBQWxCLEdBQTBCO0FBQ3hCOzs7Ozs7Ozs7OztBQVdBeHRELGtCQUFnQix3QkFBVXpNLFdBQVYsRUFBdUIyTSxVQUF2QixFQUFtQ0MsaUJBQW5DLEVBQXNEekwsT0FBdEQsRUFBK0Q7QUFDN0UsU0FBSzhRLFdBQUwsR0FBbUI0bkQsaUJBQW5CO0FBQ0EsU0FBSy9tRSxNQUFMLEdBQWM4WixrQkFBa0JzdEQsVUFBbEIsRUFBZDtBQUNBLFNBQUszbUUsV0FBTCxHQUFtQm9aLFVBQW5CO0FBQ0EsU0FBSzIvQixrQkFBTCxHQUEwQjEvQixpQkFBMUI7O0FBRUEsUUFBSTFFLFFBQVEsS0FBSzNILGVBQUwsQ0FBcUIySCxLQUFqQzs7QUFFQSxZQUFRLEtBQUs0dkQsSUFBYjtBQUNFLFdBQUssT0FBTDtBQUNBLFdBQUssTUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssS0FBTDtBQUNBLFdBQUssTUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssT0FBTDtBQUNFLGFBQUs3OEIsYUFBTCxHQUFxQjtBQUNuQmh0QyxxQkFBVztBQURRLFNBQXJCO0FBR0ErUixvQkFBWStNLGtCQUFaLEdBQWlDbE0sT0FBakMsQ0FBeUN1NEQsc0JBQXpDLEVBQWlFLElBQWpFO0FBQ0E7QUFDRixXQUFLLE9BQUw7QUFDRXhDLHNCQUFjcnlCLFlBQWQsQ0FBMkIsSUFBM0IsRUFBaUNyOEIsS0FBakMsRUFBd0N5RSxVQUF4QztBQUNBekUsZ0JBQVEwdUQsY0FBY3R5QixZQUFkLENBQTJCLElBQTNCLEVBQWlDcDhCLEtBQWpDLENBQVI7QUFDQWxJLG9CQUFZK00sa0JBQVosR0FBaUNsTSxPQUFqQyxDQUF5Q3M0RCxlQUF6QyxFQUEwRCxJQUExRDtBQUNBbjVELG9CQUFZK00sa0JBQVosR0FBaUNsTSxPQUFqQyxDQUF5Q3U0RCxzQkFBekMsRUFBaUUsSUFBakU7QUFDQTtBQUNGLFdBQUssUUFBTDtBQUNFdkMsdUJBQWV0eUIsWUFBZixDQUE0QixJQUE1QixFQUFrQ3I4QixLQUFsQyxFQUF5Q3lFLFVBQXpDO0FBQ0F6RSxnQkFBUTJ1RCxlQUFldnlCLFlBQWYsQ0FBNEIsSUFBNUIsRUFBa0NwOEIsS0FBbEMsQ0FBUjtBQUNBO0FBQ0YsV0FBSyxRQUFMO0FBQ0VtOEIsdUJBQWVFLFlBQWYsQ0FBNEIsSUFBNUIsRUFBa0NyOEIsS0FBbEMsRUFBeUN5RSxVQUF6QztBQUNBekUsZ0JBQVFtOEIsZUFBZUMsWUFBZixDQUE0QixJQUE1QixFQUFrQ3A4QixLQUFsQyxDQUFSO0FBQ0FsSSxvQkFBWStNLGtCQUFaLEdBQWlDbE0sT0FBakMsQ0FBeUN1NEQsc0JBQXpDLEVBQWlFLElBQWpFO0FBQ0E7QUFDRixXQUFLLFVBQUw7QUFDRXRDLHlCQUFpQnZ5QixZQUFqQixDQUE4QixJQUE5QixFQUFvQ3I4QixLQUFwQyxFQUEyQ3lFLFVBQTNDO0FBQ0F6RSxnQkFBUTR1RCxpQkFBaUJ4eUIsWUFBakIsQ0FBOEIsSUFBOUIsRUFBb0NwOEIsS0FBcEMsQ0FBUjtBQUNBbEksb0JBQVkrTSxrQkFBWixHQUFpQ2xNLE9BQWpDLENBQXlDczRELGVBQXpDLEVBQTBELElBQTFEO0FBQ0FuNUQsb0JBQVkrTSxrQkFBWixHQUFpQ2xNLE9BQWpDLENBQXlDdTRELHNCQUF6QyxFQUFpRSxJQUFqRTtBQUNBO0FBbENKOztBQXFDQXJCLHFCQUFpQixJQUFqQixFQUF1Qjd2RCxLQUF2Qjs7QUFFQTtBQUNBO0FBQ0EsUUFBSXlHLFlBQUo7QUFDQSxRQUFJb2UsU0FBSjtBQUNBLFFBQUlwZ0IsY0FBYyxJQUFsQixFQUF3QjtBQUN0QmdDLHFCQUFlaEMsV0FBV210RCxhQUExQjtBQUNBL3NDLGtCQUFZcGdCLFdBQVdtckQsSUFBdkI7QUFDRCxLQUhELE1BR08sSUFBSWxyRCxrQkFBa0JrckQsSUFBdEIsRUFBNEI7QUFDakNucEQscUJBQWUvQixrQkFBa0JrdEQsYUFBakM7QUFDQS9zQyxrQkFBWW5nQixrQkFBa0JrckQsSUFBOUI7QUFDRDtBQUNELFFBQUlucEQsZ0JBQWdCLElBQWhCLElBQXdCQSxpQkFBaUJoQixjQUFjK0wsR0FBL0IsSUFBc0NxVCxjQUFjLGVBQWhGLEVBQWlHO0FBQy9GcGUscUJBQWVoQixjQUFjYSxJQUE3QjtBQUNEO0FBQ0QsUUFBSUcsaUJBQWlCaEIsY0FBY2EsSUFBbkMsRUFBeUM7QUFDdkMsVUFBSSxLQUFLc3BELElBQUwsS0FBYyxLQUFsQixFQUF5QjtBQUN2Qm5wRCx1QkFBZWhCLGNBQWMrTCxHQUE3QjtBQUNELE9BRkQsTUFFTyxJQUFJLEtBQUtvK0MsSUFBTCxLQUFjLE1BQWxCLEVBQTBCO0FBQy9CbnBELHVCQUFlaEIsY0FBY2daLE1BQTdCO0FBQ0Q7QUFDRjtBQUNELFNBQUttekMsYUFBTCxHQUFxQm5yRCxZQUFyQjs7QUFFQSxRQUFJL2pCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUk2K0IsVUFBSjtBQUNBLFVBQUk1Z0IsY0FBYyxJQUFsQixFQUF3QjtBQUN0QjRnQixxQkFBYTVnQixXQUFXc3NELGFBQXhCO0FBQ0QsT0FGRCxNQUVPLElBQUlyc0Qsa0JBQWtCa3JELElBQXRCLEVBQTRCO0FBQ2pDdnFDLHFCQUFhM2dCLGtCQUFrQnFzRCxhQUEvQjtBQUNEO0FBQ0QsVUFBSTFyQyxVQUFKLEVBQWdCO0FBQ2Q7QUFDQTtBQUNBekIsMkJBQW1CLEtBQUtnc0MsSUFBeEIsRUFBOEIsSUFBOUIsRUFBb0MsSUFBcEMsRUFBMEN2cUMsVUFBMUM7QUFDRDtBQUNELFdBQUswckMsYUFBTCxHQUFxQm50QyxtQkFBbUJhLG1CQUFuQixDQUF1Q1ksVUFBdkMsRUFBbUQsS0FBS3VxQyxJQUF4RCxFQUE4RCxJQUE5RCxDQUFyQjtBQUNEOztBQUVELFFBQUlxQyxVQUFKO0FBQ0EsUUFBSW42RCxZQUFZd3JDLGdCQUFoQixFQUFrQztBQUNoQyxVQUFJejNCLGdCQUFnQm5ILGtCQUFrQjJyRCxjQUF0QztBQUNBLFVBQUk2QixFQUFKO0FBQ0EsVUFBSXpyRCxpQkFBaUJoQixjQUFjYSxJQUFuQyxFQUF5QztBQUN2QyxZQUFJLEtBQUtzcEQsSUFBTCxLQUFjLFFBQWxCLEVBQTRCO0FBQzFCO0FBQ0E7QUFDQSxjQUFJdmdCLE1BQU14akMsY0FBY3JlLGFBQWQsQ0FBNEIsS0FBNUIsQ0FBVjtBQUNBLGNBQUkyRCxPQUFPLEtBQUtrSCxlQUFMLENBQXFCbEgsSUFBaEM7QUFDQWsrQyxjQUFJNTlCLFNBQUosR0FBZ0IsTUFBTXRnQixJQUFOLEdBQWEsS0FBYixHQUFxQkEsSUFBckIsR0FBNEIsR0FBNUM7QUFDQStnRSxlQUFLN2lCLElBQUl2OUIsV0FBSixDQUFnQnU5QixJQUFJOWtELFVBQXBCLENBQUw7QUFDRCxTQVBELE1BT08sSUFBSXlWLE1BQU1raEIsRUFBVixFQUFjO0FBQ25CZ3hDLGVBQUtybUQsY0FBY3JlLGFBQWQsQ0FBNEIsS0FBSzZLLGVBQUwsQ0FBcUJsSCxJQUFqRCxFQUF1RDZPLE1BQU1raEIsRUFBN0QsQ0FBTDtBQUNELFNBRk0sTUFFQTtBQUNMO0FBQ0E7QUFDQTtBQUNBZ3hDLGVBQUtybUQsY0FBY3JlLGFBQWQsQ0FBNEIsS0FBSzZLLGVBQUwsQ0FBcUJsSCxJQUFqRCxDQUFMO0FBQ0Q7QUFDRixPQWhCRCxNQWdCTztBQUNMK2dFLGFBQUtybUQsY0FBY3NtRCxlQUFkLENBQThCMXJELFlBQTlCLEVBQTRDLEtBQUtwTyxlQUFMLENBQXFCbEgsSUFBakUsQ0FBTDtBQUNEO0FBQ0Q3Riw0QkFBc0IxQixZQUF0QixDQUFtQyxJQUFuQyxFQUF5Q3NvRSxFQUF6QztBQUNBLFdBQUtob0UsTUFBTCxJQUFldkIsTUFBTXdCLG1CQUFyQjtBQUNBLFVBQUksQ0FBQyxLQUFLa0IsV0FBVixFQUF1QjtBQUNyQnF2Qyw4QkFBc0JJLG1CQUF0QixDQUEwQ28zQixFQUExQztBQUNEO0FBQ0QsV0FBS0Usb0JBQUwsQ0FBMEIsSUFBMUIsRUFBZ0NweUQsS0FBaEMsRUFBdUNsSSxXQUF2QztBQUNBLFVBQUl1NkQsV0FBV2hyRCxZQUFZNnFELEVBQVosQ0FBZjtBQUNBLFdBQUtJLHNCQUFMLENBQTRCeDZELFdBQTVCLEVBQXlDa0ksS0FBekMsRUFBZ0QvRyxPQUFoRCxFQUF5RG81RCxRQUF6RDtBQUNBSixtQkFBYUksUUFBYjtBQUNELEtBL0JELE1BK0JPO0FBQ0wsVUFBSUUsVUFBVSxLQUFLQyxtQ0FBTCxDQUF5QzE2RCxXQUF6QyxFQUFzRGtJLEtBQXRELENBQWQ7QUFDQSxVQUFJeXlELGFBQWEsS0FBS0Msb0JBQUwsQ0FBMEI1NkQsV0FBMUIsRUFBdUNrSSxLQUF2QyxFQUE4Qy9HLE9BQTlDLENBQWpCO0FBQ0EsVUFBSSxDQUFDdzVELFVBQUQsSUFBZXJCLGlCQUFpQixLQUFLeEIsSUFBdEIsQ0FBbkIsRUFBZ0Q7QUFDOUNxQyxxQkFBYU0sVUFBVSxJQUF2QjtBQUNELE9BRkQsTUFFTztBQUNMTixxQkFBYU0sVUFBVSxHQUFWLEdBQWdCRSxVQUFoQixHQUE2QixJQUE3QixHQUFvQyxLQUFLcDZELGVBQUwsQ0FBcUJsSCxJQUF6RCxHQUFnRSxHQUE3RTtBQUNEO0FBQ0Y7O0FBRUQsWUFBUSxLQUFLeStELElBQWI7QUFDRSxXQUFLLE9BQUw7QUFDRTkzRCxvQkFBWStNLGtCQUFaLEdBQWlDbE0sT0FBakMsQ0FBeUM0M0QsY0FBekMsRUFBeUQsSUFBekQ7QUFDQSxZQUFJdndELE1BQU0yeUQsU0FBVixFQUFxQjtBQUNuQjc2RCxzQkFBWStNLGtCQUFaLEdBQWlDbE0sT0FBakMsQ0FBeUM2MUQsZUFBZW9FLGlCQUF4RCxFQUEyRSxJQUEzRTtBQUNEO0FBQ0Q7QUFDRixXQUFLLFVBQUw7QUFDRTk2RCxvQkFBWStNLGtCQUFaLEdBQWlDbE0sT0FBakMsQ0FBeUM4M0QsaUJBQXpDLEVBQTRELElBQTVEO0FBQ0EsWUFBSXp3RCxNQUFNMnlELFNBQVYsRUFBcUI7QUFDbkI3NkQsc0JBQVkrTSxrQkFBWixHQUFpQ2xNLE9BQWpDLENBQXlDNjFELGVBQWVvRSxpQkFBeEQsRUFBMkUsSUFBM0U7QUFDRDtBQUNEO0FBQ0YsV0FBSyxRQUFMO0FBQ0UsWUFBSTV5RCxNQUFNMnlELFNBQVYsRUFBcUI7QUFDbkI3NkQsc0JBQVkrTSxrQkFBWixHQUFpQ2xNLE9BQWpDLENBQXlDNjFELGVBQWVvRSxpQkFBeEQsRUFBMkUsSUFBM0U7QUFDRDtBQUNEO0FBQ0YsV0FBSyxRQUFMO0FBQ0UsWUFBSTV5RCxNQUFNMnlELFNBQVYsRUFBcUI7QUFDbkI3NkQsc0JBQVkrTSxrQkFBWixHQUFpQ2xNLE9BQWpDLENBQXlDNjFELGVBQWVvRSxpQkFBeEQsRUFBMkUsSUFBM0U7QUFDRDtBQUNEO0FBQ0YsV0FBSyxRQUFMO0FBQ0U5NkQsb0JBQVkrTSxrQkFBWixHQUFpQ2xNLE9BQWpDLENBQXlDKzNELGVBQXpDLEVBQTBELElBQTFEO0FBQ0E7QUF6Qko7O0FBNEJBLFdBQU91QixVQUFQO0FBQ0QsR0F4S3VCOztBQTBLeEI7Ozs7Ozs7Ozs7Ozs7QUFhQU8sdUNBQXFDLDZDQUFVMTZELFdBQVYsRUFBdUJrSSxLQUF2QixFQUE4QjtBQUNqRSxRQUFJd1AsTUFBTSxNQUFNLEtBQUtuWCxlQUFMLENBQXFCbEgsSUFBckM7O0FBRUEsU0FBSyxJQUFJMGhFLE9BQVQsSUFBb0I3eUQsS0FBcEIsRUFBMkI7QUFDekIsVUFBSSxDQUFDQSxNQUFNdlYsY0FBTixDQUFxQm9vRSxPQUFyQixDQUFMLEVBQW9DO0FBQ2xDO0FBQ0Q7QUFDRCxVQUFJbGlDLFlBQVkzd0IsTUFBTTZ5RCxPQUFOLENBQWhCO0FBQ0EsVUFBSWxpQyxhQUFhLElBQWpCLEVBQXVCO0FBQ3JCO0FBQ0Q7QUFDRCxVQUFJbG1CLHdCQUF3QmhnQixjQUF4QixDQUF1Q29vRSxPQUF2QyxDQUFKLEVBQXFEO0FBQ25ELFlBQUlsaUMsU0FBSixFQUFlO0FBQ2JzL0IsNkJBQW1CLElBQW5CLEVBQXlCNEMsT0FBekIsRUFBa0NsaUMsU0FBbEMsRUFBNkM3NEIsV0FBN0M7QUFDRDtBQUNGLE9BSkQsTUFJTztBQUNMLFlBQUkrNkQsWUFBWTVELEtBQWhCLEVBQXVCO0FBQ3JCLGNBQUl0K0IsU0FBSixFQUFlO0FBQ2IsZ0JBQUlqdUMsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM7QUFDQSxtQkFBS3FyRSxjQUFMLEdBQXNCbGhDLFNBQXRCO0FBQ0Q7QUFDREEsd0JBQVksS0FBS21oQyxrQkFBTCxHQUEwQjM4RCxRQUFRLEVBQVIsRUFBWTZLLE1BQU02eUMsS0FBbEIsQ0FBdEM7QUFDRDtBQUNEbGlCLHNCQUFZODlCLHNCQUFzQnFFLHFCQUF0QixDQUE0Q25pQyxTQUE1QyxFQUF1RCxJQUF2RCxDQUFaO0FBQ0Q7QUFDRCxZQUFJL3JCLFNBQVMsSUFBYjtBQUNBLFlBQUksS0FBS2dyRCxJQUFMLElBQWEsSUFBYixJQUFxQjhCLGtCQUFrQixLQUFLOUIsSUFBdkIsRUFBNkI1dkQsS0FBN0IsQ0FBekIsRUFBOEQ7QUFDNUQsY0FBSSxDQUFDYixlQUFlMVUsY0FBZixDQUE4Qm9vRSxPQUE5QixDQUFMLEVBQTZDO0FBQzNDanVELHFCQUFTODFCLHNCQUFzQk0sOEJBQXRCLENBQXFENjNCLE9BQXJELEVBQThEbGlDLFNBQTlELENBQVQ7QUFDRDtBQUNGLFNBSkQsTUFJTztBQUNML3JCLG1CQUFTODFCLHNCQUFzQkssdUJBQXRCLENBQThDODNCLE9BQTlDLEVBQXVEbGlDLFNBQXZELENBQVQ7QUFDRDtBQUNELFlBQUkvckIsTUFBSixFQUFZO0FBQ1Y0SyxpQkFBTyxNQUFNNUssTUFBYjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsUUFBSTlNLFlBQVlpN0Qsb0JBQWhCLEVBQXNDO0FBQ3BDLGFBQU92akQsR0FBUDtBQUNEOztBQUVELFFBQUksQ0FBQyxLQUFLbmtCLFdBQVYsRUFBdUI7QUFDckJta0IsYUFBTyxNQUFNa3JCLHNCQUFzQkcsbUJBQXRCLEVBQWI7QUFDRDtBQUNEcnJCLFdBQU8sTUFBTWtyQixzQkFBc0JDLGlCQUF0QixDQUF3QyxLQUFLL3ZDLE1BQTdDLENBQWI7QUFDQSxXQUFPNGtCLEdBQVA7QUFDRCxHQTFPdUI7O0FBNE94Qjs7Ozs7Ozs7O0FBU0FrakQsd0JBQXNCLDhCQUFVNTZELFdBQVYsRUFBdUJrSSxLQUF2QixFQUE4Qi9HLE9BQTlCLEVBQXVDO0FBQzNELFFBQUl1VyxNQUFNLEVBQVY7O0FBRUE7QUFDQSxRQUFJaUMsWUFBWXpSLE1BQU1tdkQsdUJBQXRCO0FBQ0EsUUFBSTE5QyxhQUFhLElBQWpCLEVBQXVCO0FBQ3JCLFVBQUlBLFVBQVV1aEQsTUFBVixJQUFvQixJQUF4QixFQUE4QjtBQUM1QnhqRCxjQUFNaUMsVUFBVXVoRCxNQUFoQjtBQUNEO0FBQ0YsS0FKRCxNQUlPO0FBQ0wsVUFBSUMsZUFBZWpFLHNCQUFxQmh2RCxNQUFNNVYsUUFBM0IsS0FBdUM0VixNQUFNNVYsUUFBN0MsR0FBd0QsSUFBM0U7QUFDQSxVQUFJOG9FLGdCQUFnQkQsZ0JBQWdCLElBQWhCLEdBQXVCLElBQXZCLEdBQThCanpELE1BQU01VixRQUF4RDtBQUNBLFVBQUk2b0UsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3hCO0FBQ0F6akQsY0FBTW1ELDRCQUE0QnNnRCxZQUE1QixDQUFOO0FBQ0EsWUFBSXZ3RSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q21xRSx3Q0FBOEJwdEUsSUFBOUIsQ0FBbUMsSUFBbkMsRUFBeUMwdkUsWUFBekM7QUFDRDtBQUNGLE9BTkQsTUFNTyxJQUFJQyxpQkFBaUIsSUFBckIsRUFBMkI7QUFDaEMsWUFBSUMsY0FBYyxLQUFLQyxhQUFMLENBQW1CRixhQUFuQixFQUFrQ3A3RCxXQUFsQyxFQUErQ21CLE9BQS9DLENBQWxCO0FBQ0F1VyxjQUFNMmpELFlBQVk1bUUsSUFBWixDQUFpQixFQUFqQixDQUFOO0FBQ0Q7QUFDRjtBQUNELFFBQUk4a0Usa0JBQWtCLEtBQUt6QixJQUF2QixLQUFnQ3BnRCxJQUFJOUMsTUFBSixDQUFXLENBQVgsTUFBa0IsSUFBdEQsRUFBNEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFPLE9BQU84QyxHQUFkO0FBQ0QsS0FaRCxNQVlPO0FBQ0wsYUFBT0EsR0FBUDtBQUNEO0FBQ0YsR0EzUnVCOztBQTZSeEI4aUQsMEJBQXdCLGdDQUFVeDZELFdBQVYsRUFBdUJrSSxLQUF2QixFQUE4Qi9HLE9BQTlCLEVBQXVDbzVELFFBQXZDLEVBQWlEO0FBQ3ZFO0FBQ0EsUUFBSTVnRCxZQUFZelIsTUFBTW12RCx1QkFBdEI7QUFDQSxRQUFJMTlDLGFBQWEsSUFBakIsRUFBdUI7QUFDckIsVUFBSUEsVUFBVXVoRCxNQUFWLElBQW9CLElBQXhCLEVBQThCO0FBQzVCM3JELG9CQUFZRixTQUFaLENBQXNCa3JELFFBQXRCLEVBQWdDNWdELFVBQVV1aEQsTUFBMUM7QUFDRDtBQUNGLEtBSkQsTUFJTztBQUNMLFVBQUlDLGVBQWVqRSxzQkFBcUJodkQsTUFBTTVWLFFBQTNCLEtBQXVDNFYsTUFBTTVWLFFBQTdDLEdBQXdELElBQTNFO0FBQ0EsVUFBSThvRSxnQkFBZ0JELGdCQUFnQixJQUFoQixHQUF1QixJQUF2QixHQUE4Qmp6RCxNQUFNNVYsUUFBeEQ7QUFDQTtBQUNBLFVBQUk2b0UsZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSUEsaUJBQWlCLEVBQXJCLEVBQXlCO0FBQ3ZCLGNBQUl2d0UsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNtcUUsMENBQThCcHRFLElBQTlCLENBQW1DLElBQW5DLEVBQXlDMHZFLFlBQXpDO0FBQ0Q7QUFDRDVyRCxzQkFBWUQsU0FBWixDQUFzQmlyRCxRQUF0QixFQUFnQ1ksWUFBaEM7QUFDRDtBQUNGLE9BWEQsTUFXTyxJQUFJQyxpQkFBaUIsSUFBckIsRUFBMkI7QUFDaEMsWUFBSUMsY0FBYyxLQUFLQyxhQUFMLENBQW1CRixhQUFuQixFQUFrQ3A3RCxXQUFsQyxFQUErQ21CLE9BQS9DLENBQWxCO0FBQ0EsYUFBSyxJQUFJeFUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJMHVFLFlBQVlwdkUsTUFBaEMsRUFBd0NVLEdBQXhDLEVBQTZDO0FBQzNDNGlCLHNCQUFZTixVQUFaLENBQXVCc3JELFFBQXZCLEVBQWlDYyxZQUFZMXVFLENBQVosQ0FBakM7QUFDRDtBQUNGO0FBQ0Y7QUFDRixHQTFUdUI7O0FBNFR4Qjs7Ozs7Ozs7QUFRQTBnQixvQkFBa0IsMEJBQVVDLFdBQVYsRUFBdUJ0TixXQUF2QixFQUFvQ21CLE9BQXBDLEVBQTZDO0FBQzdELFFBQUlvTSxjQUFjLEtBQUtoTixlQUF2QjtBQUNBLFNBQUtBLGVBQUwsR0FBdUIrTSxXQUF2QjtBQUNBLFNBQUs0d0MsZUFBTCxDQUFxQmwrQyxXQUFyQixFQUFrQ3VOLFdBQWxDLEVBQStDRCxXQUEvQyxFQUE0RG5NLE9BQTVEO0FBQ0QsR0F4VXVCOztBQTBVeEI7Ozs7Ozs7Ozs7QUFVQSs4QyxtQkFBaUIseUJBQVVsK0MsV0FBVixFQUF1QnVOLFdBQXZCLEVBQW9DRCxXQUFwQyxFQUFpRG5NLE9BQWpELEVBQTBEO0FBQ3pFLFFBQUlvNkQsWUFBWWh1RCxZQUFZckYsS0FBNUI7QUFDQSxRQUFJb3FCLFlBQVksS0FBSy94QixlQUFMLENBQXFCMkgsS0FBckM7O0FBRUEsWUFBUSxLQUFLNHZELElBQWI7QUFDRSxXQUFLLE9BQUw7QUFDRXlELG9CQUFZM0UsY0FBY3R5QixZQUFkLENBQTJCLElBQTNCLEVBQWlDaTNCLFNBQWpDLENBQVo7QUFDQWpwQyxvQkFBWXNrQyxjQUFjdHlCLFlBQWQsQ0FBMkIsSUFBM0IsRUFBaUNoUyxTQUFqQyxDQUFaO0FBQ0E7QUFDRixXQUFLLFFBQUw7QUFDRWlwQyxvQkFBWTFFLGVBQWV2eUIsWUFBZixDQUE0QixJQUE1QixFQUFrQ2kzQixTQUFsQyxDQUFaO0FBQ0FqcEMsb0JBQVl1a0MsZUFBZXZ5QixZQUFmLENBQTRCLElBQTVCLEVBQWtDaFMsU0FBbEMsQ0FBWjtBQUNBO0FBQ0YsV0FBSyxRQUFMO0FBQ0VpcEMsb0JBQVlsM0IsZUFBZUMsWUFBZixDQUE0QixJQUE1QixFQUFrQ2kzQixTQUFsQyxDQUFaO0FBQ0FqcEMsb0JBQVkrUixlQUFlQyxZQUFmLENBQTRCLElBQTVCLEVBQWtDaFMsU0FBbEMsQ0FBWjtBQUNBO0FBQ0YsV0FBSyxVQUFMO0FBQ0VpcEMsb0JBQVl6RSxpQkFBaUJ4eUIsWUFBakIsQ0FBOEIsSUFBOUIsRUFBb0NpM0IsU0FBcEMsQ0FBWjtBQUNBanBDLG9CQUFZd2tDLGlCQUFpQnh5QixZQUFqQixDQUE4QixJQUE5QixFQUFvQ2hTLFNBQXBDLENBQVo7QUFDQTtBQWhCSjs7QUFtQkF5bEMscUJBQWlCLElBQWpCLEVBQXVCemxDLFNBQXZCO0FBQ0EsU0FBS2dvQyxvQkFBTCxDQUEwQmlCLFNBQTFCLEVBQXFDanBDLFNBQXJDLEVBQWdEdHlCLFdBQWhEO0FBQ0EsU0FBS3c3RCxrQkFBTCxDQUF3QkQsU0FBeEIsRUFBbUNqcEMsU0FBbkMsRUFBOEN0eUIsV0FBOUMsRUFBMkRtQixPQUEzRDs7QUFFQSxZQUFRLEtBQUsyMkQsSUFBYjtBQUNFLFdBQUssT0FBTDtBQUNFO0FBQ0E7QUFDQTtBQUNBbEIsc0JBQWM2RSxhQUFkLENBQTRCLElBQTVCO0FBQ0E7QUFDRixXQUFLLFVBQUw7QUFDRTNFLHlCQUFpQjJFLGFBQWpCLENBQStCLElBQS9CO0FBQ0E7QUFDRixXQUFLLFFBQUw7QUFDRTtBQUNBO0FBQ0F6N0Qsb0JBQVkrTSxrQkFBWixHQUFpQ2xNLE9BQWpDLENBQXlDdzRELHVCQUF6QyxFQUFrRSxJQUFsRTtBQUNBO0FBZEo7QUFnQkQsR0EvWHVCOztBQWlZeEI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkFpQix3QkFBc0IsOEJBQVVpQixTQUFWLEVBQXFCanBDLFNBQXJCLEVBQWdDdHlCLFdBQWhDLEVBQTZDO0FBQ2pFLFFBQUkrNkQsT0FBSjtBQUNBLFFBQUlXLFNBQUo7QUFDQSxRQUFJQyxZQUFKO0FBQ0EsU0FBS1osT0FBTCxJQUFnQlEsU0FBaEIsRUFBMkI7QUFDekIsVUFBSWpwQyxVQUFVMy9CLGNBQVYsQ0FBeUJvb0UsT0FBekIsS0FBcUMsQ0FBQ1EsVUFBVTVvRSxjQUFWLENBQXlCb29FLE9BQXpCLENBQXRDLElBQTJFUSxVQUFVUixPQUFWLEtBQXNCLElBQXJHLEVBQTJHO0FBQ3pHO0FBQ0Q7QUFDRCxVQUFJQSxZQUFZNUQsS0FBaEIsRUFBdUI7QUFDckIsWUFBSXlFLFlBQVksS0FBSzVCLGtCQUFyQjtBQUNBLGFBQUswQixTQUFMLElBQWtCRSxTQUFsQixFQUE2QjtBQUMzQixjQUFJQSxVQUFVanBFLGNBQVYsQ0FBeUIrb0UsU0FBekIsQ0FBSixFQUF5QztBQUN2Q0MsMkJBQWVBLGdCQUFnQixFQUEvQjtBQUNBQSx5QkFBYUQsU0FBYixJQUEwQixFQUExQjtBQUNEO0FBQ0Y7QUFDRCxhQUFLMUIsa0JBQUwsR0FBMEIsSUFBMUI7QUFDRCxPQVRELE1BU08sSUFBSXJuRCx3QkFBd0JoZ0IsY0FBeEIsQ0FBdUNvb0UsT0FBdkMsQ0FBSixFQUFxRDtBQUMxRCxZQUFJUSxVQUFVUixPQUFWLENBQUosRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0Fsb0QseUJBQWUsSUFBZixFQUFxQmtvRCxPQUFyQjtBQUNEO0FBQ0YsT0FQTSxNQU9BLElBQUluQixrQkFBa0IsS0FBSzlCLElBQXZCLEVBQTZCeUQsU0FBN0IsQ0FBSixFQUE2QztBQUNsRCxZQUFJLENBQUNsMEQsZUFBZTFVLGNBQWYsQ0FBOEJvb0UsT0FBOUIsQ0FBTCxFQUE2QztBQUMzQ240QixnQ0FBc0JhLHVCQUF0QixDQUE4Q3d6QixRQUFRLElBQVIsQ0FBOUMsRUFBNkQ4RCxPQUE3RDtBQUNEO0FBQ0YsT0FKTSxNQUlBLElBQUl0cUUsWUFBWXVWLFVBQVosQ0FBdUIrMEQsT0FBdkIsS0FBbUN0cUUsWUFBWXFWLGlCQUFaLENBQThCaTFELE9BQTlCLENBQXZDLEVBQStFO0FBQ3BGbjRCLDhCQUFzQlEsc0JBQXRCLENBQTZDNnpCLFFBQVEsSUFBUixDQUE3QyxFQUE0RDhELE9BQTVEO0FBQ0Q7QUFDRjtBQUNELFNBQUtBLE9BQUwsSUFBZ0J6b0MsU0FBaEIsRUFBMkI7QUFDekIsVUFBSXVwQyxXQUFXdnBDLFVBQVV5b0MsT0FBVixDQUFmO0FBQ0EsVUFBSWUsV0FBV2YsWUFBWTVELEtBQVosR0FBb0IsS0FBSzZDLGtCQUF6QixHQUE4Q3VCLGFBQWEsSUFBYixHQUFvQkEsVUFBVVIsT0FBVixDQUFwQixHQUF5Q3BzRSxTQUF0RztBQUNBLFVBQUksQ0FBQzJqQyxVQUFVMy9CLGNBQVYsQ0FBeUJvb0UsT0FBekIsQ0FBRCxJQUFzQ2MsYUFBYUMsUUFBbkQsSUFBK0RELFlBQVksSUFBWixJQUFvQkMsWUFBWSxJQUFuRyxFQUF5RztBQUN2RztBQUNEO0FBQ0QsVUFBSWYsWUFBWTVELEtBQWhCLEVBQXVCO0FBQ3JCLFlBQUkwRSxRQUFKLEVBQWM7QUFDWixjQUFJanhFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDaXBFLHdDQUE0QixLQUFLcUMsa0JBQWpDLEVBQXFELEtBQUtELGNBQTFELEVBQTBFLElBQTFFO0FBQ0EsaUJBQUtBLGNBQUwsR0FBc0I4QixRQUF0QjtBQUNEO0FBQ0RBLHFCQUFXLEtBQUs3QixrQkFBTCxHQUEwQjM4RCxRQUFRLEVBQVIsRUFBWXcrRCxRQUFaLENBQXJDO0FBQ0QsU0FORCxNQU1PO0FBQ0wsZUFBSzdCLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0Q7QUFDRCxZQUFJOEIsUUFBSixFQUFjO0FBQ1o7QUFDQSxlQUFLSixTQUFMLElBQWtCSSxRQUFsQixFQUE0QjtBQUMxQixnQkFBSUEsU0FBU25wRSxjQUFULENBQXdCK29FLFNBQXhCLE1BQXVDLENBQUNHLFFBQUQsSUFBYSxDQUFDQSxTQUFTbHBFLGNBQVQsQ0FBd0Irb0UsU0FBeEIsQ0FBckQsQ0FBSixFQUE4RjtBQUM1RkMsNkJBQWVBLGdCQUFnQixFQUEvQjtBQUNBQSwyQkFBYUQsU0FBYixJQUEwQixFQUExQjtBQUNEO0FBQ0Y7QUFDRDtBQUNBLGVBQUtBLFNBQUwsSUFBa0JHLFFBQWxCLEVBQTRCO0FBQzFCLGdCQUFJQSxTQUFTbHBFLGNBQVQsQ0FBd0Irb0UsU0FBeEIsS0FBc0NJLFNBQVNKLFNBQVQsTUFBd0JHLFNBQVNILFNBQVQsQ0FBbEUsRUFBdUY7QUFDckZDLDZCQUFlQSxnQkFBZ0IsRUFBL0I7QUFDQUEsMkJBQWFELFNBQWIsSUFBMEJHLFNBQVNILFNBQVQsQ0FBMUI7QUFDRDtBQUNGO0FBQ0YsU0FmRCxNQWVPO0FBQ0w7QUFDQUMseUJBQWVFLFFBQWY7QUFDRDtBQUNGLE9BN0JELE1BNkJPLElBQUlscEQsd0JBQXdCaGdCLGNBQXhCLENBQXVDb29FLE9BQXZDLENBQUosRUFBcUQ7QUFDMUQsWUFBSWMsUUFBSixFQUFjO0FBQ1oxRCw2QkFBbUIsSUFBbkIsRUFBeUI0QyxPQUF6QixFQUFrQ2MsUUFBbEMsRUFBNEM3N0QsV0FBNUM7QUFDRCxTQUZELE1BRU8sSUFBSTg3RCxRQUFKLEVBQWM7QUFDbkJqcEQseUJBQWUsSUFBZixFQUFxQmtvRCxPQUFyQjtBQUNEO0FBQ0YsT0FOTSxNQU1BLElBQUluQixrQkFBa0IsS0FBSzlCLElBQXZCLEVBQTZCeGxDLFNBQTdCLENBQUosRUFBNkM7QUFDbEQsWUFBSSxDQUFDanJCLGVBQWUxVSxjQUFmLENBQThCb29FLE9BQTlCLENBQUwsRUFBNkM7QUFDM0NuNEIsZ0NBQXNCVyxvQkFBdEIsQ0FBMkMwekIsUUFBUSxJQUFSLENBQTNDLEVBQTBEOEQsT0FBMUQsRUFBbUVjLFFBQW5FO0FBQ0Q7QUFDRixPQUpNLE1BSUEsSUFBSXByRSxZQUFZdVYsVUFBWixDQUF1QiswRCxPQUF2QixLQUFtQ3RxRSxZQUFZcVYsaUJBQVosQ0FBOEJpMUQsT0FBOUIsQ0FBdkMsRUFBK0U7QUFDcEYsWUFBSTNwRSxPQUFPNmxFLFFBQVEsSUFBUixDQUFYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTRFLFlBQVksSUFBaEIsRUFBc0I7QUFDcEJqNUIsZ0NBQXNCTyxtQkFBdEIsQ0FBMEMveEMsSUFBMUMsRUFBZ0QycEUsT0FBaEQsRUFBeURjLFFBQXpEO0FBQ0QsU0FGRCxNQUVPO0FBQ0xqNUIsZ0NBQXNCUSxzQkFBdEIsQ0FBNkNoeUMsSUFBN0MsRUFBbUQycEUsT0FBbkQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxRQUFJWSxZQUFKLEVBQWtCO0FBQ2hCaEYsNEJBQXNCb0YsaUJBQXRCLENBQXdDOUUsUUFBUSxJQUFSLENBQXhDLEVBQXVEMEUsWUFBdkQsRUFBcUUsSUFBckU7QUFDRDtBQUNGLEdBN2V1Qjs7QUErZXhCOzs7Ozs7Ozs7QUFTQUgsc0JBQW9CLDRCQUFVRCxTQUFWLEVBQXFCanBDLFNBQXJCLEVBQWdDdHlCLFdBQWhDLEVBQTZDbUIsT0FBN0MsRUFBc0Q7QUFDeEUsUUFBSTY2RCxjQUFjOUUsc0JBQXFCcUUsVUFBVWpwRSxRQUEvQixLQUEyQ2lwRSxVQUFVanBFLFFBQXJELEdBQWdFLElBQWxGO0FBQ0EsUUFBSTJwRSxjQUFjL0Usc0JBQXFCNWtDLFVBQVVoZ0MsUUFBL0IsS0FBMkNnZ0MsVUFBVWhnQyxRQUFyRCxHQUFnRSxJQUFsRjs7QUFFQSxRQUFJNHBFLFdBQVdYLFVBQVVsRSx1QkFBVixJQUFxQ2tFLFVBQVVsRSx1QkFBVixDQUFrQzZELE1BQXRGO0FBQ0EsUUFBSWlCLFdBQVc3cEMsVUFBVStrQyx1QkFBVixJQUFxQy9rQyxVQUFVK2tDLHVCQUFWLENBQWtDNkQsTUFBdEY7O0FBRUE7QUFDQSxRQUFJa0IsZUFBZUosZUFBZSxJQUFmLEdBQXNCLElBQXRCLEdBQTZCVCxVQUFVanBFLFFBQTFEO0FBQ0EsUUFBSStwRSxlQUFlSixlQUFlLElBQWYsR0FBc0IsSUFBdEIsR0FBNkIzcEMsVUFBVWhnQyxRQUExRDs7QUFFQTtBQUNBO0FBQ0EsUUFBSWdxRSx1QkFBdUJOLGVBQWUsSUFBZixJQUF1QkUsWUFBWSxJQUE5RDtBQUNBLFFBQUlLLHVCQUF1Qk4sZUFBZSxJQUFmLElBQXVCRSxZQUFZLElBQTlEO0FBQ0EsUUFBSUMsZ0JBQWdCLElBQWhCLElBQXdCQyxnQkFBZ0IsSUFBNUMsRUFBa0Q7QUFDaEQsV0FBS0csY0FBTCxDQUFvQixJQUFwQixFQUEwQng4RCxXQUExQixFQUF1Q21CLE9BQXZDO0FBQ0QsS0FGRCxNQUVPLElBQUltN0Qsd0JBQXdCLENBQUNDLG9CQUE3QixFQUFtRDtBQUN4RCxXQUFLRSxpQkFBTCxDQUF1QixFQUF2QjtBQUNBLFVBQUk3eEUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM2ZCw2QkFBcUIzUCxTQUFyQixDQUErQi9DLGFBQS9CLENBQTZDLEtBQUt3QixRQUFsRCxFQUE0RCxFQUE1RDtBQUNEO0FBQ0Y7O0FBRUQsUUFBSTRnRSxlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLFVBQUlELGdCQUFnQkMsV0FBcEIsRUFBaUM7QUFDL0IsYUFBS1EsaUJBQUwsQ0FBdUIsS0FBS1IsV0FBNUI7QUFDQSxZQUFJcnhFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDbXFFLHdDQUE4QnB0RSxJQUE5QixDQUFtQyxJQUFuQyxFQUF5Q3d3RSxXQUF6QztBQUNEO0FBQ0Y7QUFDRixLQVBELE1BT08sSUFBSUUsWUFBWSxJQUFoQixFQUFzQjtBQUMzQixVQUFJRCxhQUFhQyxRQUFqQixFQUEyQjtBQUN6QixhQUFLTyxZQUFMLENBQWtCLEtBQUtQLFFBQXZCO0FBQ0Q7QUFDRCxVQUFJdnhFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNmQsNkJBQXFCM1AsU0FBckIsQ0FBK0IvQyxhQUEvQixDQUE2QyxLQUFLd0IsUUFBbEQsRUFBNEQsRUFBNUQ7QUFDRDtBQUNGLEtBUE0sTUFPQSxJQUFJZ2hFLGdCQUFnQixJQUFwQixFQUEwQjtBQUMvQixVQUFJenhFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDbXFFLHNDQUE4QnB0RSxJQUE5QixDQUFtQyxJQUFuQyxFQUF5QyxJQUF6QztBQUNEOztBQUVELFdBQUsrd0UsY0FBTCxDQUFvQkgsWUFBcEIsRUFBa0NyOEQsV0FBbEMsRUFBK0NtQixPQUEvQztBQUNEO0FBQ0YsR0FyaUJ1Qjs7QUF1aUJ4QjZMLGVBQWEsdUJBQVk7QUFDdkIsV0FBT2lxRCxRQUFRLElBQVIsQ0FBUDtBQUNELEdBemlCdUI7O0FBMmlCeEI7Ozs7OztBQU1BaHFELG9CQUFrQiwwQkFBVUMsTUFBVixFQUFrQjtBQUNsQyxZQUFRLEtBQUs0cUQsSUFBYjtBQUNFLFdBQUssT0FBTDtBQUNBLFdBQUssTUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssS0FBTDtBQUNBLFdBQUssTUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssT0FBTDtBQUNFLFlBQUk3cEUsWUFBWSxLQUFLZ3RDLGFBQUwsQ0FBbUJodEMsU0FBbkM7QUFDQSxZQUFJQSxTQUFKLEVBQWU7QUFDYixlQUFLLElBQUl0QixJQUFJLENBQWIsRUFBZ0JBLElBQUlzQixVQUFVaEMsTUFBOUIsRUFBc0NVLEdBQXRDLEVBQTJDO0FBQ3pDc0Isc0JBQVV0QixDQUFWLEVBQWEybkIsTUFBYjtBQUNEO0FBQ0Y7QUFDRDtBQUNGLFdBQUssT0FBTDtBQUNBLFdBQUssVUFBTDtBQUNFaW5CLDJCQUFtQk8sWUFBbkIsQ0FBZ0MsSUFBaEM7QUFDQTtBQUNGLFdBQUssTUFBTDtBQUNBLFdBQUssTUFBTDtBQUNBLFdBQUssTUFBTDtBQUNFOzs7Ozs7QUFNQSxnQkFBU2x4QyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLGtRQUFqQixFQUFxUixLQUFLa3BFLElBQTFSLENBQXhDLEdBQTBVdG5FLGVBQWUsSUFBZixFQUFxQixLQUFLc25FLElBQTFCLENBQW5WLEdBQXFYLEtBQUssQ0FBMVg7QUFDQTtBQTlCSjs7QUFpQ0EsU0FBSzZFLGVBQUwsQ0FBcUJ6dkQsTUFBckI7QUFDQTFaLDBCQUFzQnRCLFdBQXRCLENBQWtDLElBQWxDO0FBQ0FzZCxtQkFBZXVELGtCQUFmLENBQWtDLElBQWxDO0FBQ0EsU0FBS2QsV0FBTCxHQUFtQixDQUFuQjtBQUNBLFNBQUtuZixNQUFMLEdBQWMsQ0FBZDtBQUNBLFNBQUttb0MsYUFBTCxHQUFxQixJQUFyQjs7QUFFQSxRQUFJcndDLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDbXFFLG9DQUE4QnB0RSxJQUE5QixDQUFtQyxJQUFuQyxFQUF5QyxJQUF6QztBQUNEO0FBQ0YsR0E3bEJ1Qjs7QUErbEJ4QnFWLHFCQUFtQiw2QkFBWTtBQUM3QixXQUFPbTJELFFBQVEsSUFBUixDQUFQO0FBQ0Q7QUFqbUJ1QixDQUExQjs7QUFvbUJBNTVELFFBQVE0bEQsa0JBQWtCbDJELFNBQTFCLEVBQXFDazJELGtCQUFrQmdYLEtBQXZELEVBQThEbEQsZ0JBQWdCa0QsS0FBOUU7O0FBRUFwdkUsT0FBT0MsT0FBUCxHQUFpQm00RCxpQkFBakIsQzs7Ozs7Ozs7QUNoL0JBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSXp2RCx3QkFBd0IsbUJBQUFoRSxDQUFRLENBQVIsQ0FBNUI7O0FBRUEsSUFBSXd0QyxZQUFZLG1CQUFBeHRDLENBQVEsRUFBUixDQUFoQjs7QUFFQSxJQUFJa25FLGlCQUFpQjtBQUNuQm9FLHFCQUFtQiw2QkFBWTtBQUM3Qjk5QixjQUFVeHBDLHNCQUFzQkYsbUJBQXRCLENBQTBDLElBQTFDLENBQVY7QUFDRDtBQUhrQixDQUFyQjs7QUFNQXpJLE9BQU9DLE9BQVAsR0FBaUI0ckUsY0FBakIsQzs7Ozs7OztBQ3RCQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl0MEIsY0FBYyxtQkFBQTV5QyxDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJbUcsdUJBQXVCLG1CQUFBbkcsQ0FBUSxDQUFSLENBQTNCO0FBQ0EsSUFBSStjLHVCQUF1QixtQkFBQS9jLENBQVEsRUFBUixDQUEzQjs7QUFFQSxJQUFJb3RFLG9CQUFvQixtQkFBQXB0RSxDQUFRLEdBQVIsQ0FBeEI7QUFDQSxJQUFJcXRFLHNCQUFzQixtQkFBQXJ0RSxDQUFRLEdBQVIsQ0FBMUI7QUFDQSxJQUFJc3RFLHFCQUFxQixtQkFBQXR0RSxDQUFRLEdBQVIsQ0FBekI7QUFDQSxJQUFJdXRFLG9CQUFvQixtQkFBQXZ0RSxDQUFRLEdBQVIsQ0FBeEI7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJd3RFLG1CQUFtQkQsa0JBQWtCLFVBQVVyQixTQUFWLEVBQXFCO0FBQzVELFNBQU9vQixtQkFBbUJwQixTQUFuQixDQUFQO0FBQ0QsQ0FGc0IsQ0FBdkI7O0FBSUEsSUFBSXVCLDBCQUEwQixLQUE5QjtBQUNBLElBQUlDLHFCQUFxQixVQUF6QjtBQUNBLElBQUl2bkUscUJBQXFCSixTQUF6QixFQUFvQztBQUNsQyxNQUFJNG5FLFlBQVkxbkUsU0FBU0MsYUFBVCxDQUF1QixLQUF2QixFQUE4QnFsRCxLQUE5QztBQUNBLE1BQUk7QUFDRjtBQUNBb2lCLGNBQVV4N0IsSUFBVixHQUFpQixFQUFqQjtBQUNELEdBSEQsQ0FHRSxPQUFPdDJDLENBQVAsRUFBVTtBQUNWNHhFLDhCQUEwQixJQUExQjtBQUNEO0FBQ0Q7QUFDQSxNQUFJeG5FLFNBQVM4a0MsZUFBVCxDQUF5QndnQixLQUF6QixDQUErQnFpQixRQUEvQixLQUE0Q3p1RSxTQUFoRCxFQUEyRDtBQUN6RHV1RSx5QkFBcUIsWUFBckI7QUFDRDtBQUNGOztBQUVELElBQUl0eUUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM7QUFDQSxNQUFJMnVFLDhCQUE4Qix3QkFBbEM7O0FBRUE7QUFDQSxNQUFJQyxvQ0FBb0MsT0FBeEM7O0FBRUEsTUFBSUMsbUJBQW1CLEVBQXZCO0FBQ0EsTUFBSUMsb0JBQW9CLEVBQXhCO0FBQ0EsTUFBSUMsb0JBQW9CLEtBQXhCOztBQUVBLE1BQUlDLDBCQUEwQixTQUExQkEsdUJBQTBCLENBQVV4dkUsSUFBVixFQUFnQjhNLEtBQWhCLEVBQXVCO0FBQ25ELFFBQUl1aUUsaUJBQWlCNXFFLGNBQWpCLENBQWdDekUsSUFBaEMsS0FBeUNxdkUsaUJBQWlCcnZFLElBQWpCLENBQTdDLEVBQXFFO0FBQ25FO0FBQ0Q7O0FBRURxdkUscUJBQWlCcnZFLElBQWpCLElBQXlCLElBQXpCO0FBQ0F0RCxZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsbURBQWYsRUFBb0V2QixJQUFwRSxFQUEwRTB1RSxrQkFBa0IxdUUsSUFBbEIsQ0FBMUUsRUFBbUd5dkUsbUJBQW1CM2lFLEtBQW5CLENBQW5HLENBQXhDLEdBQXdLLEtBQUssQ0FBN0s7QUFDRCxHQVBEOztBQVNBLE1BQUk0aUUsMkJBQTJCLFNBQTNCQSx3QkFBMkIsQ0FBVTF2RSxJQUFWLEVBQWdCOE0sS0FBaEIsRUFBdUI7QUFDcEQsUUFBSXVpRSxpQkFBaUI1cUUsY0FBakIsQ0FBZ0N6RSxJQUFoQyxLQUF5Q3F2RSxpQkFBaUJydkUsSUFBakIsQ0FBN0MsRUFBcUU7QUFDbkU7QUFDRDs7QUFFRHF2RSxxQkFBaUJydkUsSUFBakIsSUFBeUIsSUFBekI7QUFDQXRELFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxtRUFBZixFQUFvRnZCLElBQXBGLEVBQTBGQSxLQUFLMG1CLE1BQUwsQ0FBWSxDQUFaLEVBQWVnckIsV0FBZixLQUErQjF4QyxLQUFLZ0QsS0FBTCxDQUFXLENBQVgsQ0FBekgsRUFBd0l5c0UsbUJBQW1CM2lFLEtBQW5CLENBQXhJLENBQXhDLEdBQTZNLEtBQUssQ0FBbE47QUFDRCxHQVBEOztBQVNBLE1BQUk2aUUsOEJBQThCLFNBQTlCQSwyQkFBOEIsQ0FBVTN2RSxJQUFWLEVBQWdCK1YsS0FBaEIsRUFBdUJqSixLQUF2QixFQUE4QjtBQUM5RCxRQUFJd2lFLGtCQUFrQjdxRSxjQUFsQixDQUFpQ3NSLEtBQWpDLEtBQTJDdTVELGtCQUFrQnY1RCxLQUFsQixDQUEvQyxFQUF5RTtBQUN2RTtBQUNEOztBQUVEdTVELHNCQUFrQnY1RCxLQUFsQixJQUEyQixJQUEzQjtBQUNBclosWUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLDREQUE0RCx1QkFBM0UsRUFBb0drdUUsbUJBQW1CM2lFLEtBQW5CLENBQXBHLEVBQStIOU0sSUFBL0gsRUFBcUkrVixNQUFNNVUsT0FBTixDQUFjaXVFLGlDQUFkLEVBQWlELEVBQWpELENBQXJJLENBQXhDLEdBQXFPLEtBQUssQ0FBMU87QUFDRCxHQVBEOztBQVNBLE1BQUlRLHNCQUFzQixTQUF0QkEsbUJBQXNCLENBQVU1dkUsSUFBVixFQUFnQitWLEtBQWhCLEVBQXVCakosS0FBdkIsRUFBOEI7QUFDdEQsUUFBSXlpRSxpQkFBSixFQUF1QjtBQUNyQjtBQUNEOztBQUVEQSx3QkFBb0IsSUFBcEI7QUFDQTd5RSxZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsOERBQWYsRUFBK0V2QixJQUEvRSxFQUFxRnl2RSxtQkFBbUIzaUUsS0FBbkIsQ0FBckYsQ0FBeEMsR0FBMEosS0FBSyxDQUEvSjtBQUNELEdBUEQ7O0FBU0EsTUFBSTJpRSxxQkFBcUIsU0FBckJBLGtCQUFxQixDQUFVM2lFLEtBQVYsRUFBaUI7QUFDeEMsUUFBSUEsS0FBSixFQUFXO0FBQ1QsVUFBSTlNLE9BQU84TSxNQUFNRSxPQUFOLEVBQVg7QUFDQSxVQUFJaE4sSUFBSixFQUFVO0FBQ1IsZUFBTyxrQ0FBa0NBLElBQWxDLEdBQXlDLElBQWhEO0FBQ0Q7QUFDRjtBQUNELFdBQU8sRUFBUDtBQUNELEdBUkQ7O0FBVUE7Ozs7O0FBS0EsTUFBSTZ2RSxpQkFBaUIsU0FBakJBLGNBQWlCLENBQVU3dkUsSUFBVixFQUFnQitWLEtBQWhCLEVBQXVCdFMsU0FBdkIsRUFBa0M7QUFDckQsUUFBSXFKLEtBQUo7QUFDQSxRQUFJckosU0FBSixFQUFlO0FBQ2JxSixjQUFRckosVUFBVTRPLGVBQVYsQ0FBMEJ0RixNQUFsQztBQUNEO0FBQ0QsUUFBSS9NLEtBQUs4QixPQUFMLENBQWEsR0FBYixJQUFvQixDQUFDLENBQXpCLEVBQTRCO0FBQzFCMHRFLDhCQUF3Qnh2RSxJQUF4QixFQUE4QjhNLEtBQTlCO0FBQ0QsS0FGRCxNQUVPLElBQUlxaUUsNEJBQTRCam1FLElBQTVCLENBQWlDbEosSUFBakMsQ0FBSixFQUE0QztBQUNqRDB2RSwrQkFBeUIxdkUsSUFBekIsRUFBK0I4TSxLQUEvQjtBQUNELEtBRk0sTUFFQSxJQUFJc2lFLGtDQUFrQ2xtRSxJQUFsQyxDQUF1QzZNLEtBQXZDLENBQUosRUFBbUQ7QUFDeEQ0NUQsa0NBQTRCM3ZFLElBQTVCLEVBQWtDK1YsS0FBbEMsRUFBeUNqSixLQUF6QztBQUNEOztBQUVELFFBQUksT0FBT2lKLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIwK0IsTUFBTTErQixLQUFOLENBQWpDLEVBQStDO0FBQzdDNjVELDBCQUFvQjV2RSxJQUFwQixFQUEwQitWLEtBQTFCLEVBQWlDakosS0FBakM7QUFDRDtBQUNGLEdBaEJEO0FBaUJEOztBQUVEOzs7QUFHQSxJQUFJMjdELHdCQUF3QjtBQUMxQjs7Ozs7Ozs7Ozs7OztBQWFBcUUseUJBQXVCLCtCQUFVZ0QsTUFBVixFQUFrQnJzRSxTQUFsQixFQUE2QjtBQUNsRCxRQUFJc3NFLGFBQWEsRUFBakI7QUFDQSxTQUFLLElBQUl2QyxTQUFULElBQXNCc0MsTUFBdEIsRUFBOEI7QUFDNUIsVUFBSSxDQUFDQSxPQUFPcnJFLGNBQVAsQ0FBc0Irb0UsU0FBdEIsQ0FBTCxFQUF1QztBQUNyQztBQUNEO0FBQ0QsVUFBSXdDLG1CQUFtQnhDLFVBQVUxckUsT0FBVixDQUFrQixJQUFsQixNQUE0QixDQUFuRDtBQUNBLFVBQUltdUUsYUFBYUgsT0FBT3RDLFNBQVAsQ0FBakI7QUFDQSxVQUFJOXdFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFlBQUksQ0FBQ3d2RSxnQkFBTCxFQUF1QjtBQUNyQkgseUJBQWVyQyxTQUFmLEVBQTBCeUMsVUFBMUIsRUFBc0N4c0UsU0FBdEM7QUFDRDtBQUNGO0FBQ0QsVUFBSXdzRSxjQUFjLElBQWxCLEVBQXdCO0FBQ3RCRixzQkFBY2pCLGlCQUFpQnRCLFNBQWpCLElBQThCLEdBQTVDO0FBQ0F1QyxzQkFBY3BCLG9CQUFvQm5CLFNBQXBCLEVBQStCeUMsVUFBL0IsRUFBMkN4c0UsU0FBM0MsRUFBc0R1c0UsZ0JBQXRELElBQTBFLEdBQXhGO0FBQ0Q7QUFDRjtBQUNELFdBQU9ELGNBQWMsSUFBckI7QUFDRCxHQWpDeUI7O0FBbUMxQjs7Ozs7Ozs7QUFRQWxDLHFCQUFtQiwyQkFBVTNxRSxJQUFWLEVBQWdCNHNFLE1BQWhCLEVBQXdCcnNFLFNBQXhCLEVBQW1DO0FBQ3BELFFBQUkvRyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzZkLDJCQUFxQjNQLFNBQXJCLENBQStCNm9CLGVBQS9CLENBQStDO0FBQzdDQyxvQkFBWS96QixVQUFVMEosUUFEdUI7QUFFN0NoQyxjQUFNLGVBRnVDO0FBRzdDc3NCLGlCQUFTcTRDO0FBSG9DLE9BQS9DO0FBS0Q7O0FBRUQsUUFBSWpqQixRQUFRM3BELEtBQUsycEQsS0FBakI7QUFDQSxTQUFLLElBQUkyZ0IsU0FBVCxJQUFzQnNDLE1BQXRCLEVBQThCO0FBQzVCLFVBQUksQ0FBQ0EsT0FBT3JyRSxjQUFQLENBQXNCK29FLFNBQXRCLENBQUwsRUFBdUM7QUFDckM7QUFDRDtBQUNELFVBQUl3QyxtQkFBbUJ4QyxVQUFVMXJFLE9BQVYsQ0FBa0IsSUFBbEIsTUFBNEIsQ0FBbkQ7QUFDQSxVQUFJcEYsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsWUFBSSxDQUFDd3ZFLGdCQUFMLEVBQXVCO0FBQ3JCSCx5QkFBZXJDLFNBQWYsRUFBMEJzQyxPQUFPdEMsU0FBUCxDQUExQixFQUE2Qy9wRSxTQUE3QztBQUNEO0FBQ0Y7QUFDRCxVQUFJd3NFLGFBQWF0QixvQkFBb0JuQixTQUFwQixFQUErQnNDLE9BQU90QyxTQUFQLENBQS9CLEVBQWtEL3BFLFNBQWxELEVBQTZEdXNFLGdCQUE3RCxDQUFqQjtBQUNBLFVBQUl4QyxjQUFjLE9BQWQsSUFBeUJBLGNBQWMsVUFBM0MsRUFBdUQ7QUFDckRBLG9CQUFZd0Isa0JBQVo7QUFDRDtBQUNELFVBQUlnQixnQkFBSixFQUFzQjtBQUNwQm5qQixjQUFNcWpCLFdBQU4sQ0FBa0IxQyxTQUFsQixFQUE2QnlDLFVBQTdCO0FBQ0QsT0FGRCxNQUVPLElBQUlBLFVBQUosRUFBZ0I7QUFDckJwakIsY0FBTTJnQixTQUFOLElBQW1CeUMsVUFBbkI7QUFDRCxPQUZNLE1BRUE7QUFDTCxZQUFJRSxZQUFZcEIsMkJBQTJCNzZCLFlBQVl0QywyQkFBWixDQUF3QzQ3QixTQUF4QyxDQUEzQztBQUNBLFlBQUkyQyxTQUFKLEVBQWU7QUFDYjtBQUNBO0FBQ0EsZUFBSyxJQUFJQyxtQkFBVCxJQUFnQ0QsU0FBaEMsRUFBMkM7QUFDekN0akIsa0JBQU11akIsbUJBQU4sSUFBNkIsRUFBN0I7QUFDRDtBQUNGLFNBTkQsTUFNTztBQUNMdmpCLGdCQUFNMmdCLFNBQU4sSUFBbUIsRUFBbkI7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQXBGeUIsQ0FBNUI7O0FBdUZBN3dFLE9BQU9DLE9BQVAsR0FBaUI2ckUscUJBQWpCLEM7Ozs7Ozs7O0FDck5BOzs7Ozs7Ozs7OztBQVdBOztBQUVBLElBQUk0SCxXQUFXLG1CQUFBL3VFLENBQVEsR0FBUixDQUFmOztBQUVBLElBQUlndkUsWUFBWSxPQUFoQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsU0FBUzVCLGlCQUFULENBQTJCeGlELE1BQTNCLEVBQW1DO0FBQ2pDLFNBQU9ta0QsU0FBU25rRCxPQUFPL3FCLE9BQVAsQ0FBZW12RSxTQUFmLEVBQTBCLEtBQTFCLENBQVQsQ0FBUDtBQUNEOztBQUVEM3pFLE9BQU9DLE9BQVAsR0FBaUI4eEUsaUJBQWpCLEM7Ozs7Ozs7QUN0Q0E7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0EsSUFBSTZCLGlCQUFpQixPQUFyQjs7QUFFQTs7Ozs7Ozs7O0FBU0EsU0FBU0YsUUFBVCxDQUFrQm5rRCxNQUFsQixFQUEwQjtBQUN4QixTQUFPQSxPQUFPL3FCLE9BQVAsQ0FBZW92RSxjQUFmLEVBQStCLFVBQVVDLENBQVYsRUFBYUMsU0FBYixFQUF3QjtBQUM1RCxXQUFPQSxVQUFVLytCLFdBQVYsRUFBUDtBQUNELEdBRk0sQ0FBUDtBQUdEOztBQUVELzBDLE9BQU9DLE9BQVAsR0FBaUJ5ekUsUUFBakIsQzs7Ozs7OztBQzlCQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUluOEIsY0FBYyxtQkFBQTV5QyxDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJMHRDLG1CQUFtQmtGLFlBQVlsRixnQkFBbkM7QUFDQSxJQUFJMGhDLGdCQUFnQixFQUFwQjs7QUFFQTs7Ozs7Ozs7OztBQVVBLFNBQVMvQixtQkFBVCxDQUE2QjN1RSxJQUE3QixFQUFtQytWLEtBQW5DLEVBQTBDdFMsU0FBMUMsRUFBcUR1c0UsZ0JBQXJELEVBQXVFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFJVyxVQUFVNTZELFNBQVMsSUFBVCxJQUFpQixPQUFPQSxLQUFQLEtBQWlCLFNBQWxDLElBQStDQSxVQUFVLEVBQXZFO0FBQ0EsTUFBSTQ2RCxPQUFKLEVBQWE7QUFDWCxXQUFPLEVBQVA7QUFDRDs7QUFFRCxNQUFJQyxlQUFlbjhCLE1BQU0xK0IsS0FBTixDQUFuQjtBQUNBLE1BQUlpNkQsb0JBQW9CWSxZQUFwQixJQUFvQzc2RCxVQUFVLENBQTlDLElBQW1EaTVCLGlCQUFpQnZxQyxjQUFqQixDQUFnQ3pFLElBQWhDLEtBQXlDZ3ZDLGlCQUFpQmh2QyxJQUFqQixDQUFoRyxFQUF3SDtBQUN0SCxXQUFPLEtBQUsrVixLQUFaLENBRHNILENBQ25HO0FBQ3BCOztBQUVELE1BQUksT0FBT0EsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixRQUFJclosUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM7QUFDQTtBQUNBLFVBQUlpRCxhQUFhc1MsVUFBVSxHQUEzQixFQUFnQztBQUM5QixZQUFJakosUUFBUXJKLFVBQVU0TyxlQUFWLENBQTBCdEYsTUFBdEM7QUFDQSxZQUFJakMsWUFBWWdDLFFBQVFBLE1BQU1FLE9BQU4sRUFBUixHQUEwQixJQUExQztBQUNBLFlBQUlsQyxhQUFhLENBQUM0bEUsY0FBYzVsRSxTQUFkLENBQWxCLEVBQTRDO0FBQzFDNGxFLHdCQUFjNWxFLFNBQWQsSUFBMkIsRUFBM0I7QUFDRDtBQUNELFlBQUkrbEUsU0FBUyxLQUFiO0FBQ0EsWUFBSS9sRSxTQUFKLEVBQWU7QUFDYixjQUFJZ21FLFdBQVdKLGNBQWM1bEUsU0FBZCxDQUFmO0FBQ0ErbEUsbUJBQVNDLFNBQVM5d0UsSUFBVCxDQUFUO0FBQ0EsY0FBSSxDQUFDNndFLE1BQUwsRUFBYTtBQUNYQyxxQkFBUzl3RSxJQUFULElBQWlCLElBQWpCO0FBQ0Q7QUFDRjtBQUNELFlBQUksQ0FBQzZ3RSxNQUFMLEVBQWE7QUFDWG4wRSxrQkFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLGdFQUFnRSw0REFBaEUsR0FBK0gsb0RBQTlJLEVBQW9Na0MsVUFBVTRPLGVBQVYsQ0FBMEJsSCxJQUE5TixFQUFvT0wsYUFBYSxTQUFqUCxFQUE0UDlLLElBQTVQLEVBQWtRK1YsS0FBbFEsQ0FBeEMsR0FBbVQsS0FBSyxDQUF4VDtBQUNEO0FBQ0Y7QUFDRjtBQUNEQSxZQUFRQSxNQUFNbytDLElBQU4sRUFBUjtBQUNEO0FBQ0QsU0FBT3ArQyxRQUFRLElBQWY7QUFDRDs7QUFFRHBaLE9BQU9DLE9BQVAsR0FBaUIreEUsbUJBQWpCLEM7Ozs7Ozs7O0FDN0VBOzs7Ozs7Ozs7OztBQVdBOztBQUVBLElBQUlvQyxZQUFZLG1CQUFBenZFLENBQVEsR0FBUixDQUFoQjs7QUFFQSxJQUFJZ3ZFLFlBQVksTUFBaEI7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkEsU0FBUzFCLGtCQUFULENBQTRCMWlELE1BQTVCLEVBQW9DO0FBQ2xDLFNBQU82a0QsVUFBVTdrRCxNQUFWLEVBQWtCL3FCLE9BQWxCLENBQTBCbXZFLFNBQTFCLEVBQXFDLE1BQXJDLENBQVA7QUFDRDs7QUFFRDN6RSxPQUFPQyxPQUFQLEdBQWlCZ3lFLGtCQUFqQixDOzs7Ozs7O0FDckNBOztBQUVBOzs7Ozs7Ozs7OztBQVdBLElBQUlvQyxvQkFBb0IsVUFBeEI7O0FBRUE7Ozs7Ozs7Ozs7OztBQVlBLFNBQVNELFNBQVQsQ0FBbUI3a0QsTUFBbkIsRUFBMkI7QUFDekIsU0FBT0EsT0FBTy9xQixPQUFQLENBQWU2dkUsaUJBQWYsRUFBa0MsS0FBbEMsRUFBeUNoNUQsV0FBekMsRUFBUDtBQUNEOztBQUVEcmIsT0FBT0MsT0FBUCxHQUFpQm0wRSxTQUFqQixDOzs7Ozs7O0FDL0JBOzs7Ozs7Ozs7Ozs7QUFZQTs7QUFFQTs7OztBQUlBLFNBQVNsQyxpQkFBVCxDQUEyQnI5RCxRQUEzQixFQUFxQztBQUNuQyxNQUFJMnpCLFFBQVEsRUFBWjtBQUNBLFNBQU8sVUFBVWpaLE1BQVYsRUFBa0I7QUFDdkIsUUFBSSxDQUFDaVosTUFBTTFnQyxjQUFOLENBQXFCeW5CLE1BQXJCLENBQUwsRUFBbUM7QUFDakNpWixZQUFNalosTUFBTixJQUFnQjFhLFNBQVNqVSxJQUFULENBQWMsSUFBZCxFQUFvQjJ1QixNQUFwQixDQUFoQjtBQUNEO0FBQ0QsV0FBT2laLE1BQU1qWixNQUFOLENBQVA7QUFDRCxHQUxEO0FBTUQ7O0FBRUR2dkIsT0FBT0MsT0FBUCxHQUFpQml5RSxpQkFBakIsQzs7Ozs7OztBQzVCQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlsaUQsOEJBQThCLG1CQUFBcnJCLENBQVEsRUFBUixDQUFsQzs7QUFFQTs7Ozs7O0FBTUEsU0FBUzZ5Qyw2QkFBVCxDQUF1Q3ArQixLQUF2QyxFQUE4QztBQUM1QyxTQUFPLE1BQU00Vyw0QkFBNEI1VyxLQUE1QixDQUFOLEdBQTJDLEdBQWxEO0FBQ0Q7O0FBRURwWixPQUFPQyxPQUFQLEdBQWlCdTNDLDZCQUFqQixDOzs7Ozs7O0FDeEJBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSTd5QixpQkFBaUIsbUJBQUFoZ0IsQ0FBUSxFQUFSLENBQXJCOztBQUVBLFNBQVMydkUsb0JBQVQsQ0FBOEJwdUQsTUFBOUIsRUFBc0M7QUFDcEN2QixpQkFBZTZELGFBQWYsQ0FBNkJ0QyxNQUE3QjtBQUNBdkIsaUJBQWU4RCxpQkFBZixDQUFpQyxLQUFqQztBQUNEOztBQUVELElBQUl3SCx5QkFBeUI7QUFDM0I7Ozs7QUFJQStFLGtCQUFnQix3QkFBVTVNLFlBQVYsRUFBd0J0USxVQUF4QixFQUFvQ0MsV0FBcEMsRUFBaURDLGlCQUFqRCxFQUFvRTtBQUNsRixRQUFJa08sU0FBU3ZCLGVBQWV3RCxhQUFmLENBQTZCQyxZQUE3QixFQUEyQ3RRLFVBQTNDLEVBQXVEQyxXQUF2RCxFQUFvRUMsaUJBQXBFLENBQWI7QUFDQXM4RCx5QkFBcUJwdUQsTUFBckI7QUFDRDtBQVIwQixDQUE3Qjs7QUFXQWxtQixPQUFPQyxPQUFQLEdBQWlCZ3dCLHNCQUFqQixDOzs7Ozs7O0FDOUJBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSW5sQix1QkFBdUIsbUJBQUFuRyxDQUFRLENBQVIsQ0FBM0I7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTNHZFLGFBQVQsQ0FBdUJDLFNBQXZCLEVBQWtDbHBELFNBQWxDLEVBQTZDO0FBQzNDLE1BQUkwcEIsV0FBVyxFQUFmOztBQUVBQSxXQUFTdy9CLFVBQVVuNUQsV0FBVixFQUFULElBQW9DaVEsVUFBVWpRLFdBQVYsRUFBcEM7QUFDQTI1QixXQUFTLFdBQVd3L0IsU0FBcEIsSUFBaUMsV0FBV2xwRCxTQUE1QztBQUNBMHBCLFdBQVMsUUFBUXcvQixTQUFqQixJQUE4QixRQUFRbHBELFNBQXRDO0FBQ0EwcEIsV0FBUyxPQUFPdy9CLFNBQWhCLElBQTZCLE9BQU9scEQsU0FBcEM7QUFDQTBwQixXQUFTLE1BQU13L0IsU0FBZixJQUE0QixNQUFNbHBELFVBQVVqUSxXQUFWLEVBQWxDOztBQUVBLFNBQU8yNUIsUUFBUDtBQUNEOztBQUVEOzs7QUFHQSxJQUFJeS9CLGlCQUFpQjtBQUNuQkMsZ0JBQWNILGNBQWMsV0FBZCxFQUEyQixjQUEzQixDQURLO0FBRW5CSSxzQkFBb0JKLGNBQWMsV0FBZCxFQUEyQixvQkFBM0IsQ0FGRDtBQUduQkssa0JBQWdCTCxjQUFjLFdBQWQsRUFBMkIsZ0JBQTNCLENBSEc7QUFJbkJNLGlCQUFlTixjQUFjLFlBQWQsRUFBNEIsZUFBNUI7QUFKSSxDQUFyQjs7QUFPQTs7O0FBR0EsSUFBSU8scUJBQXFCLEVBQXpCOztBQUVBOzs7QUFHQSxJQUFJNWtCLFFBQVEsRUFBWjs7QUFFQTs7O0FBR0EsSUFBSXBsRCxxQkFBcUJKLFNBQXpCLEVBQW9DO0FBQ2xDd2xELFVBQVF0bEQsU0FBU0MsYUFBVCxDQUF1QixLQUF2QixFQUE4QnFsRCxLQUF0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUksRUFBRSxvQkFBb0J2bEQsTUFBdEIsQ0FBSixFQUFtQztBQUNqQyxXQUFPOHBFLGVBQWVDLFlBQWYsQ0FBNEJLLFNBQW5DO0FBQ0EsV0FBT04sZUFBZUUsa0JBQWYsQ0FBa0NJLFNBQXpDO0FBQ0EsV0FBT04sZUFBZUcsY0FBZixDQUE4QkcsU0FBckM7QUFDRDs7QUFFRDtBQUNBLE1BQUksRUFBRSxxQkFBcUJwcUUsTUFBdkIsQ0FBSixFQUFvQztBQUNsQyxXQUFPOHBFLGVBQWVJLGFBQWYsQ0FBNkJHLFVBQXBDO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7O0FBTUEsU0FBUzlrRCwwQkFBVCxDQUFvQzVFLFNBQXBDLEVBQStDO0FBQzdDLE1BQUl3cEQsbUJBQW1CeHBELFNBQW5CLENBQUosRUFBbUM7QUFDakMsV0FBT3dwRCxtQkFBbUJ4cEQsU0FBbkIsQ0FBUDtBQUNELEdBRkQsTUFFTyxJQUFJLENBQUNtcEQsZUFBZW5wRCxTQUFmLENBQUwsRUFBZ0M7QUFDckMsV0FBT0EsU0FBUDtBQUNEOztBQUVELE1BQUkycEQsWUFBWVIsZUFBZW5wRCxTQUFmLENBQWhCOztBQUVBLE9BQUssSUFBSWtwRCxTQUFULElBQXNCUyxTQUF0QixFQUFpQztBQUMvQixRQUFJQSxVQUFVbnRFLGNBQVYsQ0FBeUIwc0UsU0FBekIsS0FBdUNBLGFBQWF0a0IsS0FBeEQsRUFBK0Q7QUFDN0QsYUFBTzRrQixtQkFBbUJ4cEQsU0FBbkIsSUFBZ0MycEQsVUFBVVQsU0FBVixDQUF2QztBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxFQUFQO0FBQ0Q7O0FBRUR4MEUsT0FBT0MsT0FBUCxHQUFpQml3QiwwQkFBakIsQzs7Ozs7OztBQ25HQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl2cUIsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCO0FBQUEsSUFDSTZOLFVBQVUsbUJBQUE3TixDQUFRLENBQVIsQ0FEZDs7QUFHQSxJQUFJb3pDLHdCQUF3QixtQkFBQXB6QyxDQUFRLEVBQVIsQ0FBNUI7QUFDQSxJQUFJODRCLG1CQUFtQixtQkFBQTk0QixDQUFRLEVBQVIsQ0FBdkI7QUFDQSxJQUFJZ0Usd0JBQXdCLG1CQUFBaEUsQ0FBUSxDQUFSLENBQTVCO0FBQ0EsSUFBSTBPLGVBQWUsbUJBQUExTyxDQUFRLEVBQVIsQ0FBbkI7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCO0FBQ0EsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUEsSUFBSWswQyxtQkFBbUIsS0FBdkI7QUFDQSxJQUFJcThCLHFCQUFxQixLQUF6QjtBQUNBLElBQUlwOEIsMkJBQTJCLEtBQS9CO0FBQ0EsSUFBSXE4QiwrQkFBK0IsS0FBbkM7QUFDQSxJQUFJQyxrQ0FBa0MsS0FBdEM7QUFDQSxJQUFJQyxrQ0FBa0MsS0FBdEM7O0FBRUEsU0FBU0Msb0JBQVQsR0FBZ0M7QUFDOUIsTUFBSSxLQUFLbHVELFdBQVQsRUFBc0I7QUFDcEI7QUFDQTJrRCxrQkFBYzZFLGFBQWQsQ0FBNEIsSUFBNUI7QUFDRDtBQUNGOztBQUVELFNBQVMyRSxZQUFULENBQXNCbDRELEtBQXRCLEVBQTZCO0FBQzNCLE1BQUltNEQsY0FBY240RCxNQUFNN08sSUFBTixLQUFlLFVBQWYsSUFBNkI2TyxNQUFNN08sSUFBTixLQUFlLE9BQTlEO0FBQ0EsU0FBT2duRSxjQUFjbjRELE1BQU04ZixPQUFOLElBQWlCLElBQS9CLEdBQXNDOWYsTUFBTWpFLEtBQU4sSUFBZSxJQUE1RDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLElBQUkyeUQsZ0JBQWdCO0FBQ2xCdHlCLGdCQUFjLHNCQUFVdnlDLElBQVYsRUFBZ0JtVyxLQUFoQixFQUF1QjtBQUNuQyxRQUFJakUsUUFBUXFrQixpQkFBaUJJLFFBQWpCLENBQTBCeGdCLEtBQTFCLENBQVo7QUFDQSxRQUFJOGYsVUFBVU0saUJBQWlCSyxVQUFqQixDQUE0QnpnQixLQUE1QixDQUFkOztBQUVBLFFBQUlvNEQsWUFBWWpqRSxRQUFRO0FBQ3RCO0FBQ0E7QUFDQWhFLFlBQU0xSyxTQUhnQjtBQUl0QjtBQUNBO0FBQ0F5bkMsWUFBTXpuQyxTQU5nQjtBQU90QjtBQUNBO0FBQ0F1L0IsV0FBS3YvQixTQVRpQjtBQVV0QjZpRSxXQUFLN2lFO0FBVmlCLEtBQVIsRUFXYnVaLEtBWGEsRUFXTjtBQUNScTRELHNCQUFnQjV4RSxTQURSO0FBRVI4MUMsb0JBQWM5MUMsU0FGTjtBQUdSc1YsYUFBT0EsU0FBUyxJQUFULEdBQWdCQSxLQUFoQixHQUF3QmxTLEtBQUtrcEMsYUFBTCxDQUFtQnVKLFlBSDFDO0FBSVJ4YyxlQUFTQSxXQUFXLElBQVgsR0FBa0JBLE9BQWxCLEdBQTRCajJCLEtBQUtrcEMsYUFBTCxDQUFtQnVsQyxjQUpoRDtBQUtSMTRDLGdCQUFVLzFCLEtBQUtrcEMsYUFBTCxDQUFtQm5UO0FBTHJCLEtBWE0sQ0FBaEI7O0FBbUJBLFdBQU93NEMsU0FBUDtBQUNELEdBekJpQjs7QUEyQmxCLzdCLGdCQUFjLHNCQUFVeHlDLElBQVYsRUFBZ0JtVyxLQUFoQixFQUF1QjtBQUNuQyxRQUFJdGQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM0NUIsdUJBQWlCQyxjQUFqQixDQUFnQyxPQUFoQyxFQUF5Q3JnQixLQUF6QyxFQUFnRG5XLEtBQUt3TyxlQUFMLENBQXFCdEYsTUFBckU7O0FBRUEsVUFBSUQsUUFBUWpKLEtBQUt3TyxlQUFMLENBQXFCdEYsTUFBakM7O0FBRUEsVUFBSWlOLE1BQU0wZixTQUFOLEtBQW9CajVCLFNBQXBCLElBQWlDLENBQUMrMEMsZ0JBQXRDLEVBQXdEO0FBQ3REOTRDLGdCQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsZ0ZBQWYsQ0FBeEMsR0FBMkksS0FBSyxDQUFoSjtBQUNBaTBDLDJCQUFtQixJQUFuQjtBQUNEO0FBQ0QsVUFBSXg3QixNQUFNeWYsV0FBTixLQUFzQmg1QixTQUF0QixJQUFtQyxDQUFDb3hFLGtCQUF4QyxFQUE0RDtBQUMxRG4xRSxnQkFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLGtGQUFmLENBQXhDLEdBQTZJLEtBQUssQ0FBbEo7QUFDQXN3RSw2QkFBcUIsSUFBckI7QUFDRDtBQUNELFVBQUk3M0QsTUFBTThmLE9BQU4sS0FBa0JyNUIsU0FBbEIsSUFBK0J1WixNQUFNcTRELGNBQU4sS0FBeUI1eEUsU0FBeEQsSUFBcUUsQ0FBQ3F4RSw0QkFBMUUsRUFBd0c7QUFDdEdwMUUsZ0JBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxpRkFBaUYsMkRBQWpGLEdBQStJLHdFQUEvSSxHQUEwTixpRUFBMU4sR0FBOFIsb0RBQTlSLEdBQXFWLDJDQUFwVyxFQUFpWnVMLFNBQVNBLE1BQU1FLE9BQU4sRUFBVCxJQUE0QixhQUE3YSxFQUE0YmdOLE1BQU03TyxJQUFsYyxDQUF4QyxHQUFrZixLQUFLLENBQXZmO0FBQ0EybUUsdUNBQStCLElBQS9CO0FBQ0Q7QUFDRCxVQUFJOTNELE1BQU1qRSxLQUFOLEtBQWdCdFYsU0FBaEIsSUFBNkJ1WixNQUFNdThCLFlBQU4sS0FBdUI5MUMsU0FBcEQsSUFBaUUsQ0FBQ2cxQyx3QkFBdEUsRUFBZ0c7QUFDOUYvNEMsZ0JBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSw2RUFBNkUsMkRBQTdFLEdBQTJJLG9FQUEzSSxHQUFrTixpRUFBbE4sR0FBc1Isb0RBQXRSLEdBQTZVLDJDQUE1VixFQUF5WXVMLFNBQVNBLE1BQU1FLE9BQU4sRUFBVCxJQUE0QixhQUFyYSxFQUFvYmdOLE1BQU03TyxJQUExYixDQUF4QyxHQUEwZSxLQUFLLENBQS9lO0FBQ0FzcUMsbUNBQTJCLElBQTNCO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJYyxlQUFldjhCLE1BQU11OEIsWUFBekI7QUFDQTF5QyxTQUFLa3BDLGFBQUwsR0FBcUI7QUFDbkJ1bEMsc0JBQWdCdDRELE1BQU04ZixPQUFOLElBQWlCLElBQWpCLEdBQXdCOWYsTUFBTThmLE9BQTlCLEdBQXdDOWYsTUFBTXE0RCxjQUQzQztBQUVuQi83QixvQkFBY3Q4QixNQUFNakUsS0FBTixJQUFlLElBQWYsR0FBc0JpRSxNQUFNakUsS0FBNUIsR0FBb0N3Z0MsWUFGL0I7QUFHbkJ4MkMsaUJBQVcsSUFIUTtBQUluQjY1QixnQkFBVTRjLGNBQWN2N0IsSUFBZCxDQUFtQnBYLElBQW5CLENBSlM7QUFLbkJxMkQsa0JBQVlnWSxhQUFhbDRELEtBQWI7QUFMTyxLQUFyQjtBQU9ELEdBM0RpQjs7QUE2RGxCdXpELGlCQUFlLHVCQUFVMXBFLElBQVYsRUFBZ0I7QUFDN0IsUUFBSW1XLFFBQVFuVyxLQUFLd08sZUFBTCxDQUFxQjJILEtBQWpDOztBQUVBLFFBQUl0ZCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJMDVELGFBQWFnWSxhQUFhbDRELEtBQWIsQ0FBakI7QUFDQSxVQUFJbE4sUUFBUWpKLEtBQUt3TyxlQUFMLENBQXFCdEYsTUFBakM7O0FBRUEsVUFBSSxDQUFDbEosS0FBS2twQyxhQUFMLENBQW1CbXRCLFVBQXBCLElBQWtDQSxVQUFsQyxJQUFnRCxDQUFDOFgsK0JBQXJELEVBQXNGO0FBQ3BGdDFFLGdCQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsdUVBQXVFLG9GQUF2RSxHQUE4SiwwREFBOUosR0FBMk4saUdBQTFPLEVBQTZVdUwsU0FBU0EsTUFBTUUsT0FBTixFQUFULElBQTRCLGFBQXpXLEVBQXdYZ04sTUFBTTdPLElBQTlYLENBQXhDLEdBQThhLEtBQUssQ0FBbmI7QUFDQTZtRSwwQ0FBa0MsSUFBbEM7QUFDRDtBQUNELFVBQUludUUsS0FBS2twQyxhQUFMLENBQW1CbXRCLFVBQW5CLElBQWlDLENBQUNBLFVBQWxDLElBQWdELENBQUM2WCwrQkFBckQsRUFBc0Y7QUFDcEZyMUUsZ0JBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxzRUFBc0Usb0ZBQXRFLEdBQTZKLDBEQUE3SixHQUEwTixpR0FBek8sRUFBNFV1TCxTQUFTQSxNQUFNRSxPQUFOLEVBQVQsSUFBNEIsYUFBeFcsRUFBdVhnTixNQUFNN08sSUFBN1gsQ0FBeEMsR0FBNmEsS0FBSyxDQUFsYjtBQUNBNG1FLDBDQUFrQyxJQUFsQztBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxRQUFJajRDLFVBQVU5ZixNQUFNOGYsT0FBcEI7QUFDQSxRQUFJQSxXQUFXLElBQWYsRUFBcUI7QUFDbkI0YSw0QkFBc0JPLG1CQUF0QixDQUEwQzN2QyxzQkFBc0JGLG1CQUF0QixDQUEwQ3ZCLElBQTFDLENBQTFDLEVBQTJGLFNBQTNGLEVBQXNHaTJCLFdBQVcsS0FBakg7QUFDRDs7QUFFRCxRQUFJNTJCLE9BQU9vQyxzQkFBc0JGLG1CQUF0QixDQUEwQ3ZCLElBQTFDLENBQVg7QUFDQSxRQUFJa1MsUUFBUXFrQixpQkFBaUJJLFFBQWpCLENBQTBCeGdCLEtBQTFCLENBQVo7QUFDQSxRQUFJakUsU0FBUyxJQUFiLEVBQW1CO0FBQ2pCLFVBQUlBLFVBQVUsQ0FBVixJQUFlN1MsS0FBSzZTLEtBQUwsS0FBZSxFQUFsQyxFQUFzQztBQUNwQzdTLGFBQUs2UyxLQUFMLEdBQWEsR0FBYjtBQUNBO0FBQ0QsT0FIRCxNQUdPLElBQUlpRSxNQUFNN08sSUFBTixLQUFlLFFBQW5CLEVBQTZCO0FBQ2xDO0FBQ0EsWUFBSW9uRSxnQkFBZ0JDLFdBQVd0dkUsS0FBSzZTLEtBQWhCLEVBQXVCLEVBQXZCLEtBQThCLENBQWxEOztBQUVBO0FBQ0E7QUFDQUEsaUJBQVN3OEQsYUFBVDtBQUNBO0FBQ0F4OEQsaUJBQVN3OEQsYUFBVCxJQUEwQnJ2RSxLQUFLNlMsS0FBTCxJQUFjQSxLQUp4QyxFQUkrQztBQUM3QztBQUNBO0FBQ0E3UyxlQUFLNlMsS0FBTCxHQUFhLEtBQUtBLEtBQWxCO0FBQ0Q7QUFDRixPQWJNLE1BYUEsSUFBSTdTLEtBQUs2UyxLQUFMLEtBQWUsS0FBS0EsS0FBeEIsRUFBK0I7QUFDcEM7QUFDQTtBQUNBN1MsYUFBSzZTLEtBQUwsR0FBYSxLQUFLQSxLQUFsQjtBQUNEO0FBQ0YsS0F0QkQsTUFzQk87QUFDTCxVQUFJaUUsTUFBTWpFLEtBQU4sSUFBZSxJQUFmLElBQXVCaUUsTUFBTXU4QixZQUFOLElBQXNCLElBQWpELEVBQXVEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJcnpDLEtBQUtxekMsWUFBTCxLQUFzQixLQUFLdjhCLE1BQU11OEIsWUFBckMsRUFBbUQ7QUFDakRyekMsZUFBS3F6QyxZQUFMLEdBQW9CLEtBQUt2OEIsTUFBTXU4QixZQUEvQjtBQUNEO0FBQ0Y7QUFDRCxVQUFJdjhCLE1BQU04ZixPQUFOLElBQWlCLElBQWpCLElBQXlCOWYsTUFBTXE0RCxjQUFOLElBQXdCLElBQXJELEVBQTJEO0FBQ3pEbnZFLGFBQUttdkUsY0FBTCxHQUFzQixDQUFDLENBQUNyNEQsTUFBTXE0RCxjQUE5QjtBQUNEO0FBQ0Y7QUFDRixHQTlIaUI7O0FBZ0lsQjdILG9CQUFrQiwwQkFBVTNtRSxJQUFWLEVBQWdCO0FBQ2hDLFFBQUltVyxRQUFRblcsS0FBS3dPLGVBQUwsQ0FBcUIySCxLQUFqQzs7QUFFQTtBQUNBO0FBQ0EsUUFBSTlXLE9BQU9vQyxzQkFBc0JGLG1CQUF0QixDQUEwQ3ZCLElBQTFDLENBQVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFRbVcsTUFBTTdPLElBQWQ7QUFDRSxXQUFLLFFBQUw7QUFDQSxXQUFLLE9BQUw7QUFDRTtBQUNGLFdBQUssT0FBTDtBQUNBLFdBQUssTUFBTDtBQUNBLFdBQUssVUFBTDtBQUNBLFdBQUssZ0JBQUw7QUFDQSxXQUFLLE9BQUw7QUFDQSxXQUFLLE1BQUw7QUFDQSxXQUFLLE1BQUw7QUFDRTtBQUNBO0FBQ0FqSSxhQUFLNlMsS0FBTCxHQUFhLEVBQWI7QUFDQTdTLGFBQUs2UyxLQUFMLEdBQWE3UyxLQUFLcXpDLFlBQWxCO0FBQ0E7QUFDRjtBQUNFcnpDLGFBQUs2UyxLQUFMLEdBQWE3UyxLQUFLNlMsS0FBbEI7QUFDQTtBQWxCSjs7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUkvVixPQUFPa0QsS0FBS2xELElBQWhCO0FBQ0EsUUFBSUEsU0FBUyxFQUFiLEVBQWlCO0FBQ2ZrRCxXQUFLbEQsSUFBTCxHQUFZLEVBQVo7QUFDRDtBQUNEa0QsU0FBS212RSxjQUFMLEdBQXNCLENBQUNudkUsS0FBS212RSxjQUE1QjtBQUNBbnZFLFNBQUttdkUsY0FBTCxHQUFzQixDQUFDbnZFLEtBQUttdkUsY0FBNUI7QUFDQSxRQUFJcnlFLFNBQVMsRUFBYixFQUFpQjtBQUNma0QsV0FBS2xELElBQUwsR0FBWUEsSUFBWjtBQUNEO0FBQ0Y7QUFoTGlCLENBQXBCOztBQW1MQSxTQUFTdzJDLGFBQVQsQ0FBdUJ0aUMsS0FBdkIsRUFBOEI7QUFDNUIsTUFBSThGLFFBQVEsS0FBSzNILGVBQUwsQ0FBcUIySCxLQUFqQzs7QUFFQSxNQUFJN0UsY0FBY2lsQixpQkFBaUJNLGVBQWpCLENBQWlDMWdCLEtBQWpDLEVBQXdDOUYsS0FBeEMsQ0FBbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0FsRSxlQUFhZ0QsSUFBYixDQUFrQmkvRCxvQkFBbEIsRUFBd0MsSUFBeEM7O0FBRUEsTUFBSWp5RSxPQUFPZ2EsTUFBTWhhLElBQWpCO0FBQ0EsTUFBSWdhLE1BQU03TyxJQUFOLEtBQWUsT0FBZixJQUEwQm5MLFFBQVEsSUFBdEMsRUFBNEM7QUFDMUMsUUFBSXl5RSxXQUFXbnRFLHNCQUFzQkYsbUJBQXRCLENBQTBDLElBQTFDLENBQWY7QUFDQSxRQUFJc3RFLFlBQVlELFFBQWhCOztBQUVBLFdBQU9DLFVBQVUxdEUsVUFBakIsRUFBNkI7QUFDM0IwdEUsa0JBQVlBLFVBQVUxdEUsVUFBdEI7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJMnRFLFFBQVFELFVBQVVFLGdCQUFWLENBQTJCLGdCQUFnQnJuQyxLQUFLQyxTQUFMLENBQWUsS0FBS3hyQyxJQUFwQixDQUFoQixHQUE0QyxpQkFBdkUsQ0FBWjs7QUFFQSxTQUFLLElBQUl2QixJQUFJLENBQWIsRUFBZ0JBLElBQUlrMEUsTUFBTTUwRSxNQUExQixFQUFrQ1UsR0FBbEMsRUFBdUM7QUFDckMsVUFBSW8wRSxZQUFZRixNQUFNbDBFLENBQU4sQ0FBaEI7QUFDQSxVQUFJbzBFLGNBQWNKLFFBQWQsSUFBMEJJLFVBQVUvb0IsSUFBVixLQUFtQjJvQixTQUFTM29CLElBQTFELEVBQWdFO0FBQzlEO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUlncEIsZ0JBQWdCeHRFLHNCQUFzQkgsbUJBQXRCLENBQTBDMHRFLFNBQTFDLENBQXBCO0FBQ0EsT0FBQ0MsYUFBRCxHQUFpQnAyRSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLCtGQUFqQixDQUF4QyxHQUE0SjRCLGVBQWUsSUFBZixDQUE3SyxHQUFvTSxLQUFLLENBQXpNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EwTixtQkFBYWdELElBQWIsQ0FBa0JpL0Qsb0JBQWxCLEVBQXdDYSxhQUF4QztBQUNEO0FBQ0Y7O0FBRUQsU0FBTzM5RCxXQUFQO0FBQ0Q7O0FBRUR4WSxPQUFPQyxPQUFQLEdBQWlCOHJFLGFBQWpCLEM7Ozs7Ozs7O0FDN1JBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSXY1RCxVQUFVLG1CQUFBN04sQ0FBUSxDQUFSLENBQWQ7O0FBRUEsSUFBSWtjLFFBQVEsbUJBQUFsYyxDQUFRLEVBQVIsQ0FBWjtBQUNBLElBQUlnRSx3QkFBd0IsbUJBQUFoRSxDQUFRLENBQVIsQ0FBNUI7QUFDQSxJQUFJNjBDLGlCQUFpQixtQkFBQTcwQyxDQUFRLEVBQVIsQ0FBckI7O0FBRUEsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7QUFDQSxJQUFJeXhFLCtCQUErQixLQUFuQzs7QUFFQSxTQUFTQyxlQUFULENBQXlCNXVFLFFBQXpCLEVBQW1DO0FBQ2pDLE1BQUlnMEIsVUFBVSxFQUFkOztBQUVBO0FBQ0E7QUFDQTVhLFFBQU1DLFFBQU4sQ0FBZS9XLE9BQWYsQ0FBdUJ0QyxRQUF2QixFQUFpQyxVQUFVNGpDLEtBQVYsRUFBaUI7QUFDaEQsUUFBSUEsU0FBUyxJQUFiLEVBQW1CO0FBQ2pCO0FBQ0Q7QUFDRCxRQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsT0FBT0EsS0FBUCxLQUFpQixRQUFsRCxFQUE0RDtBQUMxRDVQLGlCQUFXNFAsS0FBWDtBQUNELEtBRkQsTUFFTyxJQUFJLENBQUMrcUMsNEJBQUwsRUFBbUM7QUFDeENBLHFDQUErQixJQUEvQjtBQUNBcjJFLGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSw4REFBZixDQUF4QyxHQUF5SCxLQUFLLENBQTlIO0FBQ0Q7QUFDRixHQVZEOztBQVlBLFNBQU82MkIsT0FBUDtBQUNEOztBQUVEOzs7QUFHQSxJQUFJdXdDLGlCQUFpQjtBQUNuQnR5QixnQkFBYyxzQkFBVXh5QyxJQUFWLEVBQWdCbVcsS0FBaEIsRUFBdUJ5RSxVQUF2QixFQUFtQztBQUMvQztBQUNBLFFBQUkvaEIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM5RCxjQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUXlZLE1BQU1rOEIsUUFBTixJQUFrQixJQUExQixFQUFnQyxvRUFBb0UsaUNBQXBHLENBQXhDLEdBQWlMLEtBQUssQ0FBdEw7QUFDRDs7QUFFRDtBQUNBLFFBQUkrOEIsY0FBYyxJQUFsQjtBQUNBLFFBQUl4MEQsY0FBYyxJQUFsQixFQUF3QjtBQUN0QixVQUFJeTBELGVBQWV6MEQsVUFBbkI7O0FBRUEsVUFBSXkwRCxhQUFhdEosSUFBYixLQUFzQixVQUExQixFQUFzQztBQUNwQ3NKLHVCQUFlQSxhQUFhN3RFLFdBQTVCO0FBQ0Q7O0FBRUQsVUFBSTZ0RSxnQkFBZ0IsSUFBaEIsSUFBd0JBLGFBQWF0SixJQUFiLEtBQXNCLFFBQWxELEVBQTREO0FBQzFEcUosc0JBQWM5OEIsZUFBZU8scUJBQWYsQ0FBcUN3OEIsWUFBckMsQ0FBZDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBLFFBQUloOUIsV0FBVyxJQUFmO0FBQ0EsUUFBSSs4QixlQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLFVBQUlsOUQsS0FBSjtBQUNBLFVBQUlpRSxNQUFNakUsS0FBTixJQUFlLElBQW5CLEVBQXlCO0FBQ3ZCQSxnQkFBUWlFLE1BQU1qRSxLQUFOLEdBQWMsRUFBdEI7QUFDRCxPQUZELE1BRU87QUFDTEEsZ0JBQVFpOUQsZ0JBQWdCaDVELE1BQU01VixRQUF0QixDQUFSO0FBQ0Q7QUFDRDh4QyxpQkFBVyxLQUFYO0FBQ0EsVUFBSTMzQyxNQUFNdTFCLE9BQU4sQ0FBY20vQyxXQUFkLENBQUosRUFBZ0M7QUFDOUI7QUFDQSxhQUFLLElBQUl4MEUsSUFBSSxDQUFiLEVBQWdCQSxJQUFJdzBFLFlBQVlsMUUsTUFBaEMsRUFBd0NVLEdBQXhDLEVBQTZDO0FBQzNDLGNBQUksS0FBS3cwRSxZQUFZeDBFLENBQVosQ0FBTCxLQUF3QnNYLEtBQTVCLEVBQW1DO0FBQ2pDbWdDLHVCQUFXLElBQVg7QUFDQTtBQUNEO0FBQ0Y7QUFDRixPQVJELE1BUU87QUFDTEEsbUJBQVcsS0FBSys4QixXQUFMLEtBQXFCbDlELEtBQWhDO0FBQ0Q7QUFDRjs7QUFFRGxTLFNBQUtrcEMsYUFBTCxHQUFxQixFQUFFbUosVUFBVUEsUUFBWixFQUFyQjtBQUNELEdBOUNrQjs7QUFnRG5CczBCLG9CQUFrQiwwQkFBVTNtRSxJQUFWLEVBQWdCO0FBQ2hDO0FBQ0EsUUFBSW1XLFFBQVFuVyxLQUFLd08sZUFBTCxDQUFxQjJILEtBQWpDO0FBQ0EsUUFBSUEsTUFBTWpFLEtBQU4sSUFBZSxJQUFuQixFQUF5QjtBQUN2QixVQUFJN1MsT0FBT29DLHNCQUFzQkYsbUJBQXRCLENBQTBDdkIsSUFBMUMsQ0FBWDtBQUNBWCxXQUFLNHlCLFlBQUwsQ0FBa0IsT0FBbEIsRUFBMkI5YixNQUFNakUsS0FBakM7QUFDRDtBQUNGLEdBdkRrQjs7QUF5RG5CcWdDLGdCQUFjLHNCQUFVdnlDLElBQVYsRUFBZ0JtVyxLQUFoQixFQUF1QjtBQUNuQyxRQUFJbzRELFlBQVlqakUsUUFBUSxFQUFFK21DLFVBQVV6MUMsU0FBWixFQUF1QjJELFVBQVUzRCxTQUFqQyxFQUFSLEVBQXNEdVosS0FBdEQsQ0FBaEI7O0FBRUE7QUFDQTtBQUNBLFFBQUluVyxLQUFLa3BDLGFBQUwsQ0FBbUJtSixRQUFuQixJQUErQixJQUFuQyxFQUF5QztBQUN2Q2s4QixnQkFBVWw4QixRQUFWLEdBQXFCcnlDLEtBQUtrcEMsYUFBTCxDQUFtQm1KLFFBQXhDO0FBQ0Q7O0FBRUQsUUFBSTlkLFVBQVU0NkMsZ0JBQWdCaDVELE1BQU01VixRQUF0QixDQUFkOztBQUVBLFFBQUlnMEIsT0FBSixFQUFhO0FBQ1hnNkMsZ0JBQVVodUUsUUFBVixHQUFxQmcwQixPQUFyQjtBQUNEOztBQUVELFdBQU9nNkMsU0FBUDtBQUNEO0FBekVrQixDQUFyQjs7QUE0RUF6MUUsT0FBT0MsT0FBUCxHQUFpQityRSxjQUFqQixDOzs7Ozs7OztBQ3hIQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlybUUsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCO0FBQUEsSUFDSTZOLFVBQVUsbUJBQUE3TixDQUFRLENBQVIsQ0FEZDs7QUFHQSxJQUFJODRCLG1CQUFtQixtQkFBQTk0QixDQUFRLEVBQVIsQ0FBdkI7QUFDQSxJQUFJZ0Usd0JBQXdCLG1CQUFBaEUsQ0FBUSxDQUFSLENBQTVCO0FBQ0EsSUFBSTBPLGVBQWUsbUJBQUExTyxDQUFRLEVBQVIsQ0FBbkI7O0FBRUEsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCO0FBQ0EsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUEsSUFBSWswQyxtQkFBbUIsS0FBdkI7QUFDQSxJQUFJMjlCLHVCQUF1QixLQUEzQjs7QUFFQSxTQUFTbEIsb0JBQVQsR0FBZ0M7QUFDOUIsTUFBSSxLQUFLbHVELFdBQVQsRUFBc0I7QUFDcEI7QUFDQTZrRCxxQkFBaUIyRSxhQUFqQixDQUErQixJQUEvQjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztBQWVBLElBQUkzRSxtQkFBbUI7QUFDckJ4eUIsZ0JBQWMsc0JBQVV2eUMsSUFBVixFQUFnQm1XLEtBQWhCLEVBQXVCO0FBQ25DLE1BQUVBLE1BQU1tdkQsdUJBQU4sSUFBaUMsSUFBbkMsSUFBMkN6c0UsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiw4REFBakIsQ0FBeEMsR0FBMkg0QixlQUFlLElBQWYsQ0FBdEssR0FBNkwsS0FBSyxDQUFsTTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSTh2RSxZQUFZampFLFFBQVEsRUFBUixFQUFZNkssS0FBWixFQUFtQjtBQUNqQ2pFLGFBQU90VixTQUQwQjtBQUVqQzgxQyxvQkFBYzkxQyxTQUZtQjtBQUdqQzJELGdCQUFVLEtBQUtQLEtBQUtrcEMsYUFBTCxDQUFtQnVKLFlBSEQ7QUFJakMxYyxnQkFBVS8xQixLQUFLa3BDLGFBQUwsQ0FBbUJuVDtBQUpJLEtBQW5CLENBQWhCOztBQU9BLFdBQU93NEMsU0FBUDtBQUNELEdBakJvQjs7QUFtQnJCLzdCLGdCQUFjLHNCQUFVeHlDLElBQVYsRUFBZ0JtVyxLQUFoQixFQUF1QjtBQUNuQyxRQUFJdGQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekM0NUIsdUJBQWlCQyxjQUFqQixDQUFnQyxVQUFoQyxFQUE0Q3JnQixLQUE1QyxFQUFtRG5XLEtBQUt3TyxlQUFMLENBQXFCdEYsTUFBeEU7QUFDQSxVQUFJaU4sTUFBTTBmLFNBQU4sS0FBb0JqNUIsU0FBcEIsSUFBaUMsQ0FBQyswQyxnQkFBdEMsRUFBd0Q7QUFDdEQ5NEMsZ0JBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxtRkFBZixDQUF4QyxHQUE4SSxLQUFLLENBQW5KO0FBQ0FpMEMsMkJBQW1CLElBQW5CO0FBQ0Q7QUFDRCxVQUFJeDdCLE1BQU1qRSxLQUFOLEtBQWdCdFYsU0FBaEIsSUFBNkJ1WixNQUFNdThCLFlBQU4sS0FBdUI5MUMsU0FBcEQsSUFBaUUsQ0FBQzB5RSxvQkFBdEUsRUFBNEY7QUFDMUZ6MkUsZ0JBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxpRUFBaUUsb0VBQWpFLEdBQXdJLG9FQUF4SSxHQUErTSw0Q0FBL00sR0FBOFAsMkNBQTdRLENBQXhDLEdBQW9XLEtBQUssQ0FBelc7QUFDQTR4RSwrQkFBdUIsSUFBdkI7QUFDRDtBQUNGOztBQUVELFFBQUlwOUQsUUFBUXFrQixpQkFBaUJJLFFBQWpCLENBQTBCeGdCLEtBQTFCLENBQVo7QUFDQSxRQUFJczhCLGVBQWV2Z0MsS0FBbkI7O0FBRUE7QUFDQSxRQUFJQSxTQUFTLElBQWIsRUFBbUI7QUFDakIsVUFBSXdnQyxlQUFldjhCLE1BQU11OEIsWUFBekI7QUFDQTtBQUNBLFVBQUlueUMsV0FBVzRWLE1BQU01VixRQUFyQjtBQUNBLFVBQUlBLFlBQVksSUFBaEIsRUFBc0I7QUFDcEIsWUFBSTFILFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDOUQsa0JBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxnRUFBZ0UseUJBQS9FLENBQXhDLEdBQW9KLEtBQUssQ0FBeko7QUFDRDtBQUNELFVBQUVnMUMsZ0JBQWdCLElBQWxCLElBQTBCNzVDLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIscUVBQWpCLENBQXhDLEdBQWtJNEIsZUFBZSxJQUFmLENBQTVKLEdBQW1MLEtBQUssQ0FBeEw7QUFDQSxZQUFJL0QsTUFBTXUxQixPQUFOLENBQWMxdkIsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLFlBQUVBLFNBQVNyRyxNQUFULElBQW1CLENBQXJCLElBQTBCckIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiw2Q0FBakIsQ0FBeEMsR0FBMEc0QixlQUFlLElBQWYsQ0FBcEksR0FBMkosS0FBSyxDQUFoSztBQUNBOEIscUJBQVdBLFNBQVMsQ0FBVCxDQUFYO0FBQ0Q7O0FBRURteUMsdUJBQWUsS0FBS255QyxRQUFwQjtBQUNEO0FBQ0QsVUFBSW15QyxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEJBLHVCQUFlLEVBQWY7QUFDRDtBQUNERCxxQkFBZUMsWUFBZjtBQUNEOztBQUVEMXlDLFNBQUtrcEMsYUFBTCxHQUFxQjtBQUNuQnVKLG9CQUFjLEtBQUtBLFlBREE7QUFFbkJ2MkMsaUJBQVcsSUFGUTtBQUduQjY1QixnQkFBVTRjLGNBQWN2N0IsSUFBZCxDQUFtQnBYLElBQW5CO0FBSFMsS0FBckI7QUFLRCxHQS9Eb0I7O0FBaUVyQjBwRSxpQkFBZSx1QkFBVTFwRSxJQUFWLEVBQWdCO0FBQzdCLFFBQUltVyxRQUFRblcsS0FBS3dPLGVBQUwsQ0FBcUIySCxLQUFqQzs7QUFFQSxRQUFJOVcsT0FBT29DLHNCQUFzQkYsbUJBQXRCLENBQTBDdkIsSUFBMUMsQ0FBWDtBQUNBLFFBQUlrUyxRQUFRcWtCLGlCQUFpQkksUUFBakIsQ0FBMEJ4Z0IsS0FBMUIsQ0FBWjtBQUNBLFFBQUlqRSxTQUFTLElBQWIsRUFBbUI7QUFDakI7QUFDQTtBQUNBLFVBQUlxOUQsV0FBVyxLQUFLcjlELEtBQXBCOztBQUVBO0FBQ0EsVUFBSXE5RCxhQUFhbHdFLEtBQUs2UyxLQUF0QixFQUE2QjtBQUMzQjdTLGFBQUs2UyxLQUFMLEdBQWFxOUQsUUFBYjtBQUNEO0FBQ0QsVUFBSXA1RCxNQUFNdThCLFlBQU4sSUFBc0IsSUFBMUIsRUFBZ0M7QUFDOUJyekMsYUFBS3F6QyxZQUFMLEdBQW9CNjhCLFFBQXBCO0FBQ0Q7QUFDRjtBQUNELFFBQUlwNUQsTUFBTXU4QixZQUFOLElBQXNCLElBQTFCLEVBQWdDO0FBQzlCcnpDLFdBQUtxekMsWUFBTCxHQUFvQnY4QixNQUFNdThCLFlBQTFCO0FBQ0Q7QUFDRixHQXRGb0I7O0FBd0ZyQmkwQixvQkFBa0IsMEJBQVUzbUUsSUFBVixFQUFnQjtBQUNoQztBQUNBO0FBQ0EsUUFBSVgsT0FBT29DLHNCQUFzQkYsbUJBQXRCLENBQTBDdkIsSUFBMUMsQ0FBWDtBQUNBLFFBQUlnckMsY0FBYzNyQyxLQUFLMnJDLFdBQXZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSUEsZ0JBQWdCaHJDLEtBQUtrcEMsYUFBTCxDQUFtQnVKLFlBQXZDLEVBQXFEO0FBQ25EcHpDLFdBQUs2UyxLQUFMLEdBQWE4NEIsV0FBYjtBQUNEO0FBQ0Y7QUFyR29CLENBQXZCOztBQXdHQSxTQUFTMkgsYUFBVCxDQUF1QnRpQyxLQUF2QixFQUE4QjtBQUM1QixNQUFJOEYsUUFBUSxLQUFLM0gsZUFBTCxDQUFxQjJILEtBQWpDO0FBQ0EsTUFBSTdFLGNBQWNpbEIsaUJBQWlCTSxlQUFqQixDQUFpQzFnQixLQUFqQyxFQUF3QzlGLEtBQXhDLENBQWxCO0FBQ0FsRSxlQUFhZ0QsSUFBYixDQUFrQmkvRCxvQkFBbEIsRUFBd0MsSUFBeEM7QUFDQSxTQUFPOThELFdBQVA7QUFDRDs7QUFFRHhZLE9BQU9DLE9BQVAsR0FBaUJnc0UsZ0JBQWpCLEM7Ozs7Ozs7O0FDOUpBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSXRtRSxpQkFBaUIsbUJBQUFoQixDQUFRLENBQVIsQ0FBckI7O0FBRUEsSUFBSXU1Qiw0QkFBNEIsbUJBQUF2NUIsQ0FBUSxFQUFSLENBQWhDO0FBQ0EsSUFBSTZrQixtQkFBbUIsbUJBQUE3a0IsQ0FBUSxFQUFSLENBQXZCO0FBQ0EsSUFBSStjLHVCQUF1QixtQkFBQS9jLENBQVEsRUFBUixDQUEzQjs7QUFFQSxJQUFJcUgsb0JBQW9CLG1CQUFBckgsQ0FBUSxFQUFSLENBQXhCO0FBQ0EsSUFBSWlPLGtCQUFrQixtQkFBQWpPLENBQVEsRUFBUixDQUF0QjtBQUNBLElBQUkreEUsdUJBQXVCLG1CQUFBL3hFLENBQVEsR0FBUixDQUEzQjs7QUFFQSxJQUFJRCxnQkFBZ0IsbUJBQUFDLENBQVEsRUFBUixDQUFwQjtBQUNBLElBQUkweEUsa0JBQWtCLG1CQUFBMXhFLENBQVEsR0FBUixDQUF0QjtBQUNBLElBQUlaLFlBQVksbUJBQUFZLENBQVEsQ0FBUixDQUFoQjs7QUFFQTs7Ozs7OztBQU9BLFNBQVNneUUsZ0JBQVQsQ0FBMEIxMEQsTUFBMUIsRUFBa0N5WixTQUFsQyxFQUE2Q0MsT0FBN0MsRUFBc0Q7QUFDcEQ7QUFDQSxTQUFPO0FBQ0xudEIsVUFBTSxlQUREO0FBRUxpdEIsYUFBU3haLE1BRko7QUFHTDRaLGVBQVcsSUFITjtBQUlMRCxjQUFVLElBSkw7QUFLTEQsYUFBU0EsT0FMSjtBQU1MRCxlQUFXQTtBQU5OLEdBQVA7QUFRRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVNrN0MsUUFBVCxDQUFrQnZyQyxLQUFsQixFQUF5QjNQLFNBQXpCLEVBQW9DQyxPQUFwQyxFQUE2QztBQUMzQztBQUNBLFNBQU87QUFDTG50QixVQUFNLGVBREQ7QUFFTGl0QixhQUFTLElBRko7QUFHTEksZUFBV3dQLE1BQU11UCxXQUhaO0FBSUxoZixjQUFVaHBCLGdCQUFnQnVQLFdBQWhCLENBQTRCa3BCLEtBQTVCLENBSkw7QUFLTDFQLGFBQVNBLE9BTEo7QUFNTEQsZUFBV0E7QUFOTixHQUFQO0FBUUQ7O0FBRUQ7Ozs7OztBQU1BLFNBQVNtN0MsVUFBVCxDQUFvQnhyQyxLQUFwQixFQUEyQjlrQyxJQUEzQixFQUFpQztBQUMvQjtBQUNBLFNBQU87QUFDTGlJLFVBQU0sYUFERDtBQUVMaXRCLGFBQVMsSUFGSjtBQUdMSSxlQUFXd1AsTUFBTXVQLFdBSFo7QUFJTGhmLGNBQVVyMUIsSUFKTDtBQUtMbzFCLGFBQVMsSUFMSjtBQU1MRCxlQUFXO0FBTk4sR0FBUDtBQVFEOztBQUVEOzs7Ozs7QUFNQSxTQUFTbzdDLGFBQVQsQ0FBdUI3MEQsTUFBdkIsRUFBK0I7QUFDN0I7QUFDQSxTQUFPO0FBQ0x6VCxVQUFNLFlBREQ7QUFFTGl0QixhQUFTeFosTUFGSjtBQUdMNFosZUFBVyxJQUhOO0FBSUxELGNBQVUsSUFKTDtBQUtMRCxhQUFTLElBTEo7QUFNTEQsZUFBVztBQU5OLEdBQVA7QUFRRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU3E3QyxlQUFULENBQXlCN2tDLFdBQXpCLEVBQXNDO0FBQ3BDO0FBQ0EsU0FBTztBQUNMMWpDLFVBQU0sY0FERDtBQUVMaXRCLGFBQVN5VyxXQUZKO0FBR0xyVyxlQUFXLElBSE47QUFJTEQsY0FBVSxJQUpMO0FBS0xELGFBQVMsSUFMSjtBQU1MRCxlQUFXO0FBTk4sR0FBUDtBQVFEOztBQUVEOzs7O0FBSUEsU0FBUzFsQixPQUFULENBQWlCalYsS0FBakIsRUFBd0J5NkIsTUFBeEIsRUFBZ0M7QUFDOUIsTUFBSUEsTUFBSixFQUFZO0FBQ1Z6NkIsWUFBUUEsU0FBUyxFQUFqQjtBQUNBQSxVQUFNZ0IsSUFBTixDQUFXeTVCLE1BQVg7QUFDRDtBQUNELFNBQU96NkIsS0FBUDtBQUNEOztBQUVEOzs7OztBQUtBLFNBQVNpMkUsWUFBVCxDQUFzQjl2RSxJQUF0QixFQUE0Qit2RSxXQUE1QixFQUF5QztBQUN2Qy80Qyw0QkFBMEJFLHNCQUExQixDQUFpRGwzQixJQUFqRCxFQUF1RCt2RSxXQUF2RDtBQUNEOztBQUVELElBQUlDLGdDQUFnQ3h5RSxhQUFwQztBQUNBLElBQUkzRSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxNQUFJc3pFLGFBQWEsU0FBYkEsVUFBYSxDQUFVandFLElBQVYsRUFBZ0I7QUFDL0IsUUFBSSxDQUFDQSxLQUFLc0osUUFBVixFQUFvQjtBQUNsQjtBQUNBLFVBQUk0bUUsUUFBSjtBQUNBLFVBQUlBLFdBQVc1dEQsaUJBQWlCamMsR0FBakIsQ0FBcUJyRyxJQUFyQixDQUFmLEVBQTJDO0FBQ3pDQSxlQUFPa3dFLFFBQVA7QUFDRDtBQUNGO0FBQ0QsV0FBT2x3RSxLQUFLc0osUUFBWjtBQUNELEdBVEQ7QUFVQTBtRSxrQ0FBZ0MsdUNBQVV6dkUsUUFBVixFQUFvQjtBQUNsRCxRQUFJeXFELFVBQVVpbEIsV0FBVyxJQUFYLENBQWQ7QUFDQTtBQUNBO0FBQ0EsUUFBSWpsQixZQUFZLENBQWhCLEVBQW1CO0FBQ2pCeHdDLDJCQUFxQjNQLFNBQXJCLENBQStCL0MsYUFBL0IsQ0FBNkNrakQsT0FBN0MsRUFBc0R6cUQsV0FBV29CLE9BQU9vQixJQUFQLENBQVl4QyxRQUFaLEVBQXNCaUMsR0FBdEIsQ0FBMEIsVUFBVWUsR0FBVixFQUFlO0FBQ3hHLGVBQU9oRCxTQUFTZ0QsR0FBVCxFQUFjK0YsUUFBckI7QUFDRCxPQUZnRSxDQUFYLEdBRWpELEVBRkw7QUFHRDtBQUNGLEdBVEQ7QUFVRDs7QUFFRDs7Ozs7O0FBTUEsSUFBSTA3RCxrQkFBa0I7QUFDcEI7Ozs7Ozs7QUFPQWtELFNBQU87QUFDTGlJLG9DQUFnQyx3Q0FBVUMsY0FBVixFQUEwQm5pRSxXQUExQixFQUF1Q21CLE9BQXZDLEVBQWdEO0FBQzlFLFVBQUl2VyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxZQUFJMHpFLGNBQWNKLFdBQVcsSUFBWCxDQUFsQjtBQUNBLFlBQUksS0FBS3poRSxlQUFULEVBQTBCO0FBQ3hCLGNBQUk7QUFDRjFKLDhCQUFrQnVFLE9BQWxCLEdBQTRCLEtBQUttRixlQUFMLENBQXFCdEYsTUFBakQ7QUFDQSxtQkFBT3NtRSxxQkFBcUJjLG1CQUFyQixDQUF5Q0YsY0FBekMsRUFBeURuaUUsV0FBekQsRUFBc0VtQixPQUF0RSxFQUErRWloRSxXQUEvRSxDQUFQO0FBQ0QsV0FIRCxTQUdVO0FBQ1J2ckUsOEJBQWtCdUUsT0FBbEIsR0FBNEIsSUFBNUI7QUFDRDtBQUNGO0FBQ0Y7QUFDRCxhQUFPbW1FLHFCQUFxQmMsbUJBQXJCLENBQXlDRixjQUF6QyxFQUF5RG5pRSxXQUF6RCxFQUFzRW1CLE9BQXRFLENBQVA7QUFDRCxLQWRJOztBQWdCTG1oRSwrQkFBMkIsbUNBQVVDLFlBQVYsRUFBd0JDLDBCQUF4QixFQUFvRG5ILFdBQXBELEVBQWlFb0gsWUFBakUsRUFBK0V6aUUsV0FBL0UsRUFBNEZtQixPQUE1RixFQUFxRztBQUM5SCxVQUFJazdELFlBQUo7QUFDQSxVQUFJK0YsY0FBYyxDQUFsQjtBQUNBLFVBQUl4M0UsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMwekUsc0JBQWNKLFdBQVcsSUFBWCxDQUFkO0FBQ0EsWUFBSSxLQUFLemhFLGVBQVQsRUFBMEI7QUFDeEIsY0FBSTtBQUNGMUosOEJBQWtCdUUsT0FBbEIsR0FBNEIsS0FBS21GLGVBQUwsQ0FBcUJ0RixNQUFqRDtBQUNBb2hFLDJCQUFlNkUsZ0JBQWdCc0IsMEJBQWhCLEVBQTRDSixXQUE1QyxDQUFmO0FBQ0QsV0FIRCxTQUdVO0FBQ1J2ckUsOEJBQWtCdUUsT0FBbEIsR0FBNEIsSUFBNUI7QUFDRDtBQUNEbW1FLCtCQUFxQi9FLGNBQXJCLENBQW9DK0YsWUFBcEMsRUFBa0RsRyxZQUFsRCxFQUFnRWhCLFdBQWhFLEVBQTZFb0gsWUFBN0UsRUFBMkZ6aUUsV0FBM0YsRUFBd0csSUFBeEcsRUFBOEcsS0FBS3NzQyxrQkFBbkgsRUFBdUluckMsT0FBdkksRUFBZ0ppaEUsV0FBaEo7QUFDQSxpQkFBTy9GLFlBQVA7QUFDRDtBQUNGO0FBQ0RBLHFCQUFlNkUsZ0JBQWdCc0IsMEJBQWhCLEVBQTRDSixXQUE1QyxDQUFmO0FBQ0FiLDJCQUFxQi9FLGNBQXJCLENBQW9DK0YsWUFBcEMsRUFBa0RsRyxZQUFsRCxFQUFnRWhCLFdBQWhFLEVBQTZFb0gsWUFBN0UsRUFBMkZ6aUUsV0FBM0YsRUFBd0csSUFBeEcsRUFBOEcsS0FBS3NzQyxrQkFBbkgsRUFBdUluckMsT0FBdkksRUFBZ0ppaEUsV0FBaEo7QUFDQSxhQUFPL0YsWUFBUDtBQUNELEtBbkNJOztBQXFDTDs7Ozs7Ozs7QUFRQWYsbUJBQWUsdUJBQVU2RyxjQUFWLEVBQTBCbmlFLFdBQTFCLEVBQXVDbUIsT0FBdkMsRUFBZ0Q7QUFDN0QsVUFBSTdPLFdBQVcsS0FBSzR2RSw4QkFBTCxDQUFvQ0MsY0FBcEMsRUFBb0RuaUUsV0FBcEQsRUFBaUVtQixPQUFqRSxDQUFmO0FBQ0EsV0FBSzVPLGlCQUFMLEdBQXlCRCxRQUF6Qjs7QUFFQSxVQUFJK29FLGNBQWMsRUFBbEI7QUFDQSxVQUFJNWdELFFBQVEsQ0FBWjtBQUNBLFdBQUssSUFBSXZzQixJQUFULElBQWlCb0UsUUFBakIsRUFBMkI7QUFDekIsWUFBSUEsU0FBU0ssY0FBVCxDQUF3QnpFLElBQXhCLENBQUosRUFBbUM7QUFDakMsY0FBSWdvQyxRQUFRNWpDLFNBQVNwRSxJQUFULENBQVo7QUFDQSxjQUFJazBFLGNBQWMsQ0FBbEI7QUFDQSxjQUFJeDNFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDMHpFLDBCQUFjSixXQUFXLElBQVgsQ0FBZDtBQUNEO0FBQ0QsY0FBSTdILGFBQWExOEQsZ0JBQWdCZ1AsY0FBaEIsQ0FBK0J5cEIsS0FBL0IsRUFBc0NsMkIsV0FBdEMsRUFBbUQsSUFBbkQsRUFBeUQsS0FBS3NzQyxrQkFBOUQsRUFBa0ZuckMsT0FBbEYsRUFBMkZpaEUsV0FBM0YsQ0FBakI7QUFDQWxzQyxnQkFBTXVQLFdBQU4sR0FBb0JockIsT0FBcEI7QUFDQTRnRCxzQkFBWXp1RSxJQUFaLENBQWlCdXRFLFVBQWpCO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJdnZFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDcXpFLHNDQUE4QnQyRSxJQUE5QixDQUFtQyxJQUFuQyxFQUF5QzZHLFFBQXpDO0FBQ0Q7O0FBRUQsYUFBTytvRSxXQUFQO0FBQ0QsS0FyRUk7O0FBdUVMOzs7Ozs7QUFNQW9CLHVCQUFtQiwyQkFBVVIsV0FBVixFQUF1QjtBQUN4QyxVQUFJc0csZUFBZSxLQUFLaHdFLGlCQUF4QjtBQUNBO0FBQ0FndkUsMkJBQXFCNUUsZUFBckIsQ0FBcUM0RixZQUFyQyxFQUFtRCxLQUFuRDtBQUNBLFdBQUssSUFBSXIwRSxJQUFULElBQWlCcTBFLFlBQWpCLEVBQStCO0FBQzdCLFlBQUlBLGFBQWE1dkUsY0FBYixDQUE0QnpFLElBQTVCLENBQUosRUFBdUM7QUFDckMsa0JBQVN0RCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLGtEQUFqQixDQUF4QyxHQUErRzRCLGVBQWUsS0FBZixDQUF4SCxHQUFnSixLQUFLLENBQXJKO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsVUFBSTAxQixVQUFVLENBQUMwN0MsZ0JBQWdCM0YsV0FBaEIsQ0FBRCxDQUFkO0FBQ0E0RixtQkFBYSxJQUFiLEVBQW1CMzdDLE9BQW5CO0FBQ0QsS0F6Rkk7O0FBMkZMOzs7Ozs7QUFNQXcyQyxrQkFBYyxzQkFBVWdHLFVBQVYsRUFBc0I7QUFDbEMsVUFBSUgsZUFBZSxLQUFLaHdFLGlCQUF4QjtBQUNBO0FBQ0FndkUsMkJBQXFCNUUsZUFBckIsQ0FBcUM0RixZQUFyQyxFQUFtRCxLQUFuRDtBQUNBLFdBQUssSUFBSXIwRSxJQUFULElBQWlCcTBFLFlBQWpCLEVBQStCO0FBQzdCLFlBQUlBLGFBQWE1dkUsY0FBYixDQUE0QnpFLElBQTVCLENBQUosRUFBdUM7QUFDckMsa0JBQVN0RCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLGtEQUFqQixDQUF4QyxHQUErRzRCLGVBQWUsS0FBZixDQUF4SCxHQUFnSixLQUFLLENBQXJKO0FBQ0Q7QUFDRjtBQUNELFVBQUkwMUIsVUFBVSxDQUFDeTdDLGNBQWNlLFVBQWQsQ0FBRCxDQUFkO0FBQ0FiLG1CQUFhLElBQWIsRUFBbUIzN0MsT0FBbkI7QUFDRCxLQTVHSTs7QUE4R0w7Ozs7Ozs7QUFPQXMyQyxvQkFBZ0Isd0JBQVVnRywwQkFBVixFQUFzQ3hpRSxXQUF0QyxFQUFtRG1CLE9BQW5ELEVBQTREO0FBQzFFO0FBQ0EsV0FBS3doRSxlQUFMLENBQXFCSCwwQkFBckIsRUFBaUR4aUUsV0FBakQsRUFBOERtQixPQUE5RDtBQUNELEtBeEhJOztBQTBITDs7Ozs7O0FBTUF3aEUscUJBQWlCLHlCQUFVSCwwQkFBVixFQUFzQ3hpRSxXQUF0QyxFQUFtRG1CLE9BQW5ELEVBQTREO0FBQzNFLFVBQUlvaEUsZUFBZSxLQUFLaHdFLGlCQUF4QjtBQUNBLFVBQUlrd0UsZUFBZSxFQUFuQjtBQUNBLFVBQUlwSCxjQUFjLEVBQWxCO0FBQ0EsVUFBSWdCLGVBQWUsS0FBS2lHLHlCQUFMLENBQStCQyxZQUEvQixFQUE2Q0MsMEJBQTdDLEVBQXlFbkgsV0FBekUsRUFBc0ZvSCxZQUF0RixFQUFvR3ppRSxXQUFwRyxFQUFpSG1CLE9BQWpILENBQW5CO0FBQ0EsVUFBSSxDQUFDazdELFlBQUQsSUFBaUIsQ0FBQ2tHLFlBQXRCLEVBQW9DO0FBQ2xDO0FBQ0Q7QUFDRCxVQUFJcjhDLFVBQVUsSUFBZDtBQUNBLFVBQUloNEIsSUFBSjtBQUNBO0FBQ0E7QUFDQSxVQUFJMDBFLFlBQVksQ0FBaEI7QUFDQSxVQUFJbG9ELFlBQVksQ0FBaEI7QUFDQTtBQUNBLFVBQUltb0QsaUJBQWlCLENBQXJCO0FBQ0EsVUFBSUMsaUJBQWlCLElBQXJCO0FBQ0EsV0FBSzUwRSxJQUFMLElBQWFtdUUsWUFBYixFQUEyQjtBQUN6QixZQUFJLENBQUNBLGFBQWExcEUsY0FBYixDQUE0QnpFLElBQTVCLENBQUwsRUFBd0M7QUFDdEM7QUFDRDtBQUNELFlBQUk2MEUsWUFBWVIsZ0JBQWdCQSxhQUFhcjBFLElBQWIsQ0FBaEM7QUFDQSxZQUFJOEwsWUFBWXFpRSxhQUFhbnVFLElBQWIsQ0FBaEI7QUFDQSxZQUFJNjBFLGNBQWMvb0UsU0FBbEIsRUFBNkI7QUFDM0Jrc0Isb0JBQVVybEIsUUFBUXFsQixPQUFSLEVBQWlCLEtBQUtwQixTQUFMLENBQWVpK0MsU0FBZixFQUEwQkQsY0FBMUIsRUFBMENGLFNBQTFDLEVBQXFEbG9ELFNBQXJELENBQWpCLENBQVY7QUFDQUEsc0JBQVkzcEIsS0FBS3lnRSxHQUFMLENBQVN1UixVQUFVdDlCLFdBQW5CLEVBQWdDL3FCLFNBQWhDLENBQVo7QUFDQXFvRCxvQkFBVXQ5QixXQUFWLEdBQXdCbTlCLFNBQXhCO0FBQ0QsU0FKRCxNQUlPO0FBQ0wsY0FBSUcsU0FBSixFQUFlO0FBQ2I7QUFDQXJvRCx3QkFBWTNwQixLQUFLeWdFLEdBQUwsQ0FBU3VSLFVBQVV0OUIsV0FBbkIsRUFBZ0MvcUIsU0FBaEMsQ0FBWjtBQUNBO0FBQ0Q7QUFDRDtBQUNBd0wsb0JBQVVybEIsUUFBUXFsQixPQUFSLEVBQWlCLEtBQUs4OEMsa0JBQUwsQ0FBd0JocEUsU0FBeEIsRUFBbUNxaEUsWUFBWXdILGNBQVosQ0FBbkMsRUFBZ0VDLGNBQWhFLEVBQWdGRixTQUFoRixFQUEyRjVpRSxXQUEzRixFQUF3R21CLE9BQXhHLENBQWpCLENBQVY7QUFDQTBoRTtBQUNEO0FBQ0REO0FBQ0FFLHlCQUFpQnJsRSxnQkFBZ0J1UCxXQUFoQixDQUE0QmhULFNBQTVCLENBQWpCO0FBQ0Q7QUFDRDtBQUNBLFdBQUs5TCxJQUFMLElBQWF1MEUsWUFBYixFQUEyQjtBQUN6QixZQUFJQSxhQUFhOXZFLGNBQWIsQ0FBNEJ6RSxJQUE1QixDQUFKLEVBQXVDO0FBQ3JDZzRCLG9CQUFVcmxCLFFBQVFxbEIsT0FBUixFQUFpQixLQUFLKzhDLGFBQUwsQ0FBbUJWLGFBQWFyMEUsSUFBYixDQUFuQixFQUF1Q3UwRSxhQUFhdjBFLElBQWIsQ0FBdkMsQ0FBakIsQ0FBVjtBQUNEO0FBQ0Y7QUFDRCxVQUFJZzRCLE9BQUosRUFBYTtBQUNYMjdDLHFCQUFhLElBQWIsRUFBbUIzN0MsT0FBbkI7QUFDRDtBQUNELFdBQUszekIsaUJBQUwsR0FBeUI4cEUsWUFBekI7O0FBRUEsVUFBSXp4RSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3F6RSxzQ0FBOEJ0MkUsSUFBOUIsQ0FBbUMsSUFBbkMsRUFBeUM0d0UsWUFBekM7QUFDRDtBQUNGLEtBdExJOztBQXdMTDs7Ozs7OztBQU9BTSxxQkFBaUIseUJBQVV6dkQsTUFBVixFQUFrQjtBQUNqQyxVQUFJZzJELG1CQUFtQixLQUFLM3dFLGlCQUE1QjtBQUNBZ3ZFLDJCQUFxQjVFLGVBQXJCLENBQXFDdUcsZ0JBQXJDLEVBQXVEaDJELE1BQXZEO0FBQ0EsV0FBSzNhLGlCQUFMLEdBQXlCLElBQXpCO0FBQ0QsS0FuTUk7O0FBcU1MOzs7Ozs7OztBQVFBdXlCLGVBQVcsbUJBQVVvUixLQUFWLEVBQWlCM1AsU0FBakIsRUFBNEJDLE9BQTVCLEVBQXFDOUwsU0FBckMsRUFBZ0Q7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsVUFBSXdiLE1BQU11UCxXQUFOLEdBQW9CL3FCLFNBQXhCLEVBQW1DO0FBQ2pDLGVBQU8rbUQsU0FBU3ZyQyxLQUFULEVBQWdCM1AsU0FBaEIsRUFBMkJDLE9BQTNCLENBQVA7QUFDRDtBQUNGLEtBcE5JOztBQXNOTDs7Ozs7OztBQU9BMjhDLGlCQUFhLHFCQUFVanRDLEtBQVYsRUFBaUIzUCxTQUFqQixFQUE0QjR6QyxVQUE1QixFQUF3QztBQUNuRCxhQUFPcUgsaUJBQWlCckgsVUFBakIsRUFBNkI1ekMsU0FBN0IsRUFBd0MyUCxNQUFNdVAsV0FBOUMsQ0FBUDtBQUNELEtBL05JOztBQWlPTDs7Ozs7O0FBTUF6ckIsaUJBQWEscUJBQVVrYyxLQUFWLEVBQWlCOWtDLElBQWpCLEVBQXVCO0FBQ2xDLGFBQU9zd0UsV0FBV3hyQyxLQUFYLEVBQWtCOWtDLElBQWxCLENBQVA7QUFDRCxLQXpPSTs7QUEyT0w7Ozs7Ozs7Ozs7O0FBV0E0eEUsd0JBQW9CLDRCQUFVOXNDLEtBQVYsRUFBaUJpa0MsVUFBakIsRUFBNkI1ekMsU0FBN0IsRUFBd0M5TCxLQUF4QyxFQUErQ3phLFdBQS9DLEVBQTREbUIsT0FBNUQsRUFBcUU7QUFDdkYrMEIsWUFBTXVQLFdBQU4sR0FBb0JockIsS0FBcEI7QUFDQSxhQUFPLEtBQUswb0QsV0FBTCxDQUFpQmp0QyxLQUFqQixFQUF3QjNQLFNBQXhCLEVBQW1DNHpDLFVBQW5DLENBQVA7QUFDRCxLQXpQSTs7QUEyUEw7Ozs7Ozs7O0FBUUE4SSxtQkFBZSx1QkFBVS9zQyxLQUFWLEVBQWlCOWtDLElBQWpCLEVBQXVCO0FBQ3BDLFVBQUlpMUIsU0FBUyxLQUFLck0sV0FBTCxDQUFpQmtjLEtBQWpCLEVBQXdCOWtDLElBQXhCLENBQWI7QUFDQThrQyxZQUFNdVAsV0FBTixHQUFvQixJQUFwQjtBQUNBLGFBQU9wZixNQUFQO0FBQ0Q7QUF2UUk7QUFSYSxDQUF0Qjs7QUFtUkF4N0IsT0FBT0MsT0FBUCxHQUFpQmlzRSxlQUFqQixDOzs7Ozs7OztBQzViQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl0NUQsa0JBQWtCLG1CQUFBak8sQ0FBUSxFQUFSLENBQXRCOztBQUVBLElBQUk0MUMsNEJBQTRCLG1CQUFBNTFDLENBQVEsRUFBUixDQUFoQztBQUNBLElBQUkrNkIsaUJBQWlCLG1CQUFBLzZCLENBQVEsRUFBUixDQUFyQjtBQUNBLElBQUltNkIsNkJBQTZCLG1CQUFBbjZCLENBQVEsRUFBUixDQUFqQztBQUNBLElBQUltNEMsc0JBQXNCLG1CQUFBbjRDLENBQVEsRUFBUixDQUExQjtBQUNBLElBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUlnSyxzQkFBSjs7QUFFQSxJQUFJLE9BQU81TyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDQSxRQUFRdUMsR0FBMUMsSUFBaUR2QyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixNQUE5RSxFQUFzRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E4SywyQkFBeUIsbUJBQUFoSyxDQUFRLENBQVIsQ0FBekI7QUFDRDs7QUFFRCxTQUFTNHpFLGdCQUFULENBQTBCQyxjQUExQixFQUEwQ250QyxLQUExQyxFQUFpRGhvQyxJQUFqRCxFQUF1RGswRSxXQUF2RCxFQUFvRTtBQUNsRTtBQUNBLE1BQUlrQixZQUFZRCxlQUFlbjFFLElBQWYsTUFBeUJTLFNBQXpDO0FBQ0EsTUFBSS9ELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFFBQUksQ0FBQzhLLHNCQUFMLEVBQTZCO0FBQzNCQSwrQkFBeUIsbUJBQUFoSyxDQUFRLENBQVIsQ0FBekI7QUFDRDtBQUNELFFBQUksQ0FBQzh6RSxTQUFMLEVBQWdCO0FBQ2QxNEUsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLHVFQUF1RSx1RUFBdkUsR0FBaUosaUNBQWhLLEVBQW1NODZCLGVBQWVKLFFBQWYsQ0FBd0JqOEIsSUFBeEIsQ0FBbk0sRUFBa09zTCx1QkFBdUI4QixvQkFBdkIsQ0FBNEM4bUUsV0FBNUMsQ0FBbE8sQ0FBeEMsR0FBc1UsS0FBSyxDQUEzVTtBQUNEO0FBQ0Y7QUFDRCxNQUFJbHNDLFNBQVMsSUFBVCxJQUFpQm90QyxTQUFyQixFQUFnQztBQUM5QkQsbUJBQWVuMUUsSUFBZixJQUF1QmszQywwQkFBMEJsUCxLQUExQixFQUFpQyxJQUFqQyxDQUF2QjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7O0FBS0EsSUFBSXFyQyx1QkFBdUI7QUFDekI7Ozs7Ozs7O0FBUUFjLHVCQUFxQiw2QkFBVWtCLGdCQUFWLEVBQTRCdmpFLFdBQTVCLEVBQXlDbUIsT0FBekMsRUFBa0RpaEUsV0FBbEQsRUFBK0Q7QUFDcEY7QUFDRSxRQUFJbUIsb0JBQW9CLElBQXhCLEVBQThCO0FBQzVCLGFBQU8sSUFBUDtBQUNEO0FBQ0QsUUFBSUYsaUJBQWlCLEVBQXJCOztBQUVBLFFBQUl6NEUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNpNUMsMEJBQW9CNDdCLGdCQUFwQixFQUFzQyxVQUFVQyxVQUFWLEVBQXNCdHRDLEtBQXRCLEVBQTZCaG9DLElBQTdCLEVBQW1DO0FBQ3ZFLGVBQU9rMUUsaUJBQWlCSSxVQUFqQixFQUE2QnR0QyxLQUE3QixFQUFvQ2hvQyxJQUFwQyxFQUEwQ2swRSxXQUExQyxDQUFQO0FBQ0QsT0FGRCxFQUVHaUIsY0FGSDtBQUdELEtBSkQsTUFJTztBQUNMMTdCLDBCQUFvQjQ3QixnQkFBcEIsRUFBc0NILGdCQUF0QyxFQUF3REMsY0FBeEQ7QUFDRDtBQUNELFdBQU9BLGNBQVA7QUFDRCxHQXhCd0I7O0FBMEJ6Qjs7Ozs7Ozs7OztBQVVBN0csa0JBQWdCLHdCQUFVK0YsWUFBVixFQUF3QmxHLFlBQXhCLEVBQXNDaEIsV0FBdEMsRUFBbURvSCxZQUFuRCxFQUFpRXppRSxXQUFqRSxFQUE4RTJNLFVBQTlFLEVBQTBGQyxpQkFBMUYsRUFBNkd6TCxPQUE3RyxFQUFzSGloRSxXQUF0SCxFQUFtSTtBQUNuSjtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJLENBQUMvRixZQUFELElBQWlCLENBQUNrRyxZQUF0QixFQUFvQztBQUNsQztBQUNEO0FBQ0QsUUFBSXIwRSxJQUFKO0FBQ0EsUUFBSTYwRSxTQUFKO0FBQ0EsU0FBSzcwRSxJQUFMLElBQWFtdUUsWUFBYixFQUEyQjtBQUN6QixVQUFJLENBQUNBLGFBQWExcEUsY0FBYixDQUE0QnpFLElBQTVCLENBQUwsRUFBd0M7QUFDdEM7QUFDRDtBQUNENjBFLGtCQUFZUixnQkFBZ0JBLGFBQWFyMEUsSUFBYixDQUE1QjtBQUNBLFVBQUlxZixjQUFjdzFELGFBQWFBLFVBQVV4aUUsZUFBekM7QUFDQSxVQUFJK00sY0FBYyt1RCxhQUFhbnVFLElBQWIsQ0FBbEI7QUFDQSxVQUFJNjBFLGFBQWEsSUFBYixJQUFxQnA1QywyQkFBMkJwYyxXQUEzQixFQUF3Q0QsV0FBeEMsQ0FBekIsRUFBK0U7QUFDN0U3UCx3QkFBZ0I0UCxnQkFBaEIsQ0FBaUMwMUQsU0FBakMsRUFBNEN6MUQsV0FBNUMsRUFBeUR0TixXQUF6RCxFQUFzRW1CLE9BQXRFO0FBQ0FrN0QscUJBQWFudUUsSUFBYixJQUFxQjYwRSxTQUFyQjtBQUNELE9BSEQsTUFHTztBQUNMLFlBQUlBLFNBQUosRUFBZTtBQUNiTix1QkFBYXYwRSxJQUFiLElBQXFCdVAsZ0JBQWdCdVAsV0FBaEIsQ0FBNEIrMUQsU0FBNUIsQ0FBckI7QUFDQXRsRSwwQkFBZ0J3UCxnQkFBaEIsQ0FBaUM4MUQsU0FBakMsRUFBNEMsS0FBNUM7QUFDRDtBQUNEO0FBQ0EsWUFBSVUsb0JBQW9CcitCLDBCQUEwQjkzQixXQUExQixFQUF1QyxJQUF2QyxDQUF4QjtBQUNBK3VELHFCQUFhbnVFLElBQWIsSUFBcUJ1MUUsaUJBQXJCO0FBQ0E7QUFDQTtBQUNBLFlBQUlDLHNCQUFzQmptRSxnQkFBZ0JnUCxjQUFoQixDQUErQmczRCxpQkFBL0IsRUFBa0R6akUsV0FBbEQsRUFBK0QyTSxVQUEvRCxFQUEyRUMsaUJBQTNFLEVBQThGekwsT0FBOUYsRUFBdUdpaEUsV0FBdkcsQ0FBMUI7QUFDQS9HLG9CQUFZenVFLElBQVosQ0FBaUI4MkUsbUJBQWpCO0FBQ0Q7QUFDRjtBQUNEO0FBQ0EsU0FBS3gxRSxJQUFMLElBQWFxMEUsWUFBYixFQUEyQjtBQUN6QixVQUFJQSxhQUFhNXZFLGNBQWIsQ0FBNEJ6RSxJQUE1QixLQUFxQyxFQUFFbXVFLGdCQUFnQkEsYUFBYTFwRSxjQUFiLENBQTRCekUsSUFBNUIsQ0FBbEIsQ0FBekMsRUFBK0Y7QUFDN0Y2MEUsb0JBQVlSLGFBQWFyMEUsSUFBYixDQUFaO0FBQ0F1MEUscUJBQWF2MEUsSUFBYixJQUFxQnVQLGdCQUFnQnVQLFdBQWhCLENBQTRCKzFELFNBQTVCLENBQXJCO0FBQ0F0bEUsd0JBQWdCd1AsZ0JBQWhCLENBQWlDODFELFNBQWpDLEVBQTRDLEtBQTVDO0FBQ0Q7QUFDRjtBQUNGLEdBaEZ3Qjs7QUFrRnpCOzs7Ozs7O0FBT0FwRyxtQkFBaUIseUJBQVV1RyxnQkFBVixFQUE0QmgyRCxNQUE1QixFQUFvQztBQUNuRCxTQUFLLElBQUloZixJQUFULElBQWlCZzFFLGdCQUFqQixFQUFtQztBQUNqQyxVQUFJQSxpQkFBaUJ2d0UsY0FBakIsQ0FBZ0N6RSxJQUFoQyxDQUFKLEVBQTJDO0FBQ3pDLFlBQUl5MUUsZ0JBQWdCVCxpQkFBaUJoMUUsSUFBakIsQ0FBcEI7QUFDQXVQLHdCQUFnQndQLGdCQUFoQixDQUFpQzAyRCxhQUFqQyxFQUFnRHoyRCxNQUFoRDtBQUNEO0FBQ0Y7QUFDRjtBQWhHd0IsQ0FBM0I7O0FBbUdBcmlCLE9BQU9DLE9BQVAsR0FBaUJ5MkUsb0JBQWpCLEM7Ozs7Ozs7O0FDdkpBOzs7Ozs7Ozs7O0FBVUE7Ozs7QUFFQSxJQUFJL3dFLGlCQUFpQixtQkFBQWhCLENBQVEsQ0FBUixDQUFyQjtBQUFBLElBQ0k2TixVQUFVLG1CQUFBN04sQ0FBUSxDQUFSLENBRGQ7O0FBR0EsSUFBSWtjLFFBQVEsbUJBQUFsYyxDQUFRLEVBQVIsQ0FBWjtBQUNBLElBQUl1NUIsNEJBQTRCLG1CQUFBdjVCLENBQVEsRUFBUixDQUFoQztBQUNBLElBQUlxSCxvQkFBb0IsbUJBQUFySCxDQUFRLEVBQVIsQ0FBeEI7QUFDQSxJQUFJZ2lCLGtCQUFrQixtQkFBQWhpQixDQUFRLEVBQVIsQ0FBdEI7QUFDQSxJQUFJNmtCLG1CQUFtQixtQkFBQTdrQixDQUFRLEVBQVIsQ0FBdkI7QUFDQSxJQUFJK2MsdUJBQXVCLG1CQUFBL2MsQ0FBUSxFQUFSLENBQTNCO0FBQ0EsSUFBSXEyQyxpQkFBaUIsbUJBQUFyMkMsQ0FBUSxFQUFSLENBQXJCO0FBQ0EsSUFBSWlPLGtCQUFrQixtQkFBQWpPLENBQVEsRUFBUixDQUF0Qjs7QUFFQSxJQUFJNUUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSTRtQyxxQkFBcUIsbUJBQUE5bEMsQ0FBUSxHQUFSLENBQXpCO0FBQ0Q7O0FBRUQsSUFBSWttQixjQUFjLG1CQUFBbG1CLENBQVEsRUFBUixDQUFsQjtBQUNBLElBQUlaLFlBQVksbUJBQUFZLENBQVEsQ0FBUixDQUFoQjtBQUNBLElBQUk4NUIsZUFBZSxtQkFBQTk1QixDQUFRLEVBQVIsQ0FBbkI7QUFDQSxJQUFJbTZCLDZCQUE2QixtQkFBQW42QixDQUFRLEVBQVIsQ0FBakM7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJbzBFLGlCQUFpQjtBQUNuQkMsZUFBYSxDQURNO0FBRW5CQyxhQUFXLENBRlE7QUFHbkJDLHVCQUFxQjtBQUhGLENBQXJCOztBQU1BLFNBQVNDLGtCQUFULENBQTRCajRELFNBQTVCLEVBQXVDLENBQUU7QUFDekNpNEQsbUJBQW1CajNFLFNBQW5CLENBQTZCeWxDLE1BQTdCLEdBQXNDLFlBQVk7QUFDaEQsTUFBSXptQixZQUFZc0ksaUJBQWlCamMsR0FBakIsQ0FBcUIsSUFBckIsRUFBMkJtSSxlQUEzQixDQUEyQ2xILElBQTNEO0FBQ0EsTUFBSUQsVUFBVTJTLFVBQVUsS0FBSzdELEtBQWYsRUFBc0IsS0FBSy9HLE9BQTNCLEVBQW9DLEtBQUtnekIsT0FBekMsQ0FBZDtBQUNBOHZDLHVCQUFxQmw0RCxTQUFyQixFQUFnQzNTLE9BQWhDO0FBQ0EsU0FBT0EsT0FBUDtBQUNELENBTEQ7O0FBT0EsU0FBUzZxRSxvQkFBVCxDQUE4Qmw0RCxTQUE5QixFQUF5QzNTLE9BQXpDLEVBQWtEO0FBQ2hELE1BQUl4TyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzlELFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRMkosWUFBWSxJQUFaLElBQW9CQSxZQUFZLEtBQWhDLElBQXlDc1MsTUFBTXpPLGNBQU4sQ0FBcUI3RCxPQUFyQixDQUFqRCxFQUFnRiw2RUFBNkUsNERBQTdKLEVBQTJOMlMsVUFBVXpTLFdBQVYsSUFBeUJ5UyxVQUFVN2QsSUFBbkMsSUFBMkMsV0FBdFEsQ0FBeEMsR0FBNlQsS0FBSyxDQUFsVTtBQUNBdEQsWUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsQ0FBQ3NjLFVBQVU0bUIsaUJBQW5CLEVBQXNDLHlFQUF0QyxFQUFpSDVtQixVQUFVelMsV0FBVixJQUF5QnlTLFVBQVU3ZCxJQUFuQyxJQUEyQyxXQUE1SixDQUF4QyxHQUFtTixLQUFLLENBQXhOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTZzJFLGVBQVQsQ0FBeUJuNEQsU0FBekIsRUFBb0M7QUFDbEMsU0FBTyxDQUFDLEVBQUVBLFVBQVVoZixTQUFWLElBQXVCZ2YsVUFBVWhmLFNBQVYsQ0FBb0JzbkMsZ0JBQTdDLENBQVI7QUFDRDs7QUFFRCxTQUFTOHZDLGVBQVQsQ0FBeUJwNEQsU0FBekIsRUFBb0M7QUFDbEMsU0FBTyxDQUFDLEVBQUVBLFVBQVVoZixTQUFWLElBQXVCZ2YsVUFBVWhmLFNBQVYsQ0FBb0IrbkMsb0JBQTdDLENBQVI7QUFDRDs7QUFFRDtBQUNBLFNBQVNzdkMsb0JBQVQsQ0FBOEJydEUsRUFBOUIsRUFBa0NnbUQsT0FBbEMsRUFBMkN5TyxTQUEzQyxFQUFzRDtBQUNwRCxNQUFJek8sWUFBWSxDQUFoQixFQUFtQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxXQUFPaG1ELElBQVA7QUFDRDs7QUFFRHdWLHVCQUFxQjNQLFNBQXJCLENBQStCc3dELHFCQUEvQixDQUFxRG5RLE9BQXJELEVBQThEeU8sU0FBOUQ7QUFDQSxNQUFJO0FBQ0YsV0FBT3owRCxJQUFQO0FBQ0QsR0FGRCxTQUVVO0FBQ1J3Vix5QkFBcUIzUCxTQUFyQixDQUErQnV3RCxtQkFBL0IsQ0FBbURwUSxPQUFuRCxFQUE0RHlPLFNBQTVEO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkJBOzs7Ozs7QUFNQSxJQUFJNlksY0FBYyxDQUFsQjs7QUFFQTs7O0FBR0EsSUFBSXYvQiwwQkFBMEI7QUFDNUI7Ozs7Ozs7QUFPQWpoQyxhQUFXLG1CQUFVekssT0FBVixFQUFtQjtBQUM1QixTQUFLbUgsZUFBTCxHQUF1Qm5ILE9BQXZCO0FBQ0EsU0FBSzZZLFdBQUwsR0FBbUIsQ0FBbkI7QUFDQSxTQUFLcXlELGNBQUwsR0FBc0IsSUFBdEI7QUFDQSxTQUFLcjNCLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxTQUFLMTVDLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxTQUFLKzRDLGtCQUFMLEdBQTBCLElBQTFCOztBQUVBO0FBQ0EsU0FBS3JyQyxrQkFBTCxHQUEwQixJQUExQjtBQUNBLFNBQUs0cUIsZUFBTCxHQUF1QixJQUF2QjtBQUNBLFNBQUtQLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EsU0FBS0Msb0JBQUwsR0FBNEIsS0FBNUI7QUFDQSxTQUFLSixtQkFBTCxHQUEyQixLQUEzQjs7QUFFQSxTQUFLMmpCLGlCQUFMLEdBQXlCLElBQXpCO0FBQ0EsU0FBS2o5QyxrQkFBTCxHQUEwQixJQUExQjtBQUNBLFNBQUsyYixRQUFMLEdBQWdCLElBQWhCO0FBQ0EsU0FBSzFOLFdBQUwsR0FBbUIsQ0FBbkI7QUFDQSxTQUFLcXJDLGdCQUFMLEdBQXdCLElBQXhCOztBQUVBO0FBQ0EsU0FBS2hyQyxpQkFBTCxHQUF5QixJQUF6Qjs7QUFFQTtBQUNBLFNBQUtva0UsMkJBQUwsR0FBbUMsS0FBbkM7O0FBRUEsUUFBSTM1RSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxXQUFLbzhCLHdCQUFMLEdBQWdDLEtBQWhDO0FBQ0Q7QUFDRixHQXRDMkI7O0FBd0M1Qjs7Ozs7Ozs7Ozs7QUFXQXJlLGtCQUFnQix3QkFBVXpNLFdBQVYsRUFBdUIyTSxVQUF2QixFQUFtQ0MsaUJBQW5DLEVBQXNEekwsT0FBdEQsRUFBK0Q7QUFDN0UsUUFBSWt3QixRQUFRLElBQVo7O0FBRUEsU0FBSzdqQixRQUFMLEdBQWdCck0sT0FBaEI7QUFDQSxTQUFLckIsV0FBTCxHQUFtQnVrRSxhQUFuQjtBQUNBLFNBQUs5d0UsV0FBTCxHQUFtQm9aLFVBQW5CO0FBQ0EsU0FBSzIvQixrQkFBTCxHQUEwQjEvQixpQkFBMUI7O0FBRUEsUUFBSTQzRCxjQUFjLEtBQUtqa0UsZUFBTCxDQUFxQjJILEtBQXZDO0FBQ0EsUUFBSXU4RCxnQkFBZ0IsS0FBS0MsZUFBTCxDQUFxQnZqRSxPQUFyQixDQUFwQjs7QUFFQSxRQUFJNEssWUFBWSxLQUFLeEwsZUFBTCxDQUFxQmxILElBQXJDOztBQUVBLFFBQUl5b0UsY0FBYzloRSxZQUFZMmtFLGNBQVosRUFBbEI7O0FBRUE7QUFDQSxRQUFJQyxjQUFjVixnQkFBZ0JuNEQsU0FBaEIsQ0FBbEI7QUFDQSxRQUFJaGEsT0FBTyxLQUFLOHlFLG1CQUFMLENBQXlCRCxXQUF6QixFQUFzQ0osV0FBdEMsRUFBbURDLGFBQW5ELEVBQWtFM0MsV0FBbEUsQ0FBWDtBQUNBLFFBQUlnRCxlQUFKOztBQUVBO0FBQ0EsUUFBSSxDQUFDRixXQUFELEtBQWlCN3lFLFFBQVEsSUFBUixJQUFnQkEsS0FBS3lnQyxNQUFMLElBQWUsSUFBaEQsQ0FBSixFQUEyRDtBQUN6RHN5Qyx3QkFBa0IveUUsSUFBbEI7QUFDQWt5RSwyQkFBcUJsNEQsU0FBckIsRUFBZ0MrNEQsZUFBaEM7QUFDQSxRQUFFL3lFLFNBQVMsSUFBVCxJQUFpQkEsU0FBUyxLQUExQixJQUFtQzJaLE1BQU16TyxjQUFOLENBQXFCbEwsSUFBckIsQ0FBckMsSUFBbUVuSCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLG9JQUFqQixFQUF1Sm1kLFVBQVV6UyxXQUFWLElBQXlCeVMsVUFBVTdkLElBQW5DLElBQTJDLFdBQWxNLENBQXhDLEdBQXlQc0MsZUFBZSxLQUFmLEVBQXNCdWIsVUFBVXpTLFdBQVYsSUFBeUJ5UyxVQUFVN2QsSUFBbkMsSUFBMkMsV0FBakUsQ0FBNVQsR0FBNFksS0FBSyxDQUFqWjtBQUNBNkQsYUFBTyxJQUFJaXlFLGtCQUFKLENBQXVCajRELFNBQXZCLENBQVA7QUFDQSxXQUFLdTRELGNBQUwsR0FBc0JWLGVBQWVHLG1CQUFyQztBQUNELEtBTkQsTUFNTztBQUNMLFVBQUlJLGdCQUFnQnA0RCxTQUFoQixDQUFKLEVBQWdDO0FBQzlCLGFBQUt1NEQsY0FBTCxHQUFzQlYsZUFBZUUsU0FBckM7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFLUSxjQUFMLEdBQXNCVixlQUFlQyxXQUFyQztBQUNEO0FBQ0Y7O0FBRUQsUUFBSWo1RSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QztBQUNBO0FBQ0EsVUFBSXFELEtBQUt5Z0MsTUFBTCxJQUFlLElBQW5CLEVBQXlCO0FBQ3ZCNW5DLGdCQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsaUVBQWlFLHNEQUFoRixFQUF3SXNjLFVBQVV6UyxXQUFWLElBQXlCeVMsVUFBVTdkLElBQW5DLElBQTJDLFdBQW5MLENBQXhDLEdBQTBPLEtBQUssQ0FBL087QUFDRDs7QUFFRCxVQUFJNjJFLGVBQWVoekUsS0FBS21XLEtBQUwsS0FBZXM4RCxXQUFsQztBQUNBLFVBQUl0OEMsZ0JBQWdCbmMsVUFBVXpTLFdBQVYsSUFBeUJ5UyxVQUFVN2QsSUFBbkMsSUFBMkMsV0FBL0Q7O0FBRUF0RCxjQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUXNDLEtBQUttVyxLQUFMLEtBQWV2WixTQUFmLElBQTRCLENBQUNvMkUsWUFBckMsRUFBbUQsOERBQThELGlFQUFqSCxFQUFvTDc4QyxhQUFwTCxFQUFtTUEsYUFBbk0sQ0FBeEMsR0FBNFAsS0FBSyxDQUFqUTtBQUNEOztBQUVEO0FBQ0E7QUFDQW4yQixTQUFLbVcsS0FBTCxHQUFhczhELFdBQWI7QUFDQXp5RSxTQUFLb1AsT0FBTCxHQUFlc2pFLGFBQWY7QUFDQTF5RSxTQUFLcWlDLElBQUwsR0FBWTFlLFdBQVo7QUFDQTNqQixTQUFLb2lDLE9BQUwsR0FBZTJ0QyxXQUFmOztBQUVBLFNBQUs3MEIsU0FBTCxHQUFpQmw3QyxJQUFqQjs7QUFFQTtBQUNBc2lCLHFCQUFpQmxjLEdBQWpCLENBQXFCcEcsSUFBckIsRUFBMkIsSUFBM0I7O0FBRUEsUUFBSW5ILFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOUQsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsQ0FBQ3NDLEtBQUs4ckQsZUFBTixJQUF5QjlyRCxLQUFLOHJELGVBQUwsQ0FBcUJubkIsb0JBQTlDLElBQXNFM2tDLEtBQUsyOUIsS0FBbkYsRUFBMEYsa0VBQWtFLHNFQUFsRSxHQUEySSxrREFBck8sRUFBeVIsS0FBS3gwQixPQUFMLE1BQWtCLGFBQTNTLENBQXhDLEdBQW9XLEtBQUssQ0FBelc7QUFDQXRRLGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLENBQUNzQyxLQUFLMGtDLGVBQU4sSUFBeUIxa0MsS0FBSzBrQyxlQUFMLENBQXFCQyxvQkFBdEQsRUFBNEUsa0VBQWtFLHNFQUFsRSxHQUEySSx1REFBdk4sRUFBZ1IsS0FBS3g3QixPQUFMLE1BQWtCLGFBQWxTLENBQXhDLEdBQTJWLEtBQUssQ0FBaFc7QUFDQXRRLGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLENBQUNzQyxLQUFLazJCLFNBQWQsRUFBeUIsdUVBQXVFLHVDQUFoRyxFQUF5SSxLQUFLL3NCLE9BQUwsTUFBa0IsYUFBM0osQ0FBeEMsR0FBb04sS0FBSyxDQUF6TjtBQUNBdFEsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsQ0FBQ3NDLEtBQUsyZ0MsWUFBZCxFQUE0QixtRUFBbUUsaURBQS9GLEVBQWtKLEtBQUt4M0IsT0FBTCxNQUFrQixhQUFwSyxDQUF4QyxHQUE2TixLQUFLLENBQWxPO0FBQ0F0USxjQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxPQUFPc0MsS0FBS212RCxxQkFBWixLQUFzQyxVQUE5QyxFQUEwRCw0QkFBNEIsaUVBQTVCLEdBQWdHLDREQUFoRyxHQUErSiw2QkFBek4sRUFBd1AsS0FBS2htRCxPQUFMLE1BQWtCLGFBQTFRLENBQXhDLEdBQW1VLEtBQUssQ0FBeFU7QUFDQXRRLGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLE9BQU9zQyxLQUFLaXpFLG1CQUFaLEtBQW9DLFVBQTVDLEVBQXdELDRCQUE0QixnRUFBNUIsR0FBK0Ysc0NBQXZKLEVBQStMLEtBQUs5cEUsT0FBTCxNQUFrQixhQUFqTixDQUF4QyxHQUEwUSxLQUFLLENBQS9RO0FBQ0F0USxjQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxPQUFPc0MsS0FBS292RCx5QkFBWixLQUEwQyxVQUFsRCxFQUE4RCw0QkFBNEIsd0VBQTFGLEVBQW9LLEtBQUtqbUQsT0FBTCxNQUFrQixhQUF0TCxDQUF4QyxHQUErTyxLQUFLLENBQXBQO0FBQ0Q7O0FBRUQsUUFBSThsRCxlQUFlanZELEtBQUsyOUIsS0FBeEI7QUFDQSxRQUFJc3hCLGlCQUFpQnJ5RCxTQUFyQixFQUFnQztBQUM5Qm9ELFdBQUsyOUIsS0FBTCxHQUFhc3hCLGVBQWUsSUFBNUI7QUFDRDtBQUNELE1BQUUsUUFBT0EsWUFBUCx5Q0FBT0EsWUFBUCxPQUF3QixRQUF4QixJQUFvQyxDQUFDdjBELE1BQU11MUIsT0FBTixDQUFjZy9CLFlBQWQsQ0FBdkMsSUFBc0VwMkQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiw0Q0FBakIsRUFBK0QsS0FBS3NNLE9BQUwsTUFBa0IseUJBQWpGLENBQXhDLEdBQXNKMUssZUFBZSxLQUFmLEVBQXNCLEtBQUswSyxPQUFMLE1BQWtCLHlCQUF4QyxDQUE1TixHQUFpUyxLQUFLLENBQXRTOztBQUVBLFNBQUtvd0Isa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSxTQUFLQyxvQkFBTCxHQUE0QixLQUE1QjtBQUNBLFNBQUtKLG1CQUFMLEdBQTJCLEtBQTNCOztBQUVBLFFBQUlyZSxNQUFKO0FBQ0EsUUFBSS9hLEtBQUtrekUsb0JBQVQsRUFBK0I7QUFDN0JuNEQsZUFBUyxLQUFLbzRELG9DQUFMLENBQTBDSixlQUExQyxFQUEyRG40RCxVQUEzRCxFQUF1RUMsaUJBQXZFLEVBQTBGNU0sV0FBMUYsRUFBdUdtQixPQUF2RyxDQUFUO0FBQ0QsS0FGRCxNQUVPO0FBQ0wyTCxlQUFTLEtBQUtxNEQsbUJBQUwsQ0FBeUJMLGVBQXpCLEVBQTBDbjRELFVBQTFDLEVBQXNEQyxpQkFBdEQsRUFBeUU1TSxXQUF6RSxFQUFzRm1CLE9BQXRGLENBQVQ7QUFDRDs7QUFFRCxRQUFJcFAsS0FBSytyRCxpQkFBVCxFQUE0QjtBQUMxQixVQUFJbHpELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDc1Isb0JBQVkrTSxrQkFBWixHQUFpQ2xNLE9BQWpDLENBQXlDLFlBQVk7QUFDbkR1akUsK0JBQXFCLFlBQVk7QUFDL0IsbUJBQU9yeUUsS0FBSytyRCxpQkFBTCxFQUFQO0FBQ0QsV0FGRCxFQUVHenNCLE1BQU1oMkIsUUFGVCxFQUVtQixtQkFGbkI7QUFHRCxTQUpEO0FBS0QsT0FORCxNQU1PO0FBQ0wyRSxvQkFBWStNLGtCQUFaLEdBQWlDbE0sT0FBakMsQ0FBeUM5TyxLQUFLK3JELGlCQUE5QyxFQUFpRS9yRCxJQUFqRTtBQUNEO0FBQ0Y7O0FBRUQsV0FBTythLE1BQVA7QUFDRCxHQTFKMkI7O0FBNEo1QiszRCx1QkFBcUIsNkJBQVVELFdBQVYsRUFBdUJKLFdBQXZCLEVBQW9DQyxhQUFwQyxFQUFtRDNDLFdBQW5ELEVBQWdFO0FBQ25GLFFBQUlsM0UsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNtSSx3QkFBa0J1RSxPQUFsQixHQUE0QixJQUE1QjtBQUNBLFVBQUk7QUFDRixlQUFPLEtBQUtncUUsK0JBQUwsQ0FBcUNSLFdBQXJDLEVBQWtESixXQUFsRCxFQUErREMsYUFBL0QsRUFBOEUzQyxXQUE5RSxDQUFQO0FBQ0QsT0FGRCxTQUVVO0FBQ1JqckUsMEJBQWtCdUUsT0FBbEIsR0FBNEIsSUFBNUI7QUFDRDtBQUNGLEtBUEQsTUFPTztBQUNMLGFBQU8sS0FBS2dxRSwrQkFBTCxDQUFxQ1IsV0FBckMsRUFBa0RKLFdBQWxELEVBQStEQyxhQUEvRCxFQUE4RTNDLFdBQTlFLENBQVA7QUFDRDtBQUNGLEdBdksyQjs7QUF5SzVCc0QsbUNBQWlDLHlDQUFVUixXQUFWLEVBQXVCSixXQUF2QixFQUFvQ0MsYUFBcEMsRUFBbUQzQyxXQUFuRCxFQUFnRTtBQUMvRixRQUFJLzFELFlBQVksS0FBS3hMLGVBQUwsQ0FBcUJsSCxJQUFyQzs7QUFFQSxRQUFJdXJFLFdBQUosRUFBaUI7QUFDZixVQUFJaDZFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGVBQU8wMUUscUJBQXFCLFlBQVk7QUFDdEMsaUJBQU8sSUFBSXI0RCxTQUFKLENBQWN5NEQsV0FBZCxFQUEyQkMsYUFBM0IsRUFBMEMzQyxXQUExQyxDQUFQO0FBQ0QsU0FGTSxFQUVKLEtBQUt6bUUsUUFGRCxFQUVXLE1BRlgsQ0FBUDtBQUdELE9BSkQsTUFJTztBQUNMLGVBQU8sSUFBSTBRLFNBQUosQ0FBY3k0RCxXQUFkLEVBQTJCQyxhQUEzQixFQUEwQzNDLFdBQTFDLENBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQSxRQUFJbDNFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGFBQU8wMUUscUJBQXFCLFlBQVk7QUFDdEMsZUFBT3I0RCxVQUFVeTRELFdBQVYsRUFBdUJDLGFBQXZCLEVBQXNDM0MsV0FBdEMsQ0FBUDtBQUNELE9BRk0sRUFFSixLQUFLem1FLFFBRkQsRUFFVyxRQUZYLENBQVA7QUFHRCxLQUpELE1BSU87QUFDTCxhQUFPMFEsVUFBVXk0RCxXQUFWLEVBQXVCQyxhQUF2QixFQUFzQzNDLFdBQXRDLENBQVA7QUFDRDtBQUNGLEdBL0wyQjs7QUFpTTVCb0Qsd0NBQXNDLDhDQUFVSixlQUFWLEVBQTJCbjRELFVBQTNCLEVBQXVDQyxpQkFBdkMsRUFBMEQ1TSxXQUExRCxFQUF1RW1CLE9BQXZFLEVBQWdGO0FBQ3BILFFBQUkyTCxNQUFKO0FBQ0EsUUFBSTh0QixhQUFhNTZCLFlBQVk0NkIsVUFBWixFQUFqQjtBQUNBLFFBQUk7QUFDRjl0QixlQUFTLEtBQUtxNEQsbUJBQUwsQ0FBeUJMLGVBQXpCLEVBQTBDbjRELFVBQTFDLEVBQXNEQyxpQkFBdEQsRUFBeUU1TSxXQUF6RSxFQUFzRm1CLE9BQXRGLENBQVQ7QUFDRCxLQUZELENBRUUsT0FBTzlWLENBQVAsRUFBVTtBQUNWO0FBQ0EyVSxrQkFBWTY2QixRQUFaLENBQXFCRCxVQUFyQjtBQUNBLFdBQUtxUyxTQUFMLENBQWVnNEIsb0JBQWYsQ0FBb0M1NUUsQ0FBcEM7QUFDQSxVQUFJLEtBQUtpZ0Msa0JBQVQsRUFBNkI7QUFDM0IsYUFBSzJoQixTQUFMLENBQWV2ZCxLQUFmLEdBQXVCLEtBQUsyMUMsb0JBQUwsQ0FBMEIsS0FBS3A0QixTQUFMLENBQWUva0MsS0FBekMsRUFBZ0QsS0FBSytrQyxTQUFMLENBQWU5ckMsT0FBL0QsQ0FBdkI7QUFDRDtBQUNEeTVCLG1CQUFhNTZCLFlBQVk0NkIsVUFBWixFQUFiOztBQUVBLFdBQUsvb0Msa0JBQUwsQ0FBd0JvYixnQkFBeEIsQ0FBeUMsSUFBekM7QUFDQWpOLGtCQUFZNjZCLFFBQVosQ0FBcUJELFVBQXJCOztBQUVBO0FBQ0E7QUFDQTl0QixlQUFTLEtBQUtxNEQsbUJBQUwsQ0FBeUJMLGVBQXpCLEVBQTBDbjRELFVBQTFDLEVBQXNEQyxpQkFBdEQsRUFBeUU1TSxXQUF6RSxFQUFzRm1CLE9BQXRGLENBQVQ7QUFDRDtBQUNELFdBQU8yTCxNQUFQO0FBQ0QsR0F2TjJCOztBQXlONUJxNEQsdUJBQXFCLDZCQUFVTCxlQUFWLEVBQTJCbjRELFVBQTNCLEVBQXVDQyxpQkFBdkMsRUFBMEQ1TSxXQUExRCxFQUF1RW1CLE9BQXZFLEVBQWdGO0FBQ25HLFFBQUlwUCxPQUFPLEtBQUtrN0MsU0FBaEI7O0FBRUEsUUFBSThQLFVBQVUsQ0FBZDtBQUNBLFFBQUlueUQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNxdUQsZ0JBQVUsS0FBSzFoRCxRQUFmO0FBQ0Q7O0FBRUQsUUFBSXRKLEtBQUtnZ0Msa0JBQVQsRUFBNkI7QUFDM0IsVUFBSW5uQyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzAxRSw2QkFBcUIsWUFBWTtBQUMvQixpQkFBT3J5RSxLQUFLZ2dDLGtCQUFMLEVBQVA7QUFDRCxTQUZELEVBRUdnckIsT0FGSCxFQUVZLG9CQUZaO0FBR0QsT0FKRCxNQUlPO0FBQ0xockQsYUFBS2dnQyxrQkFBTDtBQUNEO0FBQ0Q7QUFDQTtBQUNBLFVBQUksS0FBS3pHLGtCQUFULEVBQTZCO0FBQzNCdjVCLGFBQUsyOUIsS0FBTCxHQUFhLEtBQUsyMUMsb0JBQUwsQ0FBMEJ0ekUsS0FBS21XLEtBQS9CLEVBQXNDblcsS0FBS29QLE9BQTNDLENBQWI7QUFDRDtBQUNGOztBQUVEO0FBQ0EsUUFBSTJqRSxvQkFBb0JuMkUsU0FBeEIsRUFBbUM7QUFDakNtMkUsd0JBQWtCLEtBQUtRLHlCQUFMLEVBQWxCO0FBQ0Q7O0FBRUQsUUFBSWgwRSxXQUFXdTBDLGVBQWVJLE9BQWYsQ0FBdUI2K0IsZUFBdkIsQ0FBZjtBQUNBLFNBQUtoMkIsaUJBQUwsR0FBeUJ4OUMsUUFBekI7QUFDQSxRQUFJNGtDLFFBQVEsS0FBSzBQLDBCQUFMLENBQWdDay9CLGVBQWhDLEVBQWlEeHpFLGFBQWF1MEMsZUFBZUcsS0FBN0UsQ0FBbUY7QUFBbkYsS0FBWjtBQUVBLFNBQUtuMEMsa0JBQUwsR0FBMEJxa0MsS0FBMUI7O0FBRUEsUUFBSXBwQixTQUFTclAsZ0JBQWdCZ1AsY0FBaEIsQ0FBK0J5cEIsS0FBL0IsRUFBc0NsMkIsV0FBdEMsRUFBbUQyTSxVQUFuRCxFQUErREMsaUJBQS9ELEVBQWtGLEtBQUswZ0Msb0JBQUwsQ0FBMEJuc0MsT0FBMUIsQ0FBbEYsRUFBc0g0N0MsT0FBdEgsQ0FBYjs7QUFFQSxRQUFJbnlELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUlxdUQsWUFBWSxDQUFoQixFQUFtQjtBQUNqQixZQUFJd1EsZ0JBQWdCcjNCLE1BQU03NkIsUUFBTixLQUFtQixDQUFuQixHQUF1QixDQUFDNjZCLE1BQU03NkIsUUFBUCxDQUF2QixHQUEwQyxFQUE5RDtBQUNBa1IsNkJBQXFCM1AsU0FBckIsQ0FBK0IvQyxhQUEvQixDQUE2Q2tqRCxPQUE3QyxFQUFzRHdRLGFBQXREO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPemdELE1BQVA7QUFDRCxHQXJRMkI7O0FBdVE1QkUsZUFBYSx1QkFBWTtBQUN2QixXQUFPdlAsZ0JBQWdCdVAsV0FBaEIsQ0FBNEIsS0FBS25iLGtCQUFqQyxDQUFQO0FBQ0QsR0F6UTJCOztBQTJRNUI7Ozs7OztBQU1Bb2Isb0JBQWtCLDBCQUFVQyxNQUFWLEVBQWtCO0FBQ2xDLFFBQUksQ0FBQyxLQUFLcmIsa0JBQVYsRUFBOEI7QUFDNUI7QUFDRDs7QUFFRCxRQUFJRSxPQUFPLEtBQUtrN0MsU0FBaEI7O0FBRUEsUUFBSWw3QyxLQUFLd2dDLG9CQUFMLElBQTZCLENBQUN4Z0MsS0FBS3d5RSwyQkFBdkMsRUFBb0U7QUFDbEV4eUUsV0FBS3d5RSwyQkFBTCxHQUFtQyxJQUFuQzs7QUFFQSxVQUFJcjNELE1BQUosRUFBWTtBQUNWLFlBQUloZixPQUFPLEtBQUtnTixPQUFMLEtBQWlCLHlCQUE1QjtBQUNBc1csd0JBQWdCOFEscUJBQWhCLENBQXNDcDBCLElBQXRDLEVBQTRDNkQsS0FBS3dnQyxvQkFBTCxDQUEwQnBwQixJQUExQixDQUErQnBYLElBQS9CLENBQTVDO0FBQ0QsT0FIRCxNQUdPO0FBQ0wsWUFBSW5ILFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDMDFFLCtCQUFxQixZQUFZO0FBQy9CLG1CQUFPcnlFLEtBQUt3Z0Msb0JBQUwsRUFBUDtBQUNELFdBRkQsRUFFRyxLQUFLbDNCLFFBRlIsRUFFa0Isc0JBRmxCO0FBR0QsU0FKRCxNQUlPO0FBQ0x0SixlQUFLd2dDLG9CQUFMO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFFBQUksS0FBSzFnQyxrQkFBVCxFQUE2QjtBQUMzQjRMLHNCQUFnQndQLGdCQUFoQixDQUFpQyxLQUFLcGIsa0JBQXRDLEVBQTBEcWIsTUFBMUQ7QUFDQSxXQUFLNGhDLGlCQUFMLEdBQXlCLElBQXpCO0FBQ0EsV0FBS2o5QyxrQkFBTCxHQUEwQixJQUExQjtBQUNBLFdBQUtvN0MsU0FBTCxHQUFpQixJQUFqQjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFNBQUszaEIsa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSxTQUFLQyxvQkFBTCxHQUE0QixLQUE1QjtBQUNBLFNBQUtKLG1CQUFMLEdBQTJCLEtBQTNCO0FBQ0EsU0FBS2hyQixpQkFBTCxHQUF5QixJQUF6QjtBQUNBLFNBQUswckIsZUFBTCxHQUF1QixJQUF2Qjs7QUFFQTtBQUNBO0FBQ0EsU0FBS3JlLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxTQUFLeUUsV0FBTCxHQUFtQixDQUFuQjtBQUNBLFNBQUtrNUIsZ0JBQUwsR0FBd0IsSUFBeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E5MkIscUJBQWlCQyxNQUFqQixDQUF3QnZpQixJQUF4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0QsR0F6VTJCOztBQTJVNUI7Ozs7Ozs7O0FBUUF3ekUsZ0JBQWMsc0JBQVVwa0UsT0FBVixFQUFtQjtBQUMvQixRQUFJNEssWUFBWSxLQUFLeEwsZUFBTCxDQUFxQmxILElBQXJDO0FBQ0EsUUFBSXE1QixlQUFlM21CLFVBQVUybUIsWUFBN0I7QUFDQSxRQUFJLENBQUNBLFlBQUwsRUFBbUI7QUFDakIsYUFBT2hkLFdBQVA7QUFDRDtBQUNELFFBQUk4dkQsZ0JBQWdCLEVBQXBCO0FBQ0EsU0FBSyxJQUFJQyxXQUFULElBQXdCL3lDLFlBQXhCLEVBQXNDO0FBQ3BDOHlDLG9CQUFjQyxXQUFkLElBQTZCdGtFLFFBQVFza0UsV0FBUixDQUE3QjtBQUNEO0FBQ0QsV0FBT0QsYUFBUDtBQUNELEdBOVYyQjs7QUFnVzVCOzs7Ozs7OztBQVFBZCxtQkFBaUIseUJBQVV2akUsT0FBVixFQUFtQjtBQUNsQyxRQUFJcWtFLGdCQUFnQixLQUFLRCxZQUFMLENBQWtCcGtFLE9BQWxCLENBQXBCO0FBQ0EsUUFBSXZXLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFVBQUlxZCxZQUFZLEtBQUt4TCxlQUFMLENBQXFCbEgsSUFBckM7QUFDQSxVQUFJMFMsVUFBVTJtQixZQUFkLEVBQTRCO0FBQzFCLGFBQUtnekMsa0JBQUwsQ0FBd0IzNUQsVUFBVTJtQixZQUFsQyxFQUFnRDh5QyxhQUFoRCxFQUErRCxTQUEvRDtBQUNEO0FBQ0Y7QUFDRCxXQUFPQSxhQUFQO0FBQ0QsR0FqWDJCOztBQW1YNUI7Ozs7O0FBS0FsNEIsd0JBQXNCLDhCQUFVcTRCLGNBQVYsRUFBMEI7QUFDOUMsUUFBSTU1RCxZQUFZLEtBQUt4TCxlQUFMLENBQXFCbEgsSUFBckM7QUFDQSxRQUFJdEgsT0FBTyxLQUFLazdDLFNBQWhCO0FBQ0EsUUFBSWtRLFlBQUo7O0FBRUEsUUFBSXByRCxLQUFLMC9CLGVBQVQsRUFBMEI7QUFDeEIsVUFBSTdtQyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzZkLDZCQUFxQjNQLFNBQXJCLENBQStCd3dELDZCQUEvQjtBQUNBLFlBQUk7QUFDRmpRLHlCQUFlcHJELEtBQUswL0IsZUFBTCxFQUFmO0FBQ0QsU0FGRCxTQUVVO0FBQ1JsbEIsK0JBQXFCM1AsU0FBckIsQ0FBK0J5d0QsMkJBQS9CO0FBQ0Q7QUFDRixPQVBELE1BT087QUFDTGxRLHVCQUFlcHJELEtBQUswL0IsZUFBTCxFQUFmO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJMHJCLFlBQUosRUFBa0I7QUFDaEIsUUFBRSxRQUFPcHhDLFVBQVU0bUIsaUJBQWpCLE1BQXVDLFFBQXpDLElBQXFEL25DLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsNEZBQWpCLEVBQStHLEtBQUtzTSxPQUFMLE1BQWtCLHlCQUFqSSxDQUF4QyxHQUFzTTFLLGVBQWUsS0FBZixFQUFzQixLQUFLMEssT0FBTCxNQUFrQix5QkFBeEMsQ0FBM1AsR0FBZ1UsS0FBSyxDQUFyVTtBQUNBLFVBQUl0USxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxhQUFLZzNFLGtCQUFMLENBQXdCMzVELFVBQVU0bUIsaUJBQWxDLEVBQXFEd3FCLFlBQXJELEVBQW1FLGVBQW5FO0FBQ0Q7QUFDRCxXQUFLLElBQUlqdkQsSUFBVCxJQUFpQml2RCxZQUFqQixFQUErQjtBQUM3QixVQUFFanZELFFBQVE2ZCxVQUFVNG1CLGlCQUFwQixJQUF5Qy9uQyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHFFQUFqQixFQUF3RixLQUFLc00sT0FBTCxNQUFrQix5QkFBMUcsRUFBcUloTixJQUFySSxDQUF4QyxHQUFxTHNDLGVBQWUsS0FBZixFQUFzQixLQUFLMEssT0FBTCxNQUFrQix5QkFBeEMsRUFBbUVoTixJQUFuRSxDQUE5TixHQUF5UyxLQUFLLENBQTlTO0FBQ0Q7QUFDRCxhQUFPbVAsUUFBUSxFQUFSLEVBQVlzb0UsY0FBWixFQUE0QnhvQixZQUE1QixDQUFQO0FBQ0Q7QUFDRCxXQUFPd29CLGNBQVA7QUFDRCxHQXJaMkI7O0FBdVo1Qjs7Ozs7Ozs7QUFRQUQsc0JBQW9CLDRCQUFVNW9CLFNBQVYsRUFBcUJocEIsTUFBckIsRUFBNkJyZSxRQUE3QixFQUF1QztBQUN6RCxRQUFJN3FCLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDNG1DLHlCQUFtQnduQixTQUFuQixFQUE4QmhwQixNQUE5QixFQUFzQ3JlLFFBQXRDLEVBQWdELEtBQUt2YSxPQUFMLEVBQWhELEVBQWdFLElBQWhFLEVBQXNFLEtBQUtHLFFBQTNFO0FBQ0Q7QUFDRixHQW5hMkI7O0FBcWE1QmdTLG9CQUFrQiwwQkFBVUMsV0FBVixFQUF1QnROLFdBQXZCLEVBQW9DNHJCLFdBQXBDLEVBQWlEO0FBQ2pFLFFBQUlyZSxjQUFjLEtBQUtoTixlQUF2QjtBQUNBLFFBQUlxbEUsY0FBYyxLQUFLcDRELFFBQXZCOztBQUVBLFNBQUtxZSxlQUFMLEdBQXVCLElBQXZCOztBQUVBLFNBQUtxeUIsZUFBTCxDQUFxQmwrQyxXQUFyQixFQUFrQ3VOLFdBQWxDLEVBQStDRCxXQUEvQyxFQUE0RHM0RCxXQUE1RCxFQUF5RWg2QyxXQUF6RTtBQUNELEdBNWEyQjs7QUE4YTVCOzs7Ozs7O0FBT0FsckIsNEJBQTBCLGtDQUFVVixXQUFWLEVBQXVCO0FBQy9DLFFBQUksS0FBSzZyQixlQUFMLElBQXdCLElBQTVCLEVBQWtDO0FBQ2hDcHVCLHNCQUFnQjRQLGdCQUFoQixDQUFpQyxJQUFqQyxFQUF1QyxLQUFLd2UsZUFBNUMsRUFBNkQ3ckIsV0FBN0QsRUFBMEUsS0FBS3dOLFFBQS9FO0FBQ0QsS0FGRCxNQUVPLElBQUksS0FBSzhkLGtCQUFMLEtBQTRCLElBQTVCLElBQW9DLEtBQUtILG1CQUE3QyxFQUFrRTtBQUN2RSxXQUFLK3lCLGVBQUwsQ0FBcUJsK0MsV0FBckIsRUFBa0MsS0FBS08sZUFBdkMsRUFBd0QsS0FBS0EsZUFBN0QsRUFBOEUsS0FBS2lOLFFBQW5GLEVBQTZGLEtBQUtBLFFBQWxHO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsV0FBS3ZNLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0Q7QUFDRixHQTdiMkI7O0FBK2I1Qjs7Ozs7Ozs7Ozs7Ozs7O0FBZUFpOUMsbUJBQWlCLHlCQUFVbCtDLFdBQVYsRUFBdUI2bEUsaUJBQXZCLEVBQTBDQyxpQkFBMUMsRUFBNkRDLG1CQUE3RCxFQUFrRkMsbUJBQWxGLEVBQXVHO0FBQ3RILFFBQUlqMEUsT0FBTyxLQUFLazdDLFNBQWhCO0FBQ0EsTUFBRWw3QyxRQUFRLElBQVYsSUFBa0JuSCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLDBGQUFqQixFQUE2RyxLQUFLc00sT0FBTCxNQUFrQix5QkFBL0gsQ0FBeEMsR0FBb00xSyxlQUFlLEtBQWYsRUFBc0IsS0FBSzBLLE9BQUwsTUFBa0IseUJBQXhDLENBQXROLEdBQTJSLEtBQUssQ0FBaFM7O0FBRUEsUUFBSStxRSxjQUFjLEtBQWxCO0FBQ0EsUUFBSXI2QyxXQUFKOztBQUVBO0FBQ0EsUUFBSSxLQUFLcGUsUUFBTCxLQUFrQnc0RCxtQkFBdEIsRUFBMkM7QUFDekNwNkMsb0JBQWM3NUIsS0FBS29QLE9BQW5CO0FBQ0QsS0FGRCxNQUVPO0FBQ0x5cUIsb0JBQWMsS0FBSzg0QyxlQUFMLENBQXFCc0IsbUJBQXJCLENBQWQ7QUFDQUMsb0JBQWMsSUFBZDtBQUNEOztBQUVELFFBQUlDLFlBQVlMLGtCQUFrQjM5RCxLQUFsQztBQUNBLFFBQUlvcUIsWUFBWXd6QyxrQkFBa0I1OUQsS0FBbEM7O0FBRUE7QUFDQSxRQUFJMjlELHNCQUFzQkMsaUJBQTFCLEVBQTZDO0FBQzNDRyxvQkFBYyxJQUFkO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsUUFBSUEsZUFBZWwwRSxLQUFLc2dDLHlCQUF4QixFQUFtRDtBQUNqRCxVQUFJem5DLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDMDFFLDZCQUFxQixZQUFZO0FBQy9CLGlCQUFPcnlFLEtBQUtzZ0MseUJBQUwsQ0FBK0JDLFNBQS9CLEVBQTBDMUcsV0FBMUMsQ0FBUDtBQUNELFNBRkQsRUFFRyxLQUFLdndCLFFBRlIsRUFFa0IsMkJBRmxCO0FBR0QsT0FKRCxNQUlPO0FBQ0x0SixhQUFLc2dDLHlCQUFMLENBQStCQyxTQUEvQixFQUEwQzFHLFdBQTFDO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJcWxCLFlBQVksS0FBS28wQixvQkFBTCxDQUEwQi95QyxTQUExQixFQUFxQzFHLFdBQXJDLENBQWhCO0FBQ0EsUUFBSXU2QyxlQUFlLElBQW5COztBQUVBLFFBQUksQ0FBQyxLQUFLaDdDLG1CQUFWLEVBQStCO0FBQzdCLFVBQUlwNUIsS0FBS2dzRCxxQkFBVCxFQUFnQztBQUM5QixZQUFJbnpELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDeTNFLHlCQUFlL0IscUJBQXFCLFlBQVk7QUFDOUMsbUJBQU9yeUUsS0FBS2dzRCxxQkFBTCxDQUEyQnpyQixTQUEzQixFQUFzQzJlLFNBQXRDLEVBQWlEcmxCLFdBQWpELENBQVA7QUFDRCxXQUZjLEVBRVosS0FBS3Z3QixRQUZPLEVBRUcsdUJBRkgsQ0FBZjtBQUdELFNBSkQsTUFJTztBQUNMOHFFLHlCQUFlcDBFLEtBQUtnc0QscUJBQUwsQ0FBMkJ6ckIsU0FBM0IsRUFBc0MyZSxTQUF0QyxFQUFpRHJsQixXQUFqRCxDQUFmO0FBQ0Q7QUFDRixPQVJELE1BUU87QUFDTCxZQUFJLEtBQUswNEMsY0FBTCxLQUF3QlYsZUFBZUUsU0FBM0MsRUFBc0Q7QUFDcERxQyx5QkFBZSxDQUFDNzhDLGFBQWE0OEMsU0FBYixFQUF3QjV6QyxTQUF4QixDQUFELElBQXVDLENBQUNoSixhQUFhdjNCLEtBQUsyOUIsS0FBbEIsRUFBeUJ1aEIsU0FBekIsQ0FBdkQ7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsUUFBSXJtRCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QzlELGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRMDJFLGlCQUFpQngzRSxTQUF6QixFQUFvQyxpRUFBaUUsbURBQXJHLEVBQTBKLEtBQUt1TSxPQUFMLE1BQWtCLHlCQUE1SyxDQUF4QyxHQUFpUCxLQUFLLENBQXRQO0FBQ0Q7O0FBRUQsU0FBSytGLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EsUUFBSWtsRSxZQUFKLEVBQWtCO0FBQ2hCLFdBQUtoN0MsbUJBQUwsR0FBMkIsS0FBM0I7QUFDQTtBQUNBLFdBQUtpN0MsdUJBQUwsQ0FBNkJOLGlCQUE3QixFQUFnRHh6QyxTQUFoRCxFQUEyRDJlLFNBQTNELEVBQXNFcmxCLFdBQXRFLEVBQW1GNXJCLFdBQW5GLEVBQWdHZ21FLG1CQUFoRztBQUNELEtBSkQsTUFJTztBQUNMO0FBQ0E7QUFDQSxXQUFLemxFLGVBQUwsR0FBdUJ1bEUsaUJBQXZCO0FBQ0EsV0FBS3Q0RCxRQUFMLEdBQWdCdzRELG1CQUFoQjtBQUNBajBFLFdBQUttVyxLQUFMLEdBQWFvcUIsU0FBYjtBQUNBdmdDLFdBQUsyOUIsS0FBTCxHQUFhdWhCLFNBQWI7QUFDQWwvQyxXQUFLb1AsT0FBTCxHQUFleXFCLFdBQWY7QUFDRDtBQUNGLEdBdmhCMkI7O0FBeWhCNUJ5NUMsd0JBQXNCLDhCQUFVbjlELEtBQVYsRUFBaUIvRyxPQUFqQixFQUEwQjtBQUM5QyxRQUFJcFAsT0FBTyxLQUFLazdDLFNBQWhCO0FBQ0EsUUFBSXJoRCxRQUFRLEtBQUswL0Isa0JBQWpCO0FBQ0EsUUFBSWo4QixVQUFVLEtBQUtrOEIsb0JBQW5CO0FBQ0EsU0FBS0Esb0JBQUwsR0FBNEIsS0FBNUI7QUFDQSxTQUFLRCxrQkFBTCxHQUEwQixJQUExQjs7QUFFQSxRQUFJLENBQUMxL0IsS0FBTCxFQUFZO0FBQ1YsYUFBT21HLEtBQUsyOUIsS0FBWjtBQUNEOztBQUVELFFBQUlyZ0MsV0FBV3pELE1BQU1LLE1BQU4sS0FBaUIsQ0FBaEMsRUFBbUM7QUFDakMsYUFBT0wsTUFBTSxDQUFOLENBQVA7QUFDRDs7QUFFRCxRQUFJcWxELFlBQVk1ekMsUUFBUSxFQUFSLEVBQVloTyxVQUFVekQsTUFBTSxDQUFOLENBQVYsR0FBcUJtRyxLQUFLMjlCLEtBQXRDLENBQWhCO0FBQ0EsU0FBSyxJQUFJL2lDLElBQUkwQyxVQUFVLENBQVYsR0FBYyxDQUEzQixFQUE4QjFDLElBQUlmLE1BQU1LLE1BQXhDLEVBQWdEVSxHQUFoRCxFQUFxRDtBQUNuRCxVQUFJMDVFLFVBQVV6NkUsTUFBTWUsQ0FBTixDQUFkO0FBQ0EwUSxjQUFRNHpDLFNBQVIsRUFBbUIsT0FBT28xQixPQUFQLEtBQW1CLFVBQW5CLEdBQWdDQSxRQUFRNTZFLElBQVIsQ0FBYXNHLElBQWIsRUFBbUJrL0MsU0FBbkIsRUFBOEIvb0MsS0FBOUIsRUFBcUMvRyxPQUFyQyxDQUFoQyxHQUFnRmtsRSxPQUFuRztBQUNEOztBQUVELFdBQU9wMUIsU0FBUDtBQUNELEdBL2lCMkI7O0FBaWpCNUI7Ozs7Ozs7Ozs7OztBQVlBbTFCLDJCQUF5QixpQ0FBVTk0RCxXQUFWLEVBQXVCZ2xCLFNBQXZCLEVBQWtDMmUsU0FBbEMsRUFBNkNybEIsV0FBN0MsRUFBMEQ1ckIsV0FBMUQsRUFBdUVzbUUsZUFBdkUsRUFBd0Y7QUFDL0csUUFBSXQwQyxTQUFTLElBQWI7O0FBRUEsUUFBSWpnQyxPQUFPLEtBQUtrN0MsU0FBaEI7O0FBRUEsUUFBSXM1Qix3QkFBd0J4aUMsUUFBUWh5QyxLQUFLa3NELGtCQUFiLENBQTVCO0FBQ0EsUUFBSWlvQixTQUFKO0FBQ0EsUUFBSU0sU0FBSjtBQUNBLFFBQUlaLFdBQUo7QUFDQSxRQUFJVyxxQkFBSixFQUEyQjtBQUN6Qkwsa0JBQVluMEUsS0FBS21XLEtBQWpCO0FBQ0FzK0Qsa0JBQVl6MEUsS0FBSzI5QixLQUFqQjtBQUNBazJDLG9CQUFjN3pFLEtBQUtvUCxPQUFuQjtBQUNEOztBQUVELFFBQUlwUCxLQUFLaXNELG1CQUFULEVBQThCO0FBQzVCLFVBQUlwekQsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMwMUUsNkJBQXFCLFlBQVk7QUFDL0IsaUJBQU9yeUUsS0FBS2lzRCxtQkFBTCxDQUF5QjFyQixTQUF6QixFQUFvQzJlLFNBQXBDLEVBQStDcmxCLFdBQS9DLENBQVA7QUFDRCxTQUZELEVBRUcsS0FBS3Z3QixRQUZSLEVBRWtCLHFCQUZsQjtBQUdELE9BSkQsTUFJTztBQUNMdEosYUFBS2lzRCxtQkFBTCxDQUF5QjFyQixTQUF6QixFQUFvQzJlLFNBQXBDLEVBQStDcmxCLFdBQS9DO0FBQ0Q7QUFDRjs7QUFFRCxTQUFLcnJCLGVBQUwsR0FBdUIrTSxXQUF2QjtBQUNBLFNBQUtFLFFBQUwsR0FBZ0I4NEQsZUFBaEI7QUFDQXYwRSxTQUFLbVcsS0FBTCxHQUFhb3FCLFNBQWI7QUFDQXZnQyxTQUFLMjlCLEtBQUwsR0FBYXVoQixTQUFiO0FBQ0FsL0MsU0FBS29QLE9BQUwsR0FBZXlxQixXQUFmOztBQUVBLFNBQUs2NkMsd0JBQUwsQ0FBOEJ6bUUsV0FBOUIsRUFBMkNzbUUsZUFBM0M7O0FBRUEsUUFBSUMscUJBQUosRUFBMkI7QUFDekIsVUFBSTM3RSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3NSLG9CQUFZK00sa0JBQVosR0FBaUNsTSxPQUFqQyxDQUF5QyxZQUFZO0FBQ25EdWpFLCtCQUFxQnJ5RSxLQUFLa3NELGtCQUFMLENBQXdCOTBDLElBQXhCLENBQTZCcFgsSUFBN0IsRUFBbUNtMEUsU0FBbkMsRUFBOENNLFNBQTlDLEVBQXlEWixXQUF6RCxDQUFyQixFQUE0RjV6QyxPQUFPMzJCLFFBQW5HLEVBQTZHLG9CQUE3RztBQUNELFNBRkQ7QUFHRCxPQUpELE1BSU87QUFDTDJFLG9CQUFZK00sa0JBQVosR0FBaUNsTSxPQUFqQyxDQUF5QzlPLEtBQUtrc0Qsa0JBQUwsQ0FBd0I5MEMsSUFBeEIsQ0FBNkJwWCxJQUE3QixFQUFtQ20wRSxTQUFuQyxFQUE4Q00sU0FBOUMsRUFBeURaLFdBQXpELENBQXpDLEVBQWdIN3pFLElBQWhIO0FBQ0Q7QUFDRjtBQUNGLEdBdm1CMkI7O0FBeW1CNUI7Ozs7OztBQU1BMDBFLDRCQUEwQixrQ0FBVXptRSxXQUFWLEVBQXVCbUIsT0FBdkIsRUFBZ0M7QUFDeEQsUUFBSXVsRSx3QkFBd0IsS0FBSzcwRSxrQkFBakM7QUFDQSxRQUFJODBFLHNCQUFzQkQsc0JBQXNCbm1FLGVBQWhEO0FBQ0EsUUFBSXFtRSxzQkFBc0IsS0FBS3RCLHlCQUFMLEVBQTFCOztBQUVBLFFBQUl2b0IsVUFBVSxDQUFkO0FBQ0EsUUFBSW55RCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q3F1RCxnQkFBVSxLQUFLMWhELFFBQWY7QUFDRDs7QUFFRCxRQUFJc3VCLDJCQUEyQmc5QyxtQkFBM0IsRUFBZ0RDLG1CQUFoRCxDQUFKLEVBQTBFO0FBQ3hFbnBFLHNCQUFnQjRQLGdCQUFoQixDQUFpQ3E1RCxxQkFBakMsRUFBd0RFLG1CQUF4RCxFQUE2RTVtRSxXQUE3RSxFQUEwRixLQUFLc3RDLG9CQUFMLENBQTBCbnNDLE9BQTFCLENBQTFGO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsVUFBSTBsRSxjQUFjcHBFLGdCQUFnQnVQLFdBQWhCLENBQTRCMDVELHFCQUE1QixDQUFsQjtBQUNBanBFLHNCQUFnQndQLGdCQUFoQixDQUFpQ3k1RCxxQkFBakMsRUFBd0QsS0FBeEQ7O0FBRUEsVUFBSXAxRSxXQUFXdTBDLGVBQWVJLE9BQWYsQ0FBdUIyZ0MsbUJBQXZCLENBQWY7QUFDQSxXQUFLOTNCLGlCQUFMLEdBQXlCeDlDLFFBQXpCO0FBQ0EsVUFBSTRrQyxRQUFRLEtBQUswUCwwQkFBTCxDQUFnQ2doQyxtQkFBaEMsRUFBcUR0MUUsYUFBYXUwQyxlQUFlRyxLQUFqRixDQUF1RjtBQUF2RixPQUFaO0FBRUEsV0FBS24wQyxrQkFBTCxHQUEwQnFrQyxLQUExQjs7QUFFQSxVQUFJd3NDLGFBQWFqbEUsZ0JBQWdCZ1AsY0FBaEIsQ0FBK0J5cEIsS0FBL0IsRUFBc0NsMkIsV0FBdEMsRUFBbUQsS0FBS3pNLFdBQXhELEVBQXFFLEtBQUsrNEMsa0JBQTFFLEVBQThGLEtBQUtnQixvQkFBTCxDQUEwQm5zQyxPQUExQixDQUE5RixFQUFrSTQ3QyxPQUFsSSxDQUFqQjs7QUFFQSxVQUFJbnlELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFlBQUlxdUQsWUFBWSxDQUFoQixFQUFtQjtBQUNqQixjQUFJd1EsZ0JBQWdCcjNCLE1BQU03NkIsUUFBTixLQUFtQixDQUFuQixHQUF1QixDQUFDNjZCLE1BQU03NkIsUUFBUCxDQUF2QixHQUEwQyxFQUE5RDtBQUNBa1IsK0JBQXFCM1AsU0FBckIsQ0FBK0IvQyxhQUEvQixDQUE2Q2tqRCxPQUE3QyxFQUFzRHdRLGFBQXREO0FBQ0Q7QUFDRjs7QUFFRCxXQUFLdVosc0JBQUwsQ0FBNEJELFdBQTVCLEVBQXlDbkUsVUFBekMsRUFBcURnRSxxQkFBckQ7QUFDRDtBQUNGLEdBaHBCMkI7O0FBa3BCNUI7Ozs7O0FBS0FJLDBCQUF3QixnQ0FBVUQsV0FBVixFQUF1Qm5FLFVBQXZCLEVBQW1DNThDLFlBQW5DLEVBQWlEO0FBQ3ZFaUQsOEJBQTBCQyxxQkFBMUIsQ0FBZ0Q2OUMsV0FBaEQsRUFBNkRuRSxVQUE3RCxFQUF5RTU4QyxZQUF6RTtBQUNELEdBenBCMkI7O0FBMnBCNUI7OztBQUdBaWhELGtEQUFnRCwwREFBWTtBQUMxRCxRQUFJaDFFLE9BQU8sS0FBS2s3QyxTQUFoQjtBQUNBLFFBQUk2M0IsZUFBSjs7QUFFQSxRQUFJbDZFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDbzJFLHdCQUFrQlYscUJBQXFCLFlBQVk7QUFDakQsZUFBT3J5RSxLQUFLeWdDLE1BQUwsRUFBUDtBQUNELE9BRmlCLEVBRWYsS0FBS24zQixRQUZVLEVBRUEsUUFGQSxDQUFsQjtBQUdELEtBSkQsTUFJTztBQUNMeXBFLHdCQUFrQi95RSxLQUFLeWdDLE1BQUwsRUFBbEI7QUFDRDs7QUFFRCxRQUFJNW5DLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDO0FBQ0EsVUFBSW8yRSxvQkFBb0JuMkUsU0FBcEIsSUFBaUNvRCxLQUFLeWdDLE1BQUwsQ0FBWXl1QixlQUFqRCxFQUFrRTtBQUNoRTtBQUNBO0FBQ0E2akIsMEJBQWtCLElBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPQSxlQUFQO0FBQ0QsR0FwckIyQjs7QUFzckI1Qjs7O0FBR0FRLDZCQUEyQixxQ0FBWTtBQUNyQyxRQUFJUixlQUFKO0FBQ0EsUUFBSWw2RSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixJQUF5QyxLQUFLNDFFLGNBQUwsS0FBd0JWLGVBQWVHLG1CQUFwRixFQUF5RztBQUN2R2x0RSx3QkFBa0J1RSxPQUFsQixHQUE0QixJQUE1QjtBQUNBLFVBQUk7QUFDRjBwRSwwQkFBa0IsS0FBS2lDLDhDQUFMLEVBQWxCO0FBQ0QsT0FGRCxTQUVVO0FBQ1Jsd0UsMEJBQWtCdUUsT0FBbEIsR0FBNEIsSUFBNUI7QUFDRDtBQUNGLEtBUEQsTUFPTztBQUNMMHBFLHdCQUFrQixLQUFLaUMsOENBQUwsRUFBbEI7QUFDRDtBQUNEO0FBQ0E7QUFDQWpDLHdCQUFvQixJQUFwQixJQUE0QkEsb0JBQW9CLEtBQWhELElBQXlEcDVELE1BQU16TyxjQUFOLENBQXFCNm5FLGVBQXJCLENBRnpELElBRWtHbDZFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsd0lBQWpCLEVBQTJKLEtBQUtzTSxPQUFMLE1BQWtCLHlCQUE3SyxDQUF4QyxHQUFrUDFLLGVBQWUsS0FBZixFQUFzQixLQUFLMEssT0FBTCxNQUFrQix5QkFBeEMsQ0FGcFYsR0FFeVosS0FBSyxDQUY5Wjs7QUFJQSxXQUFPNHBFLGVBQVA7QUFDRCxHQTFzQjJCOztBQTRzQjVCOzs7Ozs7OztBQVFBcGMsYUFBVyxtQkFBVXBoRCxHQUFWLEVBQWUzVixTQUFmLEVBQTBCO0FBQ25DLFFBQUlJLE9BQU8sS0FBSytPLGlCQUFMLEVBQVg7QUFDQSxNQUFFL08sUUFBUSxJQUFWLElBQWtCbkgsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQixpREFBakIsQ0FBeEMsR0FBOEc0QixlQUFlLEtBQWYsQ0FBaEksR0FBd0osS0FBSyxDQUE3SjtBQUNBLFFBQUl3MkUsMEJBQTBCcjFFLFVBQVVtUCxpQkFBVixFQUE5QjtBQUNBLFFBQUlsVyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJdzVCLGdCQUFnQnYyQixhQUFhQSxVQUFVdUosT0FBdkIsR0FBaUN2SixVQUFVdUosT0FBVixFQUFqQyxHQUF1RCxhQUEzRTtBQUNBdFEsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVF1M0UsMkJBQTJCLElBQTNCLElBQW1DcjFFLFVBQVUyeUUsY0FBVixLQUE2QlYsZUFBZUcsbUJBQXZGLEVBQTRHLHdEQUF3RCxzQ0FBeEQsR0FBaUcsd0NBQTdNLEVBQXVQejhELEdBQXZQLEVBQTRQNGdCLGFBQTVQLEVBQTJRLEtBQUtodEIsT0FBTCxFQUEzUSxDQUF4QyxHQUFxVSxLQUFLLENBQTFVO0FBQ0Q7QUFDRCxRQUFJazVCLE9BQU9yaUMsS0FBS3FpQyxJQUFMLEtBQWMxZSxXQUFkLEdBQTRCM2pCLEtBQUtxaUMsSUFBTCxHQUFZLEVBQXhDLEdBQTZDcmlDLEtBQUtxaUMsSUFBN0Q7QUFDQUEsU0FBSzlzQixHQUFMLElBQVkwL0QsdUJBQVo7QUFDRCxHQTl0QjJCOztBQWd1QjVCOzs7Ozs7O0FBT0FwZSxhQUFXLG1CQUFVdGhELEdBQVYsRUFBZTtBQUN4QixRQUFJOHNCLE9BQU8sS0FBS3R6QixpQkFBTCxHQUF5QnN6QixJQUFwQztBQUNBLFdBQU9BLEtBQUs5c0IsR0FBTCxDQUFQO0FBQ0QsR0ExdUIyQjs7QUE0dUI1Qjs7Ozs7O0FBTUFwTSxXQUFTLG1CQUFZO0FBQ25CLFFBQUk3QixPQUFPLEtBQUtrSCxlQUFMLENBQXFCbEgsSUFBaEM7QUFDQSxRQUFJNkosY0FBYyxLQUFLK3BDLFNBQUwsSUFBa0IsS0FBS0EsU0FBTCxDQUFlL3BDLFdBQW5EO0FBQ0EsV0FBTzdKLEtBQUtDLFdBQUwsSUFBb0I0SixlQUFlQSxZQUFZNUosV0FBL0MsSUFBOERELEtBQUtuTCxJQUFuRSxJQUEyRWdWLGVBQWVBLFlBQVloVixJQUF0RyxJQUE4RyxJQUFySDtBQUNELEdBdHZCMkI7O0FBd3ZCNUI7Ozs7Ozs7O0FBUUE0UyxxQkFBbUIsNkJBQVk7QUFDN0IsUUFBSS9PLE9BQU8sS0FBS2s3QyxTQUFoQjtBQUNBLFFBQUksS0FBS3EzQixjQUFMLEtBQXdCVixlQUFlRyxtQkFBM0MsRUFBZ0U7QUFDOUQsYUFBTyxJQUFQO0FBQ0Q7QUFDRCxXQUFPaHlFLElBQVA7QUFDRCxHQXR3QjJCOztBQXd3QjVCO0FBQ0E2ekMsOEJBQTRCO0FBendCQSxDQUE5Qjs7QUE0d0JBLzZDLE9BQU9DLE9BQVAsR0FBaUJnNkMsdUJBQWpCLEM7Ozs7Ozs7O0FDbDRCQTs7Ozs7Ozs7OztBQVVBOzs7O0FBRUEsSUFBSXQwQyxpQkFBaUIsbUJBQUFoQixDQUFRLENBQVIsQ0FBckI7O0FBRUEsSUFBSXF0RCw2QkFBNkIsbUJBQUFydEQsQ0FBUSxHQUFSLENBQWpDO0FBQ0EsSUFBSXl4Qix1QkFBdUIsbUJBQUF6eEIsQ0FBUSxFQUFSLENBQTNCOztBQUVBLElBQUlaLFlBQVksbUJBQUFZLENBQVEsQ0FBUixDQUFoQjtBQUNBLElBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUlnSyxzQkFBSjs7QUFFQSxJQUFJLE9BQU81TyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDQSxRQUFRdUMsR0FBMUMsSUFBaUR2QyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixNQUE5RSxFQUFzRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E4SywyQkFBeUIsbUJBQUFoSyxDQUFRLENBQVIsQ0FBekI7QUFDRDs7QUFFRCxJQUFJNDRCLHFCQUFxQixFQUF6Qjs7QUFFQTs7Ozs7Ozs7Ozs7O0FBWUEsU0FBU2tOLGtCQUFULENBQTRCd25CLFNBQTVCLEVBQXVDaHBCLE1BQXZDLEVBQStDcmUsUUFBL0MsRUFBeUR5UyxhQUF6RCxFQUF3RTl1QixPQUF4RSxFQUFpRjJqRCxPQUFqRixFQUEwRjtBQUN4RixPQUFLLElBQUlDLFlBQVQsSUFBeUJGLFNBQXpCLEVBQW9DO0FBQ2xDLFFBQUlBLFVBQVVucUQsY0FBVixDQUF5QnFxRCxZQUF6QixDQUFKLEVBQTRDO0FBQzFDLFVBQUk3dEQsS0FBSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQUk7QUFDRjtBQUNBO0FBQ0EsVUFBRSxPQUFPMnRELFVBQVVFLFlBQVYsQ0FBUCxLQUFtQyxVQUFyQyxJQUFtRHB5RCxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLG1GQUFqQixFQUFzR3M1QixpQkFBaUIsYUFBdkgsRUFBc0kyMEIsMkJBQTJCcG5DLFFBQTNCLENBQXRJLEVBQTRLdW5DLFlBQTVLLENBQXhDLEdBQW9PeHNELGVBQWUsSUFBZixFQUFxQjAzQixpQkFBaUIsYUFBdEMsRUFBcUQyMEIsMkJBQTJCcG5DLFFBQTNCLENBQXJELEVBQTJGdW5DLFlBQTNGLENBQXZSLEdBQWtZLEtBQUssQ0FBdlk7QUFDQTd0RCxnQkFBUTJ0RCxVQUFVRSxZQUFWLEVBQXdCbHBCLE1BQXhCLEVBQWdDa3BCLFlBQWhDLEVBQThDOTBCLGFBQTlDLEVBQTZEelMsUUFBN0QsRUFBdUUsSUFBdkUsRUFBNkV3TCxvQkFBN0UsQ0FBUjtBQUNELE9BTEQsQ0FLRSxPQUFPZzhCLEVBQVAsRUFBVztBQUNYOXRELGdCQUFROHRELEVBQVI7QUFDRDtBQUNEcnlELGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLENBQUNOLEtBQUQsSUFBVUEsaUJBQWlCakUsS0FBbkMsRUFBMEMsb0VBQW9FLCtEQUFwRSxHQUFzSSxpRUFBdEksR0FBME0sZ0VBQTFNLEdBQTZRLGlDQUF2VCxFQUEwVmc5QixpQkFBaUIsYUFBM1csRUFBMFgyMEIsMkJBQTJCcG5DLFFBQTNCLENBQTFYLEVBQWdhdW5DLFlBQWhhLFNBQXFiN3RELEtBQXJiLHlDQUFxYkEsS0FBcmIsRUFBeEMsR0FBc2UsS0FBSyxDQUEzZTtBQUNBLFVBQUlBLGlCQUFpQmpFLEtBQWpCLElBQTBCLEVBQUVpRSxNQUFNVSxPQUFOLElBQWlCdTRCLGtCQUFuQixDQUE5QixFQUFzRTtBQUNwRTtBQUNBO0FBQ0FBLDJCQUFtQmo1QixNQUFNVSxPQUF6QixJQUFvQyxJQUFwQzs7QUFFQSxZQUFJcXRELHFCQUFxQixFQUF6Qjs7QUFFQSxZQUFJdHlELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLGNBQUksQ0FBQzhLLHNCQUFMLEVBQTZCO0FBQzNCQSxxQ0FBeUIsbUJBQUFoSyxDQUFRLENBQVIsQ0FBekI7QUFDRDtBQUNELGNBQUl1dEQsWUFBWSxJQUFoQixFQUFzQjtBQUNwQkcsaUNBQXFCMWpELHVCQUF1QjhCLG9CQUF2QixDQUE0Q3loRCxPQUE1QyxDQUFyQjtBQUNELFdBRkQsTUFFTyxJQUFJM2pELFlBQVksSUFBaEIsRUFBc0I7QUFDM0I4akQsaUNBQXFCMWpELHVCQUF1QnFCLHVCQUF2QixDQUErQ3pCLE9BQS9DLENBQXJCO0FBQ0Q7QUFDRjs7QUFFRHhPLGdCQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsc0JBQWYsRUFBdUNnbUIsUUFBdkMsRUFBaUR0bUIsTUFBTVUsT0FBdkQsRUFBZ0VxdEQsa0JBQWhFLENBQXhDLEdBQThILEtBQUssQ0FBbkk7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRHJ5RCxPQUFPQyxPQUFQLEdBQWlCd3FDLGtCQUFqQixDOzs7Ozs7OztBQ3JGQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJdW5CLDZCQUE2QixFQUFqQzs7QUFFQSxJQUFJanlELFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDbXVELCtCQUE2QjtBQUMzQjc0QyxVQUFNLE1BRHFCO0FBRTNCN0MsYUFBUyxTQUZrQjtBQUczQmc4QyxrQkFBYztBQUhhLEdBQTdCO0FBS0Q7O0FBRUR0eUQsT0FBT0MsT0FBUCxHQUFpQit4RCwwQkFBakIsQzs7Ozs7Ozs7QUN2QkE7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUEsSUFBSW9xQixjQUFjLENBQWxCOztBQUVBLFNBQVNoaUMsY0FBVCxHQUEwQjtBQUN4QixTQUFPZ2lDLGFBQVA7QUFDRDs7QUFFRHA4RSxPQUFPQyxPQUFQLEdBQWlCbTZDLGNBQWpCLEM7Ozs7Ozs7QUNuQkE7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7QUFDQTs7QUFFQSxJQUFJbm9DLHFCQUFxQixPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxPQUFPLEtBQVAsQ0FBaEMsSUFBaURBLE9BQU8sS0FBUCxFQUFjLGVBQWQsQ0FBakQsSUFBbUYsTUFBNUc7O0FBRUFsUyxPQUFPQyxPQUFQLEdBQWlCZ1Msa0JBQWpCLEM7Ozs7Ozs7QUNsQkE7Ozs7Ozs7Ozs7O0FBV0E7O0FBRUE7O0FBRUEsSUFBSWs0QixrQkFBa0IsT0FBT2o0QixNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxPQUFPazRCLFFBQTdEO0FBQ0EsSUFBSUMsdUJBQXVCLFlBQTNCLEMsQ0FBeUM7O0FBRXpDOzs7Ozs7Ozs7Ozs7OztBQWNBLFNBQVNDLGFBQVQsQ0FBdUJDLGFBQXZCLEVBQXNDO0FBQ3BDLE1BQUlDLGFBQWFELGtCQUFrQkosbUJBQW1CSSxjQUFjSixlQUFkLENBQW5CLElBQXFESSxjQUFjRixvQkFBZCxDQUF2RSxDQUFqQjtBQUNBLE1BQUksT0FBT0csVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNwQyxXQUFPQSxVQUFQO0FBQ0Q7QUFDRjs7QUFFRHhxQyxPQUFPQyxPQUFQLEdBQWlCcXFDLGFBQWpCLEM7Ozs7Ozs7QUN2Q0E7Ozs7Ozs7Ozs7O0FBV0E7Ozs7QUFFQSxJQUFJNUssaUJBQWlCLG1CQUFBLzZCLENBQVEsRUFBUixDQUFyQjtBQUNBLElBQUltNEMsc0JBQXNCLG1CQUFBbjRDLENBQVEsRUFBUixDQUExQjtBQUNBLElBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUlnSyxzQkFBSjs7QUFFQSxJQUFJLE9BQU81TyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDQSxRQUFRdUMsR0FBMUMsSUFBaUR2QyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixNQUE5RSxFQUFzRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E4SywyQkFBeUIsbUJBQUFoSyxDQUFRLENBQVIsQ0FBekI7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBUzAzRSw2QkFBVCxDQUF1Q2hnQyxlQUF2QyxFQUF3RGhSLEtBQXhELEVBQStEaG9DLElBQS9ELEVBQXFFazBFLFdBQXJFLEVBQWtGO0FBQ2hGO0FBQ0EsTUFBSWw3QixtQkFBbUIsUUFBT0EsZUFBUCx5Q0FBT0EsZUFBUCxPQUEyQixRQUFsRCxFQUE0RDtBQUMxRCxRQUFJdGlDLFNBQVNzaUMsZUFBYjtBQUNBLFFBQUlvOEIsWUFBWTErRCxPQUFPMVcsSUFBUCxNQUFpQlMsU0FBakM7QUFDQSxRQUFJL0QsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsVUFBSSxDQUFDOEssc0JBQUwsRUFBNkI7QUFDM0JBLGlDQUF5QixtQkFBQWhLLENBQVEsQ0FBUixDQUF6QjtBQUNEO0FBQ0QsVUFBSSxDQUFDOHpFLFNBQUwsRUFBZ0I7QUFDZDE0RSxnQkFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLHVFQUF1RSx1RUFBdkUsR0FBaUosaUNBQWhLLEVBQW1NODZCLGVBQWVKLFFBQWYsQ0FBd0JqOEIsSUFBeEIsQ0FBbk0sRUFBa09zTCx1QkFBdUI4QixvQkFBdkIsQ0FBNEM4bUUsV0FBNUMsQ0FBbE8sQ0FBeEMsR0FBc1UsS0FBSyxDQUEzVTtBQUNEO0FBQ0Y7QUFDRCxRQUFJa0IsYUFBYXB0QyxTQUFTLElBQTFCLEVBQWdDO0FBQzlCdHhCLGFBQU8xVyxJQUFQLElBQWVnb0MsS0FBZjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7QUFLQSxTQUFTZ3JDLGVBQVQsQ0FBeUI1dUUsUUFBekIsRUFBbUM4dkUsV0FBbkMsRUFBZ0Q7QUFDOUMsTUFBSTl2RSxZQUFZLElBQWhCLEVBQXNCO0FBQ3BCLFdBQU9BLFFBQVA7QUFDRDtBQUNELE1BQUlzUyxTQUFTLEVBQWI7O0FBRUEsTUFBSWhhLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDaTVDLHdCQUFvQnIxQyxRQUFwQixFQUE4QixVQUFVNDBDLGVBQVYsRUFBMkJoUixLQUEzQixFQUFrQ2hvQyxJQUFsQyxFQUF3QztBQUNwRSxhQUFPZzVFLDhCQUE4QmhnQyxlQUE5QixFQUErQ2hSLEtBQS9DLEVBQXNEaG9DLElBQXRELEVBQTREazBFLFdBQTVELENBQVA7QUFDRCxLQUZELEVBRUd4OUQsTUFGSDtBQUdELEdBSkQsTUFJTztBQUNMK2lDLHdCQUFvQnIxQyxRQUFwQixFQUE4QjQwRSw2QkFBOUIsRUFBNkR0aUUsTUFBN0Q7QUFDRDtBQUNELFNBQU9BLE1BQVA7QUFDRDs7QUFFRC9aLE9BQU9DLE9BQVAsR0FBaUJvMkUsZUFBakIsQzs7Ozs7Ozs7QUMxRUE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJN2pFLFVBQVUsbUJBQUE3TixDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJK04sY0FBYyxtQkFBQS9OLENBQVEsRUFBUixDQUFsQjtBQUNBLElBQUlrTyxjQUFjLG1CQUFBbE8sQ0FBUSxFQUFSLENBQWxCO0FBQ0EsSUFBSStjLHVCQUF1QixtQkFBQS9jLENBQVEsRUFBUixDQUEzQjtBQUNBLElBQUkyM0UseUJBQXlCLG1CQUFBMzNFLENBQVEsR0FBUixDQUE3Qjs7QUFFQTs7Ozs7QUFLQSxJQUFJc1AsdUJBQXVCLEVBQTNCOztBQUVBLElBQUlsVSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q29RLHVCQUFxQmxTLElBQXJCLENBQTBCO0FBQ3hCeVIsZ0JBQVlrTyxxQkFBcUIzUCxTQUFyQixDQUErQjh1QyxZQURuQjtBQUV4Qm50QyxXQUFPZ08scUJBQXFCM1AsU0FBckIsQ0FBK0IrdUM7QUFGZCxHQUExQjtBQUlEOztBQUVELElBQUl5N0Isb0JBQW9CO0FBQ3RCdm1FLFdBQVMsbUJBQVksQ0FBRTtBQURELENBQXhCOztBQUlBOzs7O0FBSUEsU0FBU20yRCwrQkFBVCxDQUF5Q2lFLG9CQUF6QyxFQUErRDtBQUM3RCxPQUFLajhELHVCQUFMO0FBQ0EsT0FBS2k4RCxvQkFBTCxHQUE0QkEsb0JBQTVCO0FBQ0EsT0FBS3p2QixnQkFBTCxHQUF3QixLQUF4QjtBQUNBLE9BQUtzMkIsV0FBTCxHQUFtQixJQUFJcUYsc0JBQUosQ0FBMkIsSUFBM0IsQ0FBbkI7QUFDRDs7QUFFRCxJQUFJbE4sUUFBUTtBQUNWOzs7Ozs7QUFNQS82RCwwQkFBd0Isa0NBQVk7QUFDbEMsV0FBT0osb0JBQVA7QUFDRCxHQVRTOztBQVdWOzs7QUFHQWlPLHNCQUFvQiw4QkFBWTtBQUM5QixXQUFPcTZELGlCQUFQO0FBQ0QsR0FoQlM7O0FBa0JWOzs7QUFHQXpDLGtCQUFnQiwwQkFBWTtBQUMxQixXQUFPLEtBQUs3QyxXQUFaO0FBQ0QsR0F2QlM7O0FBeUJWOzs7O0FBSUEzaUUsY0FBWSxzQkFBWSxDQUFFLENBN0JoQjs7QUErQlZ5N0IsY0FBWSxzQkFBWSxDQUFFLENBL0JoQjs7QUFpQ1ZDLFlBQVUsb0JBQVksQ0FBRTtBQWpDZCxDQUFaOztBQW9DQXg5QixRQUFRMjVELGdDQUFnQ2pxRSxTQUF4QyxFQUFtRDJRLFdBQW5ELEVBQWdFdThELEtBQWhFOztBQUVBMThELFlBQVlpQyxZQUFaLENBQXlCdzNELCtCQUF6Qjs7QUFFQW5zRSxPQUFPQyxPQUFQLEdBQWlCa3NFLCtCQUFqQixDOzs7Ozs7OztBQ3hGQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxTQUFTdG1DLGVBQVQsQ0FBeUI3bUIsUUFBekIsRUFBbUM4bUIsV0FBbkMsRUFBZ0Q7QUFBRSxNQUFJLEVBQUU5bUIsb0JBQW9COG1CLFdBQXRCLENBQUosRUFBd0M7QUFBRSxVQUFNLElBQUk1OEIsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosSUFBSTgyQixtQkFBbUIsbUJBQUFyN0IsQ0FBUSxFQUFSLENBQXZCOztBQUVBLElBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLFNBQVN1bEMsUUFBVCxDQUFrQnJLLGNBQWxCLEVBQWtDQyxVQUFsQyxFQUE4QztBQUM1QyxNQUFJLy9CLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDLFFBQUl3VSxjQUFjd25CLGVBQWV4bkIsV0FBakM7QUFDQXRZLFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSxvREFBb0QsaUZBQXBELEdBQXdJLDhEQUF2SixFQUF1Tms3QixVQUF2TixFQUFtT0EsVUFBbk8sRUFBK096bkIsZ0JBQWdCQSxZQUFZNUosV0FBWixJQUEyQjRKLFlBQVloVixJQUF2RCxLQUFnRSxZQUEvUyxDQUF4QyxHQUF1VyxLQUFLLENBQTVXO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7QUFRQSxJQUFJaTVFLHlCQUF5QixZQUFZO0FBQ3ZDLFdBQVNBLHNCQUFULENBQWdDbm5FLFdBQWhDLEVBQTZDO0FBQzNDMHdCLG9CQUFnQixJQUFoQixFQUFzQnkyQyxzQkFBdEI7O0FBRUEsU0FBS25uRSxXQUFMLEdBQW1CQSxXQUFuQjtBQUNEOztBQUVEOzs7Ozs7OztBQVNBbW5FLHlCQUF1QnA2RSxTQUF2QixDQUFpQ2tOLFNBQWpDLEdBQTZDLFNBQVNBLFNBQVQsQ0FBbUJ5d0IsY0FBbkIsRUFBbUM7QUFDOUUsV0FBTyxLQUFQO0FBQ0QsR0FGRDs7QUFJQTs7Ozs7Ozs7O0FBVUF5OEMseUJBQXVCcDZFLFNBQXZCLENBQWlDZytCLGVBQWpDLEdBQW1ELFNBQVNBLGVBQVQsQ0FBeUJMLGNBQXpCLEVBQXlDaHJCLFFBQXpDLEVBQW1EaXJCLFVBQW5ELEVBQStEO0FBQ2hILFFBQUksS0FBSzNxQixXQUFMLENBQWlCd1gsZUFBakIsRUFBSixFQUF3QztBQUN0Q3FULHVCQUFpQkUsZUFBakIsQ0FBaUNMLGNBQWpDLEVBQWlEaHJCLFFBQWpELEVBQTJEaXJCLFVBQTNEO0FBQ0Q7QUFDRixHQUpEOztBQU1BOzs7Ozs7Ozs7Ozs7OztBQWVBdzhDLHlCQUF1QnA2RSxTQUF2QixDQUFpQ20rQixrQkFBakMsR0FBc0QsU0FBU0Esa0JBQVQsQ0FBNEJSLGNBQTVCLEVBQTRDO0FBQ2hHLFFBQUksS0FBSzFxQixXQUFMLENBQWlCd1gsZUFBakIsRUFBSixFQUF3QztBQUN0Q3FULHVCQUFpQkssa0JBQWpCLENBQW9DUixjQUFwQztBQUNELEtBRkQsTUFFTztBQUNMcUssZUFBU3JLLGNBQVQsRUFBeUIsYUFBekI7QUFDRDtBQUNGLEdBTkQ7O0FBUUE7Ozs7Ozs7Ozs7OztBQWFBeThDLHlCQUF1QnA2RSxTQUF2QixDQUFpQ3ErQixtQkFBakMsR0FBdUQsU0FBU0EsbUJBQVQsQ0FBNkJWLGNBQTdCLEVBQTZDVyxhQUE3QyxFQUE0RDtBQUNqSCxRQUFJLEtBQUtyckIsV0FBTCxDQUFpQndYLGVBQWpCLEVBQUosRUFBd0M7QUFDdENxVCx1QkFBaUJPLG1CQUFqQixDQUFxQ1YsY0FBckMsRUFBcURXLGFBQXJEO0FBQ0QsS0FGRCxNQUVPO0FBQ0wwSixlQUFTckssY0FBVCxFQUF5QixjQUF6QjtBQUNEO0FBQ0YsR0FORDs7QUFRQTs7Ozs7Ozs7Ozs7QUFZQXk4Qyx5QkFBdUJwNkUsU0FBdkIsQ0FBaUN5K0IsZUFBakMsR0FBbUQsU0FBU0EsZUFBVCxDQUF5QmQsY0FBekIsRUFBeUNlLFlBQXpDLEVBQXVEO0FBQ3hHLFFBQUksS0FBS3pyQixXQUFMLENBQWlCd1gsZUFBakIsRUFBSixFQUF3QztBQUN0Q3FULHVCQUFpQlcsZUFBakIsQ0FBaUNkLGNBQWpDLEVBQWlEZSxZQUFqRDtBQUNELEtBRkQsTUFFTztBQUNMc0osZUFBU3JLLGNBQVQsRUFBeUIsVUFBekI7QUFDRDtBQUNGLEdBTkQ7O0FBUUEsU0FBT3k4QyxzQkFBUDtBQUNELENBckc0QixFQUE3Qjs7QUF1R0F0OEUsT0FBT0MsT0FBUCxHQUFpQnE4RSxzQkFBakIsQzs7Ozs7Ozs7QUN6SUE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJOXBFLFVBQVUsbUJBQUE3TixDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJK2YsY0FBYyxtQkFBQS9mLENBQVEsRUFBUixDQUFsQjtBQUNBLElBQUlnRSx3QkFBd0IsbUJBQUFoRSxDQUFRLENBQVIsQ0FBNUI7O0FBRUEsSUFBSTB6RCx5QkFBeUIsU0FBekJBLHNCQUF5QixDQUFVN2MsV0FBVixFQUF1QjtBQUNsRDtBQUNBLE9BQUs5bEMsZUFBTCxHQUF1QixJQUF2QjtBQUNBO0FBQ0EsT0FBS3RPLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxPQUFLc0IsV0FBTCxHQUFtQixJQUFuQjtBQUNBLE9BQUsrNEMsa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSxPQUFLeDVDLE1BQUwsR0FBYyxDQUFkO0FBQ0QsQ0FSRDtBQVNBdUssUUFBUTZsRCx1QkFBdUJuMkQsU0FBL0IsRUFBMEM7QUFDeEMwZixrQkFBZ0Isd0JBQVV6TSxXQUFWLEVBQXVCMk0sVUFBdkIsRUFBbUNDLGlCQUFuQyxFQUFzRHpMLE9BQXRELEVBQStEO0FBQzdFLFFBQUlrbUUsUUFBUXo2RCxrQkFBa0JzdEQsVUFBbEIsRUFBWjtBQUNBLFNBQUtwbkUsTUFBTCxHQUFjdTBFLEtBQWQ7QUFDQSxTQUFLOXpFLFdBQUwsR0FBbUJvWixVQUFuQjtBQUNBLFNBQUsyL0Isa0JBQUwsR0FBMEIxL0IsaUJBQTFCOztBQUVBLFFBQUluYixZQUFZLG1CQUFtQixLQUFLcUIsTUFBeEIsR0FBaUMsR0FBakQ7QUFDQSxRQUFJa04sWUFBWXdyQyxnQkFBaEIsRUFBa0M7QUFDaEMsVUFBSXozQixnQkFBZ0JuSCxrQkFBa0IyckQsY0FBdEM7QUFDQSxVQUFJbm5FLE9BQU8yaUIsY0FBY3V6RCxhQUFkLENBQTRCNzFFLFNBQTVCLENBQVg7QUFDQStCLDRCQUFzQjFCLFlBQXRCLENBQW1DLElBQW5DLEVBQXlDVixJQUF6QztBQUNBLGFBQU9tZSxZQUFZbmUsSUFBWixDQUFQO0FBQ0QsS0FMRCxNQUtPO0FBQ0wsVUFBSTRPLFlBQVlpN0Qsb0JBQWhCLEVBQXNDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGVBQU8sRUFBUDtBQUNEO0FBQ0QsYUFBTyxTQUFTeHBFLFNBQVQsR0FBcUIsS0FBNUI7QUFDRDtBQUNGLEdBdEJ1QztBQXVCeEM0YixvQkFBa0IsNEJBQVksQ0FBRSxDQXZCUTtBQXdCeENMLGVBQWEsdUJBQVk7QUFDdkIsV0FBT3haLHNCQUFzQkYsbUJBQXRCLENBQTBDLElBQTFDLENBQVA7QUFDRCxHQTFCdUM7QUEyQnhDMlosb0JBQWtCLDRCQUFZO0FBQzVCelosMEJBQXNCdEIsV0FBdEIsQ0FBa0MsSUFBbEM7QUFDRDtBQTdCdUMsQ0FBMUM7O0FBZ0NBckgsT0FBT0MsT0FBUCxHQUFpQm80RCxzQkFBakIsQzs7Ozs7OztBQzFEQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUkxeUQsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCOztBQUVBLElBQUlaLFlBQVksbUJBQUFZLENBQVEsQ0FBUixDQUFoQjs7QUFFQTs7OztBQUlBLFNBQVNneUIsdUJBQVQsQ0FBaUMrbEQsS0FBakMsRUFBd0NDLEtBQXhDLEVBQStDO0FBQzdDLElBQUUsZUFBZUQsS0FBakIsSUFBMEIzOEUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQix3Q0FBakIsQ0FBeEMsR0FBcUc0QixlQUFlLElBQWYsQ0FBL0gsR0FBc0osS0FBSyxDQUEzSjtBQUNBLElBQUUsZUFBZWczRSxLQUFqQixJQUEwQjU4RSxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLHdDQUFqQixDQUF4QyxHQUFxRzRCLGVBQWUsSUFBZixDQUEvSCxHQUFzSixLQUFLLENBQTNKOztBQUVBLE1BQUlpM0UsU0FBUyxDQUFiO0FBQ0EsT0FBSyxJQUFJQyxRQUFRSCxLQUFqQixFQUF3QkcsS0FBeEIsRUFBK0JBLFFBQVFBLE1BQU1uMEUsV0FBN0MsRUFBMEQ7QUFDeERrMEU7QUFDRDtBQUNELE1BQUlFLFNBQVMsQ0FBYjtBQUNBLE9BQUssSUFBSUMsUUFBUUosS0FBakIsRUFBd0JJLEtBQXhCLEVBQStCQSxRQUFRQSxNQUFNcjBFLFdBQTdDLEVBQTBEO0FBQ3hEbzBFO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFPRixTQUFTRSxNQUFULEdBQWtCLENBQXpCLEVBQTRCO0FBQzFCSixZQUFRQSxNQUFNaDBFLFdBQWQ7QUFDQWswRTtBQUNEOztBQUVEO0FBQ0EsU0FBT0UsU0FBU0YsTUFBVCxHQUFrQixDQUF6QixFQUE0QjtBQUMxQkQsWUFBUUEsTUFBTWowRSxXQUFkO0FBQ0FvMEU7QUFDRDs7QUFFRDtBQUNBLE1BQUlFLFFBQVFKLE1BQVo7QUFDQSxTQUFPSSxPQUFQLEVBQWdCO0FBQ2QsUUFBSU4sVUFBVUMsS0FBZCxFQUFxQjtBQUNuQixhQUFPRCxLQUFQO0FBQ0Q7QUFDREEsWUFBUUEsTUFBTWgwRSxXQUFkO0FBQ0FpMEUsWUFBUUEsTUFBTWowRSxXQUFkO0FBQ0Q7QUFDRCxTQUFPLElBQVA7QUFDRDs7QUFFRDs7O0FBR0EsU0FBU2d1QixVQUFULENBQW9CZ21ELEtBQXBCLEVBQTJCQyxLQUEzQixFQUFrQztBQUNoQyxJQUFFLGVBQWVELEtBQWpCLElBQTBCMzhFLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsK0JBQWpCLENBQXhDLEdBQTRGNEIsZUFBZSxJQUFmLENBQXRILEdBQTZJLEtBQUssQ0FBbEo7QUFDQSxJQUFFLGVBQWVnM0UsS0FBakIsSUFBMEI1OEUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NFLFVBQVUsS0FBVixFQUFpQiwrQkFBakIsQ0FBeEMsR0FBNEY0QixlQUFlLElBQWYsQ0FBdEgsR0FBNkksS0FBSyxDQUFsSjs7QUFFQSxTQUFPZzNFLEtBQVAsRUFBYztBQUNaLFFBQUlBLFVBQVVELEtBQWQsRUFBcUI7QUFDbkIsYUFBTyxJQUFQO0FBQ0Q7QUFDREMsWUFBUUEsTUFBTWowRSxXQUFkO0FBQ0Q7QUFDRCxTQUFPLEtBQVA7QUFDRDs7QUFFRDs7O0FBR0EsU0FBU21kLGlCQUFULENBQTJCM2UsSUFBM0IsRUFBaUM7QUFDL0IsSUFBRSxlQUFlQSxJQUFqQixJQUF5Qm5ILFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIsc0NBQWpCLENBQXhDLEdBQW1HNEIsZUFBZSxJQUFmLENBQTVILEdBQW1KLEtBQUssQ0FBeEo7O0FBRUEsU0FBT3VCLEtBQUt3QixXQUFaO0FBQ0Q7O0FBRUQ7OztBQUdBLFNBQVNnZCxnQkFBVCxDQUEwQnhlLElBQTFCLEVBQWdDZ0YsRUFBaEMsRUFBb0NzRixHQUFwQyxFQUF5QztBQUN2QyxNQUFJc1ksT0FBTyxFQUFYO0FBQ0EsU0FBTzVpQixJQUFQLEVBQWE7QUFDWDRpQixTQUFLL25CLElBQUwsQ0FBVW1GLElBQVY7QUFDQUEsV0FBT0EsS0FBS3dCLFdBQVo7QUFDRDtBQUNELE1BQUk1RyxDQUFKO0FBQ0EsT0FBS0EsSUFBSWdvQixLQUFLMW9CLE1BQWQsRUFBc0JVLE1BQU0sQ0FBNUIsR0FBZ0M7QUFDOUJvSyxPQUFHNGQsS0FBS2hvQixDQUFMLENBQUgsRUFBWSxVQUFaLEVBQXdCMFAsR0FBeEI7QUFDRDtBQUNELE9BQUsxUCxJQUFJLENBQVQsRUFBWUEsSUFBSWdvQixLQUFLMW9CLE1BQXJCLEVBQTZCVSxHQUE3QixFQUFrQztBQUNoQ29LLE9BQUc0ZCxLQUFLaG9CLENBQUwsQ0FBSCxFQUFZLFNBQVosRUFBdUIwUCxHQUF2QjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTK1Usa0JBQVQsQ0FBNEJsYyxJQUE1QixFQUFrQ0MsRUFBbEMsRUFBc0M0QixFQUF0QyxFQUEwQytyQixPQUExQyxFQUFtREMsS0FBbkQsRUFBMEQ7QUFDeEQsTUFBSStrRCxTQUFTNXlFLFFBQVFDLEVBQVIsR0FBYXFzQix3QkFBd0J0c0IsSUFBeEIsRUFBOEJDLEVBQTlCLENBQWIsR0FBaUQsSUFBOUQ7QUFDQSxNQUFJNHlFLFdBQVcsRUFBZjtBQUNBLFNBQU83eUUsUUFBUUEsU0FBUzR5RSxNQUF4QixFQUFnQztBQUM5QkMsYUFBU243RSxJQUFULENBQWNzSSxJQUFkO0FBQ0FBLFdBQU9BLEtBQUszQixXQUFaO0FBQ0Q7QUFDRCxNQUFJeTBFLFNBQVMsRUFBYjtBQUNBLFNBQU83eUUsTUFBTUEsT0FBTzJ5RSxNQUFwQixFQUE0QjtBQUMxQkUsV0FBT3A3RSxJQUFQLENBQVl1SSxFQUFaO0FBQ0FBLFNBQUtBLEdBQUc1QixXQUFSO0FBQ0Q7QUFDRCxNQUFJNUcsQ0FBSjtBQUNBLE9BQUtBLElBQUksQ0FBVCxFQUFZQSxJQUFJbzdFLFNBQVM5N0UsTUFBekIsRUFBaUNVLEdBQWpDLEVBQXNDO0FBQ3BDb0ssT0FBR2d4RSxTQUFTcDdFLENBQVQsQ0FBSCxFQUFnQixTQUFoQixFQUEyQm0yQixPQUEzQjtBQUNEO0FBQ0QsT0FBS24yQixJQUFJcTdFLE9BQU8vN0UsTUFBaEIsRUFBd0JVLE1BQU0sQ0FBOUIsR0FBa0M7QUFDaENvSyxPQUFHaXhFLE9BQU9yN0UsQ0FBUCxDQUFILEVBQWMsVUFBZCxFQUEwQm8yQixLQUExQjtBQUNEO0FBQ0Y7O0FBRURsNEIsT0FBT0MsT0FBUCxHQUFpQjtBQUNmeTJCLGNBQVlBLFVBREc7QUFFZkMsMkJBQXlCQSx1QkFGVjtBQUdmOVEscUJBQW1CQSxpQkFISjtBQUlmSCxvQkFBa0JBLGdCQUpIO0FBS2ZhLHNCQUFvQkE7QUFMTCxDQUFqQixDOzs7Ozs7OztBQ2hJQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUk1Z0IsaUJBQWlCLG1CQUFBaEIsQ0FBUSxDQUFSLENBQXJCO0FBQUEsSUFDSTZOLFVBQVUsbUJBQUE3TixDQUFRLENBQVIsQ0FEZDs7QUFHQSxJQUFJdzJCLHdCQUF3QixtQkFBQXgyQixDQUFRLEVBQVIsQ0FBNUI7QUFDQSxJQUFJK2YsY0FBYyxtQkFBQS9mLENBQVEsRUFBUixDQUFsQjtBQUNBLElBQUlnRSx3QkFBd0IsbUJBQUFoRSxDQUFRLENBQVIsQ0FBNUI7O0FBRUEsSUFBSXFyQiw4QkFBOEIsbUJBQUFyckIsQ0FBUSxFQUFSLENBQWxDO0FBQ0EsSUFBSVosWUFBWSxtQkFBQVksQ0FBUSxDQUFSLENBQWhCO0FBQ0EsSUFBSXM4QixxQkFBcUIsbUJBQUF0OEIsQ0FBUSxFQUFSLENBQXpCOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSxJQUFJNHpELHdCQUF3QixTQUF4QkEscUJBQXdCLENBQVVocEQsSUFBVixFQUFnQjtBQUMxQztBQUNBLE9BQUttRyxlQUFMLEdBQXVCbkcsSUFBdkI7QUFDQSxPQUFLNnRFLFdBQUwsR0FBbUIsS0FBSzd0RSxJQUF4QjtBQUNBO0FBQ0EsT0FBS25JLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxPQUFLc0IsV0FBTCxHQUFtQixJQUFuQjs7QUFFQTtBQUNBLE9BQUtULE1BQUwsR0FBYyxDQUFkO0FBQ0EsT0FBSzJ5QyxXQUFMLEdBQW1CLENBQW5CO0FBQ0EsT0FBS3lpQyxlQUFMLEdBQXVCLElBQXZCO0FBQ0EsT0FBS0MsYUFBTCxHQUFxQixJQUFyQjtBQUNELENBYkQ7O0FBZUE5cUUsUUFBUStsRCxzQkFBc0JyMkQsU0FBOUIsRUFBeUM7QUFDdkM7Ozs7Ozs7O0FBUUEwZixrQkFBZ0Isd0JBQVV6TSxXQUFWLEVBQXVCMk0sVUFBdkIsRUFBbUNDLGlCQUFuQyxFQUFzRHpMLE9BQXRELEVBQStEO0FBQzdFLFFBQUl2VyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6QyxVQUFJNitCLFVBQUo7QUFDQSxVQUFJNWdCLGNBQWMsSUFBbEIsRUFBd0I7QUFDdEI0Z0IscUJBQWE1Z0IsV0FBV3NzRCxhQUF4QjtBQUNELE9BRkQsTUFFTyxJQUFJcnNELHFCQUFxQixJQUF6QixFQUErQjtBQUNwQzJnQixxQkFBYTNnQixrQkFBa0Jxc0QsYUFBL0I7QUFDRDtBQUNELFVBQUkxckMsVUFBSixFQUFnQjtBQUNkO0FBQ0E7QUFDQXpCLDJCQUFtQixJQUFuQixFQUF5QixLQUFLbThDLFdBQTlCLEVBQTJDLElBQTNDLEVBQWlEMTZDLFVBQWpEO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJODVDLFFBQVF6NkQsa0JBQWtCc3RELFVBQWxCLEVBQVo7QUFDQSxRQUFJa08sZUFBZSxrQkFBa0JmLEtBQWxCLEdBQTBCLEdBQTdDO0FBQ0EsUUFBSWdCLGVBQWUsZUFBbkI7QUFDQSxTQUFLdjFFLE1BQUwsR0FBY3UwRSxLQUFkO0FBQ0EsU0FBSzl6RSxXQUFMLEdBQW1Cb1osVUFBbkI7QUFDQSxRQUFJM00sWUFBWXdyQyxnQkFBaEIsRUFBa0M7QUFDaEMsVUFBSXozQixnQkFBZ0JuSCxrQkFBa0IyckQsY0FBdEM7QUFDQSxVQUFJcnpDLGlCQUFpQm5SLGNBQWN1ekQsYUFBZCxDQUE0QmMsWUFBNUIsQ0FBckI7QUFDQSxVQUFJcGpELGlCQUFpQmpSLGNBQWN1ekQsYUFBZCxDQUE0QmUsWUFBNUIsQ0FBckI7QUFDQSxVQUFJOU4sV0FBV2hyRCxZQUFZd0UsY0FBY3UwRCxzQkFBZCxFQUFaLENBQWY7QUFDQS80RCxrQkFBWU4sVUFBWixDQUF1QnNyRCxRQUF2QixFQUFpQ2hyRCxZQUFZMlYsY0FBWixDQUFqQztBQUNBLFVBQUksS0FBSytpRCxXQUFULEVBQXNCO0FBQ3BCMTRELG9CQUFZTixVQUFaLENBQXVCc3JELFFBQXZCLEVBQWlDaHJELFlBQVl3RSxjQUFjeVIsY0FBZCxDQUE2QixLQUFLeWlELFdBQWxDLENBQVosQ0FBakM7QUFDRDtBQUNEMTRELGtCQUFZTixVQUFaLENBQXVCc3JELFFBQXZCLEVBQWlDaHJELFlBQVl5VixjQUFaLENBQWpDO0FBQ0F4eEIsNEJBQXNCMUIsWUFBdEIsQ0FBbUMsSUFBbkMsRUFBeUNvekIsY0FBekM7QUFDQSxXQUFLZ2pELGVBQUwsR0FBdUJsakQsY0FBdkI7QUFDQSxhQUFPdTFDLFFBQVA7QUFDRCxLQWJELE1BYU87QUFDTCxVQUFJZ08sY0FBYzF0RCw0QkFBNEIsS0FBS290RCxXQUFqQyxDQUFsQjs7QUFFQSxVQUFJam9FLFlBQVlpN0Qsb0JBQWhCLEVBQXNDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGVBQU9zTixXQUFQO0FBQ0Q7O0FBRUQsYUFBTyxTQUFTSCxZQUFULEdBQXdCLEtBQXhCLEdBQWdDRyxXQUFoQyxHQUE4QyxNQUE5QyxHQUF1REYsWUFBdkQsR0FBc0UsS0FBN0U7QUFDRDtBQUNGLEdBdERzQzs7QUF3RHZDOzs7Ozs7O0FBT0FoN0Qsb0JBQWtCLDBCQUFVbTdELFFBQVYsRUFBb0J4b0UsV0FBcEIsRUFBaUM7QUFDakQsUUFBSXdvRSxhQUFhLEtBQUtqb0UsZUFBdEIsRUFBdUM7QUFDckMsV0FBS0EsZUFBTCxHQUF1QmlvRSxRQUF2QjtBQUNBLFVBQUlDLGlCQUFpQixLQUFLRCxRQUExQjtBQUNBLFVBQUlDLG1CQUFtQixLQUFLUixXQUE1QixFQUF5QztBQUN2QztBQUNBO0FBQ0E7QUFDQSxhQUFLQSxXQUFMLEdBQW1CUSxjQUFuQjtBQUNBLFlBQUlDLGVBQWUsS0FBSzE3RCxXQUFMLEVBQW5CO0FBQ0FnWiw4QkFBc0JYLG9CQUF0QixDQUEyQ3FqRCxhQUFhLENBQWIsQ0FBM0MsRUFBNERBLGFBQWEsQ0FBYixDQUE1RCxFQUE2RUQsY0FBN0U7QUFDRDtBQUNGO0FBQ0YsR0E1RXNDOztBQThFdkN6N0QsZUFBYSx1QkFBWTtBQUN2QixRQUFJNGhDLFdBQVcsS0FBS3U1QixhQUFwQjtBQUNBLFFBQUl2NUIsUUFBSixFQUFjO0FBQ1osYUFBT0EsUUFBUDtBQUNEO0FBQ0QsUUFBSSxDQUFDLEtBQUtzNUIsZUFBVixFQUEyQjtBQUN6QixVQUFJaGpELGlCQUFpQjF4QixzQkFBc0JGLG1CQUF0QixDQUEwQyxJQUExQyxDQUFyQjtBQUNBLFVBQUlsQyxPQUFPOHpCLGVBQWVueUIsV0FBMUI7QUFDQSxhQUFPLElBQVAsRUFBYTtBQUNYLFVBQUUzQixRQUFRLElBQVYsSUFBa0J4RyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLCtDQUFqQixFQUFrRSxLQUFLa0UsTUFBdkUsQ0FBeEMsR0FBeUh0QyxlQUFlLElBQWYsRUFBcUIsS0FBS3NDLE1BQTFCLENBQTNJLEdBQStLLEtBQUssQ0FBcEw7QUFDQSxZQUFJMUIsS0FBS0UsUUFBTCxLQUFrQixDQUFsQixJQUF1QkYsS0FBS0ssU0FBTCxLQUFtQixlQUE5QyxFQUErRDtBQUM3RCxlQUFLeTJFLGVBQUwsR0FBdUI5MkUsSUFBdkI7QUFDQTtBQUNEO0FBQ0RBLGVBQU9BLEtBQUsyQixXQUFaO0FBQ0Q7QUFDRjtBQUNENjdDLGVBQVcsQ0FBQyxLQUFLMzhDLFNBQU4sRUFBaUIsS0FBS2kyRSxlQUF0QixDQUFYO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQnY1QixRQUFyQjtBQUNBLFdBQU9BLFFBQVA7QUFDRCxHQWxHc0M7O0FBb0d2QzNoQyxvQkFBa0IsNEJBQVk7QUFDNUIsU0FBS2k3RCxlQUFMLEdBQXVCLElBQXZCO0FBQ0EsU0FBS0MsYUFBTCxHQUFxQixJQUFyQjtBQUNBMzBFLDBCQUFzQnRCLFdBQXRCLENBQWtDLElBQWxDO0FBQ0Q7QUF4R3NDLENBQXpDOztBQTJHQXJILE9BQU9DLE9BQVAsR0FBaUJzNEQscUJBQWpCLEM7Ozs7Ozs7O0FDaEtBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSS9sRCxVQUFVLG1CQUFBN04sQ0FBUSxDQUFSLENBQWQ7O0FBRUEsSUFBSTBPLGVBQWUsbUJBQUExTyxDQUFRLEVBQVIsQ0FBbkI7QUFDQSxJQUFJa08sY0FBYyxtQkFBQWxPLENBQVEsRUFBUixDQUFsQjs7QUFFQSxJQUFJRCxnQkFBZ0IsbUJBQUFDLENBQVEsRUFBUixDQUFwQjs7QUFFQSxJQUFJbTVFLHdCQUF3QjtBQUMxQnRxRSxjQUFZOU8sYUFEYztBQUUxQmdQLFNBQU8saUJBQVk7QUFDakI4a0QsaUNBQTZCcmlELGlCQUE3QixHQUFpRCxLQUFqRDtBQUNEO0FBSnlCLENBQTVCOztBQU9BLElBQUk0bkUsd0JBQXdCO0FBQzFCdnFFLGNBQVk5TyxhQURjO0FBRTFCZ1AsU0FBT0wsYUFBYU8sbUJBQWIsQ0FBaUMwSyxJQUFqQyxDQUFzQ2pMLFlBQXRDO0FBRm1CLENBQTVCOztBQUtBLElBQUlZLHVCQUF1QixDQUFDOHBFLHFCQUFELEVBQXdCRCxxQkFBeEIsQ0FBM0I7O0FBRUEsU0FBU0UsdUNBQVQsR0FBbUQ7QUFDakQsT0FBSzdwRSx1QkFBTDtBQUNEOztBQUVEM0IsUUFBUXdyRSx3Q0FBd0M5N0UsU0FBaEQsRUFBMkQyUSxXQUEzRCxFQUF3RTtBQUN0RXdCLDBCQUF3QixrQ0FBWTtBQUNsQyxXQUFPSixvQkFBUDtBQUNEO0FBSHFFLENBQXhFOztBQU1BLElBQUlrQixjQUFjLElBQUk2b0UsdUNBQUosRUFBbEI7O0FBRUEsSUFBSXhsQiwrQkFBK0I7QUFDakNyaUQscUJBQW1CLEtBRGM7O0FBR2pDOzs7O0FBSUF2QixrQkFBZ0Isd0JBQVVDLFFBQVYsRUFBb0I1USxDQUFwQixFQUF1QkMsQ0FBdkIsRUFBMEJDLENBQTFCLEVBQTZCQyxDQUE3QixFQUFnQzVELENBQWhDLEVBQW1DO0FBQ2pELFFBQUl5OUUseUJBQXlCemxCLDZCQUE2QnJpRCxpQkFBMUQ7O0FBRUFxaUQsaUNBQTZCcmlELGlCQUE3QixHQUFpRCxJQUFqRDs7QUFFQTtBQUNBLFFBQUk4bkUsc0JBQUosRUFBNEI7QUFDMUIsYUFBT3BwRSxTQUFTNVEsQ0FBVCxFQUFZQyxDQUFaLEVBQWVDLENBQWYsRUFBa0JDLENBQWxCLEVBQXFCNUQsQ0FBckIsQ0FBUDtBQUNELEtBRkQsTUFFTztBQUNMLGFBQU8yVSxZQUFZWCxPQUFaLENBQW9CSyxRQUFwQixFQUE4QixJQUE5QixFQUFvQzVRLENBQXBDLEVBQXVDQyxDQUF2QyxFQUEwQ0MsQ0FBMUMsRUFBNkNDLENBQTdDLEVBQWdENUQsQ0FBaEQsQ0FBUDtBQUNEO0FBQ0Y7QUFsQmdDLENBQW5DOztBQXFCQVIsT0FBT0MsT0FBUCxHQUFpQnU0RCw0QkFBakIsQzs7Ozs7OztBQ2xFQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlobUQsVUFBVSxtQkFBQTdOLENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUlvNEMsZ0JBQWdCLG1CQUFBcDRDLENBQVEsRUFBUixDQUFwQjtBQUNBLElBQUltRyx1QkFBdUIsbUJBQUFuRyxDQUFRLENBQVIsQ0FBM0I7QUFDQSxJQUFJK04sY0FBYyxtQkFBQS9OLENBQVEsRUFBUixDQUFsQjtBQUNBLElBQUlnRSx3QkFBd0IsbUJBQUFoRSxDQUFRLENBQVIsQ0FBNUI7QUFDQSxJQUFJME8sZUFBZSxtQkFBQTFPLENBQVEsRUFBUixDQUFuQjs7QUFFQSxJQUFJbWtCLGlCQUFpQixtQkFBQW5rQixDQUFRLEVBQVIsQ0FBckI7QUFDQSxJQUFJdTVFLDZCQUE2QixtQkFBQXY1RSxDQUFRLEdBQVIsQ0FBakM7O0FBRUE7Ozs7O0FBS0EsU0FBU3c1RSxVQUFULENBQW9CajNFLElBQXBCLEVBQTBCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQU9BLEtBQUt3QixXQUFaLEVBQXlCO0FBQ3ZCeEIsV0FBT0EsS0FBS3dCLFdBQVo7QUFDRDtBQUNELE1BQUlvdEUsV0FBV250RSxzQkFBc0JGLG1CQUF0QixDQUEwQ3ZCLElBQTFDLENBQWY7QUFDQSxNQUFJODRDLFlBQVk4MUIsU0FBU3p0RSxVQUF6QjtBQUNBLFNBQU9NLHNCQUFzQlIsMEJBQXRCLENBQWlENjNDLFNBQWpELENBQVA7QUFDRDs7QUFFRDtBQUNBLFNBQVNvK0IsMkJBQVQsQ0FBcUNoMkQsWUFBckMsRUFBbURyUSxXQUFuRCxFQUFnRTtBQUM5RCxPQUFLcVEsWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxPQUFLclEsV0FBTCxHQUFtQkEsV0FBbkI7QUFDQSxPQUFLc21FLFNBQUwsR0FBaUIsRUFBakI7QUFDRDtBQUNEN3JFLFFBQVE0ckUsNEJBQTRCbDhFLFNBQXBDLEVBQStDO0FBQzdDb1MsY0FBWSxzQkFBWTtBQUN0QixTQUFLOFQsWUFBTCxHQUFvQixJQUFwQjtBQUNBLFNBQUtyUSxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsU0FBS3NtRSxTQUFMLENBQWVqOUUsTUFBZixHQUF3QixDQUF4QjtBQUNEO0FBTDRDLENBQS9DO0FBT0FzUixZQUFZaUMsWUFBWixDQUF5QnlwRSwyQkFBekIsRUFBc0QxckUsWUFBWXVNLGlCQUFsRTs7QUFFQSxTQUFTcS9ELGtCQUFULENBQTRCcDBCLFdBQTVCLEVBQXlDO0FBQ3ZDLE1BQUlseUMsb0JBQW9COFEsZUFBZW9oQyxZQUFZbnlDLFdBQTNCLENBQXhCO0FBQ0EsTUFBSUQsYUFBYW5QLHNCQUFzQlIsMEJBQXRCLENBQWlENlAsaUJBQWpELENBQWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSXVtRSxXQUFXem1FLFVBQWY7QUFDQSxLQUFHO0FBQ0RveUMsZ0JBQVltMEIsU0FBWixDQUFzQnQ4RSxJQUF0QixDQUEyQnc4RSxRQUEzQjtBQUNBQSxlQUFXQSxZQUFZSixXQUFXSSxRQUFYLENBQXZCO0FBQ0QsR0FIRCxRQUdTQSxRQUhUOztBQUtBLE9BQUssSUFBSXo4RSxJQUFJLENBQWIsRUFBZ0JBLElBQUlvb0QsWUFBWW0wQixTQUFaLENBQXNCajlFLE1BQTFDLEVBQWtEVSxHQUFsRCxFQUF1RDtBQUNyRGdXLGlCQUFhb3lDLFlBQVltMEIsU0FBWixDQUFzQnY4RSxDQUF0QixDQUFiO0FBQ0EreUIsdUJBQW1CMnBELGVBQW5CLENBQW1DdDBCLFlBQVk5aEMsWUFBL0MsRUFBNkR0USxVQUE3RCxFQUF5RW95QyxZQUFZbnlDLFdBQXJGLEVBQWtHK1EsZUFBZW9oQyxZQUFZbnlDLFdBQTNCLENBQWxHO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTMG1FLGtCQUFULENBQTRCbHZDLEVBQTVCLEVBQWdDO0FBQzlCLE1BQUl5QyxpQkFBaUJrc0MsMkJBQTJCdnpFLE1BQTNCLENBQXJCO0FBQ0E0a0MsS0FBR3lDLGNBQUg7QUFDRDs7QUFFRCxJQUFJbmQscUJBQXFCO0FBQ3ZCNnBELFlBQVUsSUFEYTtBQUV2QkYsbUJBQWlCLElBRk07O0FBSXZCOW9ELGlCQUFlNXFCLHFCQUFxQkosU0FBckIsR0FBaUNDLE1BQWpDLEdBQTBDLElBSmxDOztBQU12Qm9xQixxQkFBbUIsMkJBQVVDLGNBQVYsRUFBMEI7QUFDM0NILHVCQUFtQjJwRCxlQUFuQixHQUFxQ3hwRCxjQUFyQztBQUNELEdBUnNCOztBQVV2QkMsY0FBWSxvQkFBVUMsT0FBVixFQUFtQjtBQUM3QkwsdUJBQW1CNnBELFFBQW5CLEdBQThCLENBQUMsQ0FBQ3hwRCxPQUFoQztBQUNELEdBWnNCOztBQWN2QkMsYUFBVyxxQkFBWTtBQUNyQixXQUFPTixtQkFBbUI2cEQsUUFBMUI7QUFDRCxHQWhCc0I7O0FBa0J2Qjs7Ozs7Ozs7OztBQVVBbHBELG9CQUFrQiwwQkFBVXBOLFlBQVYsRUFBd0J1TixlQUF4QixFQUF5Q3BuQixPQUF6QyxFQUFrRDtBQUNsRSxRQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaLGFBQU8sSUFBUDtBQUNEO0FBQ0QsV0FBT3d1QyxjQUFjelYsTUFBZCxDQUFxQi80QixPQUFyQixFQUE4Qm9uQixlQUE5QixFQUErQ2QsbUJBQW1Cd0QsYUFBbkIsQ0FBaUMvWixJQUFqQyxDQUFzQyxJQUF0QyxFQUE0QzhKLFlBQTVDLENBQS9DLENBQVA7QUFDRCxHQWpDc0I7O0FBbUN2Qjs7Ozs7Ozs7OztBQVVBcU4scUJBQW1CLDJCQUFVck4sWUFBVixFQUF3QnVOLGVBQXhCLEVBQXlDcG5CLE9BQXpDLEVBQWtEO0FBQ25FLFFBQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQ1osYUFBTyxJQUFQO0FBQ0Q7QUFDRCxXQUFPd3VDLGNBQWM5akIsT0FBZCxDQUFzQjFxQixPQUF0QixFQUErQm9uQixlQUEvQixFQUFnRGQsbUJBQW1Cd0QsYUFBbkIsQ0FBaUMvWixJQUFqQyxDQUFzQyxJQUF0QyxFQUE0QzhKLFlBQTVDLENBQWhELENBQVA7QUFDRCxHQWxEc0I7O0FBb0R2QitOLHNCQUFvQiw0QkFBVUYsT0FBVixFQUFtQjtBQUNyQyxRQUFJcGhCLFdBQVc0cEUsbUJBQW1CbmdFLElBQW5CLENBQXdCLElBQXhCLEVBQThCMlgsT0FBOUIsQ0FBZjtBQUNBOG1CLGtCQUFjelYsTUFBZCxDQUFxQjM4QixNQUFyQixFQUE2QixRQUE3QixFQUF1Q2tLLFFBQXZDO0FBQ0QsR0F2RHNCOztBQXlEdkJ3akIsaUJBQWUsdUJBQVVqUSxZQUFWLEVBQXdCclEsV0FBeEIsRUFBcUM7QUFDbEQsUUFBSSxDQUFDOGMsbUJBQW1CNnBELFFBQXhCLEVBQWtDO0FBQ2hDO0FBQ0Q7O0FBRUQsUUFBSXgwQixjQUFjazBCLDRCQUE0Qm5yRSxTQUE1QixDQUFzQ21WLFlBQXRDLEVBQW9EclEsV0FBcEQsQ0FBbEI7QUFDQSxRQUFJO0FBQ0Y7QUFDQTtBQUNBMUUsbUJBQWF1QixjQUFiLENBQTRCMHBFLGtCQUE1QixFQUFnRHAwQixXQUFoRDtBQUNELEtBSkQsU0FJVTtBQUNSazBCLGtDQUE0QjdwRSxPQUE1QixDQUFvQzIxQyxXQUFwQztBQUNEO0FBQ0Y7QUF0RXNCLENBQXpCOztBQXlFQWxxRCxPQUFPQyxPQUFQLEdBQWlCNDBCLGtCQUFqQixDOzs7Ozs7O0FDekpBOzs7Ozs7Ozs7OztBQVdBOztBQUVBOzs7Ozs7Ozs7OztBQVdBLFNBQVNxcEQsMEJBQVQsQ0FBb0NTLFVBQXBDLEVBQWdEO0FBQzlDLE1BQUlBLFdBQVdDLE1BQVgsSUFBcUJELHNCQUFzQkEsV0FBV0MsTUFBMUQsRUFBa0U7QUFDaEUsV0FBTztBQUNMMTVFLFNBQUd5NUUsV0FBV0UsV0FBWCxJQUEwQkYsV0FBVy96RSxRQUFYLENBQW9COGtDLGVBQXBCLENBQW9Db3ZDLFVBRDVEO0FBRUx0Z0QsU0FBR21nRCxXQUFXSSxXQUFYLElBQTBCSixXQUFXL3pFLFFBQVgsQ0FBb0I4a0MsZUFBcEIsQ0FBb0NzdkM7QUFGNUQsS0FBUDtBQUlEO0FBQ0QsU0FBTztBQUNMOTVFLE9BQUd5NUUsV0FBV0csVUFEVDtBQUVMdGdELE9BQUdtZ0QsV0FBV0s7QUFGVCxHQUFQO0FBSUQ7O0FBRURoL0UsT0FBT0MsT0FBUCxHQUFpQmkrRSwwQkFBakIsQzs7Ozs7OztBQ3JDQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl0NEUsY0FBYyxtQkFBQWpCLENBQVEsRUFBUixDQUFsQjtBQUNBLElBQUlnZ0IsaUJBQWlCLG1CQUFBaGdCLENBQVEsRUFBUixDQUFyQjtBQUNBLElBQUlpZ0IsbUJBQW1CLG1CQUFBamdCLENBQVEsRUFBUixDQUF2QjtBQUNBLElBQUl1NUIsNEJBQTRCLG1CQUFBdjVCLENBQVEsRUFBUixDQUFoQztBQUNBLElBQUl1MUMsc0JBQXNCLG1CQUFBdjFDLENBQVEsRUFBUixDQUExQjtBQUNBLElBQUlpd0IsMkJBQTJCLG1CQUFBandCLENBQVEsRUFBUixDQUEvQjtBQUNBLElBQUl3MUMscUJBQXFCLG1CQUFBeDFDLENBQVEsRUFBUixDQUF6QjtBQUNBLElBQUkwTyxlQUFlLG1CQUFBMU8sQ0FBUSxFQUFSLENBQW5COztBQUVBLElBQUk4ekQsaUJBQWlCO0FBQ25CdjNDLGFBQVdnZCwwQkFBMEJ0bkIsU0FEbEI7QUFFbkJoUixlQUFhQSxZQUFZZ1IsU0FGTjtBQUduQm9pRCxrQkFBZ0I5ZSxvQkFBb0J0akMsU0FIakI7QUFJbkIrTixrQkFBZ0JBLGVBQWUvTixTQUpaO0FBS25CZ08sb0JBQWtCQSxpQkFBaUJoTyxTQUxoQjtBQU1uQmtpRCxnQkFBY2xrQyx5QkFBeUJoZSxTQU5wQjtBQU9uQm1pRCxpQkFBZTVlLG1CQUFtQnZqQyxTQVBmO0FBUW5CcWlELFdBQVM1bEQsYUFBYXVEO0FBUkgsQ0FBckI7O0FBV0E1VyxPQUFPQyxPQUFQLEdBQWlCdzRELGNBQWpCLEM7Ozs7Ozs7QUNoQ0E7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJam1ELFVBQVUsbUJBQUE3TixDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJOE4sZ0JBQWdCLG1CQUFBOU4sQ0FBUSxFQUFSLENBQXBCO0FBQ0EsSUFBSStOLGNBQWMsbUJBQUEvTixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJaXdCLDJCQUEyQixtQkFBQWp3QixDQUFRLEVBQVIsQ0FBL0I7QUFDQSxJQUFJNDRDLHNCQUFzQixtQkFBQTU0QyxDQUFRLEVBQVIsQ0FBMUI7QUFDQSxJQUFJK2MsdUJBQXVCLG1CQUFBL2MsQ0FBUSxFQUFSLENBQTNCO0FBQ0EsSUFBSWtPLGNBQWMsbUJBQUFsTyxDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJcTdCLG1CQUFtQixtQkFBQXI3QixDQUFRLEVBQVIsQ0FBdkI7O0FBRUE7Ozs7QUFJQSxJQUFJczZFLHdCQUF3QjtBQUMxQjs7O0FBR0F6ckUsY0FBWStwQyxvQkFBb0JHLHVCQUpOO0FBSzFCOzs7QUFHQWhxQyxTQUFPNnBDLG9CQUFvQk87QUFSRCxDQUE1Qjs7QUFXQTs7Ozs7QUFLQSxJQUFJb2hDLG9CQUFvQjtBQUN0Qjs7OztBQUlBMXJFLGNBQVksc0JBQVk7QUFDdEIsUUFBSTJyRSxtQkFBbUJ2cUQseUJBQXlCTyxTQUF6QixFQUF2QjtBQUNBUCw2QkFBeUJLLFVBQXpCLENBQW9DLEtBQXBDO0FBQ0EsV0FBT2txRCxnQkFBUDtBQUNELEdBVHFCOztBQVd0Qjs7Ozs7QUFLQXpyRSxTQUFPLGVBQVUwckUsaUJBQVYsRUFBNkI7QUFDbEN4cUQsNkJBQXlCSyxVQUF6QixDQUFvQ21xRCxpQkFBcEM7QUFDRDtBQWxCcUIsQ0FBeEI7O0FBcUJBOzs7O0FBSUEsSUFBSUMsd0JBQXdCO0FBQzFCOzs7QUFHQTdyRSxjQUFZLHNCQUFZO0FBQ3RCLFNBQUs4ckUsZUFBTCxDQUFxQnZyRSxLQUFyQjtBQUNELEdBTnlCOztBQVExQjs7O0FBR0FMLFNBQU8saUJBQVk7QUFDakIsU0FBSzRyRSxlQUFMLENBQXFCdHJFLFNBQXJCO0FBQ0Q7QUFieUIsQ0FBNUI7O0FBZ0JBOzs7OztBQUtBLElBQUlDLHVCQUF1QixDQUFDZ3JFLHFCQUFELEVBQXdCQyxpQkFBeEIsRUFBMkNHLHFCQUEzQyxDQUEzQjs7QUFFQSxJQUFJdC9FLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDb1EsdUJBQXFCbFMsSUFBckIsQ0FBMEI7QUFDeEJ5UixnQkFBWWtPLHFCQUFxQjNQLFNBQXJCLENBQStCOHVDLFlBRG5CO0FBRXhCbnRDLFdBQU9nTyxxQkFBcUIzUCxTQUFyQixDQUErQit1QztBQUZkLEdBQTFCO0FBSUQ7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7O0FBY0EsU0FBU3h0Qyx5QkFBVCxDQUFtQ3F0QyxnQkFBbkMsRUFBcUQ7QUFDbkQsT0FBS3hzQyx1QkFBTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFLaThELG9CQUFMLEdBQTRCLEtBQTVCO0FBQ0EsT0FBS2tQLGVBQUwsR0FBdUI3c0UsY0FBY1EsU0FBZCxDQUF3QixJQUF4QixDQUF2QjtBQUNBLE9BQUswdEMsZ0JBQUwsR0FBd0JBLGdCQUF4QjtBQUNEOztBQUVELElBQUl5dUIsUUFBUTtBQUNWOzs7Ozs7O0FBT0EvNkQsMEJBQXdCLGtDQUFZO0FBQ2xDLFdBQU9KLG9CQUFQO0FBQ0QsR0FWUzs7QUFZVjs7O0FBR0FpTyxzQkFBb0IsOEJBQVk7QUFDOUIsV0FBTyxLQUFLbzlELGVBQVo7QUFDRCxHQWpCUzs7QUFtQlY7OztBQUdBeEYsa0JBQWdCLDBCQUFZO0FBQzFCLFdBQU85NUMsZ0JBQVA7QUFDRCxHQXhCUzs7QUEwQlY7Ozs7QUFJQStQLGNBQVksc0JBQVk7QUFDdEI7QUFDQSxXQUFPLEtBQUt1dkMsZUFBTCxDQUFxQnZ2QyxVQUFyQixFQUFQO0FBQ0QsR0FqQ1M7O0FBbUNWQyxZQUFVLGtCQUFVRCxVQUFWLEVBQXNCO0FBQzlCLFNBQUt1dkMsZUFBTCxDQUFxQnR2QyxRQUFyQixDQUE4QkQsVUFBOUI7QUFDRCxHQXJDUzs7QUF1Q1Y7Ozs7QUFJQXo3QixjQUFZLHNCQUFZO0FBQ3RCN0Isa0JBQWM4QixPQUFkLENBQXNCLEtBQUsrcUUsZUFBM0I7QUFDQSxTQUFLQSxlQUFMLEdBQXVCLElBQXZCO0FBQ0Q7QUE5Q1MsQ0FBWjs7QUFpREE5c0UsUUFBUWMsMEJBQTBCcFIsU0FBbEMsRUFBNkMyUSxXQUE3QyxFQUEwRHU4RCxLQUExRDs7QUFFQTE4RCxZQUFZaUMsWUFBWixDQUF5QnJCLHlCQUF6Qjs7QUFFQXRULE9BQU9DLE9BQVAsR0FBaUJxVCx5QkFBakIsQzs7Ozs7Ozs7QUNoTEE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJeEksdUJBQXVCLG1CQUFBbkcsQ0FBUSxDQUFSLENBQTNCOztBQUVBLElBQUk0NkUsNEJBQTRCLG1CQUFBNTZFLENBQVEsR0FBUixDQUFoQztBQUNBLElBQUk4cUMseUJBQXlCLG1CQUFBOXFDLENBQVEsRUFBUixDQUE3Qjs7QUFFQTs7Ozs7QUFLQSxTQUFTNjZFLFdBQVQsQ0FBcUJDLFVBQXJCLEVBQWlDQyxZQUFqQyxFQUErQ3Z0QyxTQUEvQyxFQUEwRHd0QyxXQUExRCxFQUF1RTtBQUNyRSxTQUFPRixlQUFldHRDLFNBQWYsSUFBNEJ1dEMsaUJBQWlCQyxXQUFwRDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7OztBQWNBLFNBQVNDLFlBQVQsQ0FBc0JyNUUsSUFBdEIsRUFBNEI7QUFDMUIsTUFBSTgzQyxZQUFZenpDLFNBQVN5ekMsU0FBekI7QUFDQSxNQUFJd2hDLGdCQUFnQnhoQyxVQUFVSSxXQUFWLEVBQXBCO0FBQ0EsTUFBSXFoQyxpQkFBaUJELGNBQWN0d0UsSUFBZCxDQUFtQm5PLE1BQXhDOztBQUVBO0FBQ0EsTUFBSTIrRSxZQUFZRixjQUFjRyxTQUFkLEVBQWhCO0FBQ0FELFlBQVVFLGlCQUFWLENBQTRCMTVFLElBQTVCO0FBQ0F3NUUsWUFBVUcsV0FBVixDQUFzQixZQUF0QixFQUFvQ0wsYUFBcEM7O0FBRUEsTUFBSU0sY0FBY0osVUFBVXh3RSxJQUFWLENBQWVuTyxNQUFqQztBQUNBLE1BQUlnL0UsWUFBWUQsY0FBY0wsY0FBOUI7O0FBRUEsU0FBTztBQUNMeGhDLFdBQU82aEMsV0FERjtBQUVMNzNDLFNBQUs4M0M7QUFGQSxHQUFQO0FBSUQ7O0FBRUQ7Ozs7QUFJQSxTQUFTQyxnQkFBVCxDQUEwQjk1RSxJQUExQixFQUFnQztBQUM5QixNQUFJODNDLFlBQVkxekMsT0FBT2t6QyxZQUFQLElBQXVCbHpDLE9BQU9rekMsWUFBUCxFQUF2Qzs7QUFFQSxNQUFJLENBQUNRLFNBQUQsSUFBY0EsVUFBVWlpQyxVQUFWLEtBQXlCLENBQTNDLEVBQThDO0FBQzVDLFdBQU8sSUFBUDtBQUNEOztBQUVELE1BQUliLGFBQWFwaEMsVUFBVW9oQyxVQUEzQjtBQUNBLE1BQUlDLGVBQWVyaEMsVUFBVXFoQyxZQUE3QjtBQUNBLE1BQUl2dEMsWUFBWWtNLFVBQVVsTSxTQUExQjtBQUNBLE1BQUl3dEMsY0FBY3RoQyxVQUFVc2hDLFdBQTVCOztBQUVBLE1BQUlZLGVBQWVsaUMsVUFBVW1pQyxVQUFWLENBQXFCLENBQXJCLENBQW5COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSTtBQUNGO0FBQ0FELGlCQUFhRSxjQUFiLENBQTRCaDZFLFFBQTVCO0FBQ0E4NUUsaUJBQWFHLFlBQWIsQ0FBMEJqNkUsUUFBMUI7QUFDQTtBQUNELEdBTEQsQ0FLRSxPQUFPakcsQ0FBUCxFQUFVO0FBQ1YsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsTUFBSW1nRix1QkFBdUJuQixZQUFZbmhDLFVBQVVvaEMsVUFBdEIsRUFBa0NwaEMsVUFBVXFoQyxZQUE1QyxFQUEwRHJoQyxVQUFVbE0sU0FBcEUsRUFBK0VrTSxVQUFVc2hDLFdBQXpGLENBQTNCOztBQUVBLE1BQUlpQixjQUFjRCx1QkFBdUIsQ0FBdkIsR0FBMkJKLGFBQWFuNkUsUUFBYixHQUF3QmhGLE1BQXJFOztBQUVBLE1BQUl5L0UsWUFBWU4sYUFBYU8sVUFBYixFQUFoQjtBQUNBRCxZQUFVRSxrQkFBVixDQUE2Qng2RSxJQUE3QjtBQUNBczZFLFlBQVVHLE1BQVYsQ0FBaUJULGFBQWFFLGNBQTlCLEVBQThDRixhQUFhSixXQUEzRDs7QUFFQSxNQUFJYyx1QkFBdUJ6QixZQUFZcUIsVUFBVUosY0FBdEIsRUFBc0NJLFVBQVVWLFdBQWhELEVBQTZEVSxVQUFVSCxZQUF2RSxFQUFxRkcsVUFBVVQsU0FBL0YsQ0FBM0I7O0FBRUEsTUFBSTloQyxRQUFRMmlDLHVCQUF1QixDQUF2QixHQUEyQkosVUFBVXo2RSxRQUFWLEdBQXFCaEYsTUFBNUQ7QUFDQSxNQUFJa25DLE1BQU1nVyxRQUFRc2lDLFdBQWxCOztBQUVBO0FBQ0EsTUFBSU0saUJBQWlCdDJFLFNBQVM2ekMsV0FBVCxFQUFyQjtBQUNBeWlDLGlCQUFlQyxRQUFmLENBQXdCMUIsVUFBeEIsRUFBb0NDLFlBQXBDO0FBQ0F3QixpQkFBZUYsTUFBZixDQUFzQjd1QyxTQUF0QixFQUFpQ3d0QyxXQUFqQztBQUNBLE1BQUl5QixhQUFhRixlQUFlRyxTQUFoQzs7QUFFQSxTQUFPO0FBQ0wvaUMsV0FBTzhpQyxhQUFhOTRDLEdBQWIsR0FBbUJnVyxLQURyQjtBQUVMaFcsU0FBSzg0QyxhQUFhOWlDLEtBQWIsR0FBcUJoVztBQUZyQixHQUFQO0FBSUQ7O0FBRUQ7Ozs7QUFJQSxTQUFTZzVDLFlBQVQsQ0FBc0IvNkUsSUFBdEIsRUFBNEJ1NEMsT0FBNUIsRUFBcUM7QUFDbkMsTUFBSWxOLFFBQVFobkMsU0FBU3l6QyxTQUFULENBQW1CSSxXQUFuQixHQUFpQ3VoQyxTQUFqQyxFQUFaO0FBQ0EsTUFBSTFoQyxLQUFKLEVBQVdoVyxHQUFYOztBQUVBLE1BQUl3VyxRQUFReFcsR0FBUixLQUFnQnhrQyxTQUFwQixFQUErQjtBQUM3Qnc2QyxZQUFRUSxRQUFRUixLQUFoQjtBQUNBaFcsVUFBTWdXLEtBQU47QUFDRCxHQUhELE1BR08sSUFBSVEsUUFBUVIsS0FBUixHQUFnQlEsUUFBUXhXLEdBQTVCLEVBQWlDO0FBQ3RDZ1csWUFBUVEsUUFBUXhXLEdBQWhCO0FBQ0FBLFVBQU13VyxRQUFRUixLQUFkO0FBQ0QsR0FITSxNQUdBO0FBQ0xBLFlBQVFRLFFBQVFSLEtBQWhCO0FBQ0FoVyxVQUFNd1csUUFBUXhXLEdBQWQ7QUFDRDs7QUFFRHNKLFFBQU1xdUMsaUJBQU4sQ0FBd0IxNUUsSUFBeEI7QUFDQXFyQyxRQUFNK00sU0FBTixDQUFnQixXQUFoQixFQUE2QkwsS0FBN0I7QUFDQTFNLFFBQU1zdUMsV0FBTixDQUFrQixZQUFsQixFQUFnQ3R1QyxLQUFoQztBQUNBQSxRQUFNZ04sT0FBTixDQUFjLFdBQWQsRUFBMkJ0VyxNQUFNZ1csS0FBakM7QUFDQTFNLFFBQU1xTixNQUFOO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7OztBQVlBLFNBQVNzaUMsZ0JBQVQsQ0FBMEJoN0UsSUFBMUIsRUFBZ0N1NEMsT0FBaEMsRUFBeUM7QUFDdkMsTUFBSSxDQUFDbjBDLE9BQU9rekMsWUFBWixFQUEwQjtBQUN4QjtBQUNEOztBQUVELE1BQUlRLFlBQVkxekMsT0FBT2t6QyxZQUFQLEVBQWhCO0FBQ0EsTUFBSXo4QyxTQUFTbUYsS0FBS2twQyx3QkFBTCxFQUErQnJ1QyxNQUE1QztBQUNBLE1BQUlrOUMsUUFBUXA0QyxLQUFLbTlCLEdBQUwsQ0FBU3liLFFBQVFSLEtBQWpCLEVBQXdCbDlDLE1BQXhCLENBQVo7QUFDQSxNQUFJa25DLE1BQU13VyxRQUFReFcsR0FBUixLQUFnQnhrQyxTQUFoQixHQUE0Qnc2QyxLQUE1QixHQUFvQ3A0QyxLQUFLbTlCLEdBQUwsQ0FBU3liLFFBQVF4VyxHQUFqQixFQUFzQmxuQyxNQUF0QixDQUE5Qzs7QUFFQTtBQUNBO0FBQ0EsTUFBSSxDQUFDaTlDLFVBQVVtakMsTUFBWCxJQUFxQmxqQyxRQUFRaFcsR0FBakMsRUFBc0M7QUFDcEMsUUFBSW01QyxPQUFPbjVDLEdBQVg7QUFDQUEsVUFBTWdXLEtBQU47QUFDQUEsWUFBUW1qQyxJQUFSO0FBQ0Q7O0FBRUQsTUFBSUMsY0FBY25DLDBCQUEwQmg1RSxJQUExQixFQUFnQyszQyxLQUFoQyxDQUFsQjtBQUNBLE1BQUlxakMsWUFBWXBDLDBCQUEwQmg1RSxJQUExQixFQUFnQytoQyxHQUFoQyxDQUFoQjs7QUFFQSxNQUFJbzVDLGVBQWVDLFNBQW5CLEVBQThCO0FBQzVCLFFBQUkvdkMsUUFBUWhuQyxTQUFTNnpDLFdBQVQsRUFBWjtBQUNBN00sVUFBTXV2QyxRQUFOLENBQWVPLFlBQVluN0UsSUFBM0IsRUFBaUNtN0UsWUFBWUUsTUFBN0M7QUFDQXZqQyxjQUFVd2pDLGVBQVY7O0FBRUEsUUFBSXZqQyxRQUFRaFcsR0FBWixFQUFpQjtBQUNmK1YsZ0JBQVV5akMsUUFBVixDQUFtQmx3QyxLQUFuQjtBQUNBeU0sZ0JBQVVtakMsTUFBVixDQUFpQkcsVUFBVXA3RSxJQUEzQixFQUFpQ283RSxVQUFVQyxNQUEzQztBQUNELEtBSEQsTUFHTztBQUNMaHdDLFlBQU1vdkMsTUFBTixDQUFhVyxVQUFVcDdFLElBQXZCLEVBQTZCbzdFLFVBQVVDLE1BQXZDO0FBQ0F2akMsZ0JBQVV5akMsUUFBVixDQUFtQmx3QyxLQUFuQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxJQUFJbXdDLGVBQWVqM0UscUJBQXFCSixTQUFyQixJQUFrQyxlQUFlRSxRQUFqRCxJQUE2RCxFQUFFLGtCQUFrQkQsTUFBcEIsQ0FBaEY7O0FBRUEsSUFBSXd5QyxvQkFBb0I7QUFDdEI7OztBQUdBMEIsY0FBWWtqQyxlQUFlbkMsWUFBZixHQUE4QlMsZ0JBSnBCOztBQU10Qjs7OztBQUlBbmhDLGNBQVk2aUMsZUFBZVQsWUFBZixHQUE4QkM7QUFWcEIsQ0FBeEI7O0FBYUF2aEYsT0FBT0MsT0FBUCxHQUFpQms5QyxpQkFBakIsQzs7Ozs7OztBQ2xOQTs7Ozs7Ozs7OztBQVVBOztBQUVBOzs7Ozs7O0FBT0EsU0FBUzZrQyxXQUFULENBQXFCejdFLElBQXJCLEVBQTJCO0FBQ3pCLFNBQU9BLFFBQVFBLEtBQUtxQixVQUFwQixFQUFnQztBQUM5QnJCLFdBQU9BLEtBQUtxQixVQUFaO0FBQ0Q7QUFDRCxTQUFPckIsSUFBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT0EsU0FBUzA3RSxjQUFULENBQXdCMTdFLElBQXhCLEVBQThCO0FBQzVCLFNBQU9BLElBQVAsRUFBYTtBQUNYLFFBQUlBLEtBQUsyQixXQUFULEVBQXNCO0FBQ3BCLGFBQU8zQixLQUFLMkIsV0FBWjtBQUNEO0FBQ0QzQixXQUFPQSxLQUFLOEIsVUFBWjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTazNFLHlCQUFULENBQW1DLzlCLElBQW5DLEVBQXlDb2dDLE1BQXpDLEVBQWlEO0FBQy9DLE1BQUlyN0UsT0FBT3k3RSxZQUFZeGdDLElBQVosQ0FBWDtBQUNBLE1BQUkwZ0MsWUFBWSxDQUFoQjtBQUNBLE1BQUlDLFVBQVUsQ0FBZDs7QUFFQSxTQUFPNTdFLElBQVAsRUFBYTtBQUNYLFFBQUlBLEtBQUtFLFFBQUwsS0FBa0IsQ0FBdEIsRUFBeUI7QUFDdkIwN0UsZ0JBQVVELFlBQVkzN0UsS0FBSzJyQyxXQUFMLENBQWlCOXdDLE1BQXZDOztBQUVBLFVBQUk4Z0YsYUFBYU4sTUFBYixJQUF1Qk8sV0FBV1AsTUFBdEMsRUFBOEM7QUFDNUMsZUFBTztBQUNMcjdFLGdCQUFNQSxJQUREO0FBRUxxN0Usa0JBQVFBLFNBQVNNO0FBRlosU0FBUDtBQUlEOztBQUVEQSxrQkFBWUMsT0FBWjtBQUNEOztBQUVENTdFLFdBQU95N0UsWUFBWUMsZUFBZTE3RSxJQUFmLENBQVosQ0FBUDtBQUNEO0FBQ0Y7O0FBRUR2RyxPQUFPQyxPQUFQLEdBQWlCcy9FLHlCQUFqQixDOzs7Ozs7O0FDeEVBOztBQUVBOzs7Ozs7Ozs7OztBQVdBLElBQUk2QyxhQUFhLG1CQUFBejlFLENBQVEsR0FBUixDQUFqQjs7QUFFQTs7QUFFQTs7O0FBR0EsU0FBU3k0QyxZQUFULENBQXNCaWxDLFNBQXRCLEVBQWlDQyxTQUFqQyxFQUE0QztBQUMxQyxNQUFJLENBQUNELFNBQUQsSUFBYyxDQUFDQyxTQUFuQixFQUE4QjtBQUM1QixXQUFPLEtBQVA7QUFDRCxHQUZELE1BRU8sSUFBSUQsY0FBY0MsU0FBbEIsRUFBNkI7QUFDbEMsV0FBTyxJQUFQO0FBQ0QsR0FGTSxNQUVBLElBQUlGLFdBQVdDLFNBQVgsQ0FBSixFQUEyQjtBQUNoQyxXQUFPLEtBQVA7QUFDRCxHQUZNLE1BRUEsSUFBSUQsV0FBV0UsU0FBWCxDQUFKLEVBQTJCO0FBQ2hDLFdBQU9sbEMsYUFBYWlsQyxTQUFiLEVBQXdCQyxVQUFVajZFLFVBQWxDLENBQVA7QUFDRCxHQUZNLE1BRUEsSUFBSSxjQUFjZzZFLFNBQWxCLEVBQTZCO0FBQ2xDLFdBQU9BLFVBQVVFLFFBQVYsQ0FBbUJELFNBQW5CLENBQVA7QUFDRCxHQUZNLE1BRUEsSUFBSUQsVUFBVUcsdUJBQWQsRUFBdUM7QUFDNUMsV0FBTyxDQUFDLEVBQUVILFVBQVVHLHVCQUFWLENBQWtDRixTQUFsQyxJQUErQyxFQUFqRCxDQUFSO0FBQ0QsR0FGTSxNQUVBO0FBQ0wsV0FBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRHRpRixPQUFPQyxPQUFQLEdBQWlCbTlDLFlBQWpCLEM7Ozs7Ozs7QUN0Q0E7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0EsSUFBSW5PLFNBQVMsbUJBQUF0cUMsQ0FBUSxHQUFSLENBQWI7O0FBRUE7Ozs7QUFJQSxTQUFTeTlFLFVBQVQsQ0FBb0IvdkUsTUFBcEIsRUFBNEI7QUFDMUIsU0FBTzQ4QixPQUFPNThCLE1BQVAsS0FBa0JBLE9BQU81TCxRQUFQLElBQW1CLENBQTVDO0FBQ0Q7O0FBRUR6RyxPQUFPQyxPQUFQLEdBQWlCbWlGLFVBQWpCLEM7Ozs7Ozs7QUN2QkE7O0FBRUE7Ozs7Ozs7Ozs7O0FBV0E7Ozs7Ozs7QUFJQSxTQUFTbnpDLE1BQVQsQ0FBZ0I1OEIsTUFBaEIsRUFBd0I7QUFDdEIsTUFBSTRXLE1BQU01VyxTQUFTQSxPQUFPNlcsYUFBUCxJQUF3QjdXLE1BQWpDLEdBQTBDekgsUUFBcEQ7QUFDQSxNQUFJdWUsY0FBY0YsSUFBSUUsV0FBSixJQUFtQnhlLE1BQXJDO0FBQ0EsU0FBTyxDQUFDLEVBQUUwSCxXQUFXLE9BQU84VyxZQUFZczVELElBQW5CLEtBQTRCLFVBQTVCLEdBQXlDcHdFLGtCQUFrQjhXLFlBQVlzNUQsSUFBdkUsR0FBOEUsUUFBT3B3RSxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQWxCLElBQThCLE9BQU9BLE9BQU81TCxRQUFkLEtBQTJCLFFBQXpELElBQXFFLE9BQU80TCxPQUFPd1IsUUFBZCxLQUEyQixRQUF6TCxDQUFGLENBQVI7QUFDRDs7QUFFRDdqQixPQUFPQyxPQUFQLEdBQWlCZ3ZDLE1BQWpCLEM7Ozs7Ozs7QUN2QkE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJeXpDLEtBQUs7QUFDUEMsU0FBTyw4QkFEQTtBQUVQQyxPQUFLO0FBRkUsQ0FBVDs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSUMsUUFBUTtBQUNWQyxnQkFBYyxlQURKO0FBRVZDLGNBQVksQ0FGRjtBQUdWQyxZQUFVLENBSEE7QUFJVkMscUJBQW1CLG9CQUpUO0FBS1ZDLGdCQUFjLGNBTEo7QUFNVkMsY0FBWSxDQU5GO0FBT1ZDLGFBQVcsQ0FQRDtBQVFWQyxjQUFZLGFBUkY7QUFTVkMsVUFBUSxDQVRFO0FBVVY5bkUsaUJBQWUsZUFWTDtBQVdWK25FLGlCQUFlLGVBWEw7QUFZVkMsZUFBYSxhQVpIO0FBYVZDLFdBQVMsQ0FiQztBQWNWQyxpQkFBZSxlQWRMO0FBZVZDLGVBQWEsYUFmSDtBQWdCVkMsaUJBQWUsZ0JBaEJMO0FBaUJWQyxRQUFNLENBakJJO0FBa0JWQyxTQUFPLENBbEJHO0FBbUJWQyxRQUFNLENBbkJJO0FBb0JWQyxNQUFJLENBcEJNO0FBcUJWQyxZQUFVLFVBckJBO0FBc0JWQyxhQUFXLFlBdEJEO0FBdUJWQyxRQUFNLENBdkJJO0FBd0JWaHpCLFlBQVUsV0F4QkE7QUF5QlZpekIsWUFBVSxXQXpCQTtBQTBCVkMsaUJBQWUsZUExQkw7QUEyQlZDLHNCQUFvQixxQkEzQlY7QUE0QlZDLDZCQUEyQiw2QkE1QmpCO0FBNkJWQyxnQkFBYyxlQTdCSjtBQThCVkMsa0JBQWdCLGlCQTlCTjtBQStCVkMscUJBQW1CLG1CQS9CVDtBQWdDVkMsb0JBQWtCLGtCQWhDUjtBQWlDVkMsVUFBUSxDQWpDRTtBQWtDVkMsTUFBSSxDQWxDTTtBQW1DVkMsTUFBSSxDQW5DTTtBQW9DVjFnRixLQUFHLENBcENPO0FBcUNWMmdGLGNBQVksQ0FyQ0Y7QUFzQ1ZDLFdBQVMsQ0F0Q0M7QUF1Q1ZDLG1CQUFpQixpQkF2Q1A7QUF3Q1ZDLGFBQVcsQ0F4Q0Q7QUF5Q1ZDLFdBQVMsQ0F6Q0M7QUEwQ1ZDLFdBQVMsQ0ExQ0M7QUEyQ1ZDLG9CQUFrQixtQkEzQ1I7QUE0Q1ZDLE9BQUssQ0E1Q0s7QUE2Q1ZDLE1BQUksQ0E3Q007QUE4Q1ZDLE1BQUksQ0E5Q007QUErQ1ZDLFlBQVUsVUEvQ0E7QUFnRFZDLGFBQVcsQ0FoREQ7QUFpRFZDLG9CQUFrQixtQkFqRFI7QUFrRFZyOUMsT0FBSyxDQWxESztBQW1EVnM5QyxZQUFVLENBbkRBO0FBb0RWQyw2QkFBMkIsMkJBcERqQjtBQXFEVkMsUUFBTSxDQXJESTtBQXNEVnh4QyxlQUFhLGNBdERIO0FBdURWeXhDLFlBQVUsV0F2REE7QUF3RFZwZ0QsVUFBUSxDQXhERTtBQXlEVnFnRCxhQUFXLFdBekREO0FBMERWQyxlQUFhLGFBMURIO0FBMkRWQyxjQUFZLGFBM0RGO0FBNERWM3hDLGdCQUFjLGVBNURKO0FBNkRWNHhDLGFBQVcsQ0E3REQ7QUE4RFZqdkMsY0FBWSxhQTlERjtBQStEVkQsWUFBVSxXQS9EQTtBQWdFVm12QyxrQkFBZ0Isa0JBaEVOO0FBaUVWQyxlQUFhLGNBakVIO0FBa0VWdHZDLGFBQVcsWUFsRUQ7QUFtRVZDLGVBQWEsY0FuRUg7QUFvRVZwRCxjQUFZLGFBcEVGO0FBcUVWaHdDLFVBQVEsQ0FyRUU7QUFzRVZ5RyxRQUFNLENBdEVJO0FBdUVWaThFLE1BQUksQ0F2RU07QUF3RVZDLE1BQUksQ0F4RU07QUF5RVZDLE1BQUksQ0F6RU07QUEwRVZDLE1BQUksQ0ExRU07QUEyRVZDLGFBQVcsWUEzRUQ7QUE0RVZDLDhCQUE0Qiw4QkE1RWxCO0FBNkVWQyw0QkFBMEIsNEJBN0VoQjtBQThFVkMsWUFBVSxVQTlFQTtBQStFVkMscUJBQW1CLG1CQS9FVDtBQWdGVkMsaUJBQWUsZUFoRkw7QUFpRlZDLFdBQVMsQ0FqRkM7QUFrRlZDLGFBQVcsYUFsRkQ7QUFtRlZDLGdCQUFjLGdCQW5GSjtBQW9GVkMsZUFBYSxDQXBGSDtBQXFGVkMsa0JBQWdCLGlCQXJGTjtBQXNGVixRQUFNLENBdEZJO0FBdUZWQyxPQUFLLENBdkZLO0FBd0ZWQyxhQUFXLENBeEZEO0FBeUZWL3JELEtBQUcsQ0F6Rk87QUEwRlZnc0QsTUFBSSxDQTFGTTtBQTJGVkMsTUFBSSxDQTNGTTtBQTRGVkMsTUFBSSxDQTVGTTtBQTZGVkMsTUFBSSxDQTdGTTtBQThGVkMsZ0JBQWMsY0E5Rko7QUErRlZDLG9CQUFrQixrQkEvRlI7QUFnR1ZDLFdBQVMsQ0FoR0M7QUFpR1ZDLGFBQVcsV0FqR0Q7QUFrR1ZDLGNBQVksWUFsR0Y7QUFtR1ZDLFlBQVUsVUFuR0E7QUFvR1ZDLGdCQUFjLGNBcEdKO0FBcUdWQyxpQkFBZSxnQkFyR0w7QUFzR1ZDLGlCQUFlLGdCQXRHTDtBQXVHVkMscUJBQW1CLG1CQXZHVDtBQXdHVkMsU0FBTyxDQXhHRztBQXlHVkMsYUFBVyxZQXpHRDtBQTBHVkMsYUFBVyxZQTFHRDtBQTJHVkMsZUFBYSxjQTNHSDtBQTRHVkMsZ0JBQWMsY0E1R0o7QUE2R1ZDLGVBQWEsYUE3R0g7QUE4R1ZDLGVBQWEsYUE5R0g7QUErR1ZsM0IsUUFBTSxDQS9HSTtBQWdIVm0zQixvQkFBa0Isa0JBaEhSO0FBaUhWQyxhQUFXLFdBakhEO0FBa0hWQyxnQkFBYyxDQWxISjtBQW1IVkMsUUFBTSxDQW5ISTtBQW9IVkMsY0FBWSxZQXBIRjtBQXFIVnBILFVBQVEsQ0FySEU7QUFzSFY3dEMsV0FBUyxDQXRIQztBQXVIVmsxQyxZQUFVLENBdkhBO0FBd0hWajFDLFNBQU8sQ0F4SEc7QUF5SFZrMUMsVUFBUSxDQXpIRTtBQTBIVkMsZUFBYSxDQTFISDtBQTJIVkMsVUFBUSxDQTNIRTtBQTRIVkMsWUFBVSxDQTVIQTtBQTZIVkMsb0JBQWtCLG1CQTdIUjtBQThIVkMscUJBQW1CLG9CQTlIVDtBQStIVkMsY0FBWSxhQS9IRjtBQWdJVkMsV0FBUyxVQWhJQztBQWlJVkMsY0FBWSxZQWpJRjtBQWtJVkMsdUJBQXFCLHFCQWxJWDtBQW1JVkMsb0JBQWtCLGtCQW5JUjtBQW9JVkMsZ0JBQWMsY0FwSUo7QUFxSVZDLGlCQUFlLGdCQXJJTDtBQXNJVkMsVUFBUSxDQXRJRTtBQXVJVkMsYUFBVyxXQXZJRDtBQXdJVkMsYUFBVyxXQXhJRDtBQXlJVkMsYUFBVyxXQXpJRDtBQTBJVkMsaUJBQWUsZUExSUw7QUEySVZDLHVCQUFxQixxQkEzSVg7QUE0SVZDLGtCQUFnQixnQkE1SU47QUE2SVZDLEtBQUcsQ0E3SU87QUE4SVZDLFVBQVEsQ0E5SUU7QUErSVZDLFFBQU0sTUEvSUk7QUFnSlZDLFFBQU0sTUFoSkk7QUFpSlZDLG1CQUFpQixrQkFqSlA7QUFrSlZDLGVBQWEsYUFsSkg7QUFtSlZDLGFBQVcsV0FuSkQ7QUFvSlZDLHNCQUFvQixvQkFwSlY7QUFxSlZDLG9CQUFrQixrQkFySlI7QUFzSlZDLFdBQVMsQ0F0SkM7QUF1SlZoeEUsVUFBUSxDQXZKRTtBQXdKVml4RSxVQUFRLENBeEpFO0FBeUpWQyxNQUFJLENBekpNO0FBMEpWQyxNQUFJLENBMUpNO0FBMkpWQyxTQUFPLENBM0pHO0FBNEpWQyxRQUFNLENBNUpJO0FBNkpWQyxrQkFBZ0IsaUJBN0pOO0FBOEpWQyxTQUFPLENBOUpHO0FBK0pWQyxXQUFTLENBL0pDO0FBZ0tWQyxvQkFBa0Isa0JBaEtSO0FBaUtWQyxvQkFBa0Isa0JBaktSO0FBa0tWQyxTQUFPLENBbEtHO0FBbUtWQyxnQkFBYyxjQW5LSjtBQW9LVnhMLGVBQWEsYUFwS0g7QUFxS1Z5TCxnQkFBYyxjQXJLSjtBQXNLVkMsU0FBTyxDQXRLRztBQXVLVkMsU0FBTyxDQXZLRztBQXdLVkMsZUFBYSxhQXhLSDtBQXlLVkMsYUFBVyxZQXpLRDtBQTBLVngzQyxlQUFhLGNBMUtIO0FBMktWeTNDLHlCQUF1Qix3QkEzS2I7QUE0S1ZDLDBCQUF3Qix5QkE1S2Q7QUE2S1YzOEQsVUFBUSxDQTdLRTtBQThLVjQ4RCxVQUFRLENBOUtFO0FBK0tWMTNDLG1CQUFpQixrQkEvS1A7QUFnTFZDLG9CQUFrQixtQkFoTFI7QUFpTFYwM0MsaUJBQWUsZ0JBakxMO0FBa0xWQyxrQkFBZ0IsaUJBbExOO0FBbUxWMTNDLG9CQUFrQixtQkFuTFI7QUFvTFZDLGlCQUFlLGdCQXBMTDtBQXFMVkMsZUFBYSxjQXJMSDtBQXNMVnkzQyxnQkFBYyxjQXRMSjtBQXVMVkMsa0JBQWdCLGdCQXZMTjtBQXdMVkMsZUFBYSxhQXhMSDtBQXlMVkMsV0FBUyxTQXpMQztBQTBMVkMsV0FBUyxTQTFMQztBQTJMVkMsY0FBWSxhQTNMRjtBQTRMVkMsa0JBQWdCLGlCQTVMTjtBQTZMVkMsaUJBQWUsZ0JBN0xMO0FBOExWQyxjQUFZLFlBOUxGO0FBK0xWeGlGLE1BQUksQ0EvTE07QUFnTVZ5aUYsYUFBVyxDQWhNRDtBQWlNVkMsTUFBSSxDQWpNTTtBQWtNVkMsTUFBSSxDQWxNTTtBQW1NVkMscUJBQW1CLG9CQW5NVDtBQW9NVkMsc0JBQW9CLHFCQXBNVjtBQXFNVkMsV0FBUyxDQXJNQztBQXNNVkMsZUFBYSxjQXRNSDtBQXVNVkMsZ0JBQWMsZUF2TUo7QUF3TVZDLGNBQVksY0F4TUY7QUF5TVZDLGVBQWEsY0F6TUg7QUEwTVZDLFlBQVUsV0ExTUE7QUEyTVZDLGdCQUFjLGVBM01KO0FBNE1WQyxpQkFBZSxnQkE1TUw7QUE2TVYxa0QsVUFBUSxDQTdNRTtBQThNVjJrRCxnQkFBYyxlQTlNSjtBQStNVnByRixXQUFTLENBL01DO0FBZ05WcXJGLFlBQVUsWUFoTkE7QUFpTlZDLGVBQWEsZUFqTkg7QUFrTlZDLGVBQWEsZUFsTkg7QUFtTlZDLFdBQVMsU0FuTkM7QUFvTlZDLGNBQVksWUFwTkY7QUFxTlZDLGNBQVksQ0FyTkY7QUFzTlZDLFVBQVEsQ0F0TkU7QUF1TlZDLGVBQWEsY0F2Tkg7QUF3TlZDLGVBQWEsY0F4Tkg7QUF5TlZucEYsS0FBRyxDQXpOTztBQTBOVm9wRixXQUFTLFVBMU5DO0FBMk5WQyxNQUFJLENBM05NO0FBNE5WQyxNQUFJLENBNU5NO0FBNk5WQyxvQkFBa0Isa0JBN05SO0FBOE5WQyxnQkFBYyxlQTlOSjtBQStOVkMsZ0JBQWMsZUEvTko7QUFnT1ZDLGFBQVcsWUFoT0Q7QUFpT1ZDLGFBQVcsWUFqT0Q7QUFrT1ZDLGFBQVcsWUFsT0Q7QUFtT1ZDLGNBQVksYUFuT0Y7QUFvT1ZDLGFBQVcsWUFwT0Q7QUFxT1ZDLFdBQVMsVUFyT0M7QUFzT1ZDLFNBQU8sQ0F0T0c7QUF1T1ZDLGNBQVksYUF2T0Y7QUF3T1ZDLFdBQVMsVUF4T0M7QUF5T1ZDLFlBQVUsV0F6T0E7QUEwT1Y3d0QsS0FBRyxDQTFPTztBQTJPVjh3RCxNQUFJLENBM09NO0FBNE9WQyxNQUFJLENBNU9NO0FBNk9WQyxvQkFBa0Isa0JBN09SO0FBOE9WQyxLQUFHLENBOU9PO0FBK09WQyxjQUFZO0FBL09GLENBQVo7O0FBa1BBLElBQUloM0IsdUJBQXVCO0FBQ3pCOTlDLGNBQVksRUFEYTtBQUV6QkMsMEJBQXdCO0FBQ3RCNnpFLGtCQUFjaE0sR0FBR0MsS0FESztBQUV0QmdNLGtCQUFjak0sR0FBR0MsS0FGSztBQUd0QmlNLGVBQVdsTSxHQUFHQyxLQUhRO0FBSXRCa00sZUFBV25NLEdBQUdDLEtBSlE7QUFLdEJtTSxlQUFXcE0sR0FBR0MsS0FMUTtBQU10Qm9NLGdCQUFZck0sR0FBR0MsS0FOTztBQU90QnFNLGVBQVd0TSxHQUFHQyxLQVBRO0FBUXRCc00sYUFBU3ZNLEdBQUdFLEdBUlU7QUFTdEJ3TSxhQUFTMU0sR0FBR0UsR0FUVTtBQVV0QnlNLGNBQVUzTSxHQUFHRTtBQVZTLEdBRkM7QUFjekI5bkUscUJBQW1CO0FBZE0sQ0FBM0I7O0FBaUJBalMsT0FBT29CLElBQVAsQ0FBWTQ0RSxLQUFaLEVBQW1COTRFLE9BQW5CLENBQTJCLFVBQVVVLEdBQVYsRUFBZTtBQUN4Q2l1RCx1QkFBcUI5OUMsVUFBckIsQ0FBZ0NuUSxHQUFoQyxJQUF1QyxDQUF2QztBQUNBLE1BQUlvNEUsTUFBTXA0RSxHQUFOLENBQUosRUFBZ0I7QUFDZGl1RCx5QkFBcUI1OUMsaUJBQXJCLENBQXVDclEsR0FBdkMsSUFBOENvNEUsTUFBTXA0RSxHQUFOLENBQTlDO0FBQ0Q7QUFDRixDQUxEOztBQU9BekssT0FBT0MsT0FBUCxHQUFpQnk0RCxvQkFBakIsQzs7Ozs7OztBQzVTQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlqeUMsbUJBQW1CLG1CQUFBOWhCLENBQVEsRUFBUixDQUF2QjtBQUNBLElBQUltRyx1QkFBdUIsbUJBQUFuRyxDQUFRLENBQVIsQ0FBM0I7QUFDQSxJQUFJZ0Usd0JBQXdCLG1CQUFBaEUsQ0FBUSxDQUFSLENBQTVCO0FBQ0EsSUFBSTQ0QyxzQkFBc0IsbUJBQUE1NEMsQ0FBUSxFQUFSLENBQTFCO0FBQ0EsSUFBSWlULGlCQUFpQixtQkFBQWpULENBQVEsRUFBUixDQUFyQjs7QUFFQSxJQUFJMDRDLG1CQUFtQixtQkFBQTE0QyxDQUFRLEVBQVIsQ0FBdkI7QUFDQSxJQUFJb3RDLHFCQUFxQixtQkFBQXB0QyxDQUFRLEVBQVIsQ0FBekI7QUFDQSxJQUFJODVCLGVBQWUsbUJBQUE5NUIsQ0FBUSxFQUFSLENBQW5COztBQUVBLElBQUlnckYsMkJBQTJCN2tGLHFCQUFxQkosU0FBckIsSUFBa0Msa0JBQWtCRSxRQUFwRCxJQUFnRUEsU0FBU3lZLFlBQVQsSUFBeUIsRUFBeEg7O0FBRUEsSUFBSWdJLGFBQWE7QUFDZjR6QixVQUFRO0FBQ045NUIsNkJBQXlCO0FBQ3ZCNDBDLGVBQVMsVUFEYztBQUV2QkMsZ0JBQVU7QUFGYSxLQURuQjtBQUtObnVDLGtCQUFjLENBQUMsU0FBRCxFQUFZLGdCQUFaLEVBQThCLFVBQTlCLEVBQTBDLFlBQTFDLEVBQXdELFVBQXhELEVBQW9FLGNBQXBFLEVBQW9GLFlBQXBGLEVBQWtHLG9CQUFsRztBQUxSO0FBRE8sQ0FBakI7O0FBVUEsSUFBSXN6QixnQkFBZ0IsSUFBcEI7QUFDQSxJQUFJOGMsb0JBQW9CLElBQXhCO0FBQ0EsSUFBSTJ6QixnQkFBZ0IsSUFBcEI7QUFDQSxJQUFJQyxZQUFZLEtBQWhCOztBQUVBO0FBQ0E7QUFDQSxJQUFJQyxjQUFjLEtBQWxCOztBQUVBOzs7Ozs7Ozs7QUFTQSxTQUFTanlDLFlBQVQsQ0FBc0J0M0MsSUFBdEIsRUFBNEI7QUFDMUIsTUFBSSxvQkFBb0JBLElBQXBCLElBQTRCZzNDLG9CQUFvQkMsd0JBQXBCLENBQTZDajNDLElBQTdDLENBQWhDLEVBQW9GO0FBQ2xGLFdBQU87QUFDTCszQyxhQUFPLzNDLEtBQUtnNEMsY0FEUDtBQUVMalcsV0FBSy9oQyxLQUFLaTRDO0FBRkwsS0FBUDtBQUlELEdBTEQsTUFLTyxJQUFJN3pDLE9BQU9rekMsWUFBWCxFQUF5QjtBQUM5QixRQUFJUSxZQUFZMXpDLE9BQU9rekMsWUFBUCxFQUFoQjtBQUNBLFdBQU87QUFDTDRoQyxrQkFBWXBoQyxVQUFVb2hDLFVBRGpCO0FBRUxDLG9CQUFjcmhDLFVBQVVxaEMsWUFGbkI7QUFHTHZ0QyxpQkFBV2tNLFVBQVVsTSxTQUhoQjtBQUlMd3RDLG1CQUFhdGhDLFVBQVVzaEM7QUFKbEIsS0FBUDtBQU1ELEdBUk0sTUFRQSxJQUFJLzBFLFNBQVN5ekMsU0FBYixFQUF3QjtBQUM3QixRQUFJek0sUUFBUWhuQyxTQUFTeXpDLFNBQVQsQ0FBbUJJLFdBQW5CLEVBQVo7QUFDQSxXQUFPO0FBQ0xDLHFCQUFlOU0sTUFBTThNLGFBQU4sRUFEVjtBQUVMbnZDLFlBQU1xaUMsTUFBTXJpQyxJQUZQO0FBR0x5bkQsV0FBS3BsQixNQUFNbStDLFdBSE47QUFJTEMsWUFBTXArQyxNQUFNcStDO0FBSlAsS0FBUDtBQU1EO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BLFNBQVNDLG9CQUFULENBQThCbjRFLFdBQTlCLEVBQTJDQyxpQkFBM0MsRUFBOEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJNjNFLGFBQWExd0MsaUJBQWlCLElBQTlCLElBQXNDQSxrQkFBa0I5QixrQkFBNUQsRUFBZ0Y7QUFDOUUsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQ7QUFDQSxNQUFJOHlDLG1CQUFtQnR5QyxhQUFhc0IsYUFBYixDQUF2QjtBQUNBLE1BQUksQ0FBQ3l3QyxhQUFELElBQWtCLENBQUNueEQsYUFBYW14RCxhQUFiLEVBQTRCTyxnQkFBNUIsQ0FBdkIsRUFBc0U7QUFDcEVQLG9CQUFnQk8sZ0JBQWhCOztBQUVBLFFBQUl4MkQsaUJBQWlCL2hCLGVBQWUzRSxTQUFmLENBQXlCb1ksV0FBVzR6QixNQUFwQyxFQUE0Q2dkLGlCQUE1QyxFQUErRGxrRCxXQUEvRCxFQUE0RUMsaUJBQTVFLENBQXJCOztBQUVBMmhCLG1CQUFlbnJCLElBQWYsR0FBc0IsUUFBdEI7QUFDQW1yQixtQkFBZXh2QixNQUFmLEdBQXdCZzFDLGFBQXhCOztBQUVBMTRCLHFCQUFpQlIsNEJBQWpCLENBQThDMFQsY0FBOUM7O0FBRUEsV0FBT0EsY0FBUDtBQUNEOztBQUVELFNBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7OztBQWNBLElBQUlnL0Isb0JBQW9CO0FBQ3RCdHRDLGNBQVlBLFVBRFU7O0FBR3RCbEQsaUJBQWUsdUJBQVVDLFlBQVYsRUFBd0J0USxVQUF4QixFQUFvQ0MsV0FBcEMsRUFBaURDLGlCQUFqRCxFQUFvRTtBQUNqRixRQUFJLENBQUM4M0UsV0FBTCxFQUFrQjtBQUNoQixhQUFPLElBQVA7QUFDRDs7QUFFRCxRQUFJcnlCLGFBQWEzbEQsYUFBYW5QLHNCQUFzQkYsbUJBQXRCLENBQTBDcVAsVUFBMUMsQ0FBYixHQUFxRW5OLE1BQXRGOztBQUVBLFlBQVF5ZCxZQUFSO0FBQ0U7QUFDQSxXQUFLLFVBQUw7QUFDRSxZQUFJMnBCLG1CQUFtQjByQixVQUFuQixLQUFrQ0EsV0FBV2hnQixlQUFYLEtBQStCLE1BQXJFLEVBQTZFO0FBQzNFMEIsMEJBQWdCc2UsVUFBaEI7QUFDQXhCLDhCQUFvQm5rRCxVQUFwQjtBQUNBODNFLDBCQUFnQixJQUFoQjtBQUNEO0FBQ0Q7QUFDRixXQUFLLFNBQUw7QUFDRXp3Qyx3QkFBZ0IsSUFBaEI7QUFDQThjLDRCQUFvQixJQUFwQjtBQUNBMnpCLHdCQUFnQixJQUFoQjtBQUNBO0FBQ0Y7QUFDQTtBQUNBLFdBQUssY0FBTDtBQUNFQyxvQkFBWSxJQUFaO0FBQ0E7QUFDRixXQUFLLGdCQUFMO0FBQ0EsV0FBSyxZQUFMO0FBQ0VBLG9CQUFZLEtBQVo7QUFDQSxlQUFPSyxxQkFBcUJuNEUsV0FBckIsRUFBa0NDLGlCQUFsQyxDQUFQO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBSyxvQkFBTDtBQUNFLFlBQUkyM0Usd0JBQUosRUFBOEI7QUFDNUI7QUFDRDtBQUNIO0FBQ0EsV0FBSyxZQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0UsZUFBT08scUJBQXFCbjRFLFdBQXJCLEVBQWtDQyxpQkFBbEMsQ0FBUDtBQXZDSjs7QUEwQ0EsV0FBTyxJQUFQO0FBQ0QsR0FyRHFCOztBQXVEdEIrUCxrQkFBZ0Isd0JBQVU3Z0IsSUFBVixFQUFnQmdlLGdCQUFoQixFQUFrQ0ksUUFBbEMsRUFBNEM7QUFDMUQsUUFBSUoscUJBQXFCLFVBQXpCLEVBQXFDO0FBQ25DNHFFLG9CQUFjLElBQWQ7QUFDRDtBQUNGO0FBM0RxQixDQUF4Qjs7QUE4REE5dkYsT0FBT0MsT0FBUCxHQUFpQjA0RCxpQkFBakIsQzs7Ozs7OztBQzFMQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJaHpELGlCQUFpQixtQkFBQWhCLENBQVEsQ0FBUixDQUFyQjs7QUFFQSxJQUFJbzRDLGdCQUFnQixtQkFBQXA0QyxDQUFRLEVBQVIsQ0FBcEI7QUFDQSxJQUFJOGhCLG1CQUFtQixtQkFBQTloQixDQUFRLEVBQVIsQ0FBdkI7QUFDQSxJQUFJZ0Usd0JBQXdCLG1CQUFBaEUsQ0FBUSxDQUFSLENBQTVCO0FBQ0EsSUFBSXlyRiwwQkFBMEIsbUJBQUF6ckYsQ0FBUSxHQUFSLENBQTlCO0FBQ0EsSUFBSTByRiwwQkFBMEIsbUJBQUExckYsQ0FBUSxHQUFSLENBQTlCO0FBQ0EsSUFBSWlULGlCQUFpQixtQkFBQWpULENBQVEsRUFBUixDQUFyQjtBQUNBLElBQUkyckYsc0JBQXNCLG1CQUFBM3JGLENBQVEsR0FBUixDQUExQjtBQUNBLElBQUk0ckYseUJBQXlCLG1CQUFBNXJGLENBQVEsR0FBUixDQUE3QjtBQUNBLElBQUk4cEIsc0JBQXNCLG1CQUFBOXBCLENBQVEsRUFBUixDQUExQjtBQUNBLElBQUk2ckYscUJBQXFCLG1CQUFBN3JGLENBQVEsR0FBUixDQUF6QjtBQUNBLElBQUk4ckYsc0JBQXNCLG1CQUFBOXJGLENBQVEsR0FBUixDQUExQjtBQUNBLElBQUkrckYsMkJBQTJCLG1CQUFBL3JGLENBQVEsR0FBUixDQUEvQjtBQUNBLElBQUkya0IsbUJBQW1CLG1CQUFBM2tCLENBQVEsRUFBUixDQUF2QjtBQUNBLElBQUlnc0Ysc0JBQXNCLG1CQUFBaHNGLENBQVEsR0FBUixDQUExQjs7QUFFQSxJQUFJRCxnQkFBZ0IsbUJBQUFDLENBQVEsRUFBUixDQUFwQjtBQUNBLElBQUlvL0IsbUJBQW1CLG1CQUFBcC9CLENBQVEsRUFBUixDQUF2QjtBQUNBLElBQUlaLFlBQVksbUJBQUFZLENBQVEsQ0FBUixDQUFoQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBLElBQUkwbUIsYUFBYSxFQUFqQjtBQUNBLElBQUl1bEUsaUNBQWlDLEVBQXJDO0FBQ0EsQ0FBQyxPQUFELEVBQVUsY0FBVixFQUEwQixvQkFBMUIsRUFBZ0QsZ0JBQWhELEVBQWtFLE1BQWxFLEVBQTBFLFNBQTFFLEVBQXFGLGdCQUFyRixFQUF1RyxPQUF2RyxFQUFnSCxhQUFoSCxFQUErSCxNQUEvSCxFQUF1SSxLQUF2SSxFQUE4SSxhQUE5SSxFQUE2SixNQUE3SixFQUFxSyxTQUFySyxFQUFnTCxXQUFoTCxFQUE2TCxVQUE3TCxFQUF5TSxXQUF6TSxFQUFzTixVQUF0TixFQUFrTyxXQUFsTyxFQUErTyxNQUEvTyxFQUF1UCxnQkFBdlAsRUFBeVEsU0FBelEsRUFBb1IsV0FBcFIsRUFBaVMsT0FBalMsRUFBMFMsT0FBMVMsRUFBbVQsT0FBblQsRUFBNFQsT0FBNVQsRUFBcVUsU0FBclUsRUFBZ1YsU0FBaFYsRUFBMlYsVUFBM1YsRUFBdVcsT0FBdlcsRUFBZ1gsTUFBaFgsRUFBd1gsWUFBeFgsRUFBc1ksZ0JBQXRZLEVBQXdaLFdBQXhaLEVBQXFhLFdBQXJhLEVBQWtiLFdBQWxiLEVBQStiLFVBQS9iLEVBQTJjLFdBQTNjLEVBQXdkLFNBQXhkLEVBQW1lLE9BQW5lLEVBQTRlLE9BQTVlLEVBQXFmLE1BQXJmLEVBQTZmLFNBQTdmLEVBQXdnQixVQUF4Z0IsRUFBb2hCLFlBQXBoQixFQUFraUIsT0FBbGlCLEVBQTJpQixRQUEzaUIsRUFBcWpCLFFBQXJqQixFQUErakIsU0FBL2pCLEVBQTBrQixTQUExa0IsRUFBcWxCLFFBQXJsQixFQUErbEIsU0FBL2xCLEVBQTBtQixZQUExbUIsRUFBd25CLGFBQXhuQixFQUF1b0IsVUFBdm9CLEVBQW1wQixXQUFucEIsRUFBZ3FCLFlBQWhxQixFQUE4cUIsZUFBOXFCLEVBQStyQixjQUEvckIsRUFBK3NCLFNBQS9zQixFQUEwdEIsT0FBMXRCLEVBQW11QjdtRixPQUFudUIsQ0FBMnVCLFVBQVV3TixLQUFWLEVBQWlCO0FBQzF2QixNQUFJczVFLG1CQUFtQnQ1RSxNQUFNLENBQU4sRUFBU3c5QixXQUFULEtBQXlCeDlCLE1BQU1sUixLQUFOLENBQVksQ0FBWixDQUFoRDtBQUNBLE1BQUl5cUYsVUFBVSxPQUFPRCxnQkFBckI7QUFDQSxNQUFJRSxXQUFXLFFBQVFGLGdCQUF2Qjs7QUFFQSxNQUFJcmlGLE9BQU87QUFDVDJXLDZCQUF5QjtBQUN2QjQwQyxlQUFTKzJCLE9BRGM7QUFFdkI5MkIsZ0JBQVU4MkIsVUFBVTtBQUZHLEtBRGhCO0FBS1RqbEUsa0JBQWMsQ0FBQ2tsRSxRQUFEO0FBTEwsR0FBWDtBQU9BMWxFLGFBQVc5VCxLQUFYLElBQW9CL0ksSUFBcEI7QUFDQW9pRixpQ0FBK0JHLFFBQS9CLElBQTJDdmlGLElBQTNDO0FBQ0QsQ0FkRDs7QUFnQkEsSUFBSXdpRixtQkFBbUIsRUFBdkI7O0FBRUEsU0FBUzdwRSxnQkFBVCxDQUEwQmpnQixJQUExQixFQUFnQztBQUM5QjtBQUNBO0FBQ0EsU0FBTyxNQUFNQSxLQUFLa2dCLFdBQWxCO0FBQ0Q7O0FBRUQsU0FBU0MsYUFBVCxDQUF1QkMsR0FBdkIsRUFBNEI7QUFDMUIsU0FBT0EsUUFBUSxRQUFSLElBQW9CQSxRQUFRLE9BQTVCLElBQXVDQSxRQUFRLFFBQS9DLElBQTJEQSxRQUFRLFVBQTFFO0FBQ0Q7O0FBRUQsSUFBSXN4QyxvQkFBb0I7QUFDdEJ2dEMsY0FBWUEsVUFEVTs7QUFHdEJsRCxpQkFBZSx1QkFBVUMsWUFBVixFQUF3QnRRLFVBQXhCLEVBQW9DQyxXQUFwQyxFQUFpREMsaUJBQWpELEVBQW9FO0FBQ2pGLFFBQUlILGlCQUFpQis0RSwrQkFBK0J4b0UsWUFBL0IsQ0FBckI7QUFDQSxRQUFJLENBQUN2USxjQUFMLEVBQXFCO0FBQ25CLGFBQU8sSUFBUDtBQUNEO0FBQ0QsUUFBSW81RSxnQkFBSjtBQUNBLFlBQVE3b0UsWUFBUjtBQUNFLFdBQUssVUFBTDtBQUNBLFdBQUssWUFBTDtBQUNBLFdBQUssbUJBQUw7QUFDQSxXQUFLLG1CQUFMO0FBQ0EsV0FBSyxZQUFMO0FBQ0EsV0FBSyxjQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0EsV0FBSyxZQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxlQUFMO0FBQ0EsV0FBSyxtQkFBTDtBQUNBLFdBQUssY0FBTDtBQUNBLFdBQUssVUFBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssWUFBTDtBQUNBLFdBQUssYUFBTDtBQUNBLFdBQUssZUFBTDtBQUNBLFdBQUssVUFBTDtBQUNBLFdBQUssV0FBTDtBQUNBLFdBQUssWUFBTDtBQUNBLFdBQUssWUFBTDtBQUNBLFdBQUssV0FBTDtBQUNBLFdBQUssWUFBTDtBQUNBLFdBQUssZUFBTDtBQUNBLFdBQUssaUJBQUw7QUFDQSxXQUFLLFlBQUw7QUFDRTtBQUNBO0FBQ0E2b0UsMkJBQW1CcjVFLGNBQW5CO0FBQ0E7QUFDRixXQUFLLGFBQUw7QUFDRTtBQUNBO0FBQ0E7QUFDQSxZQUFJbXNCLGlCQUFpQmhzQixXQUFqQixNQUFrQyxDQUF0QyxFQUF5QztBQUN2QyxpQkFBTyxJQUFQO0FBQ0Q7QUFDSDtBQUNBLFdBQUssWUFBTDtBQUNBLFdBQUssVUFBTDtBQUNFazVFLDJCQUFtQlYsc0JBQW5CO0FBQ0E7QUFDRixXQUFLLFNBQUw7QUFDQSxXQUFLLFVBQUw7QUFDRVUsMkJBQW1CWCxtQkFBbkI7QUFDQTtBQUNGLFdBQUssVUFBTDtBQUNFO0FBQ0E7QUFDQSxZQUFJdjRFLFlBQVlnVyxNQUFaLEtBQXVCLENBQTNCLEVBQThCO0FBQzVCLGlCQUFPLElBQVA7QUFDRDtBQUNIO0FBQ0EsV0FBSyxnQkFBTDtBQUNBLFdBQUssY0FBTDtBQUNBLFdBQUssY0FBTDtBQUNBLFdBQUssWUFBTDtBQUNBO0FBQ0E7QUFDQSxXQUFLLGFBQUw7QUFDQSxXQUFLLGNBQUw7QUFDQSxXQUFLLGdCQUFMO0FBQ0VrakUsMkJBQW1CeGlFLG1CQUFuQjtBQUNBO0FBQ0YsV0FBSyxTQUFMO0FBQ0EsV0FBSyxZQUFMO0FBQ0EsV0FBSyxjQUFMO0FBQ0EsV0FBSyxhQUFMO0FBQ0EsV0FBSyxjQUFMO0FBQ0EsV0FBSyxhQUFMO0FBQ0EsV0FBSyxjQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0V3aUUsMkJBQW1CVCxrQkFBbkI7QUFDQTtBQUNGLFdBQUssZ0JBQUw7QUFDQSxXQUFLLGFBQUw7QUFDQSxXQUFLLGNBQUw7QUFDQSxXQUFLLGVBQUw7QUFDRVMsMkJBQW1CUixtQkFBbkI7QUFDQTtBQUNGLFdBQUssaUJBQUw7QUFDQSxXQUFLLHVCQUFMO0FBQ0EsV0FBSyxtQkFBTDtBQUNFUSwyQkFBbUJiLHVCQUFuQjtBQUNBO0FBQ0YsV0FBSyxrQkFBTDtBQUNFYSwyQkFBbUJQLHdCQUFuQjtBQUNBO0FBQ0YsV0FBSyxXQUFMO0FBQ0VPLDJCQUFtQjNuRSxnQkFBbkI7QUFDQTtBQUNGLFdBQUssVUFBTDtBQUNFMm5FLDJCQUFtQk4sbUJBQW5CO0FBQ0E7QUFDRixXQUFLLFNBQUw7QUFDQSxXQUFLLFFBQUw7QUFDQSxXQUFLLFVBQUw7QUFDRU0sMkJBQW1CWix1QkFBbkI7QUFDQTtBQXJHSjtBQXVHQSxLQUFDWSxnQkFBRCxHQUFvQmx4RixRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLGdEQUFqQixFQUFtRXFrQixZQUFuRSxDQUF4QyxHQUEySHppQixlQUFlLElBQWYsRUFBcUJ5aUIsWUFBckIsQ0FBL0ksR0FBb0wsS0FBSyxDQUF6TDtBQUNBLFFBQUk3USxRQUFRMDVFLGlCQUFpQmgrRSxTQUFqQixDQUEyQjRFLGNBQTNCLEVBQTJDQyxVQUEzQyxFQUF1REMsV0FBdkQsRUFBb0VDLGlCQUFwRSxDQUFaO0FBQ0F5TyxxQkFBaUJSLDRCQUFqQixDQUE4QzFPLEtBQTlDO0FBQ0EsV0FBT0EsS0FBUDtBQUNELEdBcEhxQjs7QUFzSHRCd1Esa0JBQWdCLHdCQUFVN2dCLElBQVYsRUFBZ0JnZSxnQkFBaEIsRUFBa0NJLFFBQWxDLEVBQTRDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJSixxQkFBcUIsU0FBckIsSUFBa0MsQ0FBQ21DLGNBQWNuZ0IsS0FBSytsRSxJQUFuQixDQUF2QyxFQUFpRTtBQUMvRCxVQUFJeGlFLE1BQU0wYyxpQkFBaUJqZ0IsSUFBakIsQ0FBVjtBQUNBLFVBQUlYLE9BQU9vQyxzQkFBc0JGLG1CQUF0QixDQUEwQ3ZCLElBQTFDLENBQVg7QUFDQSxVQUFJLENBQUM4cEYsaUJBQWlCdm1GLEdBQWpCLENBQUwsRUFBNEI7QUFDMUJ1bUYseUJBQWlCdm1GLEdBQWpCLElBQXdCc3lDLGNBQWN6VixNQUFkLENBQXFCL2dDLElBQXJCLEVBQTJCLE9BQTNCLEVBQW9DN0IsYUFBcEMsQ0FBeEI7QUFDRDtBQUNGO0FBQ0YsR0FuSXFCOztBQXFJdEJ1akIsc0JBQW9CLDRCQUFVL2dCLElBQVYsRUFBZ0JnZSxnQkFBaEIsRUFBa0M7QUFDcEQsUUFBSUEscUJBQXFCLFNBQXJCLElBQWtDLENBQUNtQyxjQUFjbmdCLEtBQUsrbEUsSUFBbkIsQ0FBdkMsRUFBaUU7QUFDL0QsVUFBSXhpRSxNQUFNMGMsaUJBQWlCamdCLElBQWpCLENBQVY7QUFDQThwRix1QkFBaUJ2bUYsR0FBakIsRUFBc0JnZixNQUF0QjtBQUNBLGFBQU91bkUsaUJBQWlCdm1GLEdBQWpCLENBQVA7QUFDRDtBQUNGO0FBM0lxQixDQUF4Qjs7QUE4SUF6SyxPQUFPQyxPQUFQLEdBQWlCMjRELGlCQUFqQixDOzs7Ozs7OztBQ2hPQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUloaEQsaUJBQWlCLG1CQUFBalQsQ0FBUSxFQUFSLENBQXJCOztBQUVBOzs7OztBQUtBLElBQUl1c0YsMEJBQTBCO0FBQzVCQyxpQkFBZSxJQURhO0FBRTVCQyxlQUFhLElBRmU7QUFHNUJDLGlCQUFlO0FBSGEsQ0FBOUI7O0FBTUE7Ozs7OztBQU1BLFNBQVNqQix1QkFBVCxDQUFpQ3Y0RSxjQUFqQyxFQUFpRDBSLGNBQWpELEVBQWlFeFIsV0FBakUsRUFBOEVDLGlCQUE5RSxFQUFpRztBQUMvRixTQUFPSixlQUFlaFgsSUFBZixDQUFvQixJQUFwQixFQUEwQmlYLGNBQTFCLEVBQTBDMFIsY0FBMUMsRUFBMER4UixXQUExRCxFQUF1RUMsaUJBQXZFLENBQVA7QUFDRDs7QUFFREosZUFBZXlCLFlBQWYsQ0FBNEIrMkUsdUJBQTVCLEVBQXFEYyx1QkFBckQ7O0FBRUFseEYsT0FBT0MsT0FBUCxHQUFpQm13Rix1QkFBakIsQzs7Ozs7OztBQ3JDQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUl4NEUsaUJBQWlCLG1CQUFBalQsQ0FBUSxFQUFSLENBQXJCOztBQUVBOzs7O0FBSUEsSUFBSTJzRiwwQkFBMEI7QUFDNUJDLGlCQUFlLHVCQUFVaDZFLEtBQVYsRUFBaUI7QUFDOUIsV0FBTyxtQkFBbUJBLEtBQW5CLEdBQTJCQSxNQUFNZzZFLGFBQWpDLEdBQWlENW1GLE9BQU80bUYsYUFBL0Q7QUFDRDtBQUgyQixDQUE5Qjs7QUFNQTs7Ozs7O0FBTUEsU0FBU2xCLHVCQUFULENBQWlDeDRFLGNBQWpDLEVBQWlEMFIsY0FBakQsRUFBaUV4UixXQUFqRSxFQUE4RUMsaUJBQTlFLEVBQWlHO0FBQy9GLFNBQU9KLGVBQWVoWCxJQUFmLENBQW9CLElBQXBCLEVBQTBCaVgsY0FBMUIsRUFBMEMwUixjQUExQyxFQUEwRHhSLFdBQTFELEVBQXVFQyxpQkFBdkUsQ0FBUDtBQUNEOztBQUVESixlQUFleUIsWUFBZixDQUE0QmczRSx1QkFBNUIsRUFBcURpQix1QkFBckQ7O0FBRUF0eEYsT0FBT0MsT0FBUCxHQUFpQm93Rix1QkFBakIsQzs7Ozs7OztBQ3BDQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUkvbUUsbUJBQW1CLG1CQUFBM2tCLENBQVEsRUFBUixDQUF2Qjs7QUFFQTs7OztBQUlBLElBQUk2c0Ysc0JBQXNCO0FBQ3hCdmpFLGlCQUFlO0FBRFMsQ0FBMUI7O0FBSUE7Ozs7OztBQU1BLFNBQVNxaUUsbUJBQVQsQ0FBNkJ6NEUsY0FBN0IsRUFBNkMwUixjQUE3QyxFQUE2RHhSLFdBQTdELEVBQTBFQyxpQkFBMUUsRUFBNkY7QUFDM0YsU0FBT3NSLGlCQUFpQjFvQixJQUFqQixDQUFzQixJQUF0QixFQUE0QmlYLGNBQTVCLEVBQTRDMFIsY0FBNUMsRUFBNER4UixXQUE1RCxFQUF5RUMsaUJBQXpFLENBQVA7QUFDRDs7QUFFRHNSLGlCQUFpQmpRLFlBQWpCLENBQThCaTNFLG1CQUE5QixFQUFtRGtCLG1CQUFuRDs7QUFFQXh4RixPQUFPQyxPQUFQLEdBQWlCcXdGLG1CQUFqQixDOzs7Ozs7O0FDbENBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSWhuRSxtQkFBbUIsbUJBQUEza0IsQ0FBUSxFQUFSLENBQXZCOztBQUVBLElBQUlvL0IsbUJBQW1CLG1CQUFBcC9CLENBQVEsRUFBUixDQUF2QjtBQUNBLElBQUk4c0YsY0FBYyxtQkFBQTlzRixDQUFRLEdBQVIsQ0FBbEI7QUFDQSxJQUFJeW9CLHdCQUF3QixtQkFBQXpvQixDQUFRLEVBQVIsQ0FBNUI7O0FBRUE7Ozs7QUFJQSxJQUFJK3NGLHlCQUF5QjtBQUMzQmpuRixPQUFLZ25GLFdBRHNCO0FBRTNCN21FLFlBQVUsSUFGaUI7QUFHM0I4QyxXQUFTLElBSGtCO0FBSTNCQyxZQUFVLElBSmlCO0FBSzNCQyxVQUFRLElBTG1CO0FBTTNCQyxXQUFTLElBTmtCO0FBTzNCOGpFLFVBQVEsSUFQbUI7QUFRM0JDLFVBQVEsSUFSbUI7QUFTM0I5akUsb0JBQWtCVixxQkFUUztBQVUzQjtBQUNBNFcsWUFBVSxrQkFBVXpzQixLQUFWLEVBQWlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQUlBLE1BQU0vSSxJQUFOLEtBQWUsVUFBbkIsRUFBK0I7QUFDN0IsYUFBT3UxQixpQkFBaUJ4c0IsS0FBakIsQ0FBUDtBQUNEO0FBQ0QsV0FBTyxDQUFQO0FBQ0QsR0FyQjBCO0FBc0IzQjBzQixXQUFTLGlCQUFVMXNCLEtBQVYsRUFBaUI7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUlBLE1BQU0vSSxJQUFOLEtBQWUsU0FBZixJQUE0QitJLE1BQU0vSSxJQUFOLEtBQWUsT0FBL0MsRUFBd0Q7QUFDdEQsYUFBTytJLE1BQU0wc0IsT0FBYjtBQUNEO0FBQ0QsV0FBTyxDQUFQO0FBQ0QsR0FsQzBCO0FBbUMzQisyQixTQUFPLGVBQVV6akQsS0FBVixFQUFpQjtBQUN0QjtBQUNBO0FBQ0EsUUFBSUEsTUFBTS9JLElBQU4sS0FBZSxVQUFuQixFQUErQjtBQUM3QixhQUFPdTFCLGlCQUFpQnhzQixLQUFqQixDQUFQO0FBQ0Q7QUFDRCxRQUFJQSxNQUFNL0ksSUFBTixLQUFlLFNBQWYsSUFBNEIrSSxNQUFNL0ksSUFBTixLQUFlLE9BQS9DLEVBQXdEO0FBQ3RELGFBQU8rSSxNQUFNMHNCLE9BQWI7QUFDRDtBQUNELFdBQU8sQ0FBUDtBQUNEO0FBN0MwQixDQUE3Qjs7QUFnREE7Ozs7OztBQU1BLFNBQVNzc0Qsc0JBQVQsQ0FBZ0MxNEUsY0FBaEMsRUFBZ0QwUixjQUFoRCxFQUFnRXhSLFdBQWhFLEVBQTZFQyxpQkFBN0UsRUFBZ0c7QUFDOUYsU0FBT3NSLGlCQUFpQjFvQixJQUFqQixDQUFzQixJQUF0QixFQUE0QmlYLGNBQTVCLEVBQTRDMFIsY0FBNUMsRUFBNER4UixXQUE1RCxFQUF5RUMsaUJBQXpFLENBQVA7QUFDRDs7QUFFRHNSLGlCQUFpQmpRLFlBQWpCLENBQThCazNFLHNCQUE5QixFQUFzRG1CLHNCQUF0RDs7QUFFQTF4RixPQUFPQyxPQUFQLEdBQWlCc3dGLHNCQUFqQixDOzs7Ozs7O0FDbEZBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSXhzRCxtQkFBbUIsbUJBQUFwL0IsQ0FBUSxFQUFSLENBQXZCOztBQUVBOzs7O0FBSUEsSUFBSWt0RixlQUFlO0FBQ2pCQyxPQUFLLFFBRFk7QUFFakJDLFlBQVUsR0FGTztBQUdqQkMsUUFBTSxXQUhXO0FBSWpCQyxNQUFJLFNBSmE7QUFLakJDLFNBQU8sWUFMVTtBQU1qQkMsUUFBTSxXQU5XO0FBT2pCQyxPQUFLLFFBUFk7QUFRakJDLE9BQUssSUFSWTtBQVNqQkMsUUFBTSxhQVRXO0FBVWpCQyxRQUFNLGFBVlc7QUFXakJDLFVBQVEsWUFYUztBQVlqQkMsbUJBQWlCO0FBWkEsQ0FBbkI7O0FBZUE7Ozs7O0FBS0EsSUFBSUMsaUJBQWlCO0FBQ25CLEtBQUcsV0FEZ0I7QUFFbkIsS0FBRyxLQUZnQjtBQUduQixNQUFJLE9BSGU7QUFJbkIsTUFBSSxPQUplO0FBS25CLE1BQUksT0FMZTtBQU1uQixNQUFJLFNBTmU7QUFPbkIsTUFBSSxLQVBlO0FBUW5CLE1BQUksT0FSZTtBQVNuQixNQUFJLFVBVGU7QUFVbkIsTUFBSSxRQVZlO0FBV25CLE1BQUksR0FYZTtBQVluQixNQUFJLFFBWmU7QUFhbkIsTUFBSSxVQWJlO0FBY25CLE1BQUksS0FkZTtBQWVuQixNQUFJLE1BZmU7QUFnQm5CLE1BQUksV0FoQmU7QUFpQm5CLE1BQUksU0FqQmU7QUFrQm5CLE1BQUksWUFsQmU7QUFtQm5CLE1BQUksV0FuQmU7QUFvQm5CLE1BQUksUUFwQmU7QUFxQm5CLE1BQUksUUFyQmU7QUFzQm5CLE9BQUssSUF0QmM7QUF1Qm5CLE9BQUssSUF2QmM7QUF3Qm5CLE9BQUssSUF4QmM7QUF5Qm5CLE9BQUssSUF6QmM7QUEwQm5CLE9BQUssSUExQmM7QUEyQm5CLE9BQUssSUEzQmM7QUE0Qm5CLE9BQUssSUE1QmM7QUE2Qm5CLE9BQUssSUE3QmM7QUE4Qm5CLE9BQUssSUE5QmM7QUErQm5CLE9BQUssS0EvQmM7QUFnQ25CLE9BQUssS0FoQ2M7QUFpQ25CLE9BQUssS0FqQ2M7QUFrQ25CLE9BQUssU0FsQ2M7QUFtQ25CLE9BQUssWUFuQ2M7QUFvQ25CLE9BQUs7QUFwQ2MsQ0FBckI7O0FBdUNBOzs7O0FBSUEsU0FBU2pCLFdBQVQsQ0FBcUIxNUUsV0FBckIsRUFBa0M7QUFDaEMsTUFBSUEsWUFBWXROLEdBQWhCLEVBQXFCO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQUlBLE1BQU1vbkYsYUFBYTk1RSxZQUFZdE4sR0FBekIsS0FBaUNzTixZQUFZdE4sR0FBdkQ7QUFDQSxRQUFJQSxRQUFRLGNBQVosRUFBNEI7QUFDMUIsYUFBT0EsR0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxNQUFJc04sWUFBWXZKLElBQVosS0FBcUIsVUFBekIsRUFBcUM7QUFDbkMsUUFBSXcxQixXQUFXRCxpQkFBaUJoc0IsV0FBakIsQ0FBZjs7QUFFQTtBQUNBO0FBQ0EsV0FBT2lzQixhQUFhLEVBQWIsR0FBa0IsT0FBbEIsR0FBNEJyOUIsT0FBTzZDLFlBQVAsQ0FBb0J3NkIsUUFBcEIsQ0FBbkM7QUFDRDtBQUNELE1BQUlqc0IsWUFBWXZKLElBQVosS0FBcUIsU0FBckIsSUFBa0N1SixZQUFZdkosSUFBWixLQUFxQixPQUEzRCxFQUFvRTtBQUNsRTtBQUNBO0FBQ0EsV0FBT2trRixlQUFlMzZFLFlBQVlrc0IsT0FBM0IsS0FBdUMsY0FBOUM7QUFDRDtBQUNELFNBQU8sRUFBUDtBQUNEOztBQUVEamtDLE9BQU9DLE9BQVAsR0FBaUJ3eEYsV0FBakIsQzs7Ozs7OztBQzlHQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUloakUsc0JBQXNCLG1CQUFBOXBCLENBQVEsRUFBUixDQUExQjs7QUFFQTs7OztBQUlBLElBQUlndUYscUJBQXFCO0FBQ3ZCQyxnQkFBYztBQURTLENBQXpCOztBQUlBOzs7Ozs7QUFNQSxTQUFTcEMsa0JBQVQsQ0FBNEIzNEUsY0FBNUIsRUFBNEMwUixjQUE1QyxFQUE0RHhSLFdBQTVELEVBQXlFQyxpQkFBekUsRUFBNEY7QUFDMUYsU0FBT3lXLG9CQUFvQjd0QixJQUFwQixDQUF5QixJQUF6QixFQUErQmlYLGNBQS9CLEVBQStDMFIsY0FBL0MsRUFBK0R4UixXQUEvRCxFQUE0RUMsaUJBQTVFLENBQVA7QUFDRDs7QUFFRHlXLG9CQUFvQnBWLFlBQXBCLENBQWlDbTNFLGtCQUFqQyxFQUFxRG1DLGtCQUFyRDs7QUFFQTN5RixPQUFPQyxPQUFQLEdBQWlCdXdGLGtCQUFqQixDOzs7Ozs7O0FDbENBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSWxuRSxtQkFBbUIsbUJBQUEza0IsQ0FBUSxFQUFSLENBQXZCOztBQUVBLElBQUl5b0Isd0JBQXdCLG1CQUFBem9CLENBQVEsRUFBUixDQUE1Qjs7QUFFQTs7OztBQUlBLElBQUlrdUYsc0JBQXNCO0FBQ3hCQyxXQUFTLElBRGU7QUFFeEJDLGlCQUFlLElBRlM7QUFHeEJDLGtCQUFnQixJQUhRO0FBSXhCcGxFLFVBQVEsSUFKZ0I7QUFLeEJDLFdBQVMsSUFMZTtBQU14QkgsV0FBUyxJQU5lO0FBT3hCQyxZQUFVLElBUGM7QUFReEJHLG9CQUFrQlY7QUFSTSxDQUExQjs7QUFXQTs7Ozs7O0FBTUEsU0FBU3FqRSxtQkFBVCxDQUE2QjU0RSxjQUE3QixFQUE2QzBSLGNBQTdDLEVBQTZEeFIsV0FBN0QsRUFBMEVDLGlCQUExRSxFQUE2RjtBQUMzRixTQUFPc1IsaUJBQWlCMW9CLElBQWpCLENBQXNCLElBQXRCLEVBQTRCaVgsY0FBNUIsRUFBNEMwUixjQUE1QyxFQUE0RHhSLFdBQTVELEVBQXlFQyxpQkFBekUsQ0FBUDtBQUNEOztBQUVEc1IsaUJBQWlCalEsWUFBakIsQ0FBOEJvM0UsbUJBQTlCLEVBQW1Eb0MsbUJBQW5EOztBQUVBN3lGLE9BQU9DLE9BQVAsR0FBaUJ3d0YsbUJBQWpCLEM7Ozs7Ozs7QUMzQ0E7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJNzRFLGlCQUFpQixtQkFBQWpULENBQVEsRUFBUixDQUFyQjs7QUFFQTs7Ozs7QUFLQSxJQUFJc3VGLDJCQUEyQjtBQUM3QnYzRSxnQkFBYyxJQURlO0FBRTdCMDFFLGVBQWEsSUFGZ0I7QUFHN0JDLGlCQUFlO0FBSGMsQ0FBL0I7O0FBTUE7Ozs7OztBQU1BLFNBQVNYLHdCQUFULENBQWtDNzRFLGNBQWxDLEVBQWtEMFIsY0FBbEQsRUFBa0V4UixXQUFsRSxFQUErRUMsaUJBQS9FLEVBQWtHO0FBQ2hHLFNBQU9KLGVBQWVoWCxJQUFmLENBQW9CLElBQXBCLEVBQTBCaVgsY0FBMUIsRUFBMEMwUixjQUExQyxFQUEwRHhSLFdBQTFELEVBQXVFQyxpQkFBdkUsQ0FBUDtBQUNEOztBQUVESixlQUFleUIsWUFBZixDQUE0QnEzRSx3QkFBNUIsRUFBc0R1Qyx3QkFBdEQ7O0FBRUFqekYsT0FBT0MsT0FBUCxHQUFpQnl3Rix3QkFBakIsQzs7Ozs7OztBQ3JDQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlqaUUsc0JBQXNCLG1CQUFBOXBCLENBQVEsRUFBUixDQUExQjs7QUFFQTs7OztBQUlBLElBQUl1dUYsc0JBQXNCO0FBQ3hCQyxVQUFRLGdCQUFVNTdFLEtBQVYsRUFBaUI7QUFDdkIsV0FBTyxZQUFZQSxLQUFaLEdBQW9CQSxNQUFNNDdFLE1BQTFCLEdBQW1DO0FBQzFDLHFCQUFpQjU3RSxLQUFqQixHQUF5QixDQUFDQSxNQUFNNjdFLFdBQWhDLEdBQThDLENBRDlDO0FBRUQsR0FKdUI7QUFLeEJDLFVBQVEsZ0JBQVU5N0UsS0FBVixFQUFpQjtBQUN2QixXQUFPLFlBQVlBLEtBQVosR0FBb0JBLE1BQU04N0UsTUFBMUIsR0FBbUM7QUFDMUMscUJBQWlCOTdFLEtBQWpCLEdBQXlCLENBQUNBLE1BQU0rN0UsV0FBaEMsR0FBOEM7QUFDOUMsb0JBQWdCLzdFLEtBQWhCLEdBQXdCLENBQUNBLE1BQU1nOEUsVUFBL0IsR0FBNEMsQ0FGNUM7QUFHRCxHQVR1QjtBQVV4QkMsVUFBUSxJQVZnQjs7QUFZeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQUMsYUFBVztBQWhCYSxDQUExQjs7QUFtQkE7Ozs7OztBQU1BLFNBQVM5QyxtQkFBVCxDQUE2Qjk0RSxjQUE3QixFQUE2QzBSLGNBQTdDLEVBQTZEeFIsV0FBN0QsRUFBMEVDLGlCQUExRSxFQUE2RjtBQUMzRixTQUFPeVcsb0JBQW9CN3RCLElBQXBCLENBQXlCLElBQXpCLEVBQStCaVgsY0FBL0IsRUFBK0MwUixjQUEvQyxFQUErRHhSLFdBQS9ELEVBQTRFQyxpQkFBNUUsQ0FBUDtBQUNEOztBQUVEeVcsb0JBQW9CcFYsWUFBcEIsQ0FBaUNzM0UsbUJBQWpDLEVBQXNEdUMsbUJBQXREOztBQUVBbHpGLE9BQU9DLE9BQVAsR0FBaUIwd0YsbUJBQWpCLEM7Ozs7Ozs7QUNqREE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJMXZELHFCQUFxQixtQkFBQXQ4QixDQUFRLEVBQVIsQ0FBekI7O0FBRUEsSUFBSTg2QyxnQkFBZ0IsQ0FBcEI7O0FBRUEsU0FBU0oscUJBQVQsQ0FBK0JxMEMsZUFBL0IsRUFBZ0RudEYsSUFBaEQsRUFBc0Q7QUFDcEQsTUFBSTJKLE9BQU87QUFDVG93QyxzQkFBa0JvekMsZUFEVDtBQUVUcmtCLGdCQUFZLENBRkg7QUFHVDNCLG9CQUFnQm5uRSxPQUFPQSxLQUFLRSxRQUFMLEtBQWtCZzVDLGFBQWxCLEdBQWtDbDVDLElBQWxDLEdBQXlDQSxLQUFLMmlCLGFBQXJELEdBQXFFLElBSDVFO0FBSVR1a0QsV0FBT2xuRSxJQUpFO0FBS1QwbUUsVUFBTTFtRSxPQUFPQSxLQUFLc2QsUUFBTCxDQUFjeEksV0FBZCxFQUFQLEdBQXFDLElBTGxDO0FBTVQ0ekQsbUJBQWUxb0UsT0FBT0EsS0FBS3VkLFlBQVosR0FBMkI7QUFOakMsR0FBWDtBQVFBLE1BQUkvakIsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekNxTSxTQUFLaytELGFBQUwsR0FBcUI3bkUsT0FBTzA2QixtQkFBbUJhLG1CQUFuQixDQUF1QyxJQUF2QyxFQUE2QzV4QixLQUFLKzhELElBQWxELEVBQXdELElBQXhELENBQVAsR0FBdUUsSUFBNUY7QUFDRDtBQUNELFNBQU8vOEQsSUFBUDtBQUNEOztBQUVEbFEsT0FBT0MsT0FBUCxHQUFpQm8vQyxxQkFBakIsQzs7Ozs7Ozs7QUMvQkE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJQyx1QkFBdUI7QUFDekJxQixvQkFBa0IsSUFETztBQUV6Qmd6QyxZQUFVO0FBRmUsQ0FBM0I7O0FBS0EzekYsT0FBT0MsT0FBUCxHQUFpQnEvQyxvQkFBakIsQzs7Ozs7OztBQ2pCQTs7Ozs7Ozs7OztBQVVBOztBQUVBLElBQUlzMEMsVUFBVSxtQkFBQWp2RixDQUFRLEdBQVIsQ0FBZDs7QUFFQSxJQUFJa3ZGLFVBQVUsTUFBZDtBQUNBLElBQUlDLGdCQUFnQixVQUFwQjs7QUFFQSxJQUFJdjBDLHNCQUFzQjtBQUN4QitELHNCQUFvQixxQkFESTs7QUFHeEI7Ozs7QUFJQXl3Qyx1QkFBcUIsNkJBQVU5eEUsTUFBVixFQUFrQjtBQUNyQyxRQUFJb2hDLFdBQVd1d0MsUUFBUTN4RSxNQUFSLENBQWY7O0FBRUE7QUFDQSxRQUFJNnhFLGNBQWN2bkYsSUFBZCxDQUFtQjBWLE1BQW5CLENBQUosRUFBZ0M7QUFDOUIsYUFBT0EsTUFBUDtBQUNELEtBRkQsTUFFTztBQUNMLGFBQU9BLE9BQU96ZCxPQUFQLENBQWVxdkYsT0FBZixFQUF3QixNQUFNdDBDLG9CQUFvQitELGtCQUExQixHQUErQyxJQUEvQyxHQUFzREQsUUFBdEQsR0FBaUUsS0FBekYsQ0FBUDtBQUNEO0FBQ0YsR0FoQnVCOztBQWtCeEI7Ozs7O0FBS0FELGtCQUFnQix3QkFBVW5oQyxNQUFWLEVBQWtCMVQsT0FBbEIsRUFBMkI7QUFDekMsUUFBSXlsRixtQkFBbUJ6bEYsUUFBUTdILFlBQVIsQ0FBcUI2NEMsb0JBQW9CK0Qsa0JBQXpDLENBQXZCO0FBQ0Ewd0MsdUJBQW1CQSxvQkFBb0JubUYsU0FBU21tRixnQkFBVCxFQUEyQixFQUEzQixDQUF2QztBQUNBLFFBQUlDLGlCQUFpQkwsUUFBUTN4RSxNQUFSLENBQXJCO0FBQ0EsV0FBT2d5RSxtQkFBbUJELGdCQUExQjtBQUNEO0FBNUJ1QixDQUExQjs7QUErQkFoMEYsT0FBT0MsT0FBUCxHQUFpQnMvQyxtQkFBakIsQzs7Ozs7OztBQ2hEQTs7Ozs7Ozs7Ozs7QUFXQTs7QUFFQSxJQUFJMjBDLE1BQU0sS0FBVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBU04sT0FBVCxDQUFpQjFrRSxJQUFqQixFQUF1QjtBQUNyQixNQUFJanJCLElBQUksQ0FBUjtBQUNBLE1BQUlDLElBQUksQ0FBUjtBQUNBLE1BQUlwQyxJQUFJLENBQVI7QUFDQSxNQUFJcXlGLElBQUlqbEUsS0FBSzl0QixNQUFiO0FBQ0EsTUFBSWd6RixJQUFJRCxJQUFJLENBQUMsR0FBYjtBQUNBLFNBQU9yeUYsSUFBSXN5RixDQUFYLEVBQWM7QUFDWixRQUFJenFGLElBQUl6RCxLQUFLbTlCLEdBQUwsQ0FBU3ZoQyxJQUFJLElBQWIsRUFBbUJzeUYsQ0FBbkIsQ0FBUjtBQUNBLFdBQU90eUYsSUFBSTZILENBQVgsRUFBYzdILEtBQUssQ0FBbkIsRUFBc0I7QUFDcEJvQyxXQUFLLENBQUNELEtBQUtpckIsS0FBS1ksVUFBTCxDQUFnQmh1QixDQUFoQixDQUFOLEtBQTZCbUMsS0FBS2lyQixLQUFLWSxVQUFMLENBQWdCaHVCLElBQUksQ0FBcEIsQ0FBbEMsS0FBNkRtQyxLQUFLaXJCLEtBQUtZLFVBQUwsQ0FBZ0JodUIsSUFBSSxDQUFwQixDQUFsRSxLQUE2Rm1DLEtBQUtpckIsS0FBS1ksVUFBTCxDQUFnQmh1QixJQUFJLENBQXBCLENBQWxHLENBQUw7QUFDRDtBQUNEbUMsU0FBS2l3RixHQUFMO0FBQ0Fod0YsU0FBS2d3RixHQUFMO0FBQ0Q7QUFDRCxTQUFPcHlGLElBQUlxeUYsQ0FBWCxFQUFjcnlGLEdBQWQsRUFBbUI7QUFDakJvQyxTQUFLRCxLQUFLaXJCLEtBQUtZLFVBQUwsQ0FBZ0JodUIsQ0FBaEIsQ0FBVjtBQUNEO0FBQ0RtQyxPQUFLaXdGLEdBQUw7QUFDQWh3RixPQUFLZ3dGLEdBQUw7QUFDQSxTQUFPandGLElBQUlDLEtBQUssRUFBaEI7QUFDRDs7QUFFRGxFLE9BQU9DLE9BQVAsR0FBaUIyekYsT0FBakIsQzs7Ozs7OztBQzFDQTs7Ozs7Ozs7OztBQVVBOztBQUVBNXpGLE9BQU9DLE9BQVAsR0FBaUIsUUFBakIsQzs7Ozs7OztBQ1pBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSTBGLGlCQUFpQixtQkFBQWhCLENBQVEsQ0FBUixDQUFyQjs7QUFFQSxJQUFJcUgsb0JBQW9CLG1CQUFBckgsQ0FBUSxFQUFSLENBQXhCO0FBQ0EsSUFBSWdFLHdCQUF3QixtQkFBQWhFLENBQVEsQ0FBUixDQUE1QjtBQUNBLElBQUk2a0IsbUJBQW1CLG1CQUFBN2tCLENBQVEsRUFBUixDQUF2Qjs7QUFFQSxJQUFJcS9DLGdDQUFnQyxtQkFBQXIvQyxDQUFRLEVBQVIsQ0FBcEM7QUFDQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQTs7Ozs7Ozs7QUFRQSxTQUFTNnhELFdBQVQsQ0FBcUI2OUIsa0JBQXJCLEVBQXlDO0FBQ3ZDLE1BQUl0MEYsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsUUFBSXNNLFFBQVFuRSxrQkFBa0J1RSxPQUE5QjtBQUNBLFFBQUlKLFVBQVUsSUFBZCxFQUFvQjtBQUNsQnBRLGNBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRdUwsTUFBTTh2Qix3QkFBZCxFQUF3QyxzREFBc0QsbUVBQXRELEdBQTRILG9FQUE1SCxHQUFtTSxpRUFBbk0sR0FBdVEsNkJBQS9TLEVBQThVOXZCLE1BQU1FLE9BQU4sTUFBbUIsYUFBalcsQ0FBeEMsR0FBMFosS0FBSyxDQUEvWjtBQUNBRixZQUFNOHZCLHdCQUFOLEdBQWlDLElBQWpDO0FBQ0Q7QUFDRjtBQUNELE1BQUlvMEQsc0JBQXNCLElBQTFCLEVBQWdDO0FBQzlCLFdBQU8sSUFBUDtBQUNEO0FBQ0QsTUFBSUEsbUJBQW1CNXRGLFFBQW5CLEtBQWdDLENBQXBDLEVBQXVDO0FBQ3JDLFdBQU80dEYsa0JBQVA7QUFDRDs7QUFFRCxNQUFJbnRGLE9BQU9zaUIsaUJBQWlCamMsR0FBakIsQ0FBcUI4bUYsa0JBQXJCLENBQVg7QUFDQSxNQUFJbnRGLElBQUosRUFBVTtBQUNSQSxXQUFPODhDLDhCQUE4Qjk4QyxJQUE5QixDQUFQO0FBQ0EsV0FBT0EsT0FBT3lCLHNCQUFzQkYsbUJBQXRCLENBQTBDdkIsSUFBMUMsQ0FBUCxHQUF5RCxJQUFoRTtBQUNEOztBQUVELE1BQUksT0FBT210RixtQkFBbUIxc0QsTUFBMUIsS0FBcUMsVUFBekMsRUFBcUQ7QUFDbkQsWUFBUzVuQyxRQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q0UsVUFBVSxLQUFWLEVBQWlCLG1EQUFqQixDQUF4QyxHQUFnSDRCLGVBQWUsSUFBZixDQUF6SCxHQUFnSixLQUFLLENBQXJKO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsWUFBUzVGLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDRSxVQUFVLEtBQVYsRUFBaUIscUVBQWpCLEVBQXdGOEUsT0FBT29CLElBQVAsQ0FBWW9xRixrQkFBWixDQUF4RixDQUF4QyxHQUFtSzF1RixlQUFlLElBQWYsRUFBcUJrRCxPQUFPb0IsSUFBUCxDQUFZb3FGLGtCQUFaLENBQXJCLENBQTVLLEdBQW9PLEtBQUssQ0FBek87QUFDRDtBQUNGOztBQUVEcjBGLE9BQU9DLE9BQVAsR0FBaUJ1MkQsV0FBakIsQzs7Ozs7Ozs7QUMxREE7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJalcsYUFBYSxtQkFBQTU3QyxDQUFRLEVBQVIsQ0FBakI7O0FBRUEzRSxPQUFPQyxPQUFQLEdBQWlCc2dELFdBQVc4QiwwQkFBNUIsQzs7Ozs7OztBQ2RBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSXo4QyxjQUFjLG1CQUFBakIsQ0FBUSxFQUFSLENBQWxCO0FBQ0EsSUFBSStoQixzQkFBc0IsbUJBQUEvaEIsQ0FBUSxFQUFSLENBQTFCO0FBQ0EsSUFBSWdLLHlCQUF5QixtQkFBQWhLLENBQVEsQ0FBUixDQUE3Qjs7QUFFQSxJQUFJQyxVQUFVLG1CQUFBRCxDQUFRLENBQVIsQ0FBZDs7QUFFQSxJQUFJNUUsUUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBN0IsRUFBMkM7QUFDekMsTUFBSXl3RixhQUFhO0FBQ2Y3c0YsY0FBVSxJQURLO0FBRWYra0UsNkJBQXlCLElBRlY7QUFHZi9oRSxTQUFLLElBSFU7QUFJZmdTLFNBQUssSUFKVTs7QUFNZnV6RCxlQUFXLElBTkk7QUFPZnAyQixrQkFBYyxJQVBDO0FBUWY3YyxlQUFXLElBUkk7QUFTZjI0QyxvQkFBZ0IsSUFURDtBQVVmNTRDLGlCQUFhLElBVkU7QUFXZmhPLGVBQVcsSUFYSTtBQVlmMjlDLG9DQUFnQyxJQVpqQjtBQWFmVyxlQUFXLElBYkk7QUFjZkMsZ0JBQVk7QUFkRyxHQUFqQjtBQWdCQSxNQUFJa25CLG1CQUFtQixFQUF2Qjs7QUFFQSxNQUFJQyxtQkFBbUIsU0FBbkJBLGdCQUFtQixDQUFVNzJELE9BQVYsRUFBbUJ0NkIsSUFBbkIsRUFBeUI2dUQsT0FBekIsRUFBa0M7QUFDdkQsUUFBSXRzRCxZQUFZdVYsVUFBWixDQUF1QnJULGNBQXZCLENBQXNDekUsSUFBdEMsS0FBK0N1QyxZQUFZcVYsaUJBQVosQ0FBOEI1WCxJQUE5QixDQUFuRCxFQUF3RjtBQUN0RixhQUFPLElBQVA7QUFDRDtBQUNELFFBQUlpeEYsV0FBV3hzRixjQUFYLENBQTBCekUsSUFBMUIsS0FBbUNpeEYsV0FBV2p4RixJQUFYLENBQW5DLElBQXVEa3hGLGlCQUFpQnpzRixjQUFqQixDQUFnQ3pFLElBQWhDLEtBQXlDa3hGLGlCQUFpQmx4RixJQUFqQixDQUFwRyxFQUE0SDtBQUMxSCxhQUFPLElBQVA7QUFDRDtBQUNELFFBQUlxakIsb0JBQW9Cb0IsdUJBQXBCLENBQTRDaGdCLGNBQTVDLENBQTJEekUsSUFBM0QsQ0FBSixFQUFzRTtBQUNwRSxhQUFPLElBQVA7QUFDRDtBQUNEa3hGLHFCQUFpQmx4RixJQUFqQixJQUF5QixJQUF6QjtBQUNBLFFBQUl5b0IsaUJBQWlCem9CLEtBQUtnWSxXQUFMLEVBQXJCOztBQUVBO0FBQ0EsUUFBSW81RSxlQUFlN3VGLFlBQVlxVixpQkFBWixDQUE4QjZRLGNBQTlCLElBQWdEQSxjQUFoRCxHQUFpRWxtQixZQUFZcVcsdUJBQVosQ0FBb0NuVSxjQUFwQyxDQUFtRGdrQixjQUFuRCxJQUFxRWxtQixZQUFZcVcsdUJBQVosQ0FBb0M2UCxjQUFwQyxDQUFyRSxHQUEySCxJQUEvTTs7QUFFQSxRQUFJNUcsbUJBQW1Cd0Isb0JBQW9CcUYseUJBQXBCLENBQThDamtCLGNBQTlDLENBQTZEZ2tCLGNBQTdELElBQStFcEYsb0JBQW9CcUYseUJBQXBCLENBQThDRCxjQUE5QyxDQUEvRSxHQUErSSxJQUF0Szs7QUFFQSxRQUFJMm9FLGdCQUFnQixJQUFwQixFQUEwQjtBQUN4QjEwRixjQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsNkNBQWYsRUFBOER2QixJQUE5RCxFQUFvRW94RixZQUFwRSxFQUFrRjlsRix1QkFBdUI4QixvQkFBdkIsQ0FBNEN5aEQsT0FBNUMsQ0FBbEYsQ0FBeEMsR0FBa0wsS0FBSyxDQUF2TDtBQUNBLGFBQU8sSUFBUDtBQUNELEtBSEQsTUFHTyxJQUFJaHRDLG9CQUFvQixJQUF4QixFQUE4QjtBQUNuQ25sQixjQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUseURBQWYsRUFBMEV2QixJQUExRSxFQUFnRjZoQixnQkFBaEYsRUFBa0d2Vyx1QkFBdUI4QixvQkFBdkIsQ0FBNEN5aEQsT0FBNUMsQ0FBbEcsQ0FBeEMsR0FBa00sS0FBSyxDQUF2TTtBQUNBLGFBQU8sSUFBUDtBQUNELEtBSE0sTUFHQTtBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBTyxLQUFQO0FBQ0Q7QUFDRixHQS9CRDtBQWdDRDs7QUFFRCxJQUFJd2lDLHdCQUF3QixTQUF4QkEscUJBQXdCLENBQVV4aUMsT0FBVixFQUFtQjNqRCxPQUFuQixFQUE0QjtBQUN0RCxNQUFJb21GLGVBQWUsRUFBbkI7QUFDQSxPQUFLLElBQUlscUYsR0FBVCxJQUFnQjhELFFBQVE4TyxLQUF4QixFQUErQjtBQUM3QixRQUFJdTNFLFVBQVVKLGlCQUFpQmptRixRQUFRQyxJQUF6QixFQUErQi9ELEdBQS9CLEVBQW9DeW5ELE9BQXBDLENBQWQ7QUFDQSxRQUFJLENBQUMwaUMsT0FBTCxFQUFjO0FBQ1pELG1CQUFhNXlGLElBQWIsQ0FBa0IwSSxHQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsTUFBSW9xRixvQkFBb0JGLGFBQWFqckYsR0FBYixDQUFpQixVQUFVeVAsSUFBVixFQUFnQjtBQUN2RCxXQUFPLE1BQU1BLElBQU4sR0FBYSxHQUFwQjtBQUNELEdBRnVCLEVBRXJCdlAsSUFGcUIsQ0FFaEIsSUFGZ0IsQ0FBeEI7O0FBSUEsTUFBSStxRixhQUFhdnpGLE1BQWIsS0FBd0IsQ0FBNUIsRUFBK0I7QUFDN0JyQixZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUscUVBQXFFLHFEQUFwRixFQUEySWl3RixpQkFBM0ksRUFBOEp0bUYsUUFBUUMsSUFBdEssRUFBNEtHLHVCQUF1QjhCLG9CQUF2QixDQUE0Q3loRCxPQUE1QyxDQUE1SyxDQUF4QyxHQUE0USxLQUFLLENBQWpSO0FBQ0QsR0FGRCxNQUVPLElBQUl5aUMsYUFBYXZ6RixNQUFiLEdBQXNCLENBQTFCLEVBQTZCO0FBQ2xDckIsWUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLHdFQUF3RSxxREFBdkYsRUFBOElpd0YsaUJBQTlJLEVBQWlLdG1GLFFBQVFDLElBQXpLLEVBQStLRyx1QkFBdUI4QixvQkFBdkIsQ0FBNEN5aEQsT0FBNUMsQ0FBL0ssQ0FBeEMsR0FBK1EsS0FBSyxDQUFwUjtBQUNEO0FBQ0YsQ0FsQkQ7O0FBb0JBLFNBQVM0aUMsYUFBVCxDQUF1QjVpQyxPQUF2QixFQUFnQzNqRCxPQUFoQyxFQUF5QztBQUN2QyxNQUFJQSxXQUFXLElBQVgsSUFBbUIsT0FBT0EsUUFBUUMsSUFBZixLQUF3QixRQUEvQyxFQUF5RDtBQUN2RDtBQUNEO0FBQ0QsTUFBSUQsUUFBUUMsSUFBUixDQUFhckosT0FBYixDQUFxQixHQUFyQixLQUE2QixDQUE3QixJQUFrQ29KLFFBQVE4TyxLQUFSLENBQWNraEIsRUFBcEQsRUFBd0Q7QUFDdEQ7QUFDRDtBQUNEbTJELHdCQUFzQnhpQyxPQUF0QixFQUErQjNqRCxPQUEvQjtBQUNEOztBQUVELElBQUlrcEQsOEJBQThCO0FBQ2hDbm9ELDBCQUF3QixnQ0FBVTRpRCxPQUFWLEVBQW1CM2pELE9BQW5CLEVBQTRCO0FBQ2xEdW1GLGtCQUFjNWlDLE9BQWQsRUFBdUIzakQsT0FBdkI7QUFDRCxHQUgrQjtBQUloQ2tCLDJCQUF5QixpQ0FBVXlpRCxPQUFWLEVBQW1CM2pELE9BQW5CLEVBQTRCO0FBQ25EdW1GLGtCQUFjNWlDLE9BQWQsRUFBdUIzakQsT0FBdkI7QUFDRDtBQU4rQixDQUFsQzs7QUFTQXZPLE9BQU9DLE9BQVAsR0FBaUJ3M0QsMkJBQWpCLEM7Ozs7Ozs7O0FDOUdBOzs7Ozs7Ozs7O0FBVUE7O0FBRUEsSUFBSTlvRCx5QkFBeUIsbUJBQUFoSyxDQUFRLENBQVIsQ0FBN0I7O0FBRUEsSUFBSUMsVUFBVSxtQkFBQUQsQ0FBUSxDQUFSLENBQWQ7O0FBRUEsSUFBSW93RixtQkFBbUIsS0FBdkI7O0FBRUEsU0FBU0QsYUFBVCxDQUF1QjVpQyxPQUF2QixFQUFnQzNqRCxPQUFoQyxFQUF5QztBQUN2QyxNQUFJQSxXQUFXLElBQWYsRUFBcUI7QUFDbkI7QUFDRDtBQUNELE1BQUlBLFFBQVFDLElBQVIsS0FBaUIsT0FBakIsSUFBNEJELFFBQVFDLElBQVIsS0FBaUIsVUFBN0MsSUFBMkRELFFBQVFDLElBQVIsS0FBaUIsUUFBaEYsRUFBMEY7QUFDeEY7QUFDRDtBQUNELE1BQUlELFFBQVE4TyxLQUFSLElBQWlCLElBQWpCLElBQXlCOU8sUUFBUThPLEtBQVIsQ0FBY2pFLEtBQWQsS0FBd0IsSUFBakQsSUFBeUQsQ0FBQzI3RSxnQkFBOUQsRUFBZ0Y7QUFDOUVoMUYsWUFBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLDhDQUE4Qyx3RUFBOUMsR0FBeUgsZ0NBQXhJLEVBQTBLMkosUUFBUUMsSUFBbEwsRUFBd0xHLHVCQUF1QjhCLG9CQUF2QixDQUE0Q3loRCxPQUE1QyxDQUF4TCxDQUF4QyxHQUF3UixLQUFLLENBQTdSOztBQUVBNmlDLHVCQUFtQixJQUFuQjtBQUNEO0FBQ0Y7O0FBRUQsSUFBSXI5QixpQ0FBaUM7QUFDbkNwb0QsMEJBQXdCLGdDQUFVNGlELE9BQVYsRUFBbUIzakQsT0FBbkIsRUFBNEI7QUFDbER1bUYsa0JBQWM1aUMsT0FBZCxFQUF1QjNqRCxPQUF2QjtBQUNELEdBSGtDO0FBSW5Da0IsMkJBQXlCLGlDQUFVeWlELE9BQVYsRUFBbUIzakQsT0FBbkIsRUFBNEI7QUFDbkR1bUYsa0JBQWM1aUMsT0FBZCxFQUF1QjNqRCxPQUF2QjtBQUNEO0FBTmtDLENBQXJDOztBQVNBdk8sT0FBT0MsT0FBUCxHQUFpQnkzRCw4QkFBakIsQzs7Ozs7Ozs7QUN6Q0E7Ozs7Ozs7Ozs7QUFVQTs7QUFFQSxJQUFJOXhELGNBQWMsbUJBQUFqQixDQUFRLEVBQVIsQ0FBbEI7QUFDQSxJQUFJZ0sseUJBQXlCLG1CQUFBaEssQ0FBUSxDQUFSLENBQTdCOztBQUVBLElBQUlDLFVBQVUsbUJBQUFELENBQVEsQ0FBUixDQUFkOztBQUVBLElBQUk0dkYsbUJBQW1CLEVBQXZCO0FBQ0EsSUFBSVMsUUFBUSxJQUFJMW9GLE1BQUosQ0FBVyxjQUFjMUcsWUFBWXdXLG1CQUExQixHQUFnRCxLQUEzRCxDQUFaOztBQUVBLFNBQVNvNEUsZ0JBQVQsQ0FBMEI3MkQsT0FBMUIsRUFBbUN0NkIsSUFBbkMsRUFBeUM2dUQsT0FBekMsRUFBa0Q7QUFDaEQsTUFBSXFpQyxpQkFBaUJ6c0YsY0FBakIsQ0FBZ0N6RSxJQUFoQyxLQUF5Q2t4RixpQkFBaUJseEYsSUFBakIsQ0FBN0MsRUFBcUU7QUFDbkUsV0FBTyxJQUFQO0FBQ0Q7O0FBRUQsTUFBSTJ4RixNQUFNem9GLElBQU4sQ0FBV2xKLElBQVgsQ0FBSixFQUFzQjtBQUNwQixRQUFJeW9CLGlCQUFpQnpvQixLQUFLZ1ksV0FBTCxFQUFyQjtBQUNBLFFBQUlvNUUsZUFBZTd1RixZQUFZcVcsdUJBQVosQ0FBb0NuVSxjQUFwQyxDQUFtRGdrQixjQUFuRCxJQUFxRWxtQixZQUFZcVcsdUJBQVosQ0FBb0M2UCxjQUFwQyxDQUFyRSxHQUEySCxJQUE5STs7QUFFQTtBQUNBO0FBQ0EsUUFBSTJvRSxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDeEJGLHVCQUFpQmx4RixJQUFqQixJQUF5QixJQUF6QjtBQUNBLGFBQU8sS0FBUDtBQUNEO0FBQ0Q7QUFDQSxRQUFJQSxTQUFTb3hGLFlBQWIsRUFBMkI7QUFDekIxMEYsY0FBUXVDLEdBQVIsQ0FBWXVCLFFBQVosS0FBeUIsWUFBekIsR0FBd0NlLFFBQVEsS0FBUixFQUFlLCtDQUFmLEVBQWdFdkIsSUFBaEUsRUFBc0VveEYsWUFBdEUsRUFBb0Y5bEYsdUJBQXVCOEIsb0JBQXZCLENBQTRDeWhELE9BQTVDLENBQXBGLENBQXhDLEdBQW9MLEtBQUssQ0FBekw7QUFDQXFpQyx1QkFBaUJseEYsSUFBakIsSUFBeUIsSUFBekI7QUFDQSxhQUFPLElBQVA7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNEOztBQUVELFNBQVM0eEYsb0JBQVQsQ0FBOEIvaUMsT0FBOUIsRUFBdUMzakQsT0FBdkMsRUFBZ0Q7QUFDOUMsTUFBSTJtRixlQUFlLEVBQW5COztBQUVBLE9BQUssSUFBSXpxRixHQUFULElBQWdCOEQsUUFBUThPLEtBQXhCLEVBQStCO0FBQzdCLFFBQUl1M0UsVUFBVUosaUJBQWlCam1GLFFBQVFDLElBQXpCLEVBQStCL0QsR0FBL0IsRUFBb0N5bkQsT0FBcEMsQ0FBZDtBQUNBLFFBQUksQ0FBQzBpQyxPQUFMLEVBQWM7QUFDWk0sbUJBQWFuekYsSUFBYixDQUFrQjBJLEdBQWxCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJb3FGLG9CQUFvQkssYUFBYXhyRixHQUFiLENBQWlCLFVBQVV5UCxJQUFWLEVBQWdCO0FBQ3ZELFdBQU8sTUFBTUEsSUFBTixHQUFhLEdBQXBCO0FBQ0QsR0FGdUIsRUFFckJ2UCxJQUZxQixDQUVoQixJQUZnQixDQUF4Qjs7QUFJQSxNQUFJc3JGLGFBQWE5ekYsTUFBYixLQUF3QixDQUE1QixFQUErQjtBQUM3QnJCLFlBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQXpCLEdBQXdDZSxRQUFRLEtBQVIsRUFBZSx1Q0FBdUMsb0RBQXRELEVBQTRHaXdGLGlCQUE1RyxFQUErSHRtRixRQUFRQyxJQUF2SSxFQUE2SUcsdUJBQXVCOEIsb0JBQXZCLENBQTRDeWhELE9BQTVDLENBQTdJLENBQXhDLEdBQTZPLEtBQUssQ0FBbFA7QUFDRCxHQUZELE1BRU8sSUFBSWdqQyxhQUFhOXpGLE1BQWIsR0FBc0IsQ0FBMUIsRUFBNkI7QUFDbENyQixZQUFRdUMsR0FBUixDQUFZdUIsUUFBWixLQUF5QixZQUF6QixHQUF3Q2UsUUFBUSxLQUFSLEVBQWUsd0NBQXdDLG9EQUF2RCxFQUE2R2l3RixpQkFBN0csRUFBZ0l0bUYsUUFBUUMsSUFBeEksRUFBOElHLHVCQUF1QjhCLG9CQUF2QixDQUE0Q3loRCxPQUE1QyxDQUE5SSxDQUF4QyxHQUE4TyxLQUFLLENBQW5QO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNGlDLGFBQVQsQ0FBdUI1aUMsT0FBdkIsRUFBZ0MzakQsT0FBaEMsRUFBeUM7QUFDdkMsTUFBSUEsV0FBVyxJQUFYLElBQW1CLE9BQU9BLFFBQVFDLElBQWYsS0FBd0IsUUFBL0MsRUFBeUQ7QUFDdkQ7QUFDRDtBQUNELE1BQUlELFFBQVFDLElBQVIsQ0FBYXJKLE9BQWIsQ0FBcUIsR0FBckIsS0FBNkIsQ0FBN0IsSUFBa0NvSixRQUFROE8sS0FBUixDQUFja2hCLEVBQXBELEVBQXdEO0FBQ3REO0FBQ0Q7O0FBRUQwMkQsdUJBQXFCL2lDLE9BQXJCLEVBQThCM2pELE9BQTlCO0FBQ0Q7O0FBRUQsSUFBSW9wRCwwQkFBMEI7QUFDNUJyb0QsMEJBQXdCLGdDQUFVNGlELE9BQVYsRUFBbUIzakQsT0FBbkIsRUFBNEI7QUFDbEQsUUFBSXhPLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDaXhGLG9CQUFjNWlDLE9BQWQsRUFBdUIzakQsT0FBdkI7QUFDRDtBQUNGLEdBTDJCO0FBTTVCa0IsMkJBQXlCLGlDQUFVeWlELE9BQVYsRUFBbUIzakQsT0FBbkIsRUFBNEI7QUFDbkQsUUFBSXhPLFFBQVF1QyxHQUFSLENBQVl1QixRQUFaLEtBQXlCLFlBQTdCLEVBQTJDO0FBQ3pDaXhGLG9CQUFjNWlDLE9BQWQsRUFBdUIzakQsT0FBdkI7QUFDRDtBQUNGO0FBVjJCLENBQTlCOztBQWFBdk8sT0FBT0MsT0FBUCxHQUFpQjAzRCx1QkFBakIsQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JGQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBVEEsU0FBUzl4QixlQUFULENBQXlCN21CLFFBQXpCLEVBQW1DOG1CLFdBQW5DLEVBQWdEO0FBQUUsTUFBSSxFQUFFOW1CLG9CQUFvQjhtQixXQUF0QixDQUFKLEVBQXdDO0FBQUUsVUFBTSxJQUFJNThCLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQTJEO0FBQUU7O0FBRXpKLFNBQVM2OEIsMEJBQVQsQ0FBb0Nyb0IsSUFBcEMsRUFBMEM5YyxJQUExQyxFQUFnRDtBQUFFLE1BQUksQ0FBQzhjLElBQUwsRUFBVztBQUFFLFVBQU0sSUFBSXNvQixjQUFKLENBQW1CLDJEQUFuQixDQUFOO0FBQXdGLEdBQUMsT0FBT3BsQyxTQUFTLFFBQU9BLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFBNEIsT0FBT0EsSUFBUCxLQUFnQixVQUFyRCxJQUFtRUEsSUFBbkUsR0FBMEU4YyxJQUFqRjtBQUF3Rjs7QUFFaFAsU0FBU3VvQixTQUFULENBQW1CQyxRQUFuQixFQUE2QkMsVUFBN0IsRUFBeUM7QUFBRSxNQUFJLE9BQU9BLFVBQVAsS0FBc0IsVUFBdEIsSUFBb0NBLGVBQWUsSUFBdkQsRUFBNkQ7QUFBRSxVQUFNLElBQUlqOUIsU0FBSixDQUFjLHFFQUFvRWk5QixVQUFwRSx5Q0FBb0VBLFVBQXBFLEVBQWQsQ0FBTjtBQUFzRyxHQUFDRCxTQUFTaGtDLFNBQVQsR0FBcUIyRyxPQUFPb1EsTUFBUCxDQUFja3RCLGNBQWNBLFdBQVdqa0MsU0FBdkMsRUFBa0QsRUFBRW1XLGFBQWEsRUFBRWUsT0FBTzhzQixRQUFULEVBQW1CdG9CLFlBQVksS0FBL0IsRUFBc0NDLFVBQVUsSUFBaEQsRUFBc0RqRSxjQUFjLElBQXBFLEVBQWYsRUFBbEQsQ0FBckIsQ0FBcUssSUFBSXVzQixVQUFKLEVBQWdCdDlCLE9BQU91OUIsY0FBUCxHQUF3QnY5QixPQUFPdTlCLGNBQVAsQ0FBc0JGLFFBQXRCLEVBQWdDQyxVQUFoQyxDQUF4QixHQUFzRUQsU0FBU0csU0FBVCxHQUFxQkYsVUFBM0Y7QUFBd0c7O0FBTzllOzs7O0FBSUEsSUFBSTU2QixlQUFlLFVBQVUrNkIsZ0JBQVYsRUFBNEI7QUFDN0NMLFlBQVUxNkIsWUFBVixFQUF3Qis2QixnQkFBeEI7O0FBRUEsV0FBUy82QixZQUFULEdBQXdCO0FBQ3RCLFFBQUlnN0IsS0FBSixFQUFXQyxLQUFYLEVBQWtCQyxJQUFsQjs7QUFFQVosb0JBQWdCLElBQWhCLEVBQXNCdDZCLFlBQXRCOztBQUVBLFNBQUssSUFBSXpHLE9BQU9qRCxVQUFVVCxNQUFyQixFQUE2Qk8sT0FBT0MsTUFBTWtELElBQU4sQ0FBcEMsRUFBaURDLE9BQU8sQ0FBN0QsRUFBZ0VBLE9BQU9ELElBQXZFLEVBQTZFQyxNQUE3RSxFQUFxRjtBQUNuRnBELFdBQUtvRCxJQUFMLElBQWFsRCxVQUFVa0QsSUFBVixDQUFiO0FBQ0Q7O0FBRUQsV0FBTzBoQyxRQUFRRixTQUFTQyxRQUFRVCwyQkFBMkIsSUFBM0IsRUFBaUNPLGlCQUFpQjFsQyxJQUFqQixDQUFzQnVCLEtBQXRCLENBQTRCbWtDLGdCQUE1QixFQUE4QyxDQUFDLElBQUQsRUFBT2psQyxNQUFQLENBQWNNLElBQWQsQ0FBOUMsQ0FBakMsQ0FBUixFQUE4RzZrQyxLQUF2SCxHQUErSEEsTUFBTUcsT0FBTixHQUFnQixtQ0FBY0gsTUFBTW5wQixLQUFwQixDQUEvSSxFQUEyS2twQixLQUFuTCxHQUEyTFIsMkJBQTJCUyxLQUEzQixFQUFrQ0MsSUFBbEMsQ0FBbE07QUFDRDs7QUFFRGw3QixlQUFhckosU0FBYixDQUF1QnlsQyxNQUF2QixHQUFnQyxTQUFTQSxNQUFULEdBQWtCO0FBQ2hELFdBQU8sZ0JBQU05OEIsYUFBTixtQkFBNEIsRUFBRTg3QixTQUFTLEtBQUtBLE9BQWhCLEVBQXlCbC9CLFVBQVUsS0FBSzRWLEtBQUwsQ0FBVzVWLFFBQTlDLEVBQTVCLENBQVA7QUFDRCxHQUZEOztBQUlBLFNBQU84RCxZQUFQO0FBQ0QsQ0FwQmtCLENBb0JqQixnQkFBTTJWLFNBcEJXLENBQW5COztBQXNCQTNWLGFBQWE2eEIsU0FBYixHQUF5QjtBQUN2QiszRCxrQkFBZ0Isb0JBQVVsekYsS0FESDtBQUV2Qm16RixnQkFBYyxvQkFBVWhwRCxNQUZEO0FBR3ZCNUcsdUJBQXFCLG9CQUFVcE4sSUFIUjtBQUl2Qnl0QixhQUFXLG9CQUFVelosTUFKRTtBQUt2QjNrQyxZQUFVLG9CQUFVbEI7QUFMRyxDQUF6Qjs7a0JBU2VnRixZOzs7Ozs7O0FDOUNmOzs7Ozs7Ozs7QUFTQTs7QUFFQSxJQUFJN0csZ0JBQWdCLG1CQUFBQyxDQUFRLEVBQVIsQ0FBcEI7QUFDQSxJQUFJWixZQUFZLG1CQUFBWSxDQUFRLENBQVIsQ0FBaEI7QUFDQSxJQUFJeXhCLHVCQUF1QixtQkFBQXp4QixDQUFRLEVBQVIsQ0FBM0I7O0FBRUEzRSxPQUFPQyxPQUFQLEdBQWlCLFlBQVc7QUFDMUIsV0FBU28xRixJQUFULENBQWNoNEUsS0FBZCxFQUFxQi9FLFFBQXJCLEVBQStCK2tCLGFBQS9CLEVBQThDelMsUUFBOUMsRUFBd0RnakIsWUFBeEQsRUFBc0VDLE1BQXRFLEVBQThFO0FBQzVFLFFBQUlBLFdBQVd6WCxvQkFBZixFQUFxQztBQUNuQztBQUNBO0FBQ0Q7QUFDRHJ5QixjQUNFLEtBREYsRUFFRSx5RkFDQSwrQ0FEQSxHQUVBLGdEQUpGO0FBTUQ7QUFDRHN4RixPQUFLenRELFVBQUwsR0FBa0J5dEQsSUFBbEI7QUFDQSxXQUFTQyxPQUFULEdBQW1CO0FBQ2pCLFdBQU9ELElBQVA7QUFDRDtBQUNEO0FBQ0E7QUFDQSxNQUFJcDFFLGlCQUFpQjtBQUNuQmhlLFdBQU9vekYsSUFEWTtBQUVuQmxwRCxVQUFNa3BELElBRmE7QUFHbkJqOUQsVUFBTWk5RCxJQUhhO0FBSW5CanBELFlBQVFpcEQsSUFKVztBQUtuQmhqRixZQUFRZ2pGLElBTFc7QUFNbkI5bEUsWUFBUThsRSxJQU5XO0FBT25CaHBELFlBQVFncEQsSUFQVzs7QUFTbkIvb0QsU0FBSytvRCxJQVRjO0FBVW5CN29ELGFBQVM4b0QsT0FWVTtBQVduQi9tRixhQUFTOG1GLElBWFU7QUFZbkIxb0QsZ0JBQVkyb0QsT0FaTztBQWFuQi91RixVQUFNOHVGLElBYmE7QUFjbkJ2b0QsY0FBVXdvRCxPQWRTO0FBZW5CdG9ELFdBQU9zb0QsT0FmWTtBQWdCbkJwb0QsZUFBV29vRCxPQWhCUTtBQWlCbkJsb0QsV0FBT2tvRDtBQWpCWSxHQUFyQjs7QUFvQkFyMUUsaUJBQWV5ZCxjQUFmLEdBQWdDaDVCLGFBQWhDO0FBQ0F1YixpQkFBZW1CLFNBQWYsR0FBMkJuQixjQUEzQjs7QUFFQSxTQUFPQSxjQUFQO0FBQ0QsQ0EzQ0QsQzs7Ozs7OztBQ2ZBOzs7O0FBRUFoZ0IsUUFBUTJwQixVQUFSLEdBQXFCLElBQXJCOztBQUVBLElBQUk0NkIsVUFBVSxPQUFPdHlDLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsU0FBT0EsT0FBT2s0QixRQUFkLE1BQTJCLFFBQTNELEdBQXNFLFVBQVV6RixHQUFWLEVBQWU7QUFBRSxnQkFBY0EsR0FBZCwwQ0FBY0EsR0FBZDtBQUFvQixDQUEzRyxHQUE4RyxVQUFVQSxHQUFWLEVBQWU7QUFBRSxTQUFPQSxPQUFPLE9BQU96eUIsTUFBUCxLQUFrQixVQUF6QixJQUF1Q3l5QixJQUFJdHNCLFdBQUosS0FBb0JuRyxNQUEzRCxJQUFxRXl5QixRQUFRenlCLE9BQU9oUSxTQUFwRixHQUFnRyxRQUFoRyxVQUFrSHlpQyxHQUFsSCwwQ0FBa0hBLEdBQWxILENBQVA7QUFBK0gsQ0FBNVE7O0FBRUEsSUFBSVAsV0FBV3Y3QixPQUFPTyxNQUFQLElBQWlCLFVBQVVlLE1BQVYsRUFBa0I7QUFBRSxPQUFLLElBQUlySSxJQUFJLENBQWIsRUFBZ0JBLElBQUlELFVBQVVULE1BQTlCLEVBQXNDVSxHQUF0QyxFQUEyQztBQUFFLFFBQUlzSSxTQUFTdkksVUFBVUMsQ0FBVixDQUFiLENBQTJCLEtBQUssSUFBSTJJLEdBQVQsSUFBZ0JMLE1BQWhCLEVBQXdCO0FBQUUsVUFBSXZCLE9BQU8zRyxTQUFQLENBQWlCNEYsY0FBakIsQ0FBZ0NsSCxJQUFoQyxDQUFxQ3dKLE1BQXJDLEVBQTZDSyxHQUE3QyxDQUFKLEVBQXVEO0FBQUVOLGVBQU9NLEdBQVAsSUFBY0wsT0FBT0ssR0FBUCxDQUFkO0FBQTRCO0FBQUU7QUFBRSxHQUFDLE9BQU9OLE1BQVA7QUFBZ0IsQ0FBaFE7O0FBRUEsSUFBSTg2QixXQUFXLG1CQUFBdGdDLENBQVEsRUFBUixDQUFmOztBQUVBLElBQUl1Z0MsWUFBWVgsdUJBQXVCVSxRQUF2QixDQUFoQjs7QUFFQSxJQUFJUCxhQUFhLG1CQUFBLy9CLENBQVEsRUFBUixDQUFqQjs7QUFFQSxJQUFJZ2dELGlCQUFpQixtQkFBQWhnRCxDQUFRLEVBQVIsQ0FBckI7O0FBRUEsSUFBSWlnRCwyQkFBMkIsbUJBQUFqZ0QsQ0FBUSxFQUFSLENBQS9COztBQUVBLElBQUlrZ0QsNEJBQTRCdGdCLHVCQUF1QnFnQix3QkFBdkIsQ0FBaEM7O0FBRUEsU0FBU3JnQixzQkFBVCxDQUFnQ0ksR0FBaEMsRUFBcUM7QUFBRSxTQUFPQSxPQUFPQSxJQUFJL2EsVUFBWCxHQUF3QithLEdBQXhCLEdBQThCLEVBQUVDLFNBQVNELEdBQVgsRUFBckM7QUFBd0Q7O0FBRS9GLElBQUk0d0QsUUFBUSxTQUFTQSxLQUFULENBQWU1ckYsQ0FBZixFQUFrQjZyRixVQUFsQixFQUE4QkMsVUFBOUIsRUFBMEM7QUFDcEQsU0FBT3Z2RixLQUFLbTlCLEdBQUwsQ0FBU245QixLQUFLeWdFLEdBQUwsQ0FBU2g5RCxDQUFULEVBQVk2ckYsVUFBWixDQUFULEVBQWtDQyxVQUFsQyxDQUFQO0FBQ0QsQ0FGRDs7QUFJQTs7O0FBR0EsSUFBSUMsc0JBQXNCLFNBQVNBLG1CQUFULEdBQStCO0FBQ3ZELE1BQUlyNEUsUUFBUXhiLFVBQVVULE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JTLFVBQVUsQ0FBVixNQUFpQmlDLFNBQXpDLEdBQXFEakMsVUFBVSxDQUFWLENBQXJELEdBQW9FLEVBQWhGO0FBQ0EsTUFBSTJqQyxzQkFBc0Jub0IsTUFBTW1vQixtQkFBaEM7QUFBQSxNQUNJbXdELHdCQUF3QnQ0RSxNQUFNODNFLGNBRGxDO0FBQUEsTUFFSUEsaUJBQWlCUSwwQkFBMEI3eEYsU0FBMUIsR0FBc0MsQ0FBQyxHQUFELENBQXRDLEdBQThDNnhGLHFCQUZuRTtBQUFBLE1BR0lDLHNCQUFzQnY0RSxNQUFNKzNFLFlBSGhDO0FBQUEsTUFJSUEsZUFBZVEsd0JBQXdCOXhGLFNBQXhCLEdBQW9DLENBQXBDLEdBQXdDOHhGLG1CQUozRDtBQUFBLE1BS0lod0MsbUJBQW1Cdm9DLE1BQU13b0MsU0FMN0I7QUFBQSxNQU1JQSxZQUFZRCxxQkFBcUI5aEQsU0FBckIsR0FBaUMsQ0FBakMsR0FBcUM4aEQsZ0JBTnJEOztBQVNBLE1BQUlPLG9CQUFvQixDQUFDLEdBQUd0QiwwQkFBMEJqZ0IsT0FBOUIsR0FBeEI7O0FBRUEsTUFBSTJDLFdBQVcsU0FBU0EsUUFBVCxDQUFrQjZlLFNBQWxCLEVBQTZCO0FBQzFDaGlCLGFBQVN1QyxPQUFULEVBQWtCeWYsU0FBbEI7O0FBRUF6ZixZQUFRdmxDLE1BQVIsR0FBaUJ1bEMsUUFBUTJFLE9BQVIsQ0FBZ0JscUMsTUFBakM7O0FBRUEra0Qsc0JBQWtCdmdCLGVBQWxCLENBQWtDZSxRQUFRL2IsUUFBMUMsRUFBb0QrYixRQUFROXNCLE1BQTVEO0FBQ0QsR0FORDs7QUFRQSxNQUFJcXNDLFlBQVksU0FBU0EsU0FBVCxHQUFxQjtBQUNuQyxXQUFPaGdELEtBQUtDLE1BQUwsR0FBY0MsUUFBZCxDQUF1QixFQUF2QixFQUEyQjBILE1BQTNCLENBQWtDLENBQWxDLEVBQXFDKzNDLFNBQXJDLENBQVA7QUFDRCxHQUZEOztBQUlBLE1BQUlqMkIsUUFBUTJsRSxNQUFNSCxZQUFOLEVBQW9CLENBQXBCLEVBQXVCRCxlQUFlL3pGLE1BQWYsR0FBd0IsQ0FBL0MsQ0FBWjtBQUNBLE1BQUlrcUMsVUFBVTZwRCxlQUFlenJGLEdBQWYsQ0FBbUIsVUFBVTBsQyxLQUFWLEVBQWlCO0FBQ2hELFdBQU8sT0FBT0EsS0FBUCxLQUFpQixRQUFqQixHQUE0QixDQUFDLEdBQUd1VixlQUFleGdCLGNBQW5CLEVBQW1DaUwsS0FBbkMsRUFBMEN0ckMsU0FBMUMsRUFBcURvaUQsV0FBckQsQ0FBNUIsR0FBZ0csQ0FBQyxHQUFHdkIsZUFBZXhnQixjQUFuQixFQUFtQ2lMLEtBQW5DLEVBQTBDdHJDLFNBQTFDLEVBQXFEc3JDLE1BQU0za0MsR0FBTixJQUFheTdDLFdBQWxFLENBQXZHO0FBQ0QsR0FGYSxDQUFkOztBQUlBOztBQUVBLE1BQUlnQixhQUFheGlCLFdBQVcvWixVQUE1Qjs7QUFFQSxNQUFJNW9CLE9BQU8sU0FBU0EsSUFBVCxDQUFjK25CLElBQWQsRUFBb0IrYSxLQUFwQixFQUEyQjtBQUNwQyxLQUFDLEdBQUdLLFVBQVVOLE9BQWQsRUFBdUIsRUFBRSxDQUFDLE9BQU85YSxJQUFQLEtBQWdCLFdBQWhCLEdBQThCLFdBQTlCLEdBQTRDMDZCLFFBQVExNkIsSUFBUixDQUE3QyxNQUFnRSxRQUFoRSxJQUE0RUEsS0FBSythLEtBQUwsS0FBZS9nQyxTQUEzRixJQUF3RytnQyxVQUFVL2dDLFNBQXBILENBQXZCLEVBQXVKLDBFQUEwRSwwRUFBak87O0FBRUEsUUFBSStWLFNBQVMsTUFBYjtBQUNBLFFBQUkrUSxXQUFXLENBQUMsR0FBRys1QixlQUFleGdCLGNBQW5CLEVBQW1DcmEsSUFBbkMsRUFBeUMrYSxLQUF6QyxFQUFnRHFoQixXQUFoRCxFQUE2RHZmLFFBQVEvYixRQUFyRSxDQUFmOztBQUVBdTdCLHNCQUFrQjVnQixtQkFBbEIsQ0FBc0MzYSxRQUF0QyxFQUFnRC9RLE1BQWhELEVBQXdEMnJCLG1CQUF4RCxFQUE2RSxVQUFVa2hCLEVBQVYsRUFBYztBQUN6RixVQUFJLENBQUNBLEVBQUwsRUFBUzs7QUFFVCxVQUFJVyxZQUFZMWdCLFFBQVEvVyxLQUF4QjtBQUNBLFVBQUltb0QsWUFBWTF3QixZQUFZLENBQTVCOztBQUVBLFVBQUl3dUMsY0FBY2x2RCxRQUFRMkUsT0FBUixDQUFnQmpsQyxLQUFoQixDQUFzQixDQUF0QixDQUFsQjtBQUNBLFVBQUl3dkYsWUFBWXowRixNQUFaLEdBQXFCMjJFLFNBQXpCLEVBQW9DO0FBQ2xDOGQsb0JBQVlsaUYsTUFBWixDQUFtQm9rRSxTQUFuQixFQUE4QjhkLFlBQVl6MEYsTUFBWixHQUFxQjIyRSxTQUFuRCxFQUE4RG50RCxRQUE5RDtBQUNELE9BRkQsTUFFTztBQUNMaXJFLG9CQUFZOXpGLElBQVosQ0FBaUI2b0IsUUFBakI7QUFDRDs7QUFFRDJjLGVBQVM7QUFDUDF0QixnQkFBUUEsTUFERDtBQUVQK1Esa0JBQVVBLFFBRkg7QUFHUGdGLGVBQU9tb0QsU0FIQTtBQUlQenNDLGlCQUFTdXFEO0FBSkYsT0FBVDtBQU1ELEtBbkJEO0FBb0JELEdBMUJEOztBQTRCQSxNQUFJcnhGLFVBQVUsU0FBU0EsT0FBVCxDQUFpQnNsQixJQUFqQixFQUF1QithLEtBQXZCLEVBQThCO0FBQzFDLEtBQUMsR0FBR0ssVUFBVU4sT0FBZCxFQUF1QixFQUFFLENBQUMsT0FBTzlhLElBQVAsS0FBZ0IsV0FBaEIsR0FBOEIsV0FBOUIsR0FBNEMwNkIsUUFBUTE2QixJQUFSLENBQTdDLE1BQWdFLFFBQWhFLElBQTRFQSxLQUFLK2EsS0FBTCxLQUFlL2dDLFNBQTNGLElBQXdHK2dDLFVBQVUvZ0MsU0FBcEgsQ0FBdkIsRUFBdUosNkVBQTZFLDBFQUFwTzs7QUFFQSxRQUFJK1YsU0FBUyxTQUFiO0FBQ0EsUUFBSStRLFdBQVcsQ0FBQyxHQUFHKzVCLGVBQWV4Z0IsY0FBbkIsRUFBbUNyYSxJQUFuQyxFQUF5QythLEtBQXpDLEVBQWdEcWhCLFdBQWhELEVBQTZEdmYsUUFBUS9iLFFBQXJFLENBQWY7O0FBRUF1N0Isc0JBQWtCNWdCLG1CQUFsQixDQUFzQzNhLFFBQXRDLEVBQWdEL1EsTUFBaEQsRUFBd0QyckIsbUJBQXhELEVBQTZFLFVBQVVraEIsRUFBVixFQUFjO0FBQ3pGLFVBQUksQ0FBQ0EsRUFBTCxFQUFTOztBQUVUL2YsY0FBUTJFLE9BQVIsQ0FBZ0IzRSxRQUFRL1csS0FBeEIsSUFBaUNoRixRQUFqQzs7QUFFQTJjLGVBQVMsRUFBRTF0QixRQUFRQSxNQUFWLEVBQWtCK1EsVUFBVUEsUUFBNUIsRUFBVDtBQUNELEtBTkQ7QUFPRCxHQWJEOztBQWVBLE1BQUlvOEIsS0FBSyxTQUFTQSxFQUFULENBQVlyOUMsQ0FBWixFQUFlO0FBQ3RCLFFBQUlvdUUsWUFBWXdkLE1BQU01dUQsUUFBUS9XLEtBQVIsR0FBZ0JqbUIsQ0FBdEIsRUFBeUIsQ0FBekIsRUFBNEJnOUIsUUFBUTJFLE9BQVIsQ0FBZ0JscUMsTUFBaEIsR0FBeUIsQ0FBckQsQ0FBaEI7O0FBRUEsUUFBSXlZLFNBQVMsS0FBYjtBQUNBLFFBQUkrUSxXQUFXK2IsUUFBUTJFLE9BQVIsQ0FBZ0J5c0MsU0FBaEIsQ0FBZjs7QUFFQTV4QixzQkFBa0I1Z0IsbUJBQWxCLENBQXNDM2EsUUFBdEMsRUFBZ0QvUSxNQUFoRCxFQUF3RDJyQixtQkFBeEQsRUFBNkUsVUFBVWtoQixFQUFWLEVBQWM7QUFDekYsVUFBSUEsRUFBSixFQUFRO0FBQ05uZixpQkFBUztBQUNQMXRCLGtCQUFRQSxNQUREO0FBRVArUSxvQkFBVUEsUUFGSDtBQUdQZ0YsaUJBQU9tb0Q7QUFIQSxTQUFUO0FBS0QsT0FORCxNQU1PO0FBQ0w7QUFDQTtBQUNBeHdDO0FBQ0Q7QUFDRixLQVpEO0FBYUQsR0FuQkQ7O0FBcUJBLE1BQUlnZ0IsU0FBUyxTQUFTQSxNQUFULEdBQWtCO0FBQzdCLFdBQU9QLEdBQUcsQ0FBQyxDQUFKLENBQVA7QUFDRCxHQUZEOztBQUlBLE1BQUlRLFlBQVksU0FBU0EsU0FBVCxHQUFxQjtBQUNuQyxXQUFPUixHQUFHLENBQUgsQ0FBUDtBQUNELEdBRkQ7O0FBSUEsTUFBSTh1QyxRQUFRLFNBQVNBLEtBQVQsQ0FBZW5zRixDQUFmLEVBQWtCO0FBQzVCLFFBQUlvdUUsWUFBWXB4QyxRQUFRL1csS0FBUixHQUFnQmptQixDQUFoQztBQUNBLFdBQU9vdUUsYUFBYSxDQUFiLElBQWtCQSxZQUFZcHhDLFFBQVEyRSxPQUFSLENBQWdCbHFDLE1BQXJEO0FBQ0QsR0FIRDs7QUFLQSxNQUFJd21ELFFBQVEsU0FBU0EsS0FBVCxHQUFpQjtBQUMzQixRQUFJeGlCLFNBQVN2akMsVUFBVVQsTUFBVixHQUFtQixDQUFuQixJQUF3QlMsVUFBVSxDQUFWLE1BQWlCaUMsU0FBekMsR0FBcURqQyxVQUFVLENBQVYsQ0FBckQsR0FBb0UsS0FBakY7QUFDQSxXQUFPc2tELGtCQUFrQjlnQixTQUFsQixDQUE0QkQsTUFBNUIsQ0FBUDtBQUNELEdBSEQ7O0FBS0EsTUFBSWtDLFNBQVMsU0FBU0EsTUFBVCxDQUFnQmhpQixRQUFoQixFQUEwQjtBQUNyQyxXQUFPNmdDLGtCQUFrQjFnQixjQUFsQixDQUFpQ25nQixRQUFqQyxDQUFQO0FBQ0QsR0FGRDs7QUFJQSxNQUFJcWhCLFVBQVU7QUFDWnZsQyxZQUFRa3FDLFFBQVFscUMsTUFESjtBQUVaeVksWUFBUSxLQUZJO0FBR1orUSxjQUFVMGdCLFFBQVExYixLQUFSLENBSEU7QUFJWkEsV0FBT0EsS0FKSztBQUtaMGIsYUFBU0EsT0FMRztBQU1aNGIsZ0JBQVlBLFVBTkE7QUFPWm5sRCxVQUFNQSxJQVBNO0FBUVp5QyxhQUFTQSxPQVJHO0FBU1p3aUQsUUFBSUEsRUFUUTtBQVVaTyxZQUFRQSxNQVZJO0FBV1pDLGVBQVdBLFNBWEM7QUFZWnN1QyxXQUFPQSxLQVpLO0FBYVpsdUMsV0FBT0EsS0FiSztBQWNadGdCLFlBQVFBO0FBZEksR0FBZDs7QUFpQkEsU0FBT1gsT0FBUDtBQUNELENBMUlEOztBQTRJQTFtQyxRQUFRMmtDLE9BQVIsR0FBa0I4d0QsbUJBQWxCLEM7Ozs7Ozs7QUN6S0E7O0FBRUEsSUFBSUssYUFBYSxTQUFTQSxVQUFULENBQW9CenJFLFFBQXBCLEVBQThCO0FBQzdDLFNBQU9BLFNBQVNQLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBOUI7QUFDRCxDQUZEOztBQUlBO0FBQ0EsSUFBSWlzRSxZQUFZLFNBQVNBLFNBQVQsQ0FBbUJydEMsSUFBbkIsRUFBeUIvNEIsS0FBekIsRUFBZ0M7QUFDOUMsT0FBSyxJQUFJOXRCLElBQUk4dEIsS0FBUixFQUFlMkwsSUFBSXo1QixJQUFJLENBQXZCLEVBQTBCNkgsSUFBSWcvQyxLQUFLdm5ELE1BQXhDLEVBQWdEbTZCLElBQUk1eEIsQ0FBcEQsRUFBdUQ3SCxLQUFLLENBQUwsRUFBUXk1QixLQUFLLENBQXBFLEVBQXVFO0FBQ3JFb3RCLFNBQUs3bUQsQ0FBTCxJQUFVNm1ELEtBQUtwdEIsQ0FBTCxDQUFWO0FBQ0QsUUFBS2h6QixHQUFMO0FBQ0YsQ0FKRDs7QUFNQTtBQUNBLElBQUkwdEYsa0JBQWtCLFNBQVNBLGVBQVQsQ0FBeUIzckYsRUFBekIsRUFBNkI7QUFDakQsTUFBSUQsT0FBT3hJLFVBQVVULE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JTLFVBQVUsQ0FBVixNQUFpQmlDLFNBQXpDLEdBQXFEakMsVUFBVSxDQUFWLENBQXJELEdBQW9FLEVBQS9FOztBQUVBLE1BQUlxMEYsVUFBVTVyRixNQUFNQSxHQUFHUixLQUFILENBQVMsR0FBVCxDQUFOLElBQXVCLEVBQXJDO0FBQ0EsTUFBSXFzRixZQUFZOXJGLFFBQVFBLEtBQUtQLEtBQUwsQ0FBVyxHQUFYLENBQVIsSUFBMkIsRUFBM0M7O0FBRUEsTUFBSXNzRixVQUFVOXJGLE1BQU15ckYsV0FBV3pyRixFQUFYLENBQXBCO0FBQ0EsTUFBSStyRixZQUFZaHNGLFFBQVEwckYsV0FBVzFyRixJQUFYLENBQXhCO0FBQ0EsTUFBSWlzRixhQUFhRixXQUFXQyxTQUE1Qjs7QUFFQSxNQUFJL3JGLE1BQU15ckYsV0FBV3pyRixFQUFYLENBQVYsRUFBMEI7QUFDeEI7QUFDQTZyRixnQkFBWUQsT0FBWjtBQUNELEdBSEQsTUFHTyxJQUFJQSxRQUFROTBGLE1BQVosRUFBb0I7QUFDekI7QUFDQSswRixjQUFVNXRGLEdBQVY7QUFDQTR0RixnQkFBWUEsVUFBVTkwRixNQUFWLENBQWlCNjBGLE9BQWpCLENBQVo7QUFDRDs7QUFFRCxNQUFJLENBQUNDLFVBQVUvMEYsTUFBZixFQUF1QixPQUFPLEdBQVA7O0FBRXZCLE1BQUltMUYsbUJBQW1CLEtBQUssQ0FBNUI7QUFDQSxNQUFJSixVQUFVLzBGLE1BQWQsRUFBc0I7QUFDcEIsUUFBSW8xRixPQUFPTCxVQUFVQSxVQUFVLzBGLE1BQVYsR0FBbUIsQ0FBN0IsQ0FBWDtBQUNBbTFGLHVCQUFtQkMsU0FBUyxHQUFULElBQWdCQSxTQUFTLElBQXpCLElBQWlDQSxTQUFTLEVBQTdEO0FBQ0QsR0FIRCxNQUdPO0FBQ0xELHVCQUFtQixLQUFuQjtBQUNEOztBQUVELE1BQUlFLEtBQUssQ0FBVDtBQUNBLE9BQUssSUFBSTMwRixJQUFJcTBGLFVBQVUvMEYsTUFBdkIsRUFBK0JVLEtBQUssQ0FBcEMsRUFBdUNBLEdBQXZDLEVBQTRDO0FBQzFDLFFBQUk0MEYsT0FBT1AsVUFBVXIwRixDQUFWLENBQVg7O0FBRUEsUUFBSTQwRixTQUFTLEdBQWIsRUFBa0I7QUFDaEJWLGdCQUFVRyxTQUFWLEVBQXFCcjBGLENBQXJCO0FBQ0QsS0FGRCxNQUVPLElBQUk0MEYsU0FBUyxJQUFiLEVBQW1CO0FBQ3hCVixnQkFBVUcsU0FBVixFQUFxQnIwRixDQUFyQjtBQUNBMjBGO0FBQ0QsS0FITSxNQUdBLElBQUlBLEVBQUosRUFBUTtBQUNiVCxnQkFBVUcsU0FBVixFQUFxQnIwRixDQUFyQjtBQUNBMjBGO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLENBQUNILFVBQUwsRUFBaUIsT0FBT0csSUFBUCxFQUFhQSxFQUFiLEVBQWlCO0FBQ2hDTixjQUFVUSxPQUFWLENBQWtCLElBQWxCO0FBQ0QsT0FBSUwsY0FBY0gsVUFBVSxDQUFWLE1BQWlCLEVBQS9CLEtBQXNDLENBQUNBLFVBQVUsQ0FBVixDQUFELElBQWlCLENBQUNKLFdBQVdJLFVBQVUsQ0FBVixDQUFYLENBQXhELENBQUosRUFBdUZBLFVBQVVRLE9BQVYsQ0FBa0IsRUFBbEI7O0FBRXhGLE1BQUk1OEUsU0FBU284RSxVQUFVdnNGLElBQVYsQ0FBZSxHQUFmLENBQWI7O0FBRUEsTUFBSTJzRixvQkFBb0J4OEUsT0FBT2pNLE1BQVAsQ0FBYyxDQUFDLENBQWYsTUFBc0IsR0FBOUMsRUFBbURpTSxVQUFVLEdBQVY7O0FBRW5ELFNBQU9BLE1BQVA7QUFDRCxDQXJERDs7QUF1REEvWixPQUFPQyxPQUFQLEdBQWlCZzJGLGVBQWpCLEM7Ozs7Ozs7QUNyRUE7Ozs7QUFFQWgyRixRQUFRMnBCLFVBQVIsR0FBcUIsSUFBckI7O0FBRUEsSUFBSTQ2QixVQUFVLE9BQU90eUMsTUFBUCxLQUFrQixVQUFsQixJQUFnQyxTQUFPQSxPQUFPazRCLFFBQWQsTUFBMkIsUUFBM0QsR0FBc0UsVUFBVXpGLEdBQVYsRUFBZTtBQUFFLGdCQUFjQSxHQUFkLDBDQUFjQSxHQUFkO0FBQW9CLENBQTNHLEdBQThHLFVBQVVBLEdBQVYsRUFBZTtBQUFFLFNBQU9BLE9BQU8sT0FBT3p5QixNQUFQLEtBQWtCLFVBQXpCLElBQXVDeXlCLElBQUl0c0IsV0FBSixLQUFvQm5HLE1BQTNELElBQXFFeXlCLFFBQVF6eUIsT0FBT2hRLFNBQXBGLEdBQWdHLFFBQWhHLFVBQWtIeWlDLEdBQWxILDBDQUFrSEEsR0FBbEgsQ0FBUDtBQUErSCxDQUE1UTs7QUFFQSxJQUFJaXlELGFBQWEsU0FBU0EsVUFBVCxDQUFvQjN5RixDQUFwQixFQUF1QkMsQ0FBdkIsRUFBMEI7QUFDekMsTUFBSUQsTUFBTUMsQ0FBVixFQUFhLE9BQU8sSUFBUDs7QUFFYixNQUFJRCxLQUFLLElBQUwsSUFBYUMsS0FBSyxJQUF0QixFQUE0QixPQUFPLEtBQVA7O0FBRTVCLE1BQUl0QyxNQUFNdTFCLE9BQU4sQ0FBY2x6QixDQUFkLENBQUosRUFBc0IsT0FBT3JDLE1BQU11MUIsT0FBTixDQUFjanpCLENBQWQsS0FBb0JELEVBQUU3QyxNQUFGLEtBQWE4QyxFQUFFOUMsTUFBbkMsSUFBNkM2QyxFQUFFa3JDLEtBQUYsQ0FBUSxVQUFVOWhDLElBQVYsRUFBZ0J1aUIsS0FBaEIsRUFBdUI7QUFDdkcsV0FBT2duRSxXQUFXdnBGLElBQVgsRUFBaUJuSixFQUFFMHJCLEtBQUYsQ0FBakIsQ0FBUDtBQUNELEdBRnlFLENBQXBEOztBQUl0QixNQUFJaW5FLFFBQVEsT0FBTzV5RixDQUFQLEtBQWEsV0FBYixHQUEyQixXQUEzQixHQUF5Q3VnRCxRQUFRdmdELENBQVIsQ0FBckQ7QUFDQSxNQUFJNnlGLFFBQVEsT0FBTzV5RixDQUFQLEtBQWEsV0FBYixHQUEyQixXQUEzQixHQUF5Q3NnRCxRQUFRdGdELENBQVIsQ0FBckQ7O0FBRUEsTUFBSTJ5RixVQUFVQyxLQUFkLEVBQXFCLE9BQU8sS0FBUDs7QUFFckIsTUFBSUQsVUFBVSxRQUFkLEVBQXdCO0FBQ3RCLFFBQUlFLFNBQVM5eUYsRUFBRSt5RixPQUFGLEVBQWI7QUFDQSxRQUFJQyxTQUFTL3lGLEVBQUU4eUYsT0FBRixFQUFiOztBQUVBLFFBQUlELFdBQVc5eUYsQ0FBWCxJQUFnQmd6RixXQUFXL3lGLENBQS9CLEVBQWtDLE9BQU8weUYsV0FBV0csTUFBWCxFQUFtQkUsTUFBbkIsQ0FBUDs7QUFFbEMsUUFBSUMsUUFBUXJ1RixPQUFPb0IsSUFBUCxDQUFZaEcsQ0FBWixDQUFaO0FBQ0EsUUFBSWt6RixRQUFRdHVGLE9BQU9vQixJQUFQLENBQVkvRixDQUFaLENBQVo7O0FBRUEsUUFBSWd6RixNQUFNOTFGLE1BQU4sS0FBaUIrMUYsTUFBTS8xRixNQUEzQixFQUFtQyxPQUFPLEtBQVA7O0FBRW5DLFdBQU84MUYsTUFBTS9uRCxLQUFOLENBQVksVUFBVTFrQyxHQUFWLEVBQWU7QUFDaEMsYUFBT21zRixXQUFXM3lGLEVBQUV3RyxHQUFGLENBQVgsRUFBbUJ2RyxFQUFFdUcsR0FBRixDQUFuQixDQUFQO0FBQ0QsS0FGTSxDQUFQO0FBR0Q7O0FBRUQsU0FBTyxLQUFQO0FBQ0QsQ0EvQkQ7O0FBaUNBeEssUUFBUTJrQyxPQUFSLEdBQWtCZ3lELFVBQWxCLEM7Ozs7Ozs7Ozs7Ozs7OztBQ2pDQTs7OztBQUNBOzs7Ozs7QUFQQSxTQUFTL3dELGVBQVQsQ0FBeUI3bUIsUUFBekIsRUFBbUM4bUIsV0FBbkMsRUFBZ0Q7QUFBRSxNQUFJLEVBQUU5bUIsb0JBQW9COG1CLFdBQXRCLENBQUosRUFBd0M7QUFBRSxVQUFNLElBQUk1OEIsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosU0FBUzY4QiwwQkFBVCxDQUFvQ3JvQixJQUFwQyxFQUEwQzljLElBQTFDLEVBQWdEO0FBQUUsTUFBSSxDQUFDOGMsSUFBTCxFQUFXO0FBQUUsVUFBTSxJQUFJc29CLGNBQUosQ0FBbUIsMkRBQW5CLENBQU47QUFBd0YsR0FBQyxPQUFPcGxDLFNBQVMsUUFBT0EsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUFoQixJQUE0QixPQUFPQSxJQUFQLEtBQWdCLFVBQXJELElBQW1FQSxJQUFuRSxHQUEwRThjLElBQWpGO0FBQXdGOztBQUVoUCxTQUFTdW9CLFNBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCQyxVQUE3QixFQUF5QztBQUFFLE1BQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsZUFBZSxJQUF2RCxFQUE2RDtBQUFFLFVBQU0sSUFBSWo5QixTQUFKLENBQWMscUVBQW9FaTlCLFVBQXBFLHlDQUFvRUEsVUFBcEUsRUFBZCxDQUFOO0FBQXNHLEdBQUNELFNBQVNoa0MsU0FBVCxHQUFxQjJHLE9BQU9vUSxNQUFQLENBQWNrdEIsY0FBY0EsV0FBV2prQyxTQUF2QyxFQUFrRCxFQUFFbVcsYUFBYSxFQUFFZSxPQUFPOHNCLFFBQVQsRUFBbUJ0b0IsWUFBWSxLQUEvQixFQUFzQ0MsVUFBVSxJQUFoRCxFQUFzRGpFLGNBQWMsSUFBcEUsRUFBZixFQUFsRCxDQUFyQixDQUFxSyxJQUFJdXNCLFVBQUosRUFBZ0J0OUIsT0FBT3U5QixjQUFQLEdBQXdCdjlCLE9BQU91OUIsY0FBUCxDQUFzQkYsUUFBdEIsRUFBZ0NDLFVBQWhDLENBQXhCLEdBQXNFRCxTQUFTRyxTQUFULEdBQXFCRixVQUEzRjtBQUF3Rzs7QUFLOWU7Ozs7O0FBS0EsSUFBSTM2QixTQUFTLFVBQVU4NkIsZ0JBQVYsRUFBNEI7QUFDdkNMLFlBQVV6NkIsTUFBVixFQUFrQjg2QixnQkFBbEI7O0FBRUEsV0FBUzk2QixNQUFULEdBQWtCO0FBQ2hCcTZCLG9CQUFnQixJQUFoQixFQUFzQnI2QixNQUF0Qjs7QUFFQSxXQUFPdTZCLDJCQUEyQixJQUEzQixFQUFpQ08saUJBQWlCbmtDLEtBQWpCLENBQXVCLElBQXZCLEVBQTZCTixTQUE3QixDQUFqQyxDQUFQO0FBQ0Q7O0FBRUQySixTQUFPdEosU0FBUCxDQUFpQmsxRixNQUFqQixHQUEwQixTQUFTQSxNQUFULENBQWdCcHlGLE9BQWhCLEVBQXlCO0FBQ2pELFFBQUksS0FBSzZpRCxPQUFULEVBQWtCLEtBQUtBLE9BQUw7O0FBRWxCLFNBQUtBLE9BQUwsR0FBZSxLQUFLdnhDLE9BQUwsQ0FBYXV3QixNQUFiLENBQW9CRixPQUFwQixDQUE0QmloQixLQUE1QixDQUFrQzVpRCxPQUFsQyxDQUFmO0FBQ0QsR0FKRDs7QUFNQXdHLFNBQU90SixTQUFQLENBQWlCbTFGLE9BQWpCLEdBQTJCLFNBQVNBLE9BQVQsR0FBbUI7QUFDNUMsUUFBSSxLQUFLeHZDLE9BQVQsRUFBa0I7QUFDaEIsV0FBS0EsT0FBTDtBQUNBLFdBQUtBLE9BQUwsR0FBZSxJQUFmO0FBQ0Q7QUFDRixHQUxEOztBQU9BcjhDLFNBQU90SixTQUFQLENBQWlCZ2xDLGtCQUFqQixHQUFzQyxTQUFTQSxrQkFBVCxHQUE4QjtBQUNsRSxRQUFJLEtBQUs3cEIsS0FBTCxDQUFXaTZFLElBQWYsRUFBcUIsS0FBS0YsTUFBTCxDQUFZLEtBQUsvNUUsS0FBTCxDQUFXclksT0FBdkI7QUFDdEIsR0FGRDs7QUFJQXdHLFNBQU90SixTQUFQLENBQWlCc2xDLHlCQUFqQixHQUE2QyxTQUFTQSx5QkFBVCxDQUFtQ0MsU0FBbkMsRUFBOEM7QUFDekYsUUFBSUEsVUFBVTZ2RCxJQUFkLEVBQW9CO0FBQ2xCLFVBQUksQ0FBQyxLQUFLajZFLEtBQUwsQ0FBV2k2RSxJQUFaLElBQW9CLEtBQUtqNkUsS0FBTCxDQUFXclksT0FBWCxLQUF1QnlpQyxVQUFVemlDLE9BQXpELEVBQWtFLEtBQUtveUYsTUFBTCxDQUFZM3ZELFVBQVV6aUMsT0FBdEI7QUFDbkUsS0FGRCxNQUVPO0FBQ0wsV0FBS3F5RixPQUFMO0FBQ0Q7QUFDRixHQU5EOztBQVFBN3JGLFNBQU90SixTQUFQLENBQWlCd2xDLG9CQUFqQixHQUF3QyxTQUFTQSxvQkFBVCxHQUFnQztBQUN0RSxTQUFLMnZELE9BQUw7QUFDRCxHQUZEOztBQUlBN3JGLFNBQU90SixTQUFQLENBQWlCeWxDLE1BQWpCLEdBQTBCLFNBQVNBLE1BQVQsR0FBa0I7QUFDMUMsV0FBTyxJQUFQO0FBQ0QsR0FGRDs7QUFJQSxTQUFPbjhCLE1BQVA7QUFDRCxDQTNDWSxDQTJDWCxnQkFBTTBWLFNBM0NLLENBQWI7O0FBNkNBMVYsT0FBTzR4QixTQUFQLEdBQW1CO0FBQ2pCazZELFFBQU0sb0JBQVVuckQsSUFEQztBQUVqQm5uQyxXQUFTLG9CQUFVa29DLFNBQVYsQ0FBb0IsQ0FBQyxvQkFBVTlVLElBQVgsRUFBaUIsb0JBQVU3SSxNQUEzQixDQUFwQixFQUF3RHFZO0FBRmhELENBQW5CO0FBSUFwOEIsT0FBTzJTLFlBQVAsR0FBc0I7QUFDcEJtNUUsUUFBTTtBQURjLENBQXRCO0FBR0E5ckYsT0FBT3E4QixZQUFQLEdBQXNCO0FBQ3BCaEIsVUFBUSxvQkFBVXVHLEtBQVYsQ0FBZ0I7QUFDdEJ6RyxhQUFTLG9CQUFVeUcsS0FBVixDQUFnQjtBQUN2QndhLGFBQU8sb0JBQVV4dkIsSUFBVixDQUFld1A7QUFEQyxLQUFoQixFQUVOQTtBQUhtQixHQUFoQixFQUlMQTtBQUxpQixDQUF0Qjs7a0JBU2VwOEIsTTs7Ozs7Ozs7Ozs7Ozs7O0FDckVmOzs7O0FBQ0E7Ozs7OztBQVBBLFNBQVNxNkIsZUFBVCxDQUF5QjdtQixRQUF6QixFQUFtQzhtQixXQUFuQyxFQUFnRDtBQUFFLE1BQUksRUFBRTltQixvQkFBb0I4bUIsV0FBdEIsQ0FBSixFQUF3QztBQUFFLFVBQU0sSUFBSTU4QixTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUEyRDtBQUFFOztBQUV6SixTQUFTNjhCLDBCQUFULENBQW9Dcm9CLElBQXBDLEVBQTBDOWMsSUFBMUMsRUFBZ0Q7QUFBRSxNQUFJLENBQUM4YyxJQUFMLEVBQVc7QUFBRSxVQUFNLElBQUlzb0IsY0FBSixDQUFtQiwyREFBbkIsQ0FBTjtBQUF3RixHQUFDLE9BQU9wbEMsU0FBUyxRQUFPQSxJQUFQLHlDQUFPQSxJQUFQLE9BQWdCLFFBQWhCLElBQTRCLE9BQU9BLElBQVAsS0FBZ0IsVUFBckQsSUFBbUVBLElBQW5FLEdBQTBFOGMsSUFBakY7QUFBd0Y7O0FBRWhQLFNBQVN1b0IsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDO0FBQUUsTUFBSSxPQUFPQSxVQUFQLEtBQXNCLFVBQXRCLElBQW9DQSxlQUFlLElBQXZELEVBQTZEO0FBQUUsVUFBTSxJQUFJajlCLFNBQUosQ0FBYyxxRUFBb0VpOUIsVUFBcEUseUNBQW9FQSxVQUFwRSxFQUFkLENBQU47QUFBc0csR0FBQ0QsU0FBU2hrQyxTQUFULEdBQXFCMkcsT0FBT29RLE1BQVAsQ0FBY2t0QixjQUFjQSxXQUFXamtDLFNBQXZDLEVBQWtELEVBQUVtVyxhQUFhLEVBQUVlLE9BQU84c0IsUUFBVCxFQUFtQnRvQixZQUFZLEtBQS9CLEVBQXNDQyxVQUFVLElBQWhELEVBQXNEakUsY0FBYyxJQUFwRSxFQUFmLEVBQWxELENBQXJCLENBQXFLLElBQUl1c0IsVUFBSixFQUFnQnQ5QixPQUFPdTlCLGNBQVAsR0FBd0J2OUIsT0FBT3U5QixjQUFQLENBQXNCRixRQUF0QixFQUFnQ0MsVUFBaEMsQ0FBeEIsR0FBc0VELFNBQVNHLFNBQVQsR0FBcUJGLFVBQTNGO0FBQXdHOztBQUs5ZTs7Ozs7QUFLQSxJQUFJMTZCLFdBQVcsVUFBVTY2QixnQkFBVixFQUE0QjtBQUN6Q0wsWUFBVXg2QixRQUFWLEVBQW9CNjZCLGdCQUFwQjs7QUFFQSxXQUFTNzZCLFFBQVQsR0FBb0I7QUFDbEJvNkIsb0JBQWdCLElBQWhCLEVBQXNCcDZCLFFBQXRCOztBQUVBLFdBQU9zNkIsMkJBQTJCLElBQTNCLEVBQWlDTyxpQkFBaUJua0MsS0FBakIsQ0FBdUIsSUFBdkIsRUFBNkJOLFNBQTdCLENBQWpDLENBQVA7QUFDRDs7QUFFRDRKLFdBQVN2SixTQUFULENBQW1CcTFGLFFBQW5CLEdBQThCLFNBQVNBLFFBQVQsR0FBb0I7QUFDaEQsV0FBTyxLQUFLamhGLE9BQUwsQ0FBYXV3QixNQUFiLElBQXVCLEtBQUt2d0IsT0FBTCxDQUFhdXdCLE1BQWIsQ0FBb0IwZCxhQUFsRDtBQUNELEdBRkQ7O0FBSUE5NEMsV0FBU3ZKLFNBQVQsQ0FBbUJnbEMsa0JBQW5CLEdBQXdDLFNBQVNBLGtCQUFULEdBQThCO0FBQ3BFLFFBQUksS0FBS3F3RCxRQUFMLEVBQUosRUFBcUIsS0FBSy9pRixPQUFMO0FBQ3RCLEdBRkQ7O0FBSUEvSSxXQUFTdkosU0FBVCxDQUFtQit3RCxpQkFBbkIsR0FBdUMsU0FBU0EsaUJBQVQsR0FBNkI7QUFDbEUsUUFBSSxDQUFDLEtBQUtza0MsUUFBTCxFQUFMLEVBQXNCLEtBQUsvaUYsT0FBTDtBQUN2QixHQUZEOztBQUlBL0ksV0FBU3ZKLFNBQVQsQ0FBbUJzUyxPQUFuQixHQUE2QixTQUFTQSxPQUFULEdBQW1CO0FBQzlDLFFBQUlteUIsVUFBVSxLQUFLcndCLE9BQUwsQ0FBYXV3QixNQUFiLENBQW9CRixPQUFsQztBQUNBLFFBQUlTLFNBQVMsS0FBSy9wQixLQUFsQjtBQUFBLFFBQ0l0YixPQUFPcWxDLE9BQU9ybEMsSUFEbEI7QUFBQSxRQUVJdUksS0FBSzg4QixPQUFPOThCLEVBRmhCOztBQUtBLFFBQUl2SSxJQUFKLEVBQVU7QUFDUjRrQyxjQUFRNWtDLElBQVIsQ0FBYXVJLEVBQWI7QUFDRCxLQUZELE1BRU87QUFDTHE4QixjQUFRbmlDLE9BQVIsQ0FBZ0I4RixFQUFoQjtBQUNEO0FBQ0YsR0FaRDs7QUFjQW1CLFdBQVN2SixTQUFULENBQW1CeWxDLE1BQW5CLEdBQTRCLFNBQVNBLE1BQVQsR0FBa0I7QUFDNUMsV0FBTyxJQUFQO0FBQ0QsR0FGRDs7QUFJQSxTQUFPbDhCLFFBQVA7QUFDRCxDQXhDYyxDQXdDYixnQkFBTXlWLFNBeENPLENBQWY7O0FBMENBelYsU0FBUzJ4QixTQUFULEdBQXFCO0FBQ25CcjdCLFFBQU0sb0JBQVVvcUMsSUFERztBQUVuQjloQyxRQUFNLG9CQUFVa2xCLE1BRkc7QUFHbkJqbEIsTUFBSSxvQkFBVTRpQyxTQUFWLENBQW9CLENBQUMsb0JBQVUzZCxNQUFYLEVBQW1CLG9CQUFVbGQsTUFBN0IsQ0FBcEI7QUFIZSxDQUFyQjtBQUtBNUcsU0FBUzBTLFlBQVQsR0FBd0I7QUFDdEJwYyxRQUFNO0FBRGdCLENBQXhCO0FBR0EwSixTQUFTbzhCLFlBQVQsR0FBd0I7QUFDdEJoQixVQUFRLG9CQUFVdUcsS0FBVixDQUFnQjtBQUN0QnpHLGFBQVMsb0JBQVV5RyxLQUFWLENBQWdCO0FBQ3ZCcnJDLFlBQU0sb0JBQVVxMkIsSUFBVixDQUFld1AsVUFERTtBQUV2QnBqQyxlQUFTLG9CQUFVNHpCLElBQVYsQ0FBZXdQO0FBRkQsS0FBaEIsRUFHTkEsVUFKbUI7QUFLdEIyYyxtQkFBZSxvQkFBVWx5QztBQUxILEdBQWhCLEVBTUx1MUI7QUFQbUIsQ0FBeEI7O2tCQVdlbjhCLFE7Ozs7Ozs7Ozs7O0FDM0VmLElBQUkrckYsVUFBVSxtQkFBQTd5RixDQUFRLEdBQVIsQ0FBZDs7QUFFQTs7O0FBR0EzRSxPQUFPQyxPQUFQLEdBQWlCdzNGLFlBQWpCO0FBQ0F6M0YsT0FBT0MsT0FBUCxDQUFleTNGLEtBQWYsR0FBdUJBLEtBQXZCO0FBQ0ExM0YsT0FBT0MsT0FBUCxDQUFlMDNGLE9BQWYsR0FBeUJBLE9BQXpCO0FBQ0EzM0YsT0FBT0MsT0FBUCxDQUFlMjNGLGdCQUFmLEdBQWtDQSxnQkFBbEM7QUFDQTUzRixPQUFPQyxPQUFQLENBQWU0M0YsY0FBZixHQUFnQ0EsY0FBaEM7O0FBRUE7Ozs7O0FBS0EsSUFBSUMsY0FBYyxJQUFJeHJGLE1BQUosQ0FBVztBQUMzQjtBQUNBO0FBQ0EsU0FIMkI7QUFJM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBVjJCLEVBVzNCMUMsSUFYMkIsQ0FXdEIsR0FYc0IsQ0FBWCxFQVdMLEdBWEssQ0FBbEI7O0FBYUE7Ozs7Ozs7QUFPQSxTQUFTOHRGLEtBQVQsQ0FBZ0Jsb0UsR0FBaEIsRUFBcUI0WSxPQUFyQixFQUE4QjtBQUM1QixNQUFJMnZELFNBQVMsRUFBYjtBQUNBLE1BQUl0dEYsTUFBTSxDQUFWO0FBQ0EsTUFBSW1sQixRQUFRLENBQVo7QUFDQSxNQUFJOUYsT0FBTyxFQUFYO0FBQ0EsTUFBSWt1RSxtQkFBbUI1dkQsV0FBV0EsUUFBUTZ2RCxTQUFuQixJQUFnQyxHQUF2RDtBQUNBLE1BQUlsZ0UsR0FBSjs7QUFFQSxTQUFPLENBQUNBLE1BQU0rL0QsWUFBWXBvRSxJQUFaLENBQWlCRixHQUFqQixDQUFQLEtBQWlDLElBQXhDLEVBQThDO0FBQzVDLFFBQUk0a0UsSUFBSXI4RCxJQUFJLENBQUosQ0FBUjtBQUNBLFFBQUltZ0UsVUFBVW5nRSxJQUFJLENBQUosQ0FBZDtBQUNBLFFBQUk2cEQsU0FBUzdwRCxJQUFJbkksS0FBakI7QUFDQTlGLFlBQVEwRixJQUFJbnBCLEtBQUosQ0FBVXVwQixLQUFWLEVBQWlCZ3lELE1BQWpCLENBQVI7QUFDQWh5RCxZQUFRZ3lELFNBQVN3UyxFQUFFaHpGLE1BQW5COztBQUVBO0FBQ0EsUUFBSTgyRixPQUFKLEVBQWE7QUFDWHB1RSxjQUFRb3VFLFFBQVEsQ0FBUixDQUFSO0FBQ0E7QUFDRDs7QUFFRCxRQUFJMXNELE9BQU9oYyxJQUFJSSxLQUFKLENBQVg7QUFDQSxRQUFJMUYsU0FBUzZOLElBQUksQ0FBSixDQUFiO0FBQ0EsUUFBSTEwQixPQUFPMDBCLElBQUksQ0FBSixDQUFYO0FBQ0EsUUFBSWtCLFVBQVVsQixJQUFJLENBQUosQ0FBZDtBQUNBLFFBQUlpK0MsUUFBUWorQyxJQUFJLENBQUosQ0FBWjtBQUNBLFFBQUlvZ0UsV0FBV3BnRSxJQUFJLENBQUosQ0FBZjtBQUNBLFFBQUlxZ0UsV0FBV3JnRSxJQUFJLENBQUosQ0FBZjs7QUFFQTtBQUNBLFFBQUlqTyxJQUFKLEVBQVU7QUFDUml1RSxhQUFPaDJGLElBQVAsQ0FBWStuQixJQUFaO0FBQ0FBLGFBQU8sRUFBUDtBQUNEOztBQUVELFFBQUkweEQsVUFBVXR4RCxVQUFVLElBQVYsSUFBa0JzaEIsUUFBUSxJQUExQixJQUFrQ0EsU0FBU3RoQixNQUF6RDtBQUNBLFFBQUl5bkUsU0FBU3dHLGFBQWEsR0FBYixJQUFvQkEsYUFBYSxHQUE5QztBQUNBLFFBQUlFLFdBQVdGLGFBQWEsR0FBYixJQUFvQkEsYUFBYSxHQUFoRDtBQUNBLFFBQUlGLFlBQVlsZ0UsSUFBSSxDQUFKLEtBQVVpZ0UsZ0JBQTFCO0FBQ0EsUUFBSTd2RCxVQUFVbFAsV0FBVys4QyxLQUF6Qjs7QUFFQStoQixXQUFPaDJGLElBQVAsQ0FBWTtBQUNWc0IsWUFBTUEsUUFBUW9ILEtBREo7QUFFVnlmLGNBQVFBLFVBQVUsRUFGUjtBQUdWK3RFLGlCQUFXQSxTQUhEO0FBSVZJLGdCQUFVQSxRQUpBO0FBS1YxRyxjQUFRQSxNQUxFO0FBTVZuVyxlQUFTQSxPQU5DO0FBT1Y0YyxnQkFBVSxDQUFDLENBQUNBLFFBUEY7QUFRVmp3RCxlQUFTQSxVQUFVbXdELFlBQVlud0QsT0FBWixDQUFWLEdBQWtDaXdELFdBQVcsSUFBWCxHQUFrQixPQUFPRyxhQUFhTixTQUFiLENBQVAsR0FBaUM7QUFScEYsS0FBWjtBQVVEOztBQUVEO0FBQ0EsTUFBSXJvRSxRQUFRSixJQUFJcHVCLE1BQWhCLEVBQXdCO0FBQ3RCMG9CLFlBQVEwRixJQUFJMWhCLE1BQUosQ0FBVzhoQixLQUFYLENBQVI7QUFDRDs7QUFFRDtBQUNBLE1BQUk5RixJQUFKLEVBQVU7QUFDUml1RSxXQUFPaDJGLElBQVAsQ0FBWStuQixJQUFaO0FBQ0Q7O0FBRUQsU0FBT2l1RSxNQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTSixPQUFULENBQWtCbm9FLEdBQWxCLEVBQXVCNFksT0FBdkIsRUFBZ0M7QUFDOUIsU0FBT3d2RCxpQkFBaUJGLE1BQU1sb0UsR0FBTixFQUFXNFksT0FBWCxDQUFqQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVNvd0Qsd0JBQVQsQ0FBbUNocEUsR0FBbkMsRUFBd0M7QUFDdEMsU0FBT2lwRSxVQUFVanBFLEdBQVYsRUFBZWhyQixPQUFmLENBQXVCLFNBQXZCLEVBQWtDLFVBQVVMLENBQVYsRUFBYTtBQUNwRCxXQUFPLE1BQU1BLEVBQUUyckIsVUFBRixDQUFhLENBQWIsRUFBZ0IxcEIsUUFBaEIsQ0FBeUIsRUFBekIsRUFBNkIydUMsV0FBN0IsRUFBYjtBQUNELEdBRk0sQ0FBUDtBQUdEOztBQUVEOzs7Ozs7QUFNQSxTQUFTMmpELGNBQVQsQ0FBeUJscEUsR0FBekIsRUFBOEI7QUFDNUIsU0FBT2lwRSxVQUFVanBFLEdBQVYsRUFBZWhyQixPQUFmLENBQXVCLE9BQXZCLEVBQWdDLFVBQVVMLENBQVYsRUFBYTtBQUNsRCxXQUFPLE1BQU1BLEVBQUUyckIsVUFBRixDQUFhLENBQWIsRUFBZ0IxcEIsUUFBaEIsQ0FBeUIsRUFBekIsRUFBNkIydUMsV0FBN0IsRUFBYjtBQUNELEdBRk0sQ0FBUDtBQUdEOztBQUVEOzs7QUFHQSxTQUFTNmlELGdCQUFULENBQTJCRyxNQUEzQixFQUFtQztBQUNqQztBQUNBLE1BQUlZLFVBQVUsSUFBSS8yRixLQUFKLENBQVVtMkYsT0FBTzMyRixNQUFqQixDQUFkOztBQUVBO0FBQ0EsT0FBSyxJQUFJVSxJQUFJLENBQWIsRUFBZ0JBLElBQUlpMkYsT0FBTzMyRixNQUEzQixFQUFtQ1UsR0FBbkMsRUFBd0M7QUFDdEMsUUFBSSxRQUFPaTJGLE9BQU9qMkYsQ0FBUCxDQUFQLE1BQXFCLFFBQXpCLEVBQW1DO0FBQ2pDNjJGLGNBQVE3MkYsQ0FBUixJQUFhLElBQUl3SyxNQUFKLENBQVcsU0FBU3lyRixPQUFPajJGLENBQVAsRUFBVXFtQyxPQUFuQixHQUE2QixJQUF4QyxDQUFiO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPLFVBQVV4RCxHQUFWLEVBQWVpMEQsSUFBZixFQUFxQjtBQUMxQixRQUFJOXVFLE9BQU8sRUFBWDtBQUNBLFFBQUlvRixPQUFPeVYsT0FBTyxFQUFsQjtBQUNBLFFBQUl5RCxVQUFVd3dELFFBQVEsRUFBdEI7QUFDQSxRQUFJQyxTQUFTendELFFBQVEwd0QsTUFBUixHQUFpQk4sd0JBQWpCLEdBQTRDOXlGLGtCQUF6RDs7QUFFQSxTQUFLLElBQUk1RCxJQUFJLENBQWIsRUFBZ0JBLElBQUlpMkYsT0FBTzMyRixNQUEzQixFQUFtQ1UsR0FBbkMsRUFBd0M7QUFDdEMsVUFBSWkzRixRQUFRaEIsT0FBT2oyRixDQUFQLENBQVo7O0FBRUEsVUFBSSxPQUFPaTNGLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0JqdkUsZ0JBQVFpdkUsS0FBUjs7QUFFQTtBQUNEOztBQUVELFVBQUkzL0UsUUFBUThWLEtBQUs2cEUsTUFBTTExRixJQUFYLENBQVo7QUFDQSxVQUFJMjFGLE9BQUo7O0FBRUEsVUFBSTUvRSxTQUFTLElBQWIsRUFBbUI7QUFDakIsWUFBSTIvRSxNQUFNVixRQUFWLEVBQW9CO0FBQ2xCO0FBQ0EsY0FBSVUsTUFBTXZkLE9BQVYsRUFBbUI7QUFDakIxeEQsb0JBQVFpdkUsTUFBTTd1RSxNQUFkO0FBQ0Q7O0FBRUQ7QUFDRCxTQVBELE1BT087QUFDTCxnQkFBTSxJQUFJaGhCLFNBQUosQ0FBYyxlQUFlNnZGLE1BQU0xMUYsSUFBckIsR0FBNEIsaUJBQTFDLENBQU47QUFDRDtBQUNGOztBQUVELFVBQUltMEYsUUFBUXArRSxLQUFSLENBQUosRUFBb0I7QUFDbEIsWUFBSSxDQUFDMi9FLE1BQU1wSCxNQUFYLEVBQW1CO0FBQ2pCLGdCQUFNLElBQUl6b0YsU0FBSixDQUFjLGVBQWU2dkYsTUFBTTExRixJQUFyQixHQUE0QixpQ0FBNUIsR0FBZ0V1ckMsS0FBS0MsU0FBTCxDQUFlejFCLEtBQWYsQ0FBaEUsR0FBd0YsR0FBdEcsQ0FBTjtBQUNEOztBQUVELFlBQUlBLE1BQU1oWSxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLGNBQUkyM0YsTUFBTVYsUUFBVixFQUFvQjtBQUNsQjtBQUNELFdBRkQsTUFFTztBQUNMLGtCQUFNLElBQUludkYsU0FBSixDQUFjLGVBQWU2dkYsTUFBTTExRixJQUFyQixHQUE0QixtQkFBMUMsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsYUFBSyxJQUFJMFMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJcUQsTUFBTWhZLE1BQTFCLEVBQWtDMlUsR0FBbEMsRUFBdUM7QUFDckNpakYsb0JBQVVILE9BQU96L0UsTUFBTXJELENBQU4sQ0FBUCxDQUFWOztBQUVBLGNBQUksQ0FBQzRpRixRQUFRNzJGLENBQVIsRUFBV3lLLElBQVgsQ0FBZ0J5c0YsT0FBaEIsQ0FBTCxFQUErQjtBQUM3QixrQkFBTSxJQUFJOXZGLFNBQUosQ0FBYyxtQkFBbUI2dkYsTUFBTTExRixJQUF6QixHQUFnQyxjQUFoQyxHQUFpRDAxRixNQUFNNXdELE9BQXZELEdBQWlFLG1CQUFqRSxHQUF1RnlHLEtBQUtDLFNBQUwsQ0FBZW1xRCxPQUFmLENBQXZGLEdBQWlILEdBQS9ILENBQU47QUFDRDs7QUFFRGx2RSxrQkFBUSxDQUFDL1QsTUFBTSxDQUFOLEdBQVVnakYsTUFBTTd1RSxNQUFoQixHQUF5QjZ1RSxNQUFNZCxTQUFoQyxJQUE2Q2UsT0FBckQ7QUFDRDs7QUFFRDtBQUNEOztBQUVEQSxnQkFBVUQsTUFBTVgsUUFBTixHQUFpQk0sZUFBZXQvRSxLQUFmLENBQWpCLEdBQXlDeS9FLE9BQU96L0UsS0FBUCxDQUFuRDs7QUFFQSxVQUFJLENBQUN1L0UsUUFBUTcyRixDQUFSLEVBQVd5SyxJQUFYLENBQWdCeXNGLE9BQWhCLENBQUwsRUFBK0I7QUFDN0IsY0FBTSxJQUFJOXZGLFNBQUosQ0FBYyxlQUFlNnZGLE1BQU0xMUYsSUFBckIsR0FBNEIsY0FBNUIsR0FBNkMwMUYsTUFBTTV3RCxPQUFuRCxHQUE2RCxtQkFBN0QsR0FBbUY2d0QsT0FBbkYsR0FBNkYsR0FBM0csQ0FBTjtBQUNEOztBQUVEbHZFLGNBQVFpdkUsTUFBTTd1RSxNQUFOLEdBQWU4dUUsT0FBdkI7QUFDRDs7QUFFRCxXQUFPbHZFLElBQVA7QUFDRCxHQW5FRDtBQW9FRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU3l1RSxZQUFULENBQXVCL29FLEdBQXZCLEVBQTRCO0FBQzFCLFNBQU9BLElBQUlockIsT0FBSixDQUFZLDRCQUFaLEVBQTBDLE1BQTFDLENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBUzh6RixXQUFULENBQXNCdGlCLEtBQXRCLEVBQTZCO0FBQzNCLFNBQU9BLE1BQU14eEUsT0FBTixDQUFjLGVBQWQsRUFBK0IsTUFBL0IsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT0EsU0FBU3kwRixVQUFULENBQXFCeHdELEVBQXJCLEVBQXlCeCtCLElBQXpCLEVBQStCO0FBQzdCdytCLEtBQUd4K0IsSUFBSCxHQUFVQSxJQUFWO0FBQ0EsU0FBT3crQixFQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BLFNBQVN5d0QsS0FBVCxDQUFnQjl3RCxPQUFoQixFQUF5QjtBQUN2QixTQUFPQSxRQUFRK3dELFNBQVIsR0FBb0IsRUFBcEIsR0FBeUIsR0FBaEM7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVNDLGNBQVQsQ0FBeUJ0dkUsSUFBekIsRUFBK0I3ZixJQUEvQixFQUFxQztBQUNuQztBQUNBLE1BQUlvdkYsU0FBU3Z2RSxLQUFLMWYsTUFBTCxDQUFZcWxCLEtBQVosQ0FBa0IsV0FBbEIsQ0FBYjs7QUFFQSxNQUFJNHBFLE1BQUosRUFBWTtBQUNWLFNBQUssSUFBSXYzRixJQUFJLENBQWIsRUFBZ0JBLElBQUl1M0YsT0FBT2o0RixNQUEzQixFQUFtQ1UsR0FBbkMsRUFBd0M7QUFDdENtSSxXQUFLbEksSUFBTCxDQUFVO0FBQ1JzQixjQUFNdkIsQ0FERTtBQUVSb29CLGdCQUFRLElBRkE7QUFHUit0RSxtQkFBVyxJQUhIO0FBSVJJLGtCQUFVLEtBSkY7QUFLUjFHLGdCQUFRLEtBTEE7QUFNUm5XLGlCQUFTLEtBTkQ7QUFPUjRjLGtCQUFVLEtBUEY7QUFRUmp3RCxpQkFBUztBQVJELE9BQVY7QUFVRDtBQUNGOztBQUVELFNBQU84d0QsV0FBV252RSxJQUFYLEVBQWlCN2YsSUFBakIsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFBLFNBQVNxdkYsYUFBVCxDQUF3Qnh2RSxJQUF4QixFQUE4QjdmLElBQTlCLEVBQW9DbStCLE9BQXBDLEVBQTZDO0FBQzNDLE1BQUlteEQsUUFBUSxFQUFaOztBQUVBLE9BQUssSUFBSXozRixJQUFJLENBQWIsRUFBZ0JBLElBQUlnb0IsS0FBSzFvQixNQUF6QixFQUFpQ1UsR0FBakMsRUFBc0M7QUFDcEN5M0YsVUFBTXgzRixJQUFOLENBQVcwMUYsYUFBYTN0RSxLQUFLaG9CLENBQUwsQ0FBYixFQUFzQm1JLElBQXRCLEVBQTRCbStCLE9BQTVCLEVBQXFDaCtCLE1BQWhEO0FBQ0Q7O0FBRUQsTUFBSW92RixTQUFTLElBQUlsdEYsTUFBSixDQUFXLFFBQVFpdEYsTUFBTTN2RixJQUFOLENBQVcsR0FBWCxDQUFSLEdBQTBCLEdBQXJDLEVBQTBDc3ZGLE1BQU05d0QsT0FBTixDQUExQyxDQUFiOztBQUVBLFNBQU82d0QsV0FBV08sTUFBWCxFQUFtQnZ2RixJQUFuQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU3d2RixjQUFULENBQXlCM3ZFLElBQXpCLEVBQStCN2YsSUFBL0IsRUFBcUNtK0IsT0FBckMsRUFBOEM7QUFDNUMsU0FBT3l2RCxlQUFlSCxNQUFNNXRFLElBQU4sRUFBWXNlLE9BQVosQ0FBZixFQUFxQ24rQixJQUFyQyxFQUEyQ20rQixPQUEzQyxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUEsU0FBU3l2RCxjQUFULENBQXlCRSxNQUF6QixFQUFpQzl0RixJQUFqQyxFQUF1Q20rQixPQUF2QyxFQUFnRDtBQUM5QyxNQUFJLENBQUNvdkQsUUFBUXZ0RixJQUFSLENBQUwsRUFBb0I7QUFDbEJtK0IsY0FBVSxzQkFBd0JuK0IsUUFBUW0rQixPQUExQztBQUNBbitCLFdBQU8sRUFBUDtBQUNEOztBQUVEbStCLFlBQVVBLFdBQVcsRUFBckI7O0FBRUEsTUFBSUcsU0FBU0gsUUFBUUcsTUFBckI7QUFDQSxNQUFJRCxNQUFNRixRQUFRRSxHQUFSLEtBQWdCLEtBQTFCO0FBQ0EsTUFBSXhCLFFBQVEsRUFBWjs7QUFFQTtBQUNBLE9BQUssSUFBSWhsQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlpMkYsT0FBTzMyRixNQUEzQixFQUFtQ1UsR0FBbkMsRUFBd0M7QUFDdEMsUUFBSWkzRixRQUFRaEIsT0FBT2oyRixDQUFQLENBQVo7O0FBRUEsUUFBSSxPQUFPaTNGLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0JqeUQsZUFBU3l4RCxhQUFhUSxLQUFiLENBQVQ7QUFDRCxLQUZELE1BRU87QUFDTCxVQUFJN3VFLFNBQVNxdUUsYUFBYVEsTUFBTTd1RSxNQUFuQixDQUFiO0FBQ0EsVUFBSStPLFVBQVUsUUFBUTgvRCxNQUFNNXdELE9BQWQsR0FBd0IsR0FBdEM7O0FBRUFsK0IsV0FBS2xJLElBQUwsQ0FBVWczRixLQUFWOztBQUVBLFVBQUlBLE1BQU1wSCxNQUFWLEVBQWtCO0FBQ2hCMTRELG1CQUFXLFFBQVEvTyxNQUFSLEdBQWlCK08sT0FBakIsR0FBMkIsSUFBdEM7QUFDRDs7QUFFRCxVQUFJOC9ELE1BQU1WLFFBQVYsRUFBb0I7QUFDbEIsWUFBSSxDQUFDVSxNQUFNdmQsT0FBWCxFQUFvQjtBQUNsQnZpRCxvQkFBVSxRQUFRL08sTUFBUixHQUFpQixHQUFqQixHQUF1QitPLE9BQXZCLEdBQWlDLEtBQTNDO0FBQ0QsU0FGRCxNQUVPO0FBQ0xBLG9CQUFVL08sU0FBUyxHQUFULEdBQWUrTyxPQUFmLEdBQXlCLElBQW5DO0FBQ0Q7QUFDRixPQU5ELE1BTU87QUFDTEEsa0JBQVUvTyxTQUFTLEdBQVQsR0FBZStPLE9BQWYsR0FBeUIsR0FBbkM7QUFDRDs7QUFFRDZOLGVBQVM3TixPQUFUO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJZy9ELFlBQVlNLGFBQWFud0QsUUFBUTZ2RCxTQUFSLElBQXFCLEdBQWxDLENBQWhCO0FBQ0EsTUFBSXlCLG9CQUFvQjV5RCxNQUFNemdDLEtBQU4sQ0FBWSxDQUFDNHhGLFVBQVU3MkYsTUFBdkIsTUFBbUM2MkYsU0FBM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJLENBQUMxdkQsTUFBTCxFQUFhO0FBQ1h6QixZQUFRLENBQUM0eUQsb0JBQW9CNXlELE1BQU16Z0MsS0FBTixDQUFZLENBQVosRUFBZSxDQUFDNHhGLFVBQVU3MkYsTUFBMUIsQ0FBcEIsR0FBd0QwbEMsS0FBekQsSUFBa0UsS0FBbEUsR0FBMEVteEQsU0FBMUUsR0FBc0YsU0FBOUY7QUFDRDs7QUFFRCxNQUFJM3ZELEdBQUosRUFBUztBQUNQeEIsYUFBUyxHQUFUO0FBQ0QsR0FGRCxNQUVPO0FBQ0w7QUFDQTtBQUNBQSxhQUFTeUIsVUFBVW14RCxpQkFBVixHQUE4QixFQUE5QixHQUFtQyxRQUFRekIsU0FBUixHQUFvQixLQUFoRTtBQUNEOztBQUVELFNBQU9nQixXQUFXLElBQUkzc0YsTUFBSixDQUFXLE1BQU13NkIsS0FBakIsRUFBd0JveUQsTUFBTTl3RCxPQUFOLENBQXhCLENBQVgsRUFBb0RuK0IsSUFBcEQsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7QUFZQSxTQUFTd3RGLFlBQVQsQ0FBdUIzdEUsSUFBdkIsRUFBNkI3ZixJQUE3QixFQUFtQ20rQixPQUFuQyxFQUE0QztBQUMxQyxNQUFJLENBQUNvdkQsUUFBUXZ0RixJQUFSLENBQUwsRUFBb0I7QUFDbEJtK0IsY0FBVSxzQkFBd0JuK0IsUUFBUW0rQixPQUExQztBQUNBbitCLFdBQU8sRUFBUDtBQUNEOztBQUVEbStCLFlBQVVBLFdBQVcsRUFBckI7O0FBRUEsTUFBSXRlLGdCQUFnQnhkLE1BQXBCLEVBQTRCO0FBQzFCLFdBQU84c0YsZUFBZXR2RSxJQUFmLEVBQXFCLHFCQUF1QjdmLElBQTVDLENBQVA7QUFDRDs7QUFFRCxNQUFJdXRGLFFBQVExdEUsSUFBUixDQUFKLEVBQW1CO0FBQ2pCLFdBQU93dkUsZUFBYyxxQkFBdUJ4dkUsSUFBckMsRUFBNEMscUJBQXVCN2YsSUFBbkUsRUFBMEVtK0IsT0FBMUUsQ0FBUDtBQUNEOztBQUVELFNBQU9xeEQsZ0JBQWUscUJBQXVCM3ZFLElBQXRDLEVBQTZDLHFCQUF1QjdmLElBQXBFLEVBQTJFbStCLE9BQTNFLENBQVA7QUFDRCxDOzs7Ozs7Ozs7QUN6YURwb0MsT0FBT0MsT0FBUCxHQUFpQjJCLE1BQU11MUIsT0FBTixJQUFpQixVQUFVbVksR0FBVixFQUFlO0FBQy9DLFNBQU96bUMsT0FBTzNHLFNBQVAsQ0FBaUJrRSxRQUFqQixDQUEwQnhGLElBQTFCLENBQStCMHVDLEdBQS9CLEtBQXVDLGdCQUE5QztBQUNELENBRkQsQzs7Ozs7Ozs7Ozs7Ozs7O0FDVUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQWRBLElBQUlsTCxXQUFXdjdCLE9BQU9PLE1BQVAsSUFBaUIsVUFBVWUsTUFBVixFQUFrQjtBQUFFLE9BQUssSUFBSXJJLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsVUFBVVQsTUFBOUIsRUFBc0NVLEdBQXRDLEVBQTJDO0FBQUUsUUFBSXNJLFNBQVN2SSxVQUFVQyxDQUFWLENBQWIsQ0FBMkIsS0FBSyxJQUFJMkksR0FBVCxJQUFnQkwsTUFBaEIsRUFBd0I7QUFBRSxVQUFJdkIsT0FBTzNHLFNBQVAsQ0FBaUI0RixjQUFqQixDQUFnQ2xILElBQWhDLENBQXFDd0osTUFBckMsRUFBNkNLLEdBQTdDLENBQUosRUFBdUQ7QUFBRU4sZUFBT00sR0FBUCxJQUFjTCxPQUFPSyxHQUFQLENBQWQ7QUFBNEI7QUFBRTtBQUFFLEdBQUMsT0FBT04sTUFBUDtBQUFnQixDQUFoUTs7QUFFQSxTQUFTaytDLHdCQUFULENBQWtDMWpCLEdBQWxDLEVBQXVDMTZCLElBQXZDLEVBQTZDO0FBQUUsTUFBSUUsU0FBUyxFQUFiLENBQWlCLEtBQUssSUFBSXJJLENBQVQsSUFBYzZpQyxHQUFkLEVBQW1CO0FBQUUsUUFBSTE2QixLQUFLOUUsT0FBTCxDQUFhckQsQ0FBYixLQUFtQixDQUF2QixFQUEwQixTQUFVLElBQUksQ0FBQytHLE9BQU8zRyxTQUFQLENBQWlCNEYsY0FBakIsQ0FBZ0NsSCxJQUFoQyxDQUFxQytqQyxHQUFyQyxFQUEwQzdpQyxDQUExQyxDQUFMLEVBQW1ELFNBQVVxSSxPQUFPckksQ0FBUCxJQUFZNmlDLElBQUk3aUMsQ0FBSixDQUFaO0FBQXFCLEdBQUMsT0FBT3FJLE1BQVA7QUFBZ0I7O0FBRTVOLFNBQVMwN0IsZUFBVCxDQUF5QjdtQixRQUF6QixFQUFtQzhtQixXQUFuQyxFQUFnRDtBQUFFLE1BQUksRUFBRTltQixvQkFBb0I4bUIsV0FBdEIsQ0FBSixFQUF3QztBQUFFLFVBQU0sSUFBSTU4QixTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUEyRDtBQUFFOztBQUV6SixTQUFTNjhCLDBCQUFULENBQW9Dcm9CLElBQXBDLEVBQTBDOWMsSUFBMUMsRUFBZ0Q7QUFBRSxNQUFJLENBQUM4YyxJQUFMLEVBQVc7QUFBRSxVQUFNLElBQUlzb0IsY0FBSixDQUFtQiwyREFBbkIsQ0FBTjtBQUF3RixHQUFDLE9BQU9wbEMsU0FBUyxRQUFPQSxJQUFQLHlDQUFPQSxJQUFQLE9BQWdCLFFBQWhCLElBQTRCLE9BQU9BLElBQVAsS0FBZ0IsVUFBckQsSUFBbUVBLElBQW5FLEdBQTBFOGMsSUFBakY7QUFBd0Y7O0FBRWhQLFNBQVN1b0IsU0FBVCxDQUFtQkMsUUFBbkIsRUFBNkJDLFVBQTdCLEVBQXlDO0FBQUUsTUFBSSxPQUFPQSxVQUFQLEtBQXNCLFVBQXRCLElBQW9DQSxlQUFlLElBQXZELEVBQTZEO0FBQUUsVUFBTSxJQUFJajlCLFNBQUosQ0FBYyxxRUFBb0VpOUIsVUFBcEUseUNBQW9FQSxVQUFwRSxFQUFkLENBQU47QUFBc0csR0FBQ0QsU0FBU2hrQyxTQUFULEdBQXFCMkcsT0FBT29RLE1BQVAsQ0FBY2t0QixjQUFjQSxXQUFXamtDLFNBQXZDLEVBQWtELEVBQUVtVyxhQUFhLEVBQUVlLE9BQU84c0IsUUFBVCxFQUFtQnRvQixZQUFZLEtBQS9CLEVBQXNDQyxVQUFVLElBQWhELEVBQXNEakUsY0FBYyxJQUFwRSxFQUFmLEVBQWxELENBQXJCLENBQXFLLElBQUl1c0IsVUFBSixFQUFnQnQ5QixPQUFPdTlCLGNBQVAsR0FBd0J2OUIsT0FBT3U5QixjQUFQLENBQXNCRixRQUF0QixFQUFnQ0MsVUFBaEMsQ0FBeEIsR0FBc0VELFNBQVNHLFNBQVQsR0FBcUJGLFVBQTNGO0FBQXdHOztBQVE5ZSxJQUFJd3pELG9CQUFvQixTQUFTQSxpQkFBVCxDQUEyQnRuRixNQUEzQixFQUFtQztBQUN6RCxNQUFJdW5GLG1CQUFtQnZuRixPQUFPaVksUUFBOUI7QUFBQSxNQUNJQSxXQUFXc3ZFLHFCQUFxQjkxRixTQUFyQixHQUFpQyxHQUFqQyxHQUF1QzgxRixnQkFEdEQ7QUFBQSxNQUVJQyxpQkFBaUJ4bkYsT0FBT2tZLE1BRjVCO0FBQUEsTUFHSUEsU0FBU3N2RSxtQkFBbUIvMUYsU0FBbkIsR0FBK0IsRUFBL0IsR0FBb0MrMUYsY0FIakQ7QUFBQSxNQUlJQyxlQUFlem5GLE9BQU9tWSxJQUoxQjtBQUFBLE1BS0lBLE9BQU9zdkUsaUJBQWlCaDJGLFNBQWpCLEdBQTZCLEVBQTdCLEdBQWtDZzJGLFlBTDdDOztBQVFBLFNBQU87QUFDTHh2RSxjQUFVQSxRQURMO0FBRUxDLFlBQVFBLFdBQVcsR0FBWCxHQUFpQixFQUFqQixHQUFzQkEsTUFGekI7QUFHTEMsVUFBTUEsU0FBUyxHQUFULEdBQWUsRUFBZixHQUFvQkE7QUFIckIsR0FBUDtBQUtELENBZEQ7O0FBZ0JBLElBQUl1dkUsY0FBYyxTQUFTQSxXQUFULENBQXFCajBDLFFBQXJCLEVBQStCbDdCLFFBQS9CLEVBQXlDO0FBQ3pELE1BQUksQ0FBQ2s3QixRQUFMLEVBQWUsT0FBT2w3QixRQUFQOztBQUVmLFNBQU93WixTQUFTLEVBQVQsRUFBYXhaLFFBQWIsRUFBdUI7QUFDNUJOLGNBQVUsZ0NBQWdCdzdCLFFBQWhCLElBQTRCbDdCLFNBQVNOO0FBRG5CLEdBQXZCLENBQVA7QUFHRCxDQU5EOztBQVFBLElBQUlILGdCQUFnQixTQUFTQSxhQUFULENBQXVCMjdCLFFBQXZCLEVBQWlDbDdCLFFBQWpDLEVBQTJDO0FBQzdELE1BQUksQ0FBQ2s3QixRQUFMLEVBQWUsT0FBT2w3QixRQUFQOztBQUVmLE1BQUk2Z0MsT0FBTyxnQ0FBZ0IzRixRQUFoQixDQUFYOztBQUVBLE1BQUlsN0IsU0FBU04sUUFBVCxDQUFrQm5sQixPQUFsQixDQUEwQnNtRCxJQUExQixNQUFvQyxDQUF4QyxFQUEyQyxPQUFPN2dDLFFBQVA7O0FBRTNDLFNBQU93WixTQUFTLEVBQVQsRUFBYXhaLFFBQWIsRUFBdUI7QUFDNUJOLGNBQVVNLFNBQVNOLFFBQVQsQ0FBa0J4YyxNQUFsQixDQUF5QjI5QyxLQUFLcnFELE1BQTlCO0FBRGtCLEdBQXZCLENBQVA7QUFHRCxDQVZEOztBQVlBLElBQUkraUMsaUJBQWlCLFNBQVNBLGNBQVQsQ0FBd0J2WixRQUF4QixFQUFrQztBQUNyRCxTQUFPLE9BQU9BLFFBQVAsS0FBb0IsUUFBcEIsR0FBK0IsMEJBQVVBLFFBQVYsQ0FBL0IsR0FBcUQrdUUsa0JBQWtCL3VFLFFBQWxCLENBQTVEO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJb3ZFLFlBQVksU0FBU0EsU0FBVCxDQUFtQnB2RSxRQUFuQixFQUE2QjtBQUMzQyxTQUFPLE9BQU9BLFFBQVAsS0FBb0IsUUFBcEIsR0FBK0JBLFFBQS9CLEdBQTBDLDJCQUFXQSxRQUFYLENBQWpEO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJcXZFLGdCQUFnQixTQUFTQSxhQUFULENBQXVCcHdELFVBQXZCLEVBQW1DO0FBQ3JELFNBQU8sWUFBWTtBQUNqQiw2QkFBVSxLQUFWLEVBQWlCLG1DQUFqQixFQUFzREEsVUFBdEQ7QUFDRCxHQUZEO0FBR0QsQ0FKRDs7QUFNQSxJQUFJbm5DLE9BQU8sU0FBU0EsSUFBVCxHQUFnQixDQUFFLENBQTdCOztBQUVBOzs7Ozs7O0FBT0EsSUFBSWtKLGVBQWUsVUFBVTA2QixnQkFBVixFQUE0QjtBQUM3Q0wsWUFBVXI2QixZQUFWLEVBQXdCMDZCLGdCQUF4Qjs7QUFFQSxXQUFTMTZCLFlBQVQsR0FBd0I7QUFDdEIsUUFBSTI2QixLQUFKLEVBQVdDLEtBQVgsRUFBa0JDLElBQWxCOztBQUVBWixvQkFBZ0IsSUFBaEIsRUFBc0JqNkIsWUFBdEI7O0FBRUEsU0FBSyxJQUFJOUcsT0FBT2pELFVBQVVULE1BQXJCLEVBQTZCTyxPQUFPQyxNQUFNa0QsSUFBTixDQUFwQyxFQUFpREMsT0FBTyxDQUE3RCxFQUFnRUEsT0FBT0QsSUFBdkUsRUFBNkVDLE1BQTdFLEVBQXFGO0FBQ25GcEQsV0FBS29ELElBQUwsSUFBYWxELFVBQVVrRCxJQUFWLENBQWI7QUFDRDs7QUFFRCxXQUFPMGhDLFFBQVFGLFNBQVNDLFFBQVFULDJCQUEyQixJQUEzQixFQUFpQ08saUJBQWlCMWxDLElBQWpCLENBQXNCdUIsS0FBdEIsQ0FBNEJta0MsZ0JBQTVCLEVBQThDLENBQUMsSUFBRCxFQUFPamxDLE1BQVAsQ0FBY00sSUFBZCxDQUE5QyxDQUFqQyxDQUFSLEVBQThHNmtDLEtBQXZILEdBQStIQSxNQUFNMGdCLFVBQU4sR0FBbUIsVUFBVXA5QixJQUFWLEVBQWdCO0FBQy9LLGFBQU8sZ0NBQWdCMGMsTUFBTW5wQixLQUFOLENBQVl5b0MsUUFBWixHQUF1QmswQyxVQUFVbHdFLElBQVYsQ0FBdkMsQ0FBUDtBQUNELEtBRmMsRUFFWjBjLE1BQU0wekQsVUFBTixHQUFtQixVQUFVdHZFLFFBQVYsRUFBb0I7QUFDeEMsVUFBSTY5QixjQUFjamlCLE1BQU1ucEIsS0FBeEI7QUFBQSxVQUNJeW9DLFdBQVcyQyxZQUFZM0MsUUFEM0I7QUFBQSxVQUVJeHZDLFVBQVVteUMsWUFBWW55QyxPQUYxQjs7QUFJQUEsY0FBUXVELE1BQVIsR0FBaUIsTUFBakI7QUFDQXZELGNBQVFzVSxRQUFSLEdBQW1CbXZFLFlBQVlqMEMsUUFBWixFQUFzQjNoQixlQUFldlosUUFBZixDQUF0QixDQUFuQjtBQUNBdFUsY0FBUXl3QixHQUFSLEdBQWNpekQsVUFBVTFqRixRQUFRc1UsUUFBbEIsQ0FBZDtBQUNELEtBVmMsRUFVWjRiLE1BQU0yekQsYUFBTixHQUFzQixVQUFVdnZFLFFBQVYsRUFBb0I7QUFDM0MsVUFBSXd2RSxlQUFlNXpELE1BQU1ucEIsS0FBekI7QUFBQSxVQUNJeW9DLFdBQVdzMEMsYUFBYXQwQyxRQUQ1QjtBQUFBLFVBRUl4dkMsVUFBVThqRixhQUFhOWpGLE9BRjNCOztBQUlBQSxjQUFRdUQsTUFBUixHQUFpQixTQUFqQjtBQUNBdkQsY0FBUXNVLFFBQVIsR0FBbUJtdkUsWUFBWWowQyxRQUFaLEVBQXNCM2hCLGVBQWV2WixRQUFmLENBQXRCLENBQW5CO0FBQ0F0VSxjQUFReXdCLEdBQVIsR0FBY2l6RCxVQUFVMWpGLFFBQVFzVSxRQUFsQixDQUFkO0FBQ0QsS0FsQmMsRUFrQlo0YixNQUFNNnpELFlBQU4sR0FBcUIsWUFBWTtBQUNsQyxhQUFPMzNGLElBQVA7QUFDRCxLQXBCYyxFQW9CWjhqQyxNQUFNOHpELFdBQU4sR0FBb0IsWUFBWTtBQUNqQyxhQUFPNTNGLElBQVA7QUFDRCxLQXRCYyxFQXNCWjZqQyxLQXRCSSxHQXNCSVIsMkJBQTJCUyxLQUEzQixFQUFrQ0MsSUFBbEMsQ0F0Qlg7QUF1QkQ7O0FBRUQ3NkIsZUFBYTFKLFNBQWIsQ0FBdUIwa0MsZUFBdkIsR0FBeUMsU0FBU0EsZUFBVCxHQUEyQjtBQUNsRSxXQUFPO0FBQ0xDLGNBQVE7QUFDTjBkLHVCQUFlLEtBQUtsbkMsS0FBTCxDQUFXL0c7QUFEcEI7QUFESCxLQUFQO0FBS0QsR0FORDs7QUFRQTFLLGVBQWExSixTQUFiLENBQXVCeWxDLE1BQXZCLEdBQWdDLFNBQVNBLE1BQVQsR0FBa0I7QUFDaEQsUUFBSVAsU0FBUyxLQUFLL3BCLEtBQWxCO0FBQUEsUUFDSXlvQyxXQUFXMWUsT0FBTzBlLFFBRHRCO0FBQUEsUUFFSXh2QyxVQUFVOHdCLE9BQU85d0IsT0FGckI7QUFBQSxRQUdJc1UsV0FBV3djLE9BQU94YyxRQUh0QjtBQUFBLFFBSUl2TixRQUFRZ3JDLHlCQUF5QmpoQixNQUF6QixFQUFpQyxDQUFDLFVBQUQsRUFBYSxTQUFiLEVBQXdCLFVBQXhCLENBQWpDLENBSlo7O0FBTUEsUUFBSVQsVUFBVTtBQUNadWdCLGtCQUFZLEtBQUtBLFVBREw7QUFFWnJ0QyxjQUFRLEtBRkk7QUFHWitRLGdCQUFVVCxjQUFjMjdCLFFBQWQsRUFBd0IzaEIsZUFBZXZaLFFBQWYsQ0FBeEIsQ0FIRTtBQUlaN29CLFlBQU0sS0FBS200RixVQUpDO0FBS1oxMUYsZUFBUyxLQUFLMjFGLGFBTEY7QUFNWm56QyxVQUFJaXpDLGNBQWMsSUFBZCxDQU5RO0FBT1oxeUMsY0FBUTB5QyxjQUFjLFFBQWQsQ0FQSTtBQVFaenlDLGlCQUFXeXlDLGNBQWMsV0FBZCxDQVJDO0FBU1ozeUQsY0FBUSxLQUFLK3lELFlBVEQ7QUFVWnp5QyxhQUFPLEtBQUsweUM7QUFWQSxLQUFkOztBQWFBLFdBQU8sZ0JBQU16dkYsYUFBTixtQkFBNEJ1NUIsU0FBUyxFQUFULEVBQWEvbUIsS0FBYixFQUFvQixFQUFFc3BCLFNBQVNBLE9BQVgsRUFBcEIsQ0FBNUIsQ0FBUDtBQUNELEdBckJEOztBQXVCQSxTQUFPLzZCLFlBQVA7QUFDRCxDQXJFa0IsQ0FxRWpCLGdCQUFNc1YsU0FyRVcsQ0FBbkI7O0FBdUVBdFYsYUFBYXd4QixTQUFiLEdBQXlCO0FBQ3ZCMG9CLFlBQVUsb0JBQVV2MkIsTUFERztBQUV2QmpaLFdBQVMsb0JBQVVqRSxNQUFWLENBQWlCdTFCLFVBRkg7QUFHdkJoZCxZQUFVLG9CQUFVc2lCLFNBQVYsQ0FBb0IsQ0FBQyxvQkFBVTNkLE1BQVgsRUFBbUIsb0JBQVVsZCxNQUE3QixDQUFwQjtBQUhhLENBQXpCO0FBS0F6RyxhQUFhdVMsWUFBYixHQUE0QjtBQUMxQjJuQyxZQUFVLEVBRGdCO0FBRTFCbDdCLFlBQVU7QUFGZ0IsQ0FBNUI7QUFJQWhmLGFBQWFrOEIsaUJBQWIsR0FBaUM7QUFDL0JqQixVQUFRLG9CQUFVeDBCLE1BQVYsQ0FBaUJ1MUI7QUFETSxDQUFqQzs7a0JBS2VoOEIsWTs7Ozs7Ozs7Ozs7Ozs7O0FDMUpmOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFUQSxTQUFTaTZCLGVBQVQsQ0FBeUI3bUIsUUFBekIsRUFBbUM4bUIsV0FBbkMsRUFBZ0Q7QUFBRSxNQUFJLEVBQUU5bUIsb0JBQW9COG1CLFdBQXRCLENBQUosRUFBd0M7QUFBRSxVQUFNLElBQUk1OEIsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosU0FBUzY4QiwwQkFBVCxDQUFvQ3JvQixJQUFwQyxFQUEwQzljLElBQTFDLEVBQWdEO0FBQUUsTUFBSSxDQUFDOGMsSUFBTCxFQUFXO0FBQUUsVUFBTSxJQUFJc29CLGNBQUosQ0FBbUIsMkRBQW5CLENBQU47QUFBd0YsR0FBQyxPQUFPcGxDLFNBQVMsUUFBT0EsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUFoQixJQUE0QixPQUFPQSxJQUFQLEtBQWdCLFVBQXJELElBQW1FQSxJQUFuRSxHQUEwRThjLElBQWpGO0FBQXdGOztBQUVoUCxTQUFTdW9CLFNBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCQyxVQUE3QixFQUF5QztBQUFFLE1BQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsZUFBZSxJQUF2RCxFQUE2RDtBQUFFLFVBQU0sSUFBSWo5QixTQUFKLENBQWMscUVBQW9FaTlCLFVBQXBFLHlDQUFvRUEsVUFBcEUsRUFBZCxDQUFOO0FBQXNHLEdBQUNELFNBQVNoa0MsU0FBVCxHQUFxQjJHLE9BQU9vUSxNQUFQLENBQWNrdEIsY0FBY0EsV0FBV2prQyxTQUF2QyxFQUFrRCxFQUFFbVcsYUFBYSxFQUFFZSxPQUFPOHNCLFFBQVQsRUFBbUJ0b0IsWUFBWSxLQUEvQixFQUFzQ0MsVUFBVSxJQUFoRCxFQUFzRGpFLGNBQWMsSUFBcEUsRUFBZixFQUFsRCxDQUFyQixDQUFxSyxJQUFJdXNCLFVBQUosRUFBZ0J0OUIsT0FBT3U5QixjQUFQLEdBQXdCdjlCLE9BQU91OUIsY0FBUCxDQUFzQkYsUUFBdEIsRUFBZ0NDLFVBQWhDLENBQXhCLEdBQXNFRCxTQUFTRyxTQUFULEdBQXFCRixVQUEzRjtBQUF3Rzs7QUFPOWU7Ozs7QUFJQSxJQUFJdDZCLFNBQVMsVUFBVXk2QixnQkFBVixFQUE0QjtBQUN2Q0wsWUFBVXA2QixNQUFWLEVBQWtCeTZCLGdCQUFsQjs7QUFFQSxXQUFTejZCLE1BQVQsR0FBa0I7QUFDaEJnNkIsb0JBQWdCLElBQWhCLEVBQXNCaDZCLE1BQXRCOztBQUVBLFdBQU9rNkIsMkJBQTJCLElBQTNCLEVBQWlDTyxpQkFBaUJua0MsS0FBakIsQ0FBdUIsSUFBdkIsRUFBNkJOLFNBQTdCLENBQWpDLENBQVA7QUFDRDs7QUFFRGdLLFNBQU8zSixTQUFQLENBQWlCc2xDLHlCQUFqQixHQUE2QyxTQUFTQSx5QkFBVCxDQUFtQ0MsU0FBbkMsRUFBOEM7QUFDekYsMkJBQVEsRUFBRUEsVUFBVTdjLFFBQVYsSUFBc0IsQ0FBQyxLQUFLdk4sS0FBTCxDQUFXdU4sUUFBcEMsQ0FBUixFQUF1RCwwS0FBdkQ7O0FBRUEsMkJBQVEsRUFBRSxDQUFDNmMsVUFBVTdjLFFBQVgsSUFBdUIsS0FBS3ZOLEtBQUwsQ0FBV3VOLFFBQXBDLENBQVIsRUFBdUQsc0tBQXZEO0FBQ0QsR0FKRDs7QUFNQS9lLFNBQU8zSixTQUFQLENBQWlCeWxDLE1BQWpCLEdBQTBCLFNBQVNBLE1BQVQsR0FBa0I7QUFDMUMsUUFBSWIsUUFBUSxLQUFLeHdCLE9BQUwsQ0FBYXV3QixNQUFiLENBQW9CQyxLQUFoQztBQUNBLFFBQUlyL0IsV0FBVyxLQUFLNFYsS0FBTCxDQUFXNVYsUUFBMUI7O0FBRUEsUUFBSW1qQixXQUFXLEtBQUt2TixLQUFMLENBQVd1TixRQUFYLElBQXVCa2MsTUFBTWxjLFFBQTVDOztBQUVBLFFBQUk2RSxRQUFRLEtBQUssQ0FBakI7QUFBQSxRQUNJNGIsUUFBUSxLQUFLLENBRGpCO0FBRUEsb0JBQU12cUIsUUFBTixDQUFlL1csT0FBZixDQUF1QnRDLFFBQXZCLEVBQWlDLFVBQVU4RyxPQUFWLEVBQW1CO0FBQ2xELFVBQUksQ0FBQyxnQkFBTTZELGNBQU4sQ0FBcUI3RCxPQUFyQixDQUFMLEVBQW9DOztBQUVwQyxVQUFJZ3NGLGlCQUFpQmhzRixRQUFROE8sS0FBN0I7QUFBQSxVQUNJbTlFLFdBQVdELGVBQWV6d0UsSUFEOUI7QUFBQSxVQUVJZ2YsUUFBUXl4RCxlQUFlenhELEtBRjNCO0FBQUEsVUFHSVAsU0FBU2d5RCxlQUFlaHlELE1BSDVCO0FBQUEsVUFJSWwrQixPQUFPa3dGLGVBQWVsd0YsSUFKMUI7O0FBTUEsVUFBSXlmLE9BQU8wd0UsWUFBWW53RixJQUF2Qjs7QUFFQSxVQUFJb2xCLFNBQVMsSUFBYixFQUFtQjtBQUNqQjRiLGdCQUFROThCLE9BQVI7QUFDQWtoQixnQkFBUTNGLE9BQU8seUJBQVVjLFNBQVNOLFFBQW5CLEVBQTZCLEVBQUVSLE1BQU1BLElBQVIsRUFBY2dmLE9BQU9BLEtBQXJCLEVBQTRCUCxRQUFRQSxNQUFwQyxFQUE3QixDQUFQLEdBQW9GekIsTUFBTXJYLEtBQWxHO0FBQ0Q7QUFDRixLQWZEOztBQWlCQSxXQUFPQSxRQUFRLGdCQUFNOVEsWUFBTixDQUFtQjBzQixLQUFuQixFQUEwQixFQUFFemdCLFVBQVVBLFFBQVosRUFBc0J3NUIsZUFBZTMwQixLQUFyQyxFQUExQixDQUFSLEdBQWtGLElBQXpGO0FBQ0QsR0ExQkQ7O0FBNEJBLFNBQU81akIsTUFBUDtBQUNELENBNUNZLENBNENYLGdCQUFNcVYsU0E1Q0ssQ0FBYjs7QUE4Q0FyVixPQUFPZzhCLFlBQVAsR0FBc0I7QUFDcEJoQixVQUFRLG9CQUFVdUcsS0FBVixDQUFnQjtBQUN0QnRHLFdBQU8sb0JBQVV6MEIsTUFBVixDQUFpQnUxQjtBQURGLEdBQWhCLEVBRUxBO0FBSGlCLENBQXRCO0FBS0EvN0IsT0FBT3V4QixTQUFQLEdBQW1CO0FBQ2pCMzFCLFlBQVUsb0JBQVVsQixJQURIO0FBRWpCcWtCLFlBQVUsb0JBQVV2WTtBQUZILENBQW5COztrQkFNZXhHLE07Ozs7Ozs7Ozs7Ozs7QUNwRWY7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQVBBLElBQUl1NEIsV0FBV3Y3QixPQUFPTyxNQUFQLElBQWlCLFVBQVVlLE1BQVYsRUFBa0I7QUFBRSxPQUFLLElBQUlySSxJQUFJLENBQWIsRUFBZ0JBLElBQUlELFVBQVVULE1BQTlCLEVBQXNDVSxHQUF0QyxFQUEyQztBQUFFLFFBQUlzSSxTQUFTdkksVUFBVUMsQ0FBVixDQUFiLENBQTJCLEtBQUssSUFBSTJJLEdBQVQsSUFBZ0JMLE1BQWhCLEVBQXdCO0FBQUUsVUFBSXZCLE9BQU8zRyxTQUFQLENBQWlCNEYsY0FBakIsQ0FBZ0NsSCxJQUFoQyxDQUFxQ3dKLE1BQXJDLEVBQTZDSyxHQUE3QyxDQUFKLEVBQXVEO0FBQUVOLGVBQU9NLEdBQVAsSUFBY0wsT0FBT0ssR0FBUCxDQUFkO0FBQTRCO0FBQUU7QUFBRSxHQUFDLE9BQU9OLE1BQVA7QUFBZ0IsQ0FBaFE7O0FBRUEsU0FBU2srQyx3QkFBVCxDQUFrQzFqQixHQUFsQyxFQUF1QzE2QixJQUF2QyxFQUE2QztBQUFFLE1BQUlFLFNBQVMsRUFBYixDQUFpQixLQUFLLElBQUlySSxDQUFULElBQWM2aUMsR0FBZCxFQUFtQjtBQUFFLFFBQUkxNkIsS0FBSzlFLE9BQUwsQ0FBYXJELENBQWIsS0FBbUIsQ0FBdkIsRUFBMEIsU0FBVSxJQUFJLENBQUMrRyxPQUFPM0csU0FBUCxDQUFpQjRGLGNBQWpCLENBQWdDbEgsSUFBaEMsQ0FBcUMrakMsR0FBckMsRUFBMEM3aUMsQ0FBMUMsQ0FBTCxFQUFtRCxTQUFVcUksT0FBT3JJLENBQVAsSUFBWTZpQyxJQUFJN2lDLENBQUosQ0FBWjtBQUFxQixHQUFDLE9BQU9xSSxNQUFQO0FBQWdCOztBQU81Tjs7O0FBR0EsSUFBSTRCLGFBQWEsU0FBU0EsVUFBVCxDQUFvQm1WLFNBQXBCLEVBQStCO0FBQzlDLE1BQUl1NUUsSUFBSSxTQUFTQSxDQUFULENBQVdwOUUsS0FBWCxFQUFrQjtBQUN4QixRQUFJcTlFLHNCQUFzQnI5RSxNQUFNcTlFLG1CQUFoQztBQUFBLFFBQ0lDLGlCQUFpQnR5Qyx5QkFBeUJockMsS0FBekIsRUFBZ0MsQ0FBQyxxQkFBRCxDQUFoQyxDQURyQjs7QUFHQSxXQUFPLGdCQUFNeFMsYUFBTixrQkFBMkIsRUFBRTg4QixRQUFRLFNBQVNBLE1BQVQsQ0FBZ0JpekQsbUJBQWhCLEVBQXFDO0FBQzdFLGVBQU8sZ0JBQU0vdkYsYUFBTixDQUFvQnFXLFNBQXBCLEVBQStCa2pCLFNBQVMsRUFBVCxFQUFhdTJELGNBQWIsRUFBNkJDLG1CQUE3QixFQUFrRCxFQUFFbitFLEtBQUtpK0UsbUJBQVAsRUFBbEQsQ0FBL0IsQ0FBUDtBQUNELE9BRitCLEVBQTNCLENBQVA7QUFHRCxHQVBEOztBQVNBRCxJQUFFaHNGLFdBQUYsR0FBZ0IsaUJBQWlCeVMsVUFBVXpTLFdBQVYsSUFBeUJ5UyxVQUFVN2QsSUFBcEQsSUFBNEQsR0FBNUU7QUFDQW8zRixJQUFFSSxnQkFBRixHQUFxQjM1RSxTQUFyQjtBQUNBdTVFLElBQUVyOUQsU0FBRixHQUFjO0FBQ1pzOUQseUJBQXFCLG9CQUFVdGlFO0FBRG5CLEdBQWQ7O0FBSUEsU0FBTyxvQ0FBYXFpRSxDQUFiLEVBQWdCdjVFLFNBQWhCLENBQVA7QUFDRCxDQWpCRDs7a0JBbUJlblYsVTs7Ozs7OztBQy9CZjs7OztBQUlBOztBQUVBLElBQUkrdUYsZ0JBQWdCO0FBQ2hCaHpELHVCQUFtQixJQURIO0FBRWhCRCxrQkFBYyxJQUZFO0FBR2hCMXBCLGtCQUFjLElBSEU7QUFJaEIxUCxpQkFBYSxJQUpHO0FBS2hCbTlCLHFCQUFpQixJQUxEO0FBTWhCa25CLFlBQVEsSUFOUTtBQU9oQjExQixlQUFXLElBUEs7QUFRaEI1dUIsVUFBTTtBQVJVLENBQXBCOztBQVdBLElBQUl1c0YsZ0JBQWdCO0FBQ2hCMTNGLFVBQU0sSUFEVTtBQUVoQmpDLFlBQVEsSUFGUTtBQUdoQmMsZUFBVyxJQUhLO0FBSWhCODRGLFlBQVEsSUFKUTtBQUtoQm41RixlQUFXLElBTEs7QUFNaEJvNUYsV0FBTztBQU5TLENBQXBCOztBQVNBLElBQUlDLG1DQUFtQyxPQUFPcnlGLE9BQU9ELHFCQUFkLEtBQXdDLFVBQS9FOztBQUVBNUksT0FBT0MsT0FBUCxHQUFpQixTQUFTazdGLG9CQUFULENBQThCQyxlQUE5QixFQUErQ0MsZUFBL0MsRUFBZ0VDLGFBQWhFLEVBQStFO0FBQzVGLFFBQUksT0FBT0QsZUFBUCxLQUEyQixRQUEvQixFQUF5QztBQUFFO0FBQ3ZDLFlBQUlweEYsT0FBT3BCLE9BQU9TLG1CQUFQLENBQTJCK3hGLGVBQTNCLENBQVg7O0FBRUE7QUFDQSxZQUFJSCxnQ0FBSixFQUFzQztBQUNsQ2p4RixtQkFBT0EsS0FBSzVJLE1BQUwsQ0FBWXdILE9BQU9ELHFCQUFQLENBQTZCeXlGLGVBQTdCLENBQVosQ0FBUDtBQUNIOztBQUVELGFBQUssSUFBSXY1RixJQUFJLENBQWIsRUFBZ0JBLElBQUltSSxLQUFLN0ksTUFBekIsRUFBaUMsRUFBRVUsQ0FBbkMsRUFBc0M7QUFDbEMsZ0JBQUksQ0FBQ2c1RixjQUFjN3dGLEtBQUtuSSxDQUFMLENBQWQsQ0FBRCxJQUEyQixDQUFDaTVGLGNBQWM5d0YsS0FBS25JLENBQUwsQ0FBZCxDQUE1QixLQUF1RCxDQUFDdzVGLGFBQUQsSUFBa0IsQ0FBQ0EsY0FBY3J4RixLQUFLbkksQ0FBTCxDQUFkLENBQTFFLENBQUosRUFBdUc7QUFDbkcsb0JBQUk7QUFDQXM1RixvQ0FBZ0JueEYsS0FBS25JLENBQUwsQ0FBaEIsSUFBMkJ1NUYsZ0JBQWdCcHhGLEtBQUtuSSxDQUFMLENBQWhCLENBQTNCO0FBQ0gsaUJBRkQsQ0FFRSxPQUFPd0MsS0FBUCxFQUFjLENBRWY7QUFDSjtBQUNKO0FBQ0o7O0FBRUQsV0FBTzgyRixlQUFQO0FBQ0gsQ0FyQkQsQzs7Ozs7Ozs7Ozs7O0FDNUJBLElBQU1HLFlBQVk7QUFDaEJDLGlCQUFlO0FBREMsQ0FBbEI7O2tCQUllRCxTOzs7Ozs7QUNKZixrQkFBa0IsbUM7Ozs7Ozs7Ozs7Ozs7OztBQ0FsQjs7OztBQUNBOztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBRU1FLEk7OztBQUNKLGdCQUFZcCtFLEtBQVosRUFBbUI7QUFBQTs7QUFBQSw0R0FDWEEsS0FEVzs7QUFFakIsVUFBS3duQixLQUFMLEdBQWE7QUFDWDYyRCxlQUFTO0FBREUsS0FBYjtBQUZpQjtBQUtsQjs7Ozt3Q0FDbUI7QUFDbEIsV0FBS24wRCxRQUFMLENBQWM7QUFDVm0wRCxpQkFBUztBQURDLE9BQWQ7QUFHQSxVQUFJdDVGLFFBQVF3SSxTQUFTK3dGLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBWjtBQUNBLFVBQUl2NUYsS0FBSixFQUFXO0FBQ1RBLGNBQU13NUYsU0FBTixHQUFrQixLQUFLditFLEtBQUwsQ0FBV29lLE9BQVgsQ0FBbUJyNUIsS0FBckM7QUFDRCxPQUZELE1BRU87QUFDTCxZQUFJQSxTQUFRd0ksU0FBU0MsYUFBVCxDQUF1QixPQUF2QixDQUFaO0FBQ0F6SSxlQUFNdzVGLFNBQU4sR0FBa0IsS0FBS3YrRSxLQUFMLENBQVdvZSxPQUFYLENBQW1CcjVCLEtBQXJDO0FBQ0F3SSxpQkFBUyt3RixhQUFULENBQXVCLE1BQXZCLEVBQStCRSxPQUEvQixDQUF1Q3o1RixNQUF2QztBQUNEO0FBQ0Y7OzsyQ0FDc0I7QUFDckIsV0FBS21sQyxRQUFMLENBQWM7QUFDVm0wRCxpQkFBUztBQURDLE9BQWQ7QUFHRDs7OzZCQUNRO0FBQ1B6MkYsY0FBUTYyRixHQUFSLENBQVksS0FBS3orRSxLQUFqQjtBQUNBLGFBQ0U7QUFBQTtBQUFBLFVBQUssV0FDRCxDQUNFLEtBQUtBLEtBQUwsQ0FBV2srRSxTQUFYLENBQXFCQyxhQUFyQixDQUFtQ25nRixXQUFuQyxFQURGLEVBRUV6UixJQUZGLENBRU8sR0FGUCxDQURKO0FBS0UsMkRBQVMsTUFBTSxLQUFLeVQsS0FBTCxDQUFXb2UsT0FBWCxDQUFtQnNnRSxRQUFsQyxHQUxGO0FBTUUsaUVBTkY7QUFPRSxnRUFBYyxPQUFPLEtBQUsxK0UsS0FBTCxDQUFXb2UsT0FBWCxDQUFtQnI1QixLQUF4QyxFQUErQyxXQUFXLEtBQUtpYixLQUFMLENBQVdvZSxPQUFYLENBQW1CdWdFLFNBQTdFLEVBQXdGLFFBQVEsS0FBSzMrRSxLQUFMLENBQVdvZSxPQUFYLENBQW1Cd2dFLE1BQW5ILEVBQTJILE1BQU0sS0FBSzUrRSxLQUFMLENBQVdvZSxPQUFYLENBQW1CeWdFLElBQXBKO0FBUEYsT0FERjtBQVdEOzs7O0VBdENnQixnQkFBTWg3RSxTOztrQkF5Q1YsNkJBQVd1NkUsSUFBWCxDOzs7Ozs7Ozs7Ozs7Ozs7O0FDaERmOzs7Ozs7Ozs7Ozs7SUFFcUJVLE87OztBQUNuQixtQkFBWTkrRSxLQUFaLEVBQW1CO0FBQUE7O0FBQUEsa0hBQ1hBLEtBRFc7O0FBRWpCLFVBQUt3bkIsS0FBTCxHQUFhO0FBQ1g2MkQsZUFBUztBQURFLEtBQWI7QUFGaUI7QUFLbEI7Ozs7d0NBQ21CO0FBQ2xCLFdBQUtuMEQsUUFBTCxDQUFjO0FBQ1ZtMEQsaUJBQVM7QUFEQyxPQUFkO0FBR0EsVUFBSWh1QyxPQUFPOWlELFNBQVMrd0YsYUFBVCxDQUF1QixNQUF2QixDQUFYO0FBQ0EsV0FBS3QrRSxLQUFMLENBQVcrK0UsSUFBWCxDQUFnQnJ5RixPQUFoQixDQUF3QixVQUFDdWQsR0FBRCxFQUFTO0FBQy9CLFlBQUkrMEUsVUFBVXp4RixTQUFTQyxhQUFULENBQXVCLE1BQXZCLENBQWQ7QUFDQSxhQUFLLElBQUlKLEdBQVQsSUFBZ0I2YyxHQUFoQixFQUFxQjtBQUNuQiswRSxrQkFBUWxqRSxZQUFSLENBQXFCMXVCLEdBQXJCLEVBQTBCNmMsSUFBSTdjLEdBQUosQ0FBMUI7QUFDRDtBQUNEaWpELGFBQUttdUMsT0FBTCxDQUFhUSxPQUFiO0FBQ0QsT0FORDtBQU9EOzs7MkNBQ3NCO0FBQ3JCLFdBQUs5MEQsUUFBTCxDQUFjO0FBQ1ZtMEQsaUJBQVM7QUFEQyxPQUFkO0FBR0Q7Ozs2QkFDUTtBQUNQLGFBQU8sSUFBUDtBQUNEOzs7O0VBM0JrQyxnQkFBTXg2RSxTOztrQkFBdEJpN0UsTzs7Ozs7Ozs7Ozs7Ozs7OztBQ0ZyQjs7OztBQUNBOzs7Ozs7Ozs7O0lBRXFCRyxVOzs7Ozs7Ozs7Ozs2QkFDVjtBQUNQLGFBQ0U7QUFBQTtBQUFBLFVBQUssV0FDSCxDQUNFLFlBREYsRUFFRTF5RixJQUZGLENBRU8sR0FGUCxDQURGO0FBS0E7QUFBQTtBQUFBLFlBQUssV0FBVSxRQUFmO0FBQ0U7QUFBQTtBQUFBLGNBQUksV0FBTSxVQUFWO0FBQUE7QUFBQTtBQURGLFNBTEE7QUFRQSwrQ0FBSyxNQUFLLFlBQVY7QUFSQSxPQURGO0FBYUQ7Ozs7RUFmcUMsZ0JBQU1zWCxTOztrQkFBekJvN0UsVTs7Ozs7Ozs7Ozs7Ozs7O0FDR3JCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBVEEsU0FBU3oyRCxlQUFULENBQXlCN21CLFFBQXpCLEVBQW1DOG1CLFdBQW5DLEVBQWdEO0FBQUUsTUFBSSxFQUFFOW1CLG9CQUFvQjhtQixXQUF0QixDQUFKLEVBQXdDO0FBQUUsVUFBTSxJQUFJNThCLFNBQUosQ0FBYyxtQ0FBZCxDQUFOO0FBQTJEO0FBQUU7O0FBRXpKLFNBQVM2OEIsMEJBQVQsQ0FBb0Nyb0IsSUFBcEMsRUFBMEM5YyxJQUExQyxFQUFnRDtBQUFFLE1BQUksQ0FBQzhjLElBQUwsRUFBVztBQUFFLFVBQU0sSUFBSXNvQixjQUFKLENBQW1CLDJEQUFuQixDQUFOO0FBQXdGLEdBQUMsT0FBT3BsQyxTQUFTLFFBQU9BLElBQVAseUNBQU9BLElBQVAsT0FBZ0IsUUFBaEIsSUFBNEIsT0FBT0EsSUFBUCxLQUFnQixVQUFyRCxJQUFtRUEsSUFBbkUsR0FBMEU4YyxJQUFqRjtBQUF3Rjs7QUFFaFAsU0FBU3VvQixTQUFULENBQW1CQyxRQUFuQixFQUE2QkMsVUFBN0IsRUFBeUM7QUFBRSxNQUFJLE9BQU9BLFVBQVAsS0FBc0IsVUFBdEIsSUFBb0NBLGVBQWUsSUFBdkQsRUFBNkQ7QUFBRSxVQUFNLElBQUlqOUIsU0FBSixDQUFjLHFFQUFvRWk5QixVQUFwRSx5Q0FBb0VBLFVBQXBFLEVBQWQsQ0FBTjtBQUFzRyxHQUFDRCxTQUFTaGtDLFNBQVQsR0FBcUIyRyxPQUFPb1EsTUFBUCxDQUFja3RCLGNBQWNBLFdBQVdqa0MsU0FBdkMsRUFBa0QsRUFBRW1XLGFBQWEsRUFBRWUsT0FBTzhzQixRQUFULEVBQW1CdG9CLFlBQVksS0FBL0IsRUFBc0NDLFVBQVUsSUFBaEQsRUFBc0RqRSxjQUFjLElBQXBFLEVBQWYsRUFBbEQsQ0FBckIsQ0FBcUssSUFBSXVzQixVQUFKLEVBQWdCdDlCLE9BQU91OUIsY0FBUCxHQUF3QnY5QixPQUFPdTlCLGNBQVAsQ0FBc0JGLFFBQXRCLEVBQWdDQyxVQUFoQyxDQUF4QixHQUFzRUQsU0FBU0csU0FBVCxHQUFxQkYsVUFBM0Y7QUFBd0c7O0FBTzllOzs7O0FBSUEsSUFBSThoQixnQkFBZ0IsVUFBVTNoQixnQkFBVixFQUE0QjtBQUM5Q0wsWUFBVWdpQixhQUFWLEVBQXlCM2hCLGdCQUF6Qjs7QUFFQSxXQUFTMmhCLGFBQVQsR0FBeUI7QUFDdkIsUUFBSTFoQixLQUFKLEVBQVdDLEtBQVgsRUFBa0JDLElBQWxCOztBQUVBWixvQkFBZ0IsSUFBaEIsRUFBc0JvaUIsYUFBdEI7O0FBRUEsU0FBSyxJQUFJbmpELE9BQU9qRCxVQUFVVCxNQUFyQixFQUE2Qk8sT0FBT0MsTUFBTWtELElBQU4sQ0FBcEMsRUFBaURDLE9BQU8sQ0FBN0QsRUFBZ0VBLE9BQU9ELElBQXZFLEVBQTZFQyxNQUE3RSxFQUFxRjtBQUNuRnBELFdBQUtvRCxJQUFMLElBQWFsRCxVQUFVa0QsSUFBVixDQUFiO0FBQ0Q7O0FBRUQsV0FBTzBoQyxRQUFRRixTQUFTQyxRQUFRVCwyQkFBMkIsSUFBM0IsRUFBaUNPLGlCQUFpQjFsQyxJQUFqQixDQUFzQnVCLEtBQXRCLENBQTRCbWtDLGdCQUE1QixFQUE4QyxDQUFDLElBQUQsRUFBT2psQyxNQUFQLENBQWNNLElBQWQsQ0FBOUMsQ0FBakMsQ0FBUixFQUE4RzZrQyxLQUF2SCxHQUErSEEsTUFBTUcsT0FBTixHQUFnQixvQ0FBY0gsTUFBTW5wQixLQUFwQixDQUEvSSxFQUEyS2twQixLQUFuTCxHQUEyTFIsMkJBQTJCUyxLQUEzQixFQUFrQ0MsSUFBbEMsQ0FBbE07QUFDRDs7QUFFRHdoQixnQkFBYy9sRCxTQUFkLENBQXdCeWxDLE1BQXhCLEdBQWlDLFNBQVNBLE1BQVQsR0FBa0I7QUFDakQsV0FBTyxnQkFBTTk4QixhQUFOLHNCQUE0QixFQUFFODdCLFNBQVMsS0FBS0EsT0FBaEIsRUFBeUJsL0IsVUFBVSxLQUFLNFYsS0FBTCxDQUFXNVYsUUFBOUMsRUFBNUIsQ0FBUDtBQUNELEdBRkQ7O0FBSUEsU0FBT3dnRCxhQUFQO0FBQ0QsQ0FwQm1CLENBb0JsQixnQkFBTS9tQyxTQXBCWSxDQUFwQjs7QUFzQkErbUMsY0FBYzdxQixTQUFkLEdBQTBCO0FBQ3hCMG9CLFlBQVUsb0JBQVV2MkIsTUFESTtBQUV4QmsyQixnQkFBYyxvQkFBVXRaLElBRkE7QUFHeEIzRyx1QkFBcUIsb0JBQVVwTixJQUhQO0FBSXhCeXRCLGFBQVcsb0JBQVV6WixNQUpHO0FBS3hCM2tDLFlBQVUsb0JBQVVsQjtBQUxJLENBQTFCOztrQkFTZTBoRCxhOzs7Ozs7Ozs7Ozs7Ozs7QUN4Q2Y7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFUQSxTQUFTcGlCLGVBQVQsQ0FBeUI3bUIsUUFBekIsRUFBbUM4bUIsV0FBbkMsRUFBZ0Q7QUFBRSxNQUFJLEVBQUU5bUIsb0JBQW9COG1CLFdBQXRCLENBQUosRUFBd0M7QUFBRSxVQUFNLElBQUk1OEIsU0FBSixDQUFjLG1DQUFkLENBQU47QUFBMkQ7QUFBRTs7QUFFekosU0FBUzY4QiwwQkFBVCxDQUFvQ3JvQixJQUFwQyxFQUEwQzljLElBQTFDLEVBQWdEO0FBQUUsTUFBSSxDQUFDOGMsSUFBTCxFQUFXO0FBQUUsVUFBTSxJQUFJc29CLGNBQUosQ0FBbUIsMkRBQW5CLENBQU47QUFBd0YsR0FBQyxPQUFPcGxDLFNBQVMsUUFBT0EsSUFBUCx5Q0FBT0EsSUFBUCxPQUFnQixRQUFoQixJQUE0QixPQUFPQSxJQUFQLEtBQWdCLFVBQXJELElBQW1FQSxJQUFuRSxHQUEwRThjLElBQWpGO0FBQXdGOztBQUVoUCxTQUFTdW9CLFNBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCQyxVQUE3QixFQUF5QztBQUFFLE1BQUksT0FBT0EsVUFBUCxLQUFzQixVQUF0QixJQUFvQ0EsZUFBZSxJQUF2RCxFQUE2RDtBQUFFLFVBQU0sSUFBSWo5QixTQUFKLENBQWMscUVBQW9FaTlCLFVBQXBFLHlDQUFvRUEsVUFBcEUsRUFBZCxDQUFOO0FBQXNHLEdBQUNELFNBQVNoa0MsU0FBVCxHQUFxQjJHLE9BQU9vUSxNQUFQLENBQWNrdEIsY0FBY0EsV0FBV2prQyxTQUF2QyxFQUFrRCxFQUFFbVcsYUFBYSxFQUFFZSxPQUFPOHNCLFFBQVQsRUFBbUJ0b0IsWUFBWSxLQUEvQixFQUFzQ0MsVUFBVSxJQUFoRCxFQUFzRGpFLGNBQWMsSUFBcEUsRUFBZixFQUFsRCxDQUFyQixDQUFxSyxJQUFJdXNCLFVBQUosRUFBZ0J0OUIsT0FBT3U5QixjQUFQLEdBQXdCdjlCLE9BQU91OUIsY0FBUCxDQUFzQkYsUUFBdEIsRUFBZ0NDLFVBQWhDLENBQXhCLEdBQXNFRCxTQUFTRyxTQUFULEdBQXFCRixVQUEzRjtBQUF3Rzs7QUFPOWU7Ozs7QUFJQSxJQUFJK2hCLGFBQWEsVUFBVTVoQixnQkFBVixFQUE0QjtBQUMzQ0wsWUFBVWlpQixVQUFWLEVBQXNCNWhCLGdCQUF0Qjs7QUFFQSxXQUFTNGhCLFVBQVQsR0FBc0I7QUFDcEIsUUFBSTNoQixLQUFKLEVBQVdDLEtBQVgsRUFBa0JDLElBQWxCOztBQUVBWixvQkFBZ0IsSUFBaEIsRUFBc0JxaUIsVUFBdEI7O0FBRUEsU0FBSyxJQUFJcGpELE9BQU9qRCxVQUFVVCxNQUFyQixFQUE2Qk8sT0FBT0MsTUFBTWtELElBQU4sQ0FBcEMsRUFBaURDLE9BQU8sQ0FBN0QsRUFBZ0VBLE9BQU9ELElBQXZFLEVBQTZFQyxNQUE3RSxFQUFxRjtBQUNuRnBELFdBQUtvRCxJQUFMLElBQWFsRCxVQUFVa0QsSUFBVixDQUFiO0FBQ0Q7O0FBRUQsV0FBTzBoQyxRQUFRRixTQUFTQyxRQUFRVCwyQkFBMkIsSUFBM0IsRUFBaUNPLGlCQUFpQjFsQyxJQUFqQixDQUFzQnVCLEtBQXRCLENBQTRCbWtDLGdCQUE1QixFQUE4QyxDQUFDLElBQUQsRUFBT2psQyxNQUFQLENBQWNNLElBQWQsQ0FBOUMsQ0FBakMsQ0FBUixFQUE4RzZrQyxLQUF2SCxHQUErSEEsTUFBTUcsT0FBTixHQUFnQixpQ0FBY0gsTUFBTW5wQixLQUFwQixDQUEvSSxFQUEyS2twQixLQUFuTCxHQUEyTFIsMkJBQTJCUyxLQUEzQixFQUFrQ0MsSUFBbEMsQ0FBbE07QUFDRDs7QUFFRHloQixhQUFXaG1ELFNBQVgsQ0FBcUJ5bEMsTUFBckIsR0FBOEIsU0FBU0EsTUFBVCxHQUFrQjtBQUM5QyxXQUFPLGdCQUFNOThCLGFBQU4sc0JBQTRCLEVBQUU4N0IsU0FBUyxLQUFLQSxPQUFoQixFQUF5QmwvQixVQUFVLEtBQUs0VixLQUFMLENBQVc1VixRQUE5QyxFQUE1QixDQUFQO0FBQ0QsR0FGRDs7QUFJQSxTQUFPeWdELFVBQVA7QUFDRCxDQXBCZ0IsQ0FvQmYsZ0JBQU1obkMsU0FwQlMsQ0FBakI7O0FBc0JBZ25DLFdBQVc5cUIsU0FBWCxHQUF1QjtBQUNyQjBvQixZQUFVLG9CQUFVdjJCLE1BREM7QUFFckJpVyx1QkFBcUIsb0JBQVVwTixJQUZWO0FBR3JCbWtFLFlBQVUsb0JBQVV2dkQsS0FBVixDQUFnQixDQUFDLFVBQUQsRUFBYSxTQUFiLEVBQXdCLE9BQXhCLENBQWhCLENBSFc7QUFJckJ2bEMsWUFBVSxvQkFBVWxCO0FBSkMsQ0FBdkI7O2tCQVFlMmhELFU7Ozs7Ozs7QUM3Q2Y7O0FBRUFqb0QsUUFBUTJwQixVQUFSLEdBQXFCLElBQXJCOztBQUVBLElBQUl3YSxXQUFXdjdCLE9BQU9PLE1BQVAsSUFBaUIsVUFBVWUsTUFBVixFQUFrQjtBQUFFLE9BQUssSUFBSXJJLElBQUksQ0FBYixFQUFnQkEsSUFBSUQsVUFBVVQsTUFBOUIsRUFBc0NVLEdBQXRDLEVBQTJDO0FBQUUsUUFBSXNJLFNBQVN2SSxVQUFVQyxDQUFWLENBQWIsQ0FBMkIsS0FBSyxJQUFJMkksR0FBVCxJQUFnQkwsTUFBaEIsRUFBd0I7QUFBRSxVQUFJdkIsT0FBTzNHLFNBQVAsQ0FBaUI0RixjQUFqQixDQUFnQ2xILElBQWhDLENBQXFDd0osTUFBckMsRUFBNkNLLEdBQTdDLENBQUosRUFBdUQ7QUFBRU4sZUFBT00sR0FBUCxJQUFjTCxPQUFPSyxHQUFQLENBQWQ7QUFBNEI7QUFBRTtBQUFFLEdBQUMsT0FBT04sTUFBUDtBQUFnQixDQUFoUTs7QUFFQSxJQUFJODZCLFdBQVcsbUJBQUF0Z0MsQ0FBUSxFQUFSLENBQWY7O0FBRUEsSUFBSXVnQyxZQUFZWCx1QkFBdUJVLFFBQXZCLENBQWhCOztBQUVBLElBQUl3ZixhQUFhLG1CQUFBOS9DLENBQVEsRUFBUixDQUFqQjs7QUFFQSxJQUFJKy9DLGNBQWNuZ0IsdUJBQXVCa2dCLFVBQXZCLENBQWxCOztBQUVBLElBQUlFLGlCQUFpQixtQkFBQWhnRCxDQUFRLEVBQVIsQ0FBckI7O0FBRUEsSUFBSSsvQixhQUFhLG1CQUFBLy9CLENBQVEsRUFBUixDQUFqQjs7QUFFQSxJQUFJaWdELDJCQUEyQixtQkFBQWpnRCxDQUFRLEVBQVIsQ0FBL0I7O0FBRUEsSUFBSWtnRCw0QkFBNEJ0Z0IsdUJBQXVCcWdCLHdCQUF2QixDQUFoQzs7QUFFQSxJQUFJRSxZQUFZLG1CQUFBbmdELENBQVEsRUFBUixDQUFoQjs7QUFFQSxTQUFTNC9CLHNCQUFULENBQWdDSSxHQUFoQyxFQUFxQztBQUFFLFNBQU9BLE9BQU9BLElBQUkvYSxVQUFYLEdBQXdCK2EsR0FBeEIsR0FBOEIsRUFBRUMsU0FBU0QsR0FBWCxFQUFyQztBQUF3RDs7QUFFL0YsSUFBSXFnQixrQkFBa0IsWUFBdEI7O0FBRUEsSUFBSXczQyxpQkFBaUI7QUFDbkJDLFlBQVU7QUFDUkMsZ0JBQVksU0FBU0EsVUFBVCxDQUFvQjV5RSxJQUFwQixFQUEwQjtBQUNwQyxhQUFPQSxLQUFLQyxNQUFMLENBQVksQ0FBWixNQUFtQixHQUFuQixHQUF5QkQsSUFBekIsR0FBZ0MsT0FBTyxDQUFDLEdBQUc0YSxXQUFXMWEsaUJBQWYsRUFBa0NGLElBQWxDLENBQTlDO0FBQ0QsS0FITztBQUlSNnlFLGdCQUFZLFNBQVNBLFVBQVQsQ0FBb0I3eUUsSUFBcEIsRUFBMEI7QUFDcEMsYUFBT0EsS0FBS0MsTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBbkIsR0FBeUJELEtBQUtoYyxNQUFMLENBQVksQ0FBWixDQUF6QixHQUEwQ2djLElBQWpEO0FBQ0Q7QUFOTyxHQURTO0FBU25COHlFLFdBQVM7QUFDUEYsZ0JBQVloNEQsV0FBVzFhLGlCQURoQjtBQUVQMnlFLGdCQUFZajRELFdBQVc3YTtBQUZoQixHQVRVO0FBYW5CZ3pFLFNBQU87QUFDTEgsZ0JBQVloNEQsV0FBVzdhLGVBRGxCO0FBRUw4eUUsZ0JBQVlqNEQsV0FBVzdhO0FBRmxCO0FBYlksQ0FBckI7O0FBbUJBLElBQUlpekUsY0FBYyxTQUFTQSxXQUFULEdBQXVCO0FBQ3ZDO0FBQ0E7QUFDQSxNQUFJMzFDLE9BQU94OEMsT0FBT2lnQixRQUFQLENBQWdCdThCLElBQTNCO0FBQ0EsTUFBSTE4QixZQUFZMDhCLEtBQUtoaUQsT0FBTCxDQUFhLEdBQWIsQ0FBaEI7QUFDQSxTQUFPc2xCLGNBQWMsQ0FBQyxDQUFmLEdBQW1CLEVBQW5CLEdBQXdCMDhCLEtBQUtwM0IsU0FBTCxDQUFldEYsWUFBWSxDQUEzQixDQUEvQjtBQUNELENBTkQ7O0FBUUEsSUFBSXN5RSxlQUFlLFNBQVNBLFlBQVQsQ0FBc0JqekUsSUFBdEIsRUFBNEI7QUFDN0MsU0FBT25mLE9BQU9pZ0IsUUFBUCxDQUFnQkosSUFBaEIsR0FBdUJWLElBQTlCO0FBQ0QsQ0FGRDs7QUFJQSxJQUFJa3pFLGtCQUFrQixTQUFTQSxlQUFULENBQXlCbHpFLElBQXpCLEVBQStCO0FBQ25ELE1BQUlXLFlBQVk5ZixPQUFPaWdCLFFBQVAsQ0FBZ0J1OEIsSUFBaEIsQ0FBcUJoaUQsT0FBckIsQ0FBNkIsR0FBN0IsQ0FBaEI7O0FBRUF3RixTQUFPaWdCLFFBQVAsQ0FBZ0JwbUIsT0FBaEIsQ0FBd0JtRyxPQUFPaWdCLFFBQVAsQ0FBZ0J1OEIsSUFBaEIsQ0FBcUI5Z0QsS0FBckIsQ0FBMkIsQ0FBM0IsRUFBOEJva0IsYUFBYSxDQUFiLEdBQWlCQSxTQUFqQixHQUE2QixDQUEzRCxJQUFnRSxHQUFoRSxHQUFzRVgsSUFBOUY7QUFDRCxDQUpEOztBQU1BLElBQUltekUsb0JBQW9CLFNBQVNBLGlCQUFULEdBQTZCO0FBQ25ELE1BQUk1L0UsUUFBUXhiLFVBQVVULE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0JTLFVBQVUsQ0FBVixNQUFpQmlDLFNBQXpDLEdBQXFEakMsVUFBVSxDQUFWLENBQXJELEdBQW9FLEVBQWhGOztBQUVBLEdBQUMsR0FBRzZpRCxZQUFZOWYsT0FBaEIsRUFBeUJrZ0IsVUFBVXA2QyxTQUFuQyxFQUE4QywwQkFBOUM7O0FBRUEsTUFBSXk2QyxnQkFBZ0J4NkMsT0FBT2c4QixPQUEzQjtBQUNBLE1BQUl1MkQscUJBQXFCLENBQUMsR0FBR3A0QyxVQUFVa0QsZ0NBQWQsR0FBekI7O0FBRUEsTUFBSXRDLHdCQUF3QnJvQyxNQUFNbW9CLG1CQUFsQztBQUFBLE1BQ0lBLHNCQUFzQmtnQiwwQkFBMEI1aEQsU0FBMUIsR0FBc0NnaEQsVUFBVWEsZUFBaEQsR0FBa0VELHFCQUQ1RjtBQUFBLE1BRUl5M0Msa0JBQWtCOS9FLE1BQU1rL0UsUUFGNUI7QUFBQSxNQUdJQSxXQUFXWSxvQkFBb0JyNUYsU0FBcEIsR0FBZ0MsT0FBaEMsR0FBMENxNUYsZUFIekQ7O0FBS0EsTUFBSXIzQyxXQUFXem9DLE1BQU15b0MsUUFBTixHQUFpQixDQUFDLEdBQUdwaEIsV0FBV3RhLGtCQUFmLEVBQW1DLENBQUMsR0FBR3NhLFdBQVc3YSxlQUFmLEVBQWdDeE0sTUFBTXlvQyxRQUF0QyxDQUFuQyxDQUFqQixHQUF1RyxFQUF0SDs7QUFFQSxNQUFJczNDLHdCQUF3QlosZUFBZUQsUUFBZixDQUE1QjtBQUFBLE1BQ0lHLGFBQWFVLHNCQUFzQlYsVUFEdkM7QUFBQSxNQUVJQyxhQUFhUyxzQkFBc0JULFVBRnZDOztBQUtBLE1BQUk1MkMsaUJBQWlCLFNBQVNBLGNBQVQsR0FBMEI7QUFDN0MsUUFBSWo4QixPQUFPNnlFLFdBQVdHLGFBQVgsQ0FBWDs7QUFFQSxLQUFDLEdBQUc1M0QsVUFBVU4sT0FBZCxFQUF1QixDQUFDa2hCLFFBQUQsSUFBYSxDQUFDLEdBQUdwaEIsV0FBV3phLFdBQWYsRUFBNEJILElBQTVCLEVBQWtDZzhCLFFBQWxDLENBQXBDLEVBQWlGLGtGQUFrRixvQ0FBbEYsR0FBeUhoOEIsSUFBekgsR0FBZ0ksbUJBQWhJLEdBQXNKZzhCLFFBQXRKLEdBQWlLLElBQWxQOztBQUVBLFFBQUlBLFFBQUosRUFBY2g4QixPQUFPLENBQUMsR0FBRzRhLFdBQVd2YSxhQUFmLEVBQThCTCxJQUE5QixFQUFvQ2c4QixRQUFwQyxDQUFQOztBQUVkLFdBQU8sQ0FBQyxHQUFHbkIsZUFBZXhnQixjQUFuQixFQUFtQ3JhLElBQW5DLENBQVA7QUFDRCxHQVJEOztBQVVBLE1BQUlxOEIsb0JBQW9CLENBQUMsR0FBR3RCLDBCQUEwQmpnQixPQUE5QixHQUF4Qjs7QUFFQSxNQUFJMkMsV0FBVyxTQUFTQSxRQUFULENBQWtCNmUsU0FBbEIsRUFBNkI7QUFDMUNoaUIsYUFBU3VDLE9BQVQsRUFBa0J5ZixTQUFsQjs7QUFFQXpmLFlBQVF2bEMsTUFBUixHQUFpQitqRCxjQUFjL2pELE1BQS9COztBQUVBK2tELHNCQUFrQnZnQixlQUFsQixDQUFrQ2UsUUFBUS9iLFFBQTFDLEVBQW9EK2IsUUFBUTlzQixNQUE1RDtBQUNELEdBTkQ7O0FBUUEsTUFBSTRzQyxlQUFlLEtBQW5CO0FBQ0EsTUFBSTQyQyxhQUFhLElBQWpCOztBQUVBLE1BQUk3MkMsbUJBQW1CLFNBQVNBLGdCQUFULEdBQTRCO0FBQ2pELFFBQUkxOEIsT0FBT2d6RSxhQUFYO0FBQ0EsUUFBSVEsY0FBY1osV0FBVzV5RSxJQUFYLENBQWxCOztBQUVBLFFBQUlBLFNBQVN3ekUsV0FBYixFQUEwQjtBQUN4QjtBQUNBTixzQkFBZ0JNLFdBQWhCO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsVUFBSTF5RSxXQUFXbTdCLGdCQUFmO0FBQ0EsVUFBSXczQyxlQUFlNTJELFFBQVEvYixRQUEzQjs7QUFFQSxVQUFJLENBQUM2N0IsWUFBRCxJQUFpQixDQUFDLEdBQUc5QixlQUFlemdCLGlCQUFuQixFQUFzQ3E1RCxZQUF0QyxFQUFvRDN5RSxRQUFwRCxDQUFyQixFQUFvRixPQUovRSxDQUl1Rjs7QUFFNUYsVUFBSXl5RSxlQUFlLENBQUMsR0FBRzM0RCxXQUFXL1osVUFBZixFQUEyQkMsUUFBM0IsQ0FBbkIsRUFBeUQsT0FOcEQsQ0FNNEQ7O0FBRWpFeXlFLG1CQUFhLElBQWI7O0FBRUE5MkMsZ0JBQVUzN0IsUUFBVjtBQUNEO0FBQ0YsR0FuQkQ7O0FBcUJBLE1BQUkyN0IsWUFBWSxTQUFTQSxTQUFULENBQW1CMzdCLFFBQW5CLEVBQTZCO0FBQzNDLFFBQUk2N0IsWUFBSixFQUFrQjtBQUNoQkEscUJBQWUsS0FBZjtBQUNBbGY7QUFDRCxLQUhELE1BR087QUFDTCxVQUFJMXRCLFNBQVMsS0FBYjs7QUFFQXNzQyx3QkFBa0I1Z0IsbUJBQWxCLENBQXNDM2EsUUFBdEMsRUFBZ0QvUSxNQUFoRCxFQUF3RDJyQixtQkFBeEQsRUFBNkUsVUFBVWtoQixFQUFWLEVBQWM7QUFDekYsWUFBSUEsRUFBSixFQUFRO0FBQ05uZixtQkFBUyxFQUFFMXRCLFFBQVFBLE1BQVYsRUFBa0IrUSxVQUFVQSxRQUE1QixFQUFUO0FBQ0QsU0FGRCxNQUVPO0FBQ0wrN0Isb0JBQVUvN0IsUUFBVjtBQUNEO0FBQ0YsT0FORDtBQU9EO0FBQ0YsR0FmRDs7QUFpQkEsTUFBSSs3QixZQUFZLFNBQVNBLFNBQVQsQ0FBbUJDLFlBQW5CLEVBQWlDO0FBQy9DLFFBQUlDLGFBQWFsZ0IsUUFBUS9iLFFBQXpCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFJK1EsVUFBVTZoRSxTQUFTQyxXQUFULENBQXFCLENBQUMsR0FBRy80RCxXQUFXL1osVUFBZixFQUEyQms4QixVQUEzQixDQUFyQixDQUFkOztBQUVBLFFBQUlsckIsWUFBWSxDQUFDLENBQWpCLEVBQW9CQSxVQUFVLENBQVY7O0FBRXBCLFFBQUlFLFlBQVkyaEUsU0FBU0MsV0FBVCxDQUFxQixDQUFDLEdBQUcvNEQsV0FBVy9aLFVBQWYsRUFBMkJpOEIsWUFBM0IsQ0FBckIsQ0FBaEI7O0FBRUEsUUFBSS9xQixjQUFjLENBQUMsQ0FBbkIsRUFBc0JBLFlBQVksQ0FBWjs7QUFFdEIsUUFBSWtyQixRQUFRcHJCLFVBQVVFLFNBQXRCOztBQUVBLFFBQUlrckIsS0FBSixFQUFXO0FBQ1ROLHFCQUFlLElBQWY7QUFDQU8sU0FBR0QsS0FBSDtBQUNEO0FBQ0YsR0FyQkQ7O0FBdUJBO0FBQ0EsTUFBSWo5QixPQUFPZ3pFLGFBQVg7QUFDQSxNQUFJUSxjQUFjWixXQUFXNXlFLElBQVgsQ0FBbEI7O0FBRUEsTUFBSUEsU0FBU3d6RSxXQUFiLEVBQTBCTixnQkFBZ0JNLFdBQWhCOztBQUUxQixNQUFJcjJDLGtCQUFrQmxCLGdCQUF0QjtBQUNBLE1BQUl5M0MsV0FBVyxDQUFDLENBQUMsR0FBRzk0RCxXQUFXL1osVUFBZixFQUEyQnM4QixlQUEzQixDQUFELENBQWY7O0FBRUE7O0FBRUEsTUFBSUMsYUFBYSxTQUFTQSxVQUFULENBQW9CdDhCLFFBQXBCLEVBQThCO0FBQzdDLFdBQU8sTUFBTTh4RSxXQUFXNTJDLFdBQVcsQ0FBQyxHQUFHcGhCLFdBQVcvWixVQUFmLEVBQTJCQyxRQUEzQixDQUF0QixDQUFiO0FBQ0QsR0FGRDs7QUFJQSxNQUFJN29CLE9BQU8sU0FBU0EsSUFBVCxDQUFjK25CLElBQWQsRUFBb0IrYSxLQUFwQixFQUEyQjtBQUNwQyxLQUFDLEdBQUdLLFVBQVVOLE9BQWQsRUFBdUJDLFVBQVUvZ0MsU0FBakMsRUFBNEMsK0NBQTVDOztBQUVBLFFBQUkrVixTQUFTLE1BQWI7QUFDQSxRQUFJK1EsV0FBVyxDQUFDLEdBQUcrNUIsZUFBZXhnQixjQUFuQixFQUFtQ3JhLElBQW5DLEVBQXlDaG1CLFNBQXpDLEVBQW9EQSxTQUFwRCxFQUErRDZpQyxRQUFRL2IsUUFBdkUsQ0FBZjs7QUFFQXU3QixzQkFBa0I1Z0IsbUJBQWxCLENBQXNDM2EsUUFBdEMsRUFBZ0QvUSxNQUFoRCxFQUF3RDJyQixtQkFBeEQsRUFBNkUsVUFBVWtoQixFQUFWLEVBQWM7QUFDekYsVUFBSSxDQUFDQSxFQUFMLEVBQVM7O0FBRVQsVUFBSTU4QixPQUFPLENBQUMsR0FBRzRhLFdBQVcvWixVQUFmLEVBQTJCQyxRQUEzQixDQUFYO0FBQ0EsVUFBSTB5RSxjQUFjWixXQUFXNTJDLFdBQVdoOEIsSUFBdEIsQ0FBbEI7QUFDQSxVQUFJNHpFLGNBQWNaLGtCQUFrQlEsV0FBcEM7O0FBRUEsVUFBSUksV0FBSixFQUFpQjtBQUNmO0FBQ0E7QUFDQTtBQUNBTCxxQkFBYXZ6RSxJQUFiO0FBQ0FpekUscUJBQWFPLFdBQWI7O0FBRUEsWUFBSWoyQyxZQUFZbTJDLFNBQVNDLFdBQVQsQ0FBcUIsQ0FBQyxHQUFHLzRELFdBQVcvWixVQUFmLEVBQTJCZ2MsUUFBUS9iLFFBQW5DLENBQXJCLENBQWhCO0FBQ0EsWUFBSSt5RSxZQUFZSCxTQUFTbjNGLEtBQVQsQ0FBZSxDQUFmLEVBQWtCZ2hELGNBQWMsQ0FBQyxDQUFmLEdBQW1CLENBQW5CLEdBQXVCQSxZQUFZLENBQXJELENBQWhCOztBQUVBczJDLGtCQUFVNTdGLElBQVYsQ0FBZStuQixJQUFmO0FBQ0EwekUsbUJBQVdHLFNBQVg7O0FBRUFwMkQsaUJBQVMsRUFBRTF0QixRQUFRQSxNQUFWLEVBQWtCK1EsVUFBVUEsUUFBNUIsRUFBVDtBQUNELE9BZEQsTUFjTztBQUNMLFNBQUMsR0FBR3NhLFVBQVVOLE9BQWQsRUFBdUIsS0FBdkIsRUFBOEIsNEZBQTlCOztBQUVBMkM7QUFDRDtBQUNGLEtBMUJEO0FBMkJELEdBakNEOztBQW1DQSxNQUFJL2lDLFVBQVUsU0FBU0EsT0FBVCxDQUFpQnNsQixJQUFqQixFQUF1QithLEtBQXZCLEVBQThCO0FBQzFDLEtBQUMsR0FBR0ssVUFBVU4sT0FBZCxFQUF1QkMsVUFBVS9nQyxTQUFqQyxFQUE0QyxrREFBNUM7O0FBRUEsUUFBSStWLFNBQVMsU0FBYjtBQUNBLFFBQUkrUSxXQUFXLENBQUMsR0FBRys1QixlQUFleGdCLGNBQW5CLEVBQW1DcmEsSUFBbkMsRUFBeUNobUIsU0FBekMsRUFBb0RBLFNBQXBELEVBQStENmlDLFFBQVEvYixRQUF2RSxDQUFmOztBQUVBdTdCLHNCQUFrQjVnQixtQkFBbEIsQ0FBc0MzYSxRQUF0QyxFQUFnRC9RLE1BQWhELEVBQXdEMnJCLG1CQUF4RCxFQUE2RSxVQUFVa2hCLEVBQVYsRUFBYztBQUN6RixVQUFJLENBQUNBLEVBQUwsRUFBUzs7QUFFVCxVQUFJNThCLE9BQU8sQ0FBQyxHQUFHNGEsV0FBVy9aLFVBQWYsRUFBMkJDLFFBQTNCLENBQVg7QUFDQSxVQUFJMHlFLGNBQWNaLFdBQVc1MkMsV0FBV2g4QixJQUF0QixDQUFsQjtBQUNBLFVBQUk0ekUsY0FBY1osa0JBQWtCUSxXQUFwQzs7QUFFQSxVQUFJSSxXQUFKLEVBQWlCO0FBQ2Y7QUFDQTtBQUNBO0FBQ0FMLHFCQUFhdnpFLElBQWI7QUFDQWt6RSx3QkFBZ0JNLFdBQWhCO0FBQ0Q7O0FBRUQsVUFBSWoyQyxZQUFZbTJDLFNBQVNyNEYsT0FBVCxDQUFpQixDQUFDLEdBQUd1L0IsV0FBVy9aLFVBQWYsRUFBMkJnYyxRQUFRL2IsUUFBbkMsQ0FBakIsQ0FBaEI7O0FBRUEsVUFBSXk4QixjQUFjLENBQUMsQ0FBbkIsRUFBc0JtMkMsU0FBU24yQyxTQUFULElBQXNCdjlCLElBQXRCOztBQUV0QnlkLGVBQVMsRUFBRTF0QixRQUFRQSxNQUFWLEVBQWtCK1EsVUFBVUEsUUFBNUIsRUFBVDtBQUNELEtBcEJEO0FBcUJELEdBM0JEOztBQTZCQSxNQUFJbzhCLEtBQUssU0FBU0EsRUFBVCxDQUFZcjlDLENBQVosRUFBZTtBQUN0QixLQUFDLEdBQUd1N0IsVUFBVU4sT0FBZCxFQUF1QnM0RCxrQkFBdkIsRUFBMkMsOERBQTNDOztBQUVBLzNDLGtCQUFjNkIsRUFBZCxDQUFpQnI5QyxDQUFqQjtBQUNELEdBSkQ7O0FBTUEsTUFBSTQ5QyxTQUFTLFNBQVNBLE1BQVQsR0FBa0I7QUFDN0IsV0FBT1AsR0FBRyxDQUFDLENBQUosQ0FBUDtBQUNELEdBRkQ7O0FBSUEsTUFBSVEsWUFBWSxTQUFTQSxTQUFULEdBQXFCO0FBQ25DLFdBQU9SLEdBQUcsQ0FBSCxDQUFQO0FBQ0QsR0FGRDs7QUFJQSxNQUFJUyxnQkFBZ0IsQ0FBcEI7O0FBRUEsTUFBSUMsb0JBQW9CLFNBQVNBLGlCQUFULENBQTJCWCxLQUEzQixFQUFrQztBQUN4RFUscUJBQWlCVixLQUFqQjs7QUFFQSxRQUFJVSxrQkFBa0IsQ0FBdEIsRUFBeUI7QUFDdkIsT0FBQyxHQUFHM0MsVUFBVTU1QyxnQkFBZCxFQUFnQ1AsTUFBaEMsRUFBd0NxNkMsZUFBeEMsRUFBeUR3QixnQkFBekQ7QUFDRCxLQUZELE1BRU8sSUFBSWlCLGtCQUFrQixDQUF0QixFQUF5QjtBQUM5QixPQUFDLEdBQUczQyxVQUFVbnNCLG1CQUFkLEVBQW1DaHVCLE1BQW5DLEVBQTJDcTZDLGVBQTNDLEVBQTREd0IsZ0JBQTVEO0FBQ0Q7QUFDRixHQVJEOztBQVVBLE1BQUltQixZQUFZLEtBQWhCOztBQUVBLE1BQUlDLFFBQVEsU0FBU0EsS0FBVCxHQUFpQjtBQUMzQixRQUFJeGlCLFNBQVN2akMsVUFBVVQsTUFBVixHQUFtQixDQUFuQixJQUF3QlMsVUFBVSxDQUFWLE1BQWlCaUMsU0FBekMsR0FBcURqQyxVQUFVLENBQVYsQ0FBckQsR0FBb0UsS0FBakY7O0FBRUEsUUFBSWdtRCxVQUFVMUIsa0JBQWtCOWdCLFNBQWxCLENBQTRCRCxNQUE1QixDQUFkOztBQUVBLFFBQUksQ0FBQ3VpQixTQUFMLEVBQWdCO0FBQ2RELHdCQUFrQixDQUFsQjtBQUNBQyxrQkFBWSxJQUFaO0FBQ0Q7O0FBRUQsV0FBTyxZQUFZO0FBQ2pCLFVBQUlBLFNBQUosRUFBZTtBQUNiQSxvQkFBWSxLQUFaO0FBQ0FELDBCQUFrQixDQUFDLENBQW5CO0FBQ0Q7O0FBRUQsYUFBT0csU0FBUDtBQUNELEtBUEQ7QUFRRCxHQWxCRDs7QUFvQkEsTUFBSXZnQixTQUFTLFNBQVNBLE1BQVQsQ0FBZ0JoaUIsUUFBaEIsRUFBMEI7QUFDckMsUUFBSStoQixXQUFXOGUsa0JBQWtCMWdCLGNBQWxCLENBQWlDbmdCLFFBQWpDLENBQWY7QUFDQW9pQyxzQkFBa0IsQ0FBbEI7O0FBRUEsV0FBTyxZQUFZO0FBQ2pCQSx3QkFBa0IsQ0FBQyxDQUFuQjtBQUNBcmdCO0FBQ0QsS0FIRDtBQUlELEdBUkQ7O0FBVUEsTUFBSVYsVUFBVTtBQUNadmxDLFlBQVErakQsY0FBYy9qRCxNQURWO0FBRVp5WSxZQUFRLEtBRkk7QUFHWitRLGNBQVVxOEIsZUFIRTtBQUlaQyxnQkFBWUEsVUFKQTtBQUtabmxELFVBQU1BLElBTE07QUFNWnlDLGFBQVNBLE9BTkc7QUFPWndpRCxRQUFJQSxFQVBRO0FBUVpPLFlBQVFBLE1BUkk7QUFTWkMsZUFBV0EsU0FUQztBQVVaSSxXQUFPQSxLQVZLO0FBV1p0Z0IsWUFBUUE7QUFYSSxHQUFkOztBQWNBLFNBQU9YLE9BQVA7QUFDRCxDQWhRRDs7QUFrUUExbUMsUUFBUTJrQyxPQUFSLEdBQWtCcTRELGlCQUFsQixDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JDblVTMXhGLFk7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTVQ7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7Ozs7QUFUQSxJQUFJNjRCLFdBQVd2N0IsT0FBT08sTUFBUCxJQUFpQixVQUFVZSxNQUFWLEVBQWtCO0FBQUUsT0FBSyxJQUFJckksSUFBSSxDQUFiLEVBQWdCQSxJQUFJRCxVQUFVVCxNQUE5QixFQUFzQ1UsR0FBdEMsRUFBMkM7QUFBRSxRQUFJc0ksU0FBU3ZJLFVBQVVDLENBQVYsQ0FBYixDQUEyQixLQUFLLElBQUkySSxHQUFULElBQWdCTCxNQUFoQixFQUF3QjtBQUFFLFVBQUl2QixPQUFPM0csU0FBUCxDQUFpQjRGLGNBQWpCLENBQWdDbEgsSUFBaEMsQ0FBcUN3SixNQUFyQyxFQUE2Q0ssR0FBN0MsQ0FBSixFQUF1RDtBQUFFTixlQUFPTSxHQUFQLElBQWNMLE9BQU9LLEdBQVAsQ0FBZDtBQUE0QjtBQUFFO0FBQUUsR0FBQyxPQUFPTixNQUFQO0FBQWdCLENBQWhROztBQUVBLElBQUlxNkMsVUFBVSxPQUFPdHlDLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsU0FBT0EsT0FBT2s0QixRQUFkLE1BQTJCLFFBQTNELEdBQXNFLFVBQVV6RixHQUFWLEVBQWU7QUFBRSxnQkFBY0EsR0FBZCwwQ0FBY0EsR0FBZDtBQUFvQixDQUEzRyxHQUE4RyxVQUFVQSxHQUFWLEVBQWU7QUFBRSxTQUFPQSxPQUFPLE9BQU96eUIsTUFBUCxLQUFrQixVQUF6QixJQUF1Q3l5QixJQUFJdHNCLFdBQUosS0FBb0JuRyxNQUEzRCxJQUFxRXl5QixRQUFRenlCLE9BQU9oUSxTQUFwRixHQUFnRyxRQUFoRyxVQUFrSHlpQyxHQUFsSCwwQ0FBa0hBLEdBQWxILENBQVA7QUFBK0gsQ0FBNVE7O0FBRUEsU0FBUzBqQix3QkFBVCxDQUFrQzFqQixHQUFsQyxFQUF1QzE2QixJQUF2QyxFQUE2QztBQUFFLE1BQUlFLFNBQVMsRUFBYixDQUFpQixLQUFLLElBQUlySSxDQUFULElBQWM2aUMsR0FBZCxFQUFtQjtBQUFFLFFBQUkxNkIsS0FBSzlFLE9BQUwsQ0FBYXJELENBQWIsS0FBbUIsQ0FBdkIsRUFBMEIsU0FBVSxJQUFJLENBQUMrRyxPQUFPM0csU0FBUCxDQUFpQjRGLGNBQWpCLENBQWdDbEgsSUFBaEMsQ0FBcUMrakMsR0FBckMsRUFBMEM3aUMsQ0FBMUMsQ0FBTCxFQUFtRCxTQUFVcUksT0FBT3JJLENBQVAsSUFBWTZpQyxJQUFJN2lDLENBQUosQ0FBWjtBQUFxQixHQUFDLE9BQU9xSSxNQUFQO0FBQWdCOztBQU81Tjs7O0FBR0EsSUFBSWkrQyxVQUFVLFNBQVNBLE9BQVQsQ0FBaUJsRSxJQUFqQixFQUF1QjtBQUNuQyxNQUFJNTVDLEtBQUs0NUMsS0FBSzU1QyxFQUFkO0FBQUEsTUFDSXcrQixRQUFRb2IsS0FBS3BiLEtBRGpCO0FBQUEsTUFFSVAsU0FBUzJiLEtBQUszYixNQUZsQjtBQUFBLE1BR0kzZCxXQUFXczVCLEtBQUt0NUIsUUFIcEI7QUFBQSxNQUlJZ3pFLGtCQUFrQjE1QyxLQUFLMDVDLGVBSjNCO0FBQUEsTUFLSXI1QixZQUFZcmdCLEtBQUtxZ0IsU0FMckI7QUFBQSxNQU1JczVCLGNBQWMzNUMsS0FBSzI1QyxXQU52QjtBQUFBLE1BT0kzdEMsUUFBUWhNLEtBQUtnTSxLQVBqQjtBQUFBLE1BUUk0dEMsY0FBYzU1QyxLQUFLeGUsUUFSdkI7QUFBQSxNQVNJcTRELE9BQU8xMUMseUJBQXlCbkUsSUFBekIsRUFBK0IsQ0FBQyxJQUFELEVBQU8sT0FBUCxFQUFnQixRQUFoQixFQUEwQixVQUExQixFQUFzQyxpQkFBdEMsRUFBeUQsV0FBekQsRUFBc0UsYUFBdEUsRUFBcUYsT0FBckYsRUFBOEYsVUFBOUYsQ0FBL0IsQ0FUWDs7QUFXQSxTQUFPLGdCQUFNcjVDLGFBQU4scUJBQTJCO0FBQ2hDaWYsVUFBTSxDQUFDLE9BQU94ZixFQUFQLEtBQWMsV0FBZCxHQUE0QixXQUE1QixHQUEwQ2s2QyxRQUFRbDZDLEVBQVIsQ0FBM0MsTUFBNEQsUUFBNUQsR0FBdUVBLEdBQUdnZ0IsUUFBMUUsR0FBcUZoZ0IsRUFEM0Q7QUFFaEN3K0IsV0FBT0EsS0FGeUI7QUFHaENQLFlBQVFBLE1BSHdCO0FBSWhDM2QsY0FBVUEsUUFKc0I7QUFLaENuakIsY0FBVSxTQUFTQSxRQUFULENBQWtCMDhDLEtBQWxCLEVBQXlCO0FBQ2pDLFVBQUl2NUIsV0FBV3U1QixNQUFNdjVCLFFBQXJCO0FBQUEsVUFDSTZFLFFBQVEwMEIsTUFBTTEwQixLQURsQjs7QUFHQSxVQUFJaVcsV0FBVyxDQUFDLEVBQUVvNEQsY0FBY0EsWUFBWXJ1RSxLQUFaLEVBQW1CN0UsUUFBbkIsQ0FBZCxHQUE2QzZFLEtBQS9DLENBQWhCOztBQUVBLGFBQU8sZ0JBQU01a0IsYUFBTixpQkFBMEJ1NUIsU0FBUztBQUN4Qzk1QixZQUFJQSxFQURvQztBQUV4Q2k2RCxtQkFBVzcrQixXQUFXLENBQUNrNEQsZUFBRCxFQUFrQnI1QixTQUFsQixFQUE2QjUrQixNQUE3QixDQUFvQyxVQUFVN2pDLENBQVYsRUFBYTtBQUNyRSxpQkFBT0EsQ0FBUDtBQUNELFNBRnFCLEVBRW5COEgsSUFGbUIsQ0FFZCxHQUZjLENBQVgsR0FFSTI2RCxTQUp5QjtBQUt4Q3JVLGVBQU94cUIsV0FBV3RCLFNBQVMsRUFBVCxFQUFhOHJCLEtBQWIsRUFBb0IydEMsV0FBcEIsQ0FBWCxHQUE4QzN0QztBQUxiLE9BQVQsRUFNOUI2dEMsSUFOOEIsQ0FBMUIsQ0FBUDtBQU9EO0FBbEIrQixHQUEzQixDQUFQO0FBb0JELENBaENEOztBQWtDQTMxQyxRQUFRaHJCLFNBQVIsR0FBb0I7QUFDbEI5eUIsTUFBSSxlQUFLOHlCLFNBQUwsQ0FBZTl5QixFQUREO0FBRWxCdytCLFNBQU8sb0JBQVVxRCxJQUZDO0FBR2xCNUQsVUFBUSxvQkFBVTRELElBSEE7QUFJbEJ2aEIsWUFBVSxvQkFBVXZZLE1BSkY7QUFLbEJ1ckYsbUJBQWlCLG9CQUFVcnVFLE1BTFQ7QUFNbEJnMUMsYUFBVyxvQkFBVWgxQyxNQU5IO0FBT2xCc3VFLGVBQWEsb0JBQVV4ckYsTUFQTDtBQVFsQjY5QyxTQUFPLG9CQUFVNzlDLE1BUkM7QUFTbEJxekIsWUFBVSxvQkFBVXROO0FBVEYsQ0FBcEI7O0FBWUFnd0IsUUFBUWpxQyxZQUFSLEdBQXVCO0FBQ3JCeS9FLG1CQUFpQjtBQURJLENBQXZCOztrQkFJZXgxQyxPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JDaEVONThDLE07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQ0FBQyxROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkNBQUMsSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JDQUFDLE07Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQ0FBQyxZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkNBQUMsTTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0JDQUFDLFM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dCQ0FBQyxVOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBVDs7OztBQUNBOztBQUVBOzs7O0FBR0E7Ozs7Ozs7Ozs7OztBQUZBLElBQU1peUYsa0JBQWtCLCtCQUF4Qjs7SUFJcUJDLFk7Ozs7Ozs7Ozs7OzZCQUNWO0FBQ1AsVUFBTWpDLFlBQVksS0FBSzMrRSxLQUFMLENBQVcyK0UsU0FBWCxDQUFxQnR5RixHQUFyQixDQUF5QixVQUFDdzBGLE9BQUQsRUFBVUMsR0FBVixFQUFrQjtBQUMzRCxlQUFPO0FBQUE7QUFBQSxZQUFJLEtBQUtBLEdBQVQ7QUFDTDtBQUFBO0FBQUEsY0FBTSxrQkFBZ0JELFFBQVE5d0YsRUFBOUI7QUFDRTtBQUFBO0FBQUE7QUFBSzh3RixzQkFBUTk3RjtBQUFiLGFBREY7QUFFRTtBQUFBO0FBQUE7QUFBSTg3RixzQkFBUUU7QUFBWixhQUZGO0FBR0UsbURBQUssS0FBS0osZ0JBQWdCSyxTQUFoQixDQUEwQixHQUExQixFQUErQkgsUUFBUTl3RixFQUF2QyxFQUEyQ3E3RCxHQUFyRCxFQUEwRCxLQUFJLEVBQTlEO0FBSEY7QUFESyxTQUFQO0FBT0QsT0FSaUIsQ0FBbEI7QUFTQSxhQUNFO0FBQUE7QUFBQSxVQUFLLFdBQ0gsQ0FDRSxjQURGLEVBRUU3K0QsSUFGRixDQUVPLEdBRlAsQ0FERjtBQUtFLDBEQUFRLE1BQUssR0FBYixFQUFpQixNQUFNLEtBQUt5VCxLQUFMLENBQVdqYixLQUFsQyxHQUxGO0FBTUU7QUFBQTtBQUFBO0FBQ0c0NUY7QUFESDtBQU5GLE9BREY7QUFZRDs7OztFQXZCdUMsZ0JBQU05NkUsUzs7a0JBQTNCKzhFLFk7Ozs7Ozs7Ozs7Ozs7OztBQ1JyQjs7Ozs7Ozs7SUFFTUssZTtBQUNKLDZCQUFjO0FBQUE7O0FBQ1osU0FBS3RDLFNBQUwsR0FBaUIsa0JBQVFBLFNBQXpCO0FBQ0EsU0FBS0MsTUFBTCxHQUFjLGtCQUFRQSxNQUF0QjtBQUNBLFNBQUtDLElBQUwsR0FBWSxrQkFBUUEsSUFBcEI7QUFDRDs7OzsrQkFDVTl1RixFLEVBQUk7QUFDYixhQUFPLEtBQUs0dUYsU0FBTCxDQUFlcjJELE1BQWYsQ0FBc0IsbUJBQVM7QUFDcEMsZUFBT3U0RCxRQUFROXdGLEVBQVIsS0FBZUEsRUFBdEI7QUFDRCxPQUZNLEVBRUosQ0FGSSxDQUFQO0FBR0Q7Ozs2QkFDUUEsRSxFQUFJO0FBQ1gsYUFBTyxLQUFLNnVGLE1BQUwsQ0FBWXQyRCxNQUFaLENBQW1CLGlCQUFPO0FBQy9CLGVBQU80NEQsTUFBTW54RixFQUFOLEtBQWFBLEVBQXBCO0FBQ0QsT0FGTSxFQUVKLENBRkksQ0FBUDtBQUdEOzs7MkJBQ01BLEUsRUFBSTtBQUNULGFBQU8sS0FBSzh1RixJQUFMLENBQVV2MkQsTUFBVixDQUFpQixlQUFLO0FBQzNCLGVBQU82NEQsSUFBSXB4RixFQUFKLEtBQVdBLEVBQWxCO0FBQ0QsT0FGTSxFQUVKLENBRkksQ0FBUDtBQUdEOzs7OEJBQ1NvQixJLEVBQU1wQixFLEVBQUk7QUFDbEIsYUFBTyxLQUFLOHVGLElBQUwsQ0FBVXYyRCxNQUFWLENBQWlCLFVBQUM2NEQsR0FBRCxFQUFPO0FBQzdCLGVBQU9BLElBQUlod0YsSUFBSixLQUFhQSxJQUFiLElBQXFCZ3dGLElBQUlDLEdBQUosS0FBWXJ4RixFQUF4QztBQUNELE9BRk0sRUFFSixDQUZJLENBQVA7QUFHRDs7Ozs7O2tCQUdZa3hGLGU7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5QmY7Ozs7Ozs7Ozs7OztJQUVxQkksTTs7O0FBQ25CLGtCQUFZcmhGLEtBQVosRUFBbUI7QUFBQTs7QUFBQSxnSEFDWEEsS0FEVzs7QUFFakIsVUFBS3duQixLQUFMLEdBQWE7QUFDWDYyRCxlQUFTO0FBREUsS0FBYjtBQUZpQjtBQUtsQjs7Ozt3Q0FDbUI7QUFDbEIsV0FBS24wRCxRQUFMLENBQWM7QUFDVm0wRCxpQkFBUztBQURDLE9BQWQ7QUFHRDs7OzJDQUNzQjtBQUNyQixXQUFLbjBELFFBQUwsQ0FBYztBQUNWbTBELGlCQUFTO0FBREMsT0FBZDtBQUdEOzs7NkJBQ1E7QUFBQTs7QUFDUCxVQUFNaUQsa0JBQWdCLEtBQUt0aEYsS0FBTCxDQUFXN08sSUFBakM7QUFDQSxhQUNFO0FBQUMsaUJBQUQ7QUFBQTtBQUNFLHFCQUFPLENBQ0wsUUFESyxFQUVMNUUsSUFGSyxDQUVBLEdBRkEsQ0FEVDtBQUlFLGVBQUssYUFBQzlDLFNBQUQsRUFBZTtBQUFDLG1CQUFLNm1ELE1BQUwsR0FBYzdtRCxTQUFkO0FBQXdCO0FBSi9DO0FBTUcsYUFBS3VXLEtBQUwsQ0FBVzlOO0FBTmQsT0FERjtBQVVEOzs7O0VBN0JpQyxnQkFBTTJSLFM7O2tCQUFyQnc5RSxNOzs7Ozs7QUNGckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDLEM7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBdUMsY0FBYyxlQUFlLDJCQUEyQixHQUFHLFFBQVEsdUJBQXVCLEdBQUcsZ0JBQWdCLGlCQUFpQixHQUFHLGNBQWMsNkJBQTZCLCtDQUF3RCxpUUFBc1Msd0JBQXdCLHVCQUF1QixHQUFHLGNBQWMsa0NBQWtDLCtDQUE0RCxzUUFBMlQsd0JBQXdCLHVCQUF1QixHQUFHLGNBQWMsa0NBQWtDLDBDQUEwQyxpSUFBaUksd0JBQXdCLHVCQUF1QixHQUFHLGNBQWMsMEJBQTBCLDhJQUE4SSx3QkFBd0IsdUJBQXVCLEdBQUcsYUFBYSxrQkFBa0Isd0JBQXdCLDRCQUE0QixnQ0FBZ0MsR0FBRyxpQkFBaUIsc0JBQXNCLEdBQUcsZUFBZSxlQUFlLGdCQUFnQiwyQkFBMkIsR0FBRyx1QkFBdUIsa0JBQWtCLHdCQUF3Qiw0QkFBNEIsR0FBRyxxQkFBcUIsZ0JBQWdCLHVCQUF1QixHQUFHLGtCQUFrQiw2Q0FBNkMsbUJBQW1CLEdBQUcsc0JBQXNCLDBCQUEwQixlQUFlLEdBQUc7O0FBRW5sRTs7Ozs7OztBQ1BBO0FBQ0E7OztBQUdBO0FBQ0Esd1hBQXlYLHNCQUFzQix1Q0FBdUMsMkNBQTJDLFdBQVcsNEtBQTRLLGNBQWMsR0FBRyx5R0FBeUcsbUJBQW1CLEdBQUcsc0pBQXNKLG1CQUFtQixxQkFBcUIsR0FBRyxpT0FBaU8sMkJBQTJCLEdBQUcsNERBQTRELHFCQUFxQixHQUFHLDJHQUEyRyw0QkFBNEIsc0JBQXNCLDhCQUE4QixXQUFXLHVKQUF1SixzQ0FBc0MsMkJBQTJCLFdBQVcsMlBBQTJQLGtDQUFrQyxrREFBa0QsV0FBVywyS0FBMkssd0JBQXdCLHVDQUF1Qyw4Q0FBOEMsV0FBVyw0R0FBNEcseUJBQXlCLEdBQUcseUZBQXlGLHdCQUF3QixHQUFHLHFLQUFxSyxzQ0FBc0MsMkJBQTJCLFdBQVcscUVBQXFFLHVCQUF1QixHQUFHLHlFQUF5RSwyQkFBMkIsZ0JBQWdCLEdBQUcsc0VBQXNFLG1CQUFtQixHQUFHLG9IQUFvSCxtQkFBbUIsbUJBQW1CLHVCQUF1Qiw2QkFBNkIsR0FBRyxTQUFTLG9CQUFvQixHQUFHLFNBQVMsZ0JBQWdCLEdBQUcsOEtBQThLLDBCQUEwQixHQUFHLCtFQUErRSxrQkFBa0IsY0FBYyxHQUFHLDZFQUE2RSx1QkFBdUIsR0FBRyw2REFBNkQscUJBQXFCLEdBQUcsMFFBQTBRLDRCQUE0Qiw0QkFBNEIsOEJBQThCLHNCQUFzQixXQUFXLCtGQUErRiw4QkFBOEIsR0FBRyxvS0FBb0ssaUNBQWlDLEdBQUcsaVJBQWlSLCtCQUErQixXQUFXLCtNQUErTSx1QkFBdUIsZUFBZSxHQUFHLHdNQUF3TSxtQ0FBbUMsR0FBRyw4REFBOEQsbUNBQW1DLEdBQUcsd1FBQXdRLDJCQUEyQiwyQkFBMkIsMkJBQTJCLDRCQUE0Qix1QkFBdUIsZ0NBQWdDLFdBQVcsNElBQTRJLDBCQUEwQixxQ0FBcUMsV0FBVywyRUFBMkUsbUJBQW1CLEdBQUcsMElBQTBJLDJCQUEyQix1QkFBdUIsV0FBVyx3TEFBd0wsaUJBQWlCLEdBQUcsdUlBQXVJLGtDQUFrQyxpQ0FBaUMsV0FBVywrTEFBK0wsNkJBQTZCLEdBQUcsNktBQTZLLCtCQUErQiwwQkFBMEIsV0FBVywwT0FBME8sbUJBQW1CLEdBQUcscUVBQXFFLHVCQUF1QixHQUFHLGdLQUFnSywwQkFBMEIsR0FBRyw2REFBNkQsa0JBQWtCLEdBQUcsZ0tBQWdLLGtCQUFrQixHQUFHOztBQUU5aFE7Ozs7Ozs7QUNQQSw2Q0FBNkMsd244RTs7Ozs7O0FDQTdDLGdEQUFnRCxvaDhFOzs7Ozs7QUNBaEQsaUU7Ozs7OztBQ0FBLDZDQUE2QyxnM29DOzs7Ozs7QUNBN0MsZ0RBQWdELGdpNEQ7Ozs7OztBQ0FoRCxxRTs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBLFFBQVEsdUJBQXVCO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxnQ0FBZ0Msc0JBQXNCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTAyKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAxODIyMTZlZjE4MTY0YWJmYTE3YSIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgdmFsaWRhdGVGb3JtYXQoZm9ybWF0KTtcblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKCdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICsgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSkpO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ludmFyaWFudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG5mdW5jdGlvbiByZWFjdFByb2RJbnZhcmlhbnQoY29kZSkge1xuICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTtcblxuICB2YXIgbWVzc2FnZSA9ICdNaW5pZmllZCBSZWFjdCBlcnJvciAjJyArIGNvZGUgKyAnOyB2aXNpdCAnICsgJ2h0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PScgKyBjb2RlO1xuXG4gIGZvciAodmFyIGFyZ0lkeCA9IDA7IGFyZ0lkeCA8IGFyZ0NvdW50OyBhcmdJZHgrKykge1xuICAgIG1lc3NhZ2UgKz0gJyZhcmdzW109JyArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbYXJnSWR4ICsgMV0pO1xuICB9XG5cbiAgbWVzc2FnZSArPSAnIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCcgKyAnIGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLic7XG5cbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgcmVhY3RQcm9kSW52YXJpYW50J3Mgb3duIGZyYW1lXG5cbiAgdGhyb3cgZXJyb3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3RQcm9kSW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIEFUVFJfTkFNRSA9IERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FO1xudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcblxudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gbm9kZSBzaG91bGQgYmUgY2FjaGVkLlxuICovXG5mdW5jdGlvbiBzaG91bGRQcmVjYWNoZU5vZGUobm9kZSwgbm9kZUlEKSB7XG4gIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAxICYmIG5vZGUuZ2V0QXR0cmlidXRlKEFUVFJfTkFNRSkgPT09IFN0cmluZyhub2RlSUQpIHx8IG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgcmVhY3QtdGV4dDogJyArIG5vZGVJRCArICcgJyB8fCBub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LWVtcHR5OiAnICsgbm9kZUlEICsgJyAnO1xufVxuXG4vKipcbiAqIERyaWxsIGRvd24gKHRocm91Z2ggY29tcG9zaXRlcyBhbmQgZW1wdHkgY29tcG9uZW50cykgdW50aWwgd2UgZ2V0IGEgaG9zdCBvclxuICogaG9zdCB0ZXh0IGNvbXBvbmVudC5cbiAqXG4gKiBUaGlzIGlzIHByZXR0eSBwb2x5bW9ycGhpYyBidXQgdW5hdm9pZGFibGUgd2l0aCB0aGUgY3VycmVudCBzdHJ1Y3R1cmUgd2UgaGF2ZVxuICogZm9yIGBfcmVuZGVyZWRDaGlsZHJlbmAuXG4gKi9cbmZ1bmN0aW9uIGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoY29tcG9uZW50KSB7XG4gIHZhciByZW5kZXJlZDtcbiAgd2hpbGUgKHJlbmRlcmVkID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudCA9IHJlbmRlcmVkO1xuICB9XG4gIHJldHVybiBjb21wb25lbnQ7XG59XG5cbi8qKlxuICogUG9wdWxhdGUgYF9ob3N0Tm9kZWAgb24gdGhlIHJlbmRlcmVkIGhvc3QvdGV4dCBjb21wb25lbnQgd2l0aCB0aGUgZ2l2ZW5cbiAqIERPTSBub2RlLiBUaGUgcGFzc2VkIGBpbnN0YCBjYW4gYmUgYSBjb21wb3NpdGUuXG4gKi9cbmZ1bmN0aW9uIHByZWNhY2hlTm9kZShpbnN0LCBub2RlKSB7XG4gIHZhciBob3N0SW5zdCA9IGdldFJlbmRlcmVkSG9zdE9yVGV4dEZyb21Db21wb25lbnQoaW5zdCk7XG4gIGhvc3RJbnN0Ll9ob3N0Tm9kZSA9IG5vZGU7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuZnVuY3Rpb24gdW5jYWNoZU5vZGUoaW5zdCkge1xuICB2YXIgbm9kZSA9IGluc3QuX2hvc3ROb2RlO1xuICBpZiAobm9kZSkge1xuICAgIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICAgIGluc3QuX2hvc3ROb2RlID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIGBfaG9zdE5vZGVgIG9uIGVhY2ggY2hpbGQgb2YgYGluc3RgLCBhc3N1bWluZyB0aGF0IHRoZSBjaGlsZHJlblxuICogbWF0Y2ggdXAgd2l0aCB0aGUgRE9NIChlbGVtZW50KSBjaGlsZHJlbiBvZiBgbm9kZWAuXG4gKlxuICogV2UgY2FjaGUgZW50aXJlIGxldmVscyBhdCBvbmNlIHRvIGF2b2lkIGFuIG5eMiBwcm9ibGVtIHdoZXJlIHdlIGFjY2VzcyB0aGVcbiAqIGNoaWxkcmVuIG9mIGEgbm9kZSBzZXF1ZW50aWFsbHkgYW5kIGhhdmUgdG8gd2FsayBmcm9tIHRoZSBzdGFydCB0byBvdXIgdGFyZ2V0XG4gKiBub2RlIGV2ZXJ5IHRpbWUuXG4gKlxuICogU2luY2Ugd2UgdXBkYXRlIGBfcmVuZGVyZWRDaGlsZHJlbmAgYW5kIHRoZSBhY3R1YWwgRE9NIGF0IChzbGlnaHRseSlcbiAqIGRpZmZlcmVudCB0aW1lcywgd2UgY291bGQgcmFjZSBoZXJlIGFuZCBzZWUgYSBuZXdlciBgX3JlbmRlcmVkQ2hpbGRyZW5gIHRoYW5cbiAqIHRoZSBET00gbm9kZXMgd2Ugc2VlLiBUbyBhdm9pZCB0aGlzLCBSZWFjdE11bHRpQ2hpbGQgY2FsbHNcbiAqIGBwcmVwYXJlVG9NYW5hZ2VDaGlsZHJlbmAgYmVmb3JlIHdlIGNoYW5nZSBgX3JlbmRlcmVkQ2hpbGRyZW5gLCBhdCB3aGljaFxuICogdGltZSB0aGUgY29udGFpbmVyJ3MgY2hpbGQgbm9kZXMgYXJlIGFsd2F5cyBjYWNoZWQgKHVudGlsIGl0IHVubW91bnRzKS5cbiAqL1xuZnVuY3Rpb24gcHJlY2FjaGVDaGlsZE5vZGVzKGluc3QsIG5vZGUpIHtcbiAgaWYgKGluc3QuX2ZsYWdzICYgRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2Rlcykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBpbnN0Ll9yZW5kZXJlZENoaWxkcmVuO1xuICB2YXIgY2hpbGROb2RlID0gbm9kZS5maXJzdENoaWxkO1xuICBvdXRlcjogZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgIGlmICghY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgY2hpbGRJbnN0ID0gY2hpbGRyZW5bbmFtZV07XG4gICAgdmFyIGNoaWxkSUQgPSBnZXRSZW5kZXJlZEhvc3RPclRleHRGcm9tQ29tcG9uZW50KGNoaWxkSW5zdCkuX2RvbUlEO1xuICAgIGlmIChjaGlsZElEID09PSAwKSB7XG4gICAgICAvLyBXZSdyZSBjdXJyZW50bHkgdW5tb3VudGluZyB0aGlzIGNoaWxkIGluIFJlYWN0TXVsdGlDaGlsZDsgc2tpcCBpdC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBXZSBhc3N1bWUgdGhlIGNoaWxkIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgY2hpbGQgaW5zdGFuY2VzLlxuICAgIGZvciAoOyBjaGlsZE5vZGUgIT09IG51bGw7IGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZykge1xuICAgICAgaWYgKHNob3VsZFByZWNhY2hlTm9kZShjaGlsZE5vZGUsIGNoaWxkSUQpKSB7XG4gICAgICAgIHByZWNhY2hlTm9kZShjaGlsZEluc3QsIGNoaWxkTm9kZSk7XG4gICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIERPTSBjaGlsZHJlbiB3aXRob3V0IGZpbmRpbmcgYW4gSUQgbWF0Y2guXG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIGVsZW1lbnQgd2l0aCBJRCAlcy4nLCBjaGlsZElEKSA6IF9wcm9kSW52YXJpYW50KCczMicsIGNoaWxkSUQpIDogdm9pZCAwO1xuICB9XG4gIGluc3QuX2ZsYWdzIHw9IEZsYWdzLmhhc0NhY2hlZENoaWxkTm9kZXM7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBpbnN0YW5jZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY2xvc2VzdDtcbiAgdmFyIGluc3Q7XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gICAgaWYgKHBhcmVudHMubGVuZ3RoKSB7XG4gICAgICBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgbm9kZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKSB7XG4gIHZhciBpbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gIGlmIChpbnN0ICE9IG51bGwgJiYgaW5zdC5faG9zdE5vZGUgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3RET01Db21wb25lbnQgb3IgUmVhY3RET01UZXh0Q29tcG9uZW50LCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmdcbiAqIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIHtcbiAgLy8gV2l0aG91dCB0aGlzIGZpcnN0IGludmFyaWFudCwgcGFzc2luZyBhIG5vbi1ET00tY29tcG9uZW50IHRyaWdnZXJzIHRoZSBuZXh0XG4gIC8vIGludmFyaWFudCBmb3IgYSBtaXNzaW5nIHBhcmVudCwgd2hpY2ggaXMgc3VwZXIgY29uZnVzaW5nLlxuICAhKGluc3QuX2hvc3ROb2RlICE9PSB1bmRlZmluZWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcblxuICBpZiAoaW5zdC5faG9zdE5vZGUpIHtcbiAgICByZXR1cm4gaW5zdC5faG9zdE5vZGU7XG4gIH1cblxuICAvLyBXYWxrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYW4gYW5jZXN0b3Igd2hvc2UgRE9NIG5vZGUgd2UgaGF2ZSBjYWNoZWQuXG4gIHZhciBwYXJlbnRzID0gW107XG4gIHdoaWxlICghaW5zdC5faG9zdE5vZGUpIHtcbiAgICBwYXJlbnRzLnB1c2goaW5zdCk7XG4gICAgIWluc3QuX2hvc3RQYXJlbnQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgRE9NIHRyZWUgcm9vdCBzaG91bGQgYWx3YXlzIGhhdmUgYSBub2RlIHJlZmVyZW5jZS4nKSA6IF9wcm9kSW52YXJpYW50KCczNCcpIDogdm9pZCAwO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG5cbiAgLy8gTm93IHBhcmVudHMgY29udGFpbnMgZWFjaCBhbmNlc3RvciB0aGF0IGRvZXMgKm5vdCogaGF2ZSBhIGNhY2hlZCBuYXRpdmVcbiAgLy8gbm9kZSwgYW5kIGBpbnN0YCBpcyB0aGUgZGVlcGVzdCBhbmNlc3RvciB0aGF0IGRvZXMuXG4gIGZvciAoOyBwYXJlbnRzLmxlbmd0aDsgaW5zdCA9IHBhcmVudHMucG9wKCkpIHtcbiAgICBwcmVjYWNoZUNoaWxkTm9kZXMoaW5zdCwgaW5zdC5faG9zdE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGluc3QuX2hvc3ROb2RlO1xufVxuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0ge1xuICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGdldEluc3RhbmNlRnJvbU5vZGUsXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UsXG4gIHByZWNhY2hlQ2hpbGROb2RlczogcHJlY2FjaGVDaGlsZE5vZGVzLFxuICBwcmVjYWNoZU5vZGU6IHByZWNhY2hlTm9kZSxcbiAgdW5jYWNoZU5vZGU6IHVuY2FjaGVOb2RlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUNvbXBvbmVudFRyZWUuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9yZWFjdC5qcyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiaW1wb3J0IF9NZW1vcnlSb3V0ZXIgZnJvbSAnLi9NZW1vcnlSb3V0ZXInO1xuZXhwb3J0IHsgX01lbW9yeVJvdXRlciBhcyBNZW1vcnlSb3V0ZXIgfTtcbmltcG9ydCBfUHJvbXB0IGZyb20gJy4vUHJvbXB0JztcbmV4cG9ydCB7IF9Qcm9tcHQgYXMgUHJvbXB0IH07XG5pbXBvcnQgX1JlZGlyZWN0IGZyb20gJy4vUmVkaXJlY3QnO1xuZXhwb3J0IHsgX1JlZGlyZWN0IGFzIFJlZGlyZWN0IH07XG5pbXBvcnQgX1JvdXRlIGZyb20gJy4vUm91dGUnO1xuZXhwb3J0IHsgX1JvdXRlIGFzIFJvdXRlIH07XG5pbXBvcnQgX1JvdXRlciBmcm9tICcuL1JvdXRlcic7XG5leHBvcnQgeyBfUm91dGVyIGFzIFJvdXRlciB9O1xuaW1wb3J0IF9TdGF0aWNSb3V0ZXIgZnJvbSAnLi9TdGF0aWNSb3V0ZXInO1xuZXhwb3J0IHsgX1N0YXRpY1JvdXRlciBhcyBTdGF0aWNSb3V0ZXIgfTtcbmltcG9ydCBfU3dpdGNoIGZyb20gJy4vU3dpdGNoJztcbmV4cG9ydCB7IF9Td2l0Y2ggYXMgU3dpdGNoIH07XG5pbXBvcnQgX21hdGNoUGF0aCBmcm9tICcuL21hdGNoUGF0aCc7XG5leHBvcnQgeyBfbWF0Y2hQYXRoIGFzIG1hdGNoUGF0aCB9O1xuaW1wb3J0IF93aXRoUm91dGVyIGZyb20gJy4vd2l0aFJvdXRlcic7XG5leHBvcnQgeyBfd2l0aFJvdXRlciBhcyB3aXRoUm91dGVyIH07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gaXNOYXRpdmUoZm4pIHtcbiAgLy8gQmFzZWQgb24gaXNOYXRpdmUoKSBmcm9tIExvZGFzaFxuICB2YXIgZnVuY1RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgKyBmdW5jVG9TdHJpbmdcbiAgLy8gVGFrZSBhbiBleGFtcGxlIG5hdGl2ZSBmdW5jdGlvbiBzb3VyY2UgZm9yIGNvbXBhcmlzb25cbiAgLmNhbGwoaGFzT3duUHJvcGVydHlcbiAgLy8gU3RyaXAgcmVnZXggY2hhcmFjdGVycyBzbyB3ZSBjYW4gdXNlIGl0IGZvciByZWdleFxuICApLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJ1xuICAvLyBSZW1vdmUgaGFzT3duUHJvcGVydHkgZnJvbSB0aGUgdGVtcGxhdGUgdG8gbWFrZSBpdCBnZW5lcmljXG4gICkucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCcpO1xuICB0cnkge1xuICAgIHZhciBzb3VyY2UgPSBmdW5jVG9TdHJpbmcuY2FsbChmbik7XG4gICAgcmV0dXJuIHJlSXNOYXRpdmUudGVzdChzb3VyY2UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxudmFyIGNhblVzZUNvbGxlY3Rpb25zID1cbi8vIEFycmF5LmZyb21cbnR5cGVvZiBBcnJheS5mcm9tID09PSAnZnVuY3Rpb24nICYmXG4vLyBNYXBcbnR5cGVvZiBNYXAgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoTWFwKSAmJlxuLy8gTWFwLnByb3RvdHlwZS5rZXlzXG5NYXAucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIE1hcC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXAucHJvdG90eXBlLmtleXMpICYmXG4vLyBTZXRcbnR5cGVvZiBTZXQgPT09ICdmdW5jdGlvbicgJiYgaXNOYXRpdmUoU2V0KSAmJlxuLy8gU2V0LnByb3RvdHlwZS5rZXlzXG5TZXQucHJvdG90eXBlICE9IG51bGwgJiYgdHlwZW9mIFNldC5wcm90b3R5cGUua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQucHJvdG90eXBlLmtleXMpO1xuXG52YXIgc2V0SXRlbTtcbnZhciBnZXRJdGVtO1xudmFyIHJlbW92ZUl0ZW07XG52YXIgZ2V0SXRlbUlEcztcbnZhciBhZGRSb290O1xudmFyIHJlbW92ZVJvb3Q7XG52YXIgZ2V0Um9vdElEcztcblxuaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gIHZhciBpdGVtTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgcm9vdElEU2V0ID0gbmV3IFNldCgpO1xuXG4gIHNldEl0ZW0gPSBmdW5jdGlvbiAoaWQsIGl0ZW0pIHtcbiAgICBpdGVtTWFwLnNldChpZCwgaXRlbSk7XG4gIH07XG4gIGdldEl0ZW0gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaXRlbU1hcC5nZXQoaWQpO1xuICB9O1xuICByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgaXRlbU1hcFsnZGVsZXRlJ10oaWQpO1xuICB9O1xuICBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1NYXAua2V5cygpKTtcbiAgfTtcblxuICBhZGRSb290ID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgcm9vdElEU2V0LmFkZChpZCk7XG4gIH07XG4gIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByb290SURTZXRbJ2RlbGV0ZSddKGlkKTtcbiAgfTtcbiAgZ2V0Um9vdElEcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShyb290SURTZXQua2V5cygpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBpdGVtQnlLZXkgPSB7fTtcbiAgdmFyIHJvb3RCeUtleSA9IHt9O1xuXG4gIC8vIFVzZSBub24tbnVtZXJpYyBrZXlzIHRvIHByZXZlbnQgVjggcGVyZm9ybWFuY2UgaXNzdWVzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG4gIHZhciBnZXRLZXlGcm9tSUQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gJy4nICsgaWQ7XG4gIH07XG4gIHZhciBnZXRJREZyb21LZXkgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGtleS5zdWJzdHIoMSksIDEwKTtcbiAgfTtcblxuICBzZXRJdGVtID0gZnVuY3Rpb24gKGlkLCBpdGVtKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgaXRlbUJ5S2V5W2tleV0gPSBpdGVtO1xuICB9O1xuICBnZXRJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgcmV0dXJuIGl0ZW1CeUtleVtrZXldO1xuICB9O1xuICByZW1vdmVJdGVtID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGtleSA9IGdldEtleUZyb21JRChpZCk7XG4gICAgZGVsZXRlIGl0ZW1CeUtleVtrZXldO1xuICB9O1xuICBnZXRJdGVtSURzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhpdGVtQnlLZXkpLm1hcChnZXRJREZyb21LZXkpO1xuICB9O1xuXG4gIGFkZFJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByb290QnlLZXlba2V5XSA9IHRydWU7XG4gIH07XG4gIHJlbW92ZVJvb3QgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgcm9vdEJ5S2V5W2tleV07XG4gIH07XG4gIGdldFJvb3RJRHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3RCeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH07XG59XG5cbnZhciB1bm1vdW50ZWRJRHMgPSBbXTtcblxuZnVuY3Rpb24gcHVyZ2VEZWVwKGlkKSB7XG4gIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gIGlmIChpdGVtKSB7XG4gICAgdmFyIGNoaWxkSURzID0gaXRlbS5jaGlsZElEcztcblxuICAgIHJlbW92ZUl0ZW0oaWQpO1xuICAgIGNoaWxkSURzLmZvckVhY2gocHVyZ2VEZWVwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiAnI2VtcHR5JztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuICcjdGV4dCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ1Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlSUQoaWQpIHtcbiAgdmFyIG5hbWUgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKTtcbiAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcklEKSB7XG4gICAgb3duZXJOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShvd25lcklEKTtcbiAgfVxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50LCAnUmVhY3RDb21wb25lbnRUcmVlSG9vazogTWlzc2luZyBSZWFjdCBlbGVtZW50IGZvciBkZWJ1Z0lEICVzIHdoZW4gJyArICdidWlsZGluZyBzdGFjaycsIGlkKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgZWxlbWVudCAmJiBlbGVtZW50Ll9zb3VyY2UsIG93bmVyTmFtZSk7XG59XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0ge1xuICBvblNldENoaWxkcmVuOiBmdW5jdGlvbiAoaWQsIG5leHRDaGlsZElEcykge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgIWl0ZW0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSXRlbSBtdXN0IGhhdmUgYmVlbiBzZXQnKSA6IF9wcm9kSW52YXJpYW50KCcxNDQnKSA6IHZvaWQgMDtcbiAgICBpdGVtLmNoaWxkSURzID0gbmV4dENoaWxkSURzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Q2hpbGRJRHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRJRCA9IG5leHRDaGlsZElEc1tpXTtcbiAgICAgIHZhciBuZXh0Q2hpbGQgPSBnZXRJdGVtKG5leHRDaGlsZElEKTtcbiAgICAgICFuZXh0Q2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9vayBldmVudHMgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDAnKSA6IHZvaWQgMDtcbiAgICAgICEobmV4dENoaWxkLmNoaWxkSURzICE9IG51bGwgfHwgdHlwZW9mIG5leHRDaGlsZC5lbGVtZW50ICE9PSAnb2JqZWN0JyB8fCBuZXh0Q2hpbGQuZWxlbWVudCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvblNldENoaWxkcmVuKCkgdG8gZmlyZSBmb3IgYSBjb250YWluZXIgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MScpIDogdm9pZCAwO1xuICAgICAgIW5leHRDaGlsZC5pc01vdW50ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25Nb3VudENvbXBvbmVudCgpIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnNzEnKSA6IHZvaWQgMDtcbiAgICAgIGlmIChuZXh0Q2hpbGQucGFyZW50SUQgPT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGQucGFyZW50SUQgPSBpZDtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IGJ1dCBtb3VudGluZyBhIG5ldyByb290IGR1cmluZyBpblxuICAgICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgY3VycmVudGx5IGNhdXNlcyBub3QteWV0LW1vdW50ZWQgY29tcG9uZW50cyB0b1xuICAgICAgICAvLyBiZSBwdXJnZWQgZnJvbSBvdXIgdHJlZSBkYXRhIHNvIHRoZWlyIHBhcmVudCBpZCBpcyBtaXNzaW5nLlxuICAgICAgfVxuICAgICAgIShuZXh0Q2hpbGQucGFyZW50SUQgPT09IGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbkJlZm9yZU1vdW50Q29tcG9uZW50KCkgcGFyZW50IGFuZCBvblNldENoaWxkcmVuKCkgdG8gYmUgY29uc2lzdGVudCAoJXMgaGFzIHBhcmVudHMgJXMgYW5kICVzKS4nLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiBfcHJvZEludmFyaWFudCgnMTQyJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBwYXJlbnRJRCkge1xuICAgIHZhciBpdGVtID0ge1xuICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICAgIHRleHQ6IG51bGwsXG4gICAgICBjaGlsZElEczogW10sXG4gICAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgICAgdXBkYXRlQ291bnQ6IDBcbiAgICB9O1xuICAgIHNldEl0ZW0oaWQsIGl0ZW0pO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50KSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0uZWxlbWVudCA9IGVsZW1lbnQ7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgIWl0ZW0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSXRlbSBtdXN0IGhhdmUgYmVlbiBzZXQnKSA6IF9wcm9kSW52YXJpYW50KCcxNDQnKSA6IHZvaWQgMDtcbiAgICBpdGVtLmlzTW91bnRlZCA9IHRydWU7XG4gICAgdmFyIGlzUm9vdCA9IGl0ZW0ucGFyZW50SUQgPT09IDA7XG4gICAgaWYgKGlzUm9vdCkge1xuICAgICAgYWRkUm9vdChpZCk7XG4gICAgfVxuICB9LFxuICBvblVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uaXNNb3VudGVkKSB7XG4gICAgICAvLyBXZSBtYXkgZW5kIHVwIGhlcmUgYXMgYSByZXN1bHQgb2Ygc2V0U3RhdGUoKSBpbiBjb21wb25lbnRXaWxsVW5tb3VudCgpLlxuICAgICAgLy8gSW4gdGhpcyBjYXNlLCBpZ25vcmUgdGhlIGVsZW1lbnQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGl0ZW0udXBkYXRlQ291bnQrKztcbiAgfSxcbiAgb25Vbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIGl0IGV4aXN0cy5cbiAgICAgIC8vIGBpdGVtYCBtaWdodCBub3QgZXhpc3QgaWYgaXQgaXMgaW5zaWRlIGFuIGVycm9yIGJvdW5kYXJ5LCBhbmQgYSBzaWJsaW5nXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSBjaGlsZCB0aHJldyB3aGlsZSBtb3VudGluZy4gVGhlbiB0aGlzIGluc3RhbmNlIG5ldmVyXG4gICAgICAvLyBnb3QgYSBjaGFuY2UgdG8gbW91bnQsIGJ1dCBpdCBzdGlsbCBnZXRzIGFuIHVubW91bnRpbmcgZXZlbnQgZHVyaW5nXG4gICAgICAvLyB0aGUgZXJyb3IgYm91bmRhcnkgY2xlYW51cC5cbiAgICAgIGl0ZW0uaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgcmVtb3ZlUm9vdChpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5wdXNoKGlkKTtcbiAgfSxcbiAgcHVyZ2VVbm1vdW50ZWRDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0Q29tcG9uZW50VHJlZUhvb2suX3ByZXZlbnRQdXJnaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0aW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5tb3VudGVkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSB1bm1vdW50ZWRJRHNbaV07XG4gICAgICBwdXJnZURlZXAoaWQpO1xuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5pc01vdW50ZWQgOiBmYWxzZTtcbiAgfSxcbiAgZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW06IGZ1bmN0aW9uICh0b3BFbGVtZW50KSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICBpZiAodG9wRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZSh0b3BFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IHRvcEVsZW1lbnQuX293bmVyO1xuICAgICAgaW5mbyArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIHRvcEVsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudE93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB2YXIgaWQgPSBjdXJyZW50T3duZXIgJiYgY3VycmVudE93bmVyLl9kZWJ1Z0lEO1xuXG4gICAgaW5mbyArPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGlkKTtcbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0U3RhY2tBZGRlbmR1bUJ5SUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgd2hpbGUgKGlkKSB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlSUQoaWQpO1xuICAgICAgaWQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm87XG4gIH0sXG4gIGdldENoaWxkSURzOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldEl0ZW0oaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5jaGlsZElEcyA6IFtdO1xuICB9LFxuICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShlbGVtZW50KTtcbiAgfSxcbiAgZ2V0RWxlbWVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gIH0sXG4gIGdldE93bmVySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuX293bmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQuX293bmVyLl9kZWJ1Z0lEO1xuICB9LFxuICBnZXRQYXJlbnRJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXRJdGVtKGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0ucGFyZW50SUQgOiBudWxsO1xuICB9LFxuICBnZXRTb3VyY2U6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgdmFyIGVsZW1lbnQgPSBpdGVtID8gaXRlbS5lbGVtZW50IDogbnVsbDtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudCAhPSBudWxsID8gZWxlbWVudC5fc291cmNlIDogbnVsbDtcbiAgICByZXR1cm4gc291cmNlO1xuICB9LFxuICBnZXRUZXh0OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiAnJyArIGVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbiAgZ2V0VXBkYXRlQ291bnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0SXRlbShpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnVwZGF0ZUNvdW50IDogMDtcbiAgfSxcblxuXG4gIGdldFJvb3RJRHM6IGdldFJvb3RJRHMsXG4gIGdldFJlZ2lzdGVyZWRJRHM6IGdldEl0ZW1JRHMsXG5cbiAgcHVzaE5vblN0YW5kYXJkV2FybmluZ1N0YWNrOiBmdW5jdGlvbiAoaXNDcmVhdGluZ0VsZW1lbnQsIGN1cnJlbnRTb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUucmVhY3RTdGFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBjdXJyZW50T3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIHZhciBpZCA9IGN1cnJlbnRPd25lciAmJiBjdXJyZW50T3duZXIuX2RlYnVnSUQ7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGlzQ3JlYXRpbmdFbGVtZW50KSB7XG4gICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgIG5hbWU6IGlkID8gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCkgOiBudWxsLFxuICAgICAgICAgIGZpbGVOYW1lOiBjdXJyZW50U291cmNlID8gY3VycmVudFNvdXJjZS5maWxlTmFtZSA6IG51bGwsXG4gICAgICAgICAgbGluZU51bWJlcjogY3VycmVudFNvdXJjZSA/IGN1cnJlbnRTb3VyY2UubGluZU51bWJlciA6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpZCkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RWxlbWVudChpZCk7XG4gICAgICAgIHZhciBwYXJlbnRJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UGFyZW50SUQoaWQpO1xuICAgICAgICB2YXIgb3duZXJJRCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0T3duZXJJRChpZCk7XG4gICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lcklEID8gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShvd25lcklEKSA6IG51bGw7XG4gICAgICAgIHZhciBzb3VyY2UgPSBlbGVtZW50ICYmIGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgICAgbmFtZTogb3duZXJOYW1lLFxuICAgICAgICAgIGZpbGVOYW1lOiBzb3VyY2UgPyBzb3VyY2UuZmlsZU5hbWUgOiBudWxsLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IHNvdXJjZSA/IHNvdXJjZS5saW5lTnVtYmVyIDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgaWQgPSBwYXJlbnRJRDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEludGVybmFsIHN0YXRlIGlzIG1lc3NlZCB1cC5cbiAgICAgIC8vIFN0b3AgYnVpbGRpbmcgdGhlIHN0YWNrIChpdCdzIGp1c3QgYSBuaWNlIHRvIGhhdmUpLlxuICAgIH1cblxuICAgIGNvbnNvbGUucmVhY3RTdGFjayhzdGFjayk7XG4gIH0sXG4gIHBvcE5vblN0YW5kYXJkV2FybmluZ1N0YWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlLnJlYWN0U3RhY2tFbmQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS5yZWFjdFN0YWNrRW5kKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2suanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIFJlYWN0SW5zdHJ1bWVudGF0aW9uIHdpdGggYSBfX0RFVl9fIGNoZWNrXG5cbnZhciBkZWJ1Z1Rvb2wgPSBudWxsO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3REZWJ1Z1Rvb2wgPSByZXF1aXJlKCcuL1JlYWN0RGVidWdUb29sJyk7XG4gIGRlYnVnVG9vbCA9IFJlYWN0RGVidWdUb29sO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVidWdUb29sOiBkZWJ1Z1Rvb2wgfTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEluc3RydW1lbnRhdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG52YXIgdXBkYXRlQmF0Y2hOdW1iZXIgPSAwO1xudmFyIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbnZhciBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcblxudmFyIGJhdGNoaW5nU3RyYXRlZ3kgPSBudWxsO1xuXG5mdW5jdGlvbiBlbnN1cmVJbmplY3RlZCgpIHtcbiAgIShSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiAmJiBiYXRjaGluZ1N0cmF0ZWd5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgaW5qZWN0IGEgcmVjb25jaWxlIHRyYW5zYWN0aW9uIGNsYXNzIGFuZCBiYXRjaGluZyBzdHJhdGVneScpIDogX3Byb2RJbnZhcmlhbnQoJzEyMycpIDogdm9pZCAwO1xufVxuXG52YXIgTkVTVEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IGRpcnR5Q29tcG9uZW50cy5sZW5ndGg7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoICE9PSBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBBZGRpdGlvbmFsIHVwZGF0ZXMgd2VyZSBlbnF1ZXVlZCBieSBjb21wb25lbnREaWRVcGRhdGUgaGFuZGxlcnMgb3JcbiAgICAgIC8vIHNpbWlsYXI7IGJlZm9yZSBvdXIgb3duIFVQREFURV9RVUVVRUlORyB3cmFwcGVyIGNsb3Nlcywgd2Ugd2FudCB0byBydW5cbiAgICAgIC8vIHRoZXNlIG5ldyB1cGRhdGVzIHNvIHRoYXQgaWYgQSdzIGNvbXBvbmVudERpZFVwZGF0ZSBjYWxscyBzZXRTdGF0ZSBvblxuICAgICAgLy8gQiwgQiB3aWxsIHVwZGF0ZSBiZWZvcmUgdGhlIGNhbGxiYWNrIEEncyB1cGRhdGVyIHByb3ZpZGVkIHdoZW4gY2FsbGluZ1xuICAgICAgLy8gc2V0U3RhdGUuXG4gICAgICBkaXJ0eUNvbXBvbmVudHMuc3BsaWNlKDAsIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoKTtcbiAgICAgIGZsdXNoQmF0Y2hlZFVwZGF0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlydHlDb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xuXG52YXIgVVBEQVRFX1FVRVVFSU5HID0ge1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLnJlc2V0KCk7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlLm5vdGlmeUFsbCgpO1xuICB9XG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbTkVTVEVEX1VQREFURVMsIFVQREFURV9RVUVVRUlOR107XG5cbmZ1bmN0aW9uIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiB1c2VDcmVhdGVFbGVtZW50ICovdHJ1ZSk7XG59XG5cbl9hc3NpZ24oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLCB7XG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gbnVsbDtcbiAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UodGhpcy5jYWxsYmFja1F1ZXVlKTtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUgPSBudWxsO1xuICAgIFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLnJlbGVhc2UodGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gICAgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiA9IG51bGw7XG4gIH0sXG5cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEpIHtcbiAgICAvLyBFc3NlbnRpYWxseSBjYWxscyBgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbi5wZXJmb3JtKG1ldGhvZCwgc2NvcGUsIGEpYFxuICAgIC8vIHdpdGggdGhpcyB0cmFuc2FjdGlvbidzIHdyYXBwZXJzIGFyb3VuZCBpdC5cbiAgICByZXR1cm4gVHJhbnNhY3Rpb24ucGVyZm9ybS5jYWxsKHRoaXMsIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybSwgdGhpcy5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgbWV0aG9kLCBzY29wZSwgYSk7XG4gIH1cbn0pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbik7XG5cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKSB7XG4gIGVuc3VyZUluamVjdGVkKCk7XG4gIHJldHVybiBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKTtcbn1cblxuLyoqXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgbW91bnQgb3JkZXJpbmcuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzEgZmlyc3QgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMyIHNlY29uZCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gdmFsdWUgdXNhYmxlIGJ5IEFycmF5LnByb3RvdHlwZS5zb3J0KCkuXG4gKi9cbmZ1bmN0aW9uIG1vdW50T3JkZXJDb21wYXJhdG9yKGMxLCBjMikge1xuICByZXR1cm4gYzEuX21vdW50T3JkZXIgLSBjMi5fbW91bnRPcmRlcjtcbn1cblxuZnVuY3Rpb24gcnVuQmF0Y2hlZFVwZGF0ZXModHJhbnNhY3Rpb24pIHtcbiAgdmFyIGxlbiA9IHRyYW5zYWN0aW9uLmRpcnR5Q29tcG9uZW50c0xlbmd0aDtcbiAgIShsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGZsdXNoIHRyYW5zYWN0aW9uXFwncyBzdG9yZWQgZGlydHktY29tcG9uZW50cyBsZW5ndGggKCVzKSB0byBtYXRjaCBkaXJ0eS1jb21wb25lbnRzIGFycmF5IGxlbmd0aCAoJXMpLicsIGxlbiwgZGlydHlDb21wb25lbnRzLmxlbmd0aCkgOiBfcHJvZEludmFyaWFudCgnMTI0JywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IHZvaWQgMDtcblxuICAvLyBTaW5jZSByZWNvbmNpbGluZyBhIGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIG93bmVyIGhpZXJhcmNoeSB1c3VhbGx5IChub3RcbiAgLy8gYWx3YXlzIC0tIHNlZSBzaG91bGRDb21wb25lbnRVcGRhdGUoKSkgd2lsbCByZWNvbmNpbGUgY2hpbGRyZW4sIHJlY29uY2lsZVxuICAvLyB0aGVtIGJlZm9yZSB0aGVpciBjaGlsZHJlbiBieSBzb3J0aW5nIHRoZSBhcnJheS5cbiAgZGlydHlDb21wb25lbnRzLnNvcnQobW91bnRPcmRlckNvbXBhcmF0b3IpO1xuXG4gIC8vIEFueSB1cGRhdGVzIGVucXVldWVkIHdoaWxlIHJlY29uY2lsaW5nIG11c3QgYmUgcGVyZm9ybWVkIGFmdGVyIHRoaXMgZW50aXJlXG4gIC8vIGJhdGNoLiBPdGhlcndpc2UsIGlmIGRpcnR5Q29tcG9uZW50cyBpcyBbQSwgQl0gd2hlcmUgQSBoYXMgY2hpbGRyZW4gQiBhbmRcbiAgLy8gQywgQiBjb3VsZCB1cGRhdGUgdHdpY2UgaW4gYSBzaW5nbGUgYmF0Y2ggaWYgQydzIHJlbmRlciBlbnF1ZXVlcyBhbiB1cGRhdGVcbiAgLy8gdG8gQiAoc2luY2UgQiB3b3VsZCBoYXZlIGFscmVhZHkgdXBkYXRlZCwgd2Ugc2hvdWxkIHNraXAgaXQsIGFuZCB0aGUgb25seVxuICAvLyB3YXkgd2UgY2FuIGtub3cgdG8gZG8gc28gaXMgYnkgY2hlY2tpbmcgdGhlIGJhdGNoIGNvdW50ZXIpLlxuICB1cGRhdGVCYXRjaE51bWJlcisrO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAvLyBJZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgYmVmb3JlIHBlbmRpbmcgY2hhbmdlcyBhcHBseSwgaXQgd2lsbCBzdGlsbFxuICAgIC8vIGJlIGhlcmUsIGJ1dCB3ZSBhc3N1bWUgdGhhdCBpdCBoYXMgY2xlYXJlZCBpdHMgX3BlbmRpbmdDYWxsYmFja3MgYW5kXG4gICAgLy8gdGhhdCBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaXMgYSBub29wLlxuICAgIHZhciBjb21wb25lbnQgPSBkaXJ0eUNvbXBvbmVudHNbaV07XG5cbiAgICAvLyBJZiBwZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkgaGFwcGVucyB0byBlbnF1ZXVlIGFueSBuZXcgdXBkYXRlcywgd2VcbiAgICAvLyBzaG91bGRuJ3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2tzIHVudGlsIHRoZSBuZXh0IHJlbmRlciBoYXBwZW5zLCBzb1xuICAgIC8vIHN0YXNoIHRoZSBjYWxsYmFja3MgZmlyc3RcbiAgICB2YXIgY2FsbGJhY2tzID0gY29tcG9uZW50Ll9wZW5kaW5nQ2FsbGJhY2tzO1xuICAgIGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG5cbiAgICB2YXIgbWFya2VyTmFtZTtcbiAgICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XG4gICAgICB2YXIgbmFtZWRDb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAvLyBEdWNrIHR5cGUgVG9wTGV2ZWxXcmFwcGVyLiBUaGlzIGlzIHByb2JhYmx5IGFsd2F5cyB0cnVlLlxuICAgICAgaWYgKGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQudHlwZS5pc1JlYWN0VG9wTGV2ZWxXcmFwcGVyKSB7XG4gICAgICAgIG5hbWVkQ29tcG9uZW50ID0gY29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgICAgIH1cbiAgICAgIG1hcmtlck5hbWUgPSAnUmVhY3QgdXBkYXRlOiAnICsgbmFtZWRDb21wb25lbnQuZ2V0TmFtZSgpO1xuICAgICAgY29uc29sZS50aW1lKG1hcmtlck5hbWUpO1xuICAgIH1cblxuICAgIFJlYWN0UmVjb25jaWxlci5wZXJmb3JtVXBkYXRlSWZOZWNlc3NhcnkoY29tcG9uZW50LCB0cmFuc2FjdGlvbi5yZWNvbmNpbGVUcmFuc2FjdGlvbiwgdXBkYXRlQmF0Y2hOdW1iZXIpO1xuXG4gICAgaWYgKG1hcmtlck5hbWUpIHtcbiAgICAgIGNvbnNvbGUudGltZUVuZChtYXJrZXJOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNhbGxiYWNrcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0cmFuc2FjdGlvbi5jYWxsYmFja1F1ZXVlLmVucXVldWUoY2FsbGJhY2tzW2pdLCBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBmbHVzaEJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uJ3Mgd3JhcHBlcnMgd2lsbCBjbGVhciB0aGUgZGlydHlDb21wb25lbnRzXG4gIC8vIGFycmF5IGFuZCBwZXJmb3JtIGFueSB1cGRhdGVzIGVucXVldWVkIGJ5IG1vdW50LXJlYWR5IGhhbmRsZXJzIChpLmUuLFxuICAvLyBjb21wb25lbnREaWRVcGRhdGUpIGJ1dCB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUgdG9vIGluIG9yZGVyIHRvIGNhdGNoXG4gIC8vIHVwZGF0ZXMgZW5xdWV1ZWQgYnkgc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCBhc2FwIGNhbGxzLlxuICB3aGlsZSAoZGlydHlDb21wb25lbnRzLmxlbmd0aCB8fCBhc2FwRW5xdWV1ZWQpIHtcbiAgICBpZiAoZGlydHlDb21wb25lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5nZXRQb29sZWQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0ocnVuQmF0Y2hlZFVwZGF0ZXMsIG51bGwsIHRyYW5zYWN0aW9uKTtcbiAgICAgIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGFzYXBFbnF1ZXVlZCkge1xuICAgICAgYXNhcEVucXVldWVkID0gZmFsc2U7XG4gICAgICB2YXIgcXVldWUgPSBhc2FwQ2FsbGJhY2tRdWV1ZTtcbiAgICAgIGFzYXBDYWxsYmFja1F1ZXVlID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKTtcbiAgICAgIHF1ZXVlLm5vdGlmeUFsbCgpO1xuICAgICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTWFyayBhIGNvbXBvbmVudCBhcyBuZWVkaW5nIGEgcmVyZW5kZXIsIGFkZGluZyBhbiBvcHRpb25hbCBjYWxsYmFjayB0byBhXG4gKiBsaXN0IG9mIGZ1bmN0aW9ucyB3aGljaCB3aWxsIGJlIGV4ZWN1dGVkIG9uY2UgdGhlIHJlcmVuZGVyIG9jY3Vycy5cbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShjb21wb25lbnQpIHtcbiAgZW5zdXJlSW5qZWN0ZWQoKTtcblxuICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFRoaXMgaXMgY2FsbGVkIGJ5IGVhY2ggdG9wLWxldmVsIHVwZGF0ZVxuICAvLyBmdW5jdGlvbiwgbGlrZSBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICBpZiAoY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsKSB7XG4gICAgY29tcG9uZW50Ll91cGRhdGVCYXRjaE51bWJlciA9IHVwZGF0ZUJhdGNoTnVtYmVyICsgMTtcbiAgfVxufVxuXG4vKipcbiAqIEVucXVldWUgYSBjYWxsYmFjayB0byBiZSBydW4gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBiYXRjaGluZyBjeWNsZS4gVGhyb3dzXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxuICovXG5mdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmV1cGRhdGVzIGFyZSBub3QgYmVpbmcgYmF0Y2hlZC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMjUnKSA6IHZvaWQgMDtcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XG4gIGFzYXBFbnF1ZXVlZCA9IHRydWU7XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IF9wcm9kSW52YXJpYW50KCcxMjYnKSA6IHZvaWQgMDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbiA9IFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuICB9LFxuXG4gIGluamVjdEJhdGNoaW5nU3RyYXRlZ3k6IGZ1bmN0aW9uIChfYmF0Y2hpbmdTdHJhdGVneSkge1xuICAgICFfYmF0Y2hpbmdTdHJhdGVneSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdFVwZGF0ZXM6IG11c3QgcHJvdmlkZSBhIGJhdGNoaW5nIHN0cmF0ZWd5JykgOiBfcHJvZEludmFyaWFudCgnMTI3JykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgX2JhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMgPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGEgYmF0Y2hlZFVwZGF0ZXMoKSBmdW5jdGlvbicpIDogX3Byb2RJbnZhcmlhbnQoJzEyOCcpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJykgOiBfcHJvZEludmFyaWFudCgnMTI5JykgOiB2b2lkIDA7XG4gICAgYmF0Y2hpbmdTdHJhdGVneSA9IF9iYXRjaGluZ1N0cmF0ZWd5O1xuICB9XG59O1xuXG52YXIgUmVhY3RVcGRhdGVzID0ge1xuICAvKipcbiAgICogUmVhY3QgcmVmZXJlbmNlcyBgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbmAgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiBvcmRlclxuICAgKiB0byBhbGxvdyBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBudWxsLFxuXG4gIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcbiAgZW5xdWV1ZVVwZGF0ZTogZW5xdWV1ZVVwZGF0ZSxcbiAgZmx1c2hCYXRjaGVkVXBkYXRlczogZmx1c2hCYXRjaGVkVXBkYXRlcyxcbiAgaW5qZWN0aW9uOiBSZWFjdFVwZGF0ZXNJbmplY3Rpb24sXG4gIGFzYXA6IGFzYXBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RVcGRhdGVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0VXBkYXRlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IGZhbHNlO1xudmFyIGlzUHJveHlTdXBwb3J0ZWQgPSB0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbic7XG5cbnZhciBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyA9IFsnZGlzcGF0Y2hDb25maWcnLCAnX3RhcmdldEluc3QnLCAnbmF0aXZlRXZlbnQnLCAnaXNEZWZhdWx0UHJldmVudGVkJywgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJywgJ19kaXNwYXRjaExpc3RlbmVycycsICdfZGlzcGF0Y2hJbnN0YW5jZXMnXTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHsqfSB0YXJnZXRJbnN0IE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gbmF0aXZlRXZlbnRUYXJnZXQgVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gIH1cblxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2ZcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllc1tpXV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbikpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzdG9wUHJvcGFnYXRpb24nLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdzdG9wUHJvcGFnYXRpb24nLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgfVxuICB9XG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgfHwgdGFyZ2V0LmlzUGVyc2lzdGVudCgpLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIFwiICsgXCJzZWVpbmcgdGhpcywgeW91J3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gXCIgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgX2Fzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG5cbiAgUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENsYXNzLCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xufTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50LCBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAgKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAgKlxuICAqIEBwYXJhbSB7b2JqZWN0fSBTeW50aGV0aWNFdmVudFxuICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5pbmdDb25kaXRpb24sIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIFwiICsgXCJ5b3UncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiBcIiArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KSA6IHZvaWQgMDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9QUk9QRVJUWTogMHgxLFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg0LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHg4LFxuICBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTogMHgxMCB8IDB4OCxcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHgyMCxcblxuICAvKipcbiAgICogSW5qZWN0IHNvbWUgc3BlY2lhbGl6ZWQga25vd2xlZGdlIGFib3V0IHRoZSBET00uIFRoaXMgdGFrZXMgYSBjb25maWcgb2JqZWN0XG4gICAqIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gdGhhdCBnaXZlbiBhbiBhdHRyaWJ1dGUgbmFtZSB3aWxsIHJldHVybiB0cnVlXG4gICAqIGlmIGl0IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00gdmVyYmF0aW0uIFVzZWZ1bCBmb3IgZGF0YS0qIG9yIGFyaWEtKlxuICAgKiBhdHRyaWJ1dGVzIHdoZXJlIGl0J3MgaW1wb3NzaWJsZSB0byBlbnVtZXJhdGUgYWxsIG9mIHRoZSBwb3NzaWJsZVxuICAgKiBhdHRyaWJ1dGUgbmFtZXMsXG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lc3BhY2UgVVJMLiAoQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIG5vIG5hbWVzcGFjZS4pXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgSW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG4gICAgdmFyIFByb3BlcnRpZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lc3BhY2VzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNwYWNlcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NUHJvcGVydHlOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTVByb3BlcnR5TmFtZXMgfHwge307XG4gICAgdmFyIERPTU11dGF0aW9uTWV0aG9kcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTU11dGF0aW9uTWV0aG9kcyB8fCB7fTtcblxuICAgIGlmIChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSkge1xuICAgICAgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLnB1c2goZG9tUHJvcGVydHlDb25maWcuaXNDdXN0b21BdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIFByb3BlcnRpZXMpIHtcbiAgICAgICEhRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaW5qZWN0RE9NUHJvcGVydHlDb25maWcoLi4uKTogWW91XFwncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgXFwnJXNcXCcgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBpbmplY3RlZC4gWW91IG1heSBiZSBhY2NpZGVudGFsbHkgaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgaW5qZWN0aW5nIHR3byBjb25maWdzIHRoYXQgaGF2ZSBjb25mbGljdGluZyBwcm9wZXJ0eSBuYW1lcy4nLCBwcm9wTmFtZSkgOiBfcHJvZEludmFyaWFudCgnNDgnLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IF9wcm9kSW52YXJpYW50KCc1MCcsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZF0gPSBwcm9wTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IERPTUF0dHJpYnV0ZU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2F0dHJpYnV0ZU5hbWVdID0gcHJvcE5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBET01BdHRyaWJ1dGVOYW1lc3BhY2VzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTVByb3BlcnR5TmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWUgPSBET01Qcm9wZXJ0eU5hbWVzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTU11dGF0aW9uTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kID0gRE9NTXV0YXRpb25NZXRob2RzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wTmFtZV0gPSBwcm9wZXJ0eUluZm87XG4gICAgfVxuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9ICc6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEJztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG4vKipcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcbiAqXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnaWQnXVxuICogICB0cnVlXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cbiAqICAgdW5kZWZpbmVkXG4gKlxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcbiAqL1xudmFyIERPTVByb3BlcnR5ID0ge1xuICBJRF9BVFRSSUJVVEVfTkFNRTogJ2RhdGEtcmVhY3RpZCcsXG4gIFJPT1RfQVRUUklCVVRFX05BTUU6ICdkYXRhLXJlYWN0cm9vdCcsXG5cbiAgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUixcbiAgQVRUUklCVVRFX05BTUVfQ0hBUjogQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICdcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MCcsXG5cbiAgLyoqXG4gICAqIE1hcCBmcm9tIHByb3BlcnR5IFwic3RhbmRhcmQgbmFtZVwiIHRvIGFuIG9iamVjdCB3aXRoIGluZm8gYWJvdXQgaG93IHRvIHNldFxuICAgKiB0aGUgcHJvcGVydHkgaW4gdGhlIERPTS4gRWFjaCBvYmplY3QgY29udGFpbnM6XG4gICAqXG4gICAqIGF0dHJpYnV0ZU5hbWU6XG4gICAqICAgVXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAgICogYXR0cmlidXRlTmFtZXNwYWNlXG4gICAqIHByb3BlcnR5TmFtZTpcbiAgICogICBVc2VkIG9uIERPTSBub2RlIGluc3RhbmNlcy4gKFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IG11dGF0ZSBkdWUgdG9cbiAgICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAgICogbXV0YXRpb25NZXRob2Q6XG4gICAqICAgSWYgbm9uLW51bGwsIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkgb3IgYHNldEF0dHJpYnV0ZSgpYCBhZnRlclxuICAgKiAgIGluaXRpYWwgcmVuZGVyLlxuICAgKiBtdXN0VXNlUHJvcGVydHk6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gICAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICAgKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICAgKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICAgKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3BlcnRpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLCB1c2VkXG4gICAqIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBwcm9wZXJ0aWVzLiBBdmFpbGFibGUgb25seSBpbiBfX0RFVl9fLlxuICAgKlxuICAgKiBhdXRvZm9jdXMgaXMgcHJlZGVmaW5lZCwgYmVjYXVzZSBhZGRpbmcgaXQgdG8gdGhlIHByb3BlcnR5IHdoaXRlbGlzdFxuICAgKiBjYXVzZXMgdW5pbnRlbmRlZCBzaWRlIGVmZmVjdHMuXG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBnZXRQb3NzaWJsZVN0YW5kYXJkTmFtZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHsgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyB9IDogbnVsbCxcblxuICAvKipcbiAgICogQWxsIG9mIHRoZSBpc0N1c3RvbUF0dHJpYnV0ZSgpIGZ1bmN0aW9ucyB0aGF0IGhhdmUgYmVlbiBpbmplY3RlZC5cbiAgICovXG4gIF9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uczogW10sXG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIGN1c3RvbSBhdHRyaWJ1dGUuXG4gICAqIEBtZXRob2RcbiAgICovXG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRE9NUHJvcGVydHkuX2lzQ3VzdG9tQXR0cmlidXRlRnVuY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXNDdXN0b21BdHRyaWJ1dGVGbiA9IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9uc1tpXTtcbiAgICAgIGlmIChpc0N1c3RvbUF0dHJpYnV0ZUZuKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9ET01Qcm9wZXJ0eS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50U3ltYm9sJyk7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2VsZlxuICAgICAgfSk7XG4gICAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGVsZW1lbnQuX3NlbGYgPSBzZWxmO1xuICAgICAgZWxlbWVudC5fc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVlbGVtZW50XG4gKi9cblJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRBcnJheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuJCR0eXBlb2YgPT09ICd1bmRlZmluZWQnIHx8IHByb3BzLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVmYWN0b3J5XG4gKi9cblJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIGZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gZWFzaWx5IGFjY2Vzc2VkIG9uIGVsZW1lbnRzLiBFLmcuIGA8Rm9vIC8+LnR5cGUgPT09IEZvb2AuXG4gIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBuYW1lZCBgY29uc3RydWN0b3JgIHNpbmNlIHRoaXMgbWF5IG5vdCBiZSB0aGUgZnVuY3Rpb25cbiAgLy8gdGhhdCBjcmVhdGVkIHRoZSBlbGVtZW50LCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICBmYWN0b3J5LnR5cGUgPSB0eXBlO1xuICByZXR1cm4gZmFjdG9yeTtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNsb25lZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmlzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5SZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgc3RhbmRhcmRSZWxlYXNlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICAhKGluc3RhbmNlIGluc3RhbmNlb2YgS2xhc3MpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiBfcHJvZEludmFyaWFudCgnMjUnKSA6IHZvaWQgMDtcbiAgaW5zdGFuY2UuZGVzdHJ1Y3RvcigpO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCA8IEtsYXNzLnBvb2xTaXplKSB7XG4gICAgS2xhc3MuaW5zdGFuY2VQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59O1xuXG52YXIgREVGQVVMVF9QT09MX1NJWkUgPSAxMDtcbnZhciBERUZBVUxUX1BPT0xFUiA9IG9uZUFyZ3VtZW50UG9vbGVyO1xuXG4vKipcbiAqIEF1Z21lbnRzIGBDb3B5Q29uc3RydWN0b3JgIHRvIGJlIGEgcG9vbGFibGUgY2xhc3MsIGF1Z21lbnRpbmcgb25seSB0aGUgY2xhc3NcbiAqIGl0c2VsZiAoc3RhdGljYWxseSkgbm90IGFkZGluZyBhbnkgcHJvdG90eXBpY2FsIGZpZWxkcy4gQW55IENvcHlDb25zdHJ1Y3RvclxuICogeW91IGdpdmUgdGhpcyBtYXkgaGF2ZSBhIGBwb29sU2l6ZWAgcHJvcGVydHksIGFuZCB3aWxsIGxvb2sgZm9yIGFcbiAqIHByb3RvdHlwaWNhbCBgZGVzdHJ1Y3RvcmAgb24gaW5zdGFuY2VzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IENvcHlDb25zdHJ1Y3RvciBDb25zdHJ1Y3RvciB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcG9vbGVyIEN1c3RvbWl6YWJsZSBwb29sZXIuXG4gKi9cbnZhciBhZGRQb29saW5nVG8gPSBmdW5jdGlvbiAoQ29weUNvbnN0cnVjdG9yLCBwb29sZXIpIHtcbiAgLy8gQ2FzdGluZyBhcyBhbnkgc28gdGhhdCBmbG93IGlnbm9yZXMgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbiBhbmQgdHJ1c3RzXG4gIC8vIGl0IHRvIG1hdGNoIHRoZSB0eXBlIHdlIGRlY2xhcmVkXG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBQb29sZWRDbGFzcyA9IHtcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXG4gIG9uZUFyZ3VtZW50UG9vbGVyOiBvbmVBcmd1bWVudFBvb2xlcixcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxuICBmb3VyQXJndW1lbnRQb29sZXI6IGZvdXJBcmd1bWVudFBvb2xlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sZWRDbGFzcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9Qb29sZWRDbGFzcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3dhcm5pbmcvYnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RCYXNlQ2xhc3NlcyA9IHJlcXVpcmUoJy4vUmVhY3RCYXNlQ2xhc3NlcycpO1xudmFyIFJlYWN0Q2hpbGRyZW4gPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRyZW4nKTtcbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHJlcXVpcmUoJy4vUmVhY3RET01GYWN0b3JpZXMnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBjcmVhdGVSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9jcmVhdGVDbGFzcycpO1xudmFyIG9ubHlDaGlsZCA9IHJlcXVpcmUoJy4vb25seUNoaWxkJyk7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQ7XG52YXIgY3JlYXRlRmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5O1xudmFyIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQ7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSByZXF1aXJlKCcuL2xvd1ByaW9yaXR5V2FybmluZycpO1xuICB2YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICB2YXIgZGlkV2FyblByb3BUeXBlc0RlcHJlY2F0ZWQgPSBmYWxzZTtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBfX3NwcmVhZCA9IF9hc3NpZ247XG52YXIgY3JlYXRlTWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgcmV0dXJuIG1peGluO1xufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5lZEZvclNwcmVhZCA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9yQ3JlYXRlTWl4aW4gPSBmYWxzZTtcbiAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG93UHJpb3JpdHlXYXJuaW5nKHdhcm5lZEZvclNwcmVhZCwgJ1JlYWN0Ll9fc3ByZWFkIGlzIGRlcHJlY2F0ZWQgYW5kIHNob3VsZCBub3QgYmUgdXNlZC4gVXNlICcgKyAnT2JqZWN0LmFzc2lnbiBkaXJlY3RseSBvciBhbm90aGVyIGhlbHBlciBmdW5jdGlvbiB3aXRoIHNpbWlsYXIgJyArICdzZW1hbnRpY3MuIFlvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8geW91ciBjb21waWxlci4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcHJlYWQtZGVwcmVjYXRpb24gZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICB3YXJuZWRGb3JTcHJlYWQgPSB0cnVlO1xuICAgIHJldHVybiBfYXNzaWduLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgY3JlYXRlTWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICBsb3dQcmlvcml0eVdhcm5pbmcod2FybmVkRm9yQ3JlYXRlTWl4aW4sICdSZWFjdC5jcmVhdGVNaXhpbiBpcyBkZXByZWNhdGVkIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuICcgKyAnSW4gUmVhY3QgdjE2LjAsIGl0IHdpbGwgYmUgcmVtb3ZlZC4gJyArICdZb3UgY2FuIHVzZSB0aGlzIG1peGluIGRpcmVjdGx5IGluc3RlYWQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvY3JlYXRlbWl4aW4td2FzLW5ldmVyLWltcGxlbWVudGVkIGZvciBtb3JlIGluZm8uJyk7XG4gICAgd2FybmVkRm9yQ3JlYXRlTWl4aW4gPSB0cnVlO1xuICAgIHJldHVybiBtaXhpbjtcbiAgfTtcbn1cblxudmFyIFJlYWN0ID0ge1xuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IFJlYWN0QmFzZUNsYXNzZXMuQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBSZWFjdEJhc2VDbGFzc2VzLlB1cmVDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnQsXG4gIGlzVmFsaWRFbGVtZW50OiBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQsXG5cbiAgLy8gQ2xhc3NpY1xuXG4gIFByb3BUeXBlczogUmVhY3RQcm9wVHlwZXMsXG4gIGNyZWF0ZUNsYXNzOiBjcmVhdGVSZWFjdENsYXNzLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5LFxuICBjcmVhdGVNaXhpbjogY3JlYXRlTWl4aW4sXG5cbiAgLy8gVGhpcyBsb29rcyBET00gc3BlY2lmaWMgYnV0IHRoZXNlIGFyZSBhY3R1YWxseSBpc29tb3JwaGljIGhlbHBlcnNcbiAgLy8gc2luY2UgdGhleSBhcmUganVzdCBnZW5lcmF0aW5nIERPTSBzdHJpbmdzLlxuICBET006IFJlYWN0RE9NRmFjdG9yaWVzLFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvLyBEZXByZWNhdGVkIGhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZy5cbiAgX19zcHJlYWQ6IF9fc3ByZWFkXG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgd2FybmVkRm9yQ3JlYXRlQ2xhc3MgPSBmYWxzZTtcbiAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWN0LCAnUHJvcFR5cGVzJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyhkaWRXYXJuUHJvcFR5cGVzRGVwcmVjYXRlZCwgJ0FjY2Vzc2luZyBQcm9wVHlwZXMgdmlhIHRoZSBtYWluIFJlYWN0IHBhY2thZ2UgaXMgZGVwcmVjYXRlZCwnICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluICBSZWFjdCB2MTYuMC4nICsgJyBVc2UgdGhlIGxhdGVzdCBhdmFpbGFibGUgdjE1LiogcHJvcC10eXBlcyBwYWNrYWdlIGZyb20gbnBtIGluc3RlYWQuJyArICcgRm9yIGluZm8gb24gdXNhZ2UsIGNvbXBhdGliaWxpdHksIG1pZ3JhdGlvbiBhbmQgbW9yZSwgc2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9wcm9wLXR5cGVzLWRvY3MnKTtcbiAgICAgICAgZGlkV2FyblByb3BUeXBlc0RlcHJlY2F0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3QsICdjcmVhdGVDbGFzcycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmcod2FybmVkRm9yQ3JlYXRlQ2xhc3MsICdBY2Nlc3NpbmcgY3JlYXRlQ2xhc3MgdmlhIHRoZSBtYWluIFJlYWN0IHBhY2thZ2UgaXMgZGVwcmVjYXRlZCwnICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IHYxNi4wLicgKyBcIiBVc2UgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzIGluc3RlYWQuIElmIHlvdSdyZSBub3QgeWV0IFwiICsgJ3JlYWR5IHRvIG1pZ3JhdGUsIGNyZWF0ZS1yZWFjdC1jbGFzcyB2MTUuKiBpcyBhdmFpbGFibGUgJyArICdvbiBucG0gYXMgYSB0ZW1wb3JhcnksIGRyb3AtaW4gcmVwbGFjZW1lbnQuICcgKyAnRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1jcmVhdGUtY2xhc3MnKTtcbiAgICAgICAgd2FybmVkRm9yQ3JlYXRlQ2xhc3MgPSB0cnVlO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVhY3RDbGFzcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJlYWN0LkRPTSBmYWN0b3JpZXMgYXJlIGRlcHJlY2F0ZWQuIFdyYXAgdGhlc2UgbWV0aG9kcyBzbyB0aGF0XG4gIC8vIGludm9jYXRpb25zIG9mIHRoZSBSZWFjdC5ET00gbmFtZXNwYWNlIGFuZCBhbGVydCB1c2VycyB0byBzd2l0Y2hcbiAgLy8gdG8gdGhlIGByZWFjdC1kb20tZmFjdG9yaWVzYCBwYWNrYWdlLlxuICBSZWFjdC5ET00gPSB7fTtcbiAgdmFyIHdhcm5lZEZvckZhY3RvcmllcyA9IGZhbHNlO1xuICBPYmplY3Qua2V5cyhSZWFjdERPTUZhY3RvcmllcykuZm9yRWFjaChmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIFJlYWN0LkRPTVtmYWN0b3J5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghd2FybmVkRm9yRmFjdG9yaWVzKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyhmYWxzZSwgJ0FjY2Vzc2luZyBmYWN0b3JpZXMgbGlrZSBSZWFjdC5ET00uJXMgaGFzIGJlZW4gZGVwcmVjYXRlZCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjE2LjArLiBVc2UgdGhlICcgKyAncmVhY3QtZG9tLWZhY3RvcmllcyBwYWNrYWdlIGluc3RlYWQuICcgKyAnIFZlcnNpb24gMS4wIHByb3ZpZGVzIGEgZHJvcC1pbiByZXBsYWNlbWVudC4nICsgJyBGb3IgbW9yZSBpbmZvLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1kb20tZmFjdG9yaWVzJywgZmFjdG9yeSk7XG4gICAgICAgIHdhcm5lZEZvckZhY3RvcmllcyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RET01GYWN0b3JpZXNbZmFjdG9yeV0uYXBwbHkoUmVhY3RET01GYWN0b3JpZXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuZnVuY3Rpb24gcmVhY3RQcm9kSW52YXJpYW50KGNvZGUpIHtcbiAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIG1lc3NhZ2UgPSAnTWluaWZpZWQgUmVhY3QgZXJyb3IgIycgKyBjb2RlICsgJzsgdmlzaXQgJyArICdodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBhcmdJZHggPSAwOyBhcmdJZHggPCBhcmdDb3VudDsgYXJnSWR4KyspIHtcbiAgICBtZXNzYWdlICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2FyZ0lkeCArIDFdKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQnICsgJyBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nO1xuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHJlYWN0UHJvZEludmFyaWFudCdzIG93biBmcmFtZVxuXG4gIHRocm93IGVycm9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0UHJvZEludmFyaWFudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3JlYWN0UHJvZEludmFyaWFudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFJlZiA9IHJlcXVpcmUoJy4vUmVhY3RSZWYnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogSGVscGVyIHRvIGNhbGwgUmVhY3RSZWYuYXR0YWNoUmVmcyB3aXRoIHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCwgc3BsaXQgb3V0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW9ucyBpbiB0aGUgdHJhbnNhY3Rpb24gbW91bnQtcmVhZHkgcXVldWUuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFJlZnMoKSB7XG4gIFJlYWN0UmVmLmF0dGFjaFJlZnModGhpcywgdGhpcy5fY3VycmVudEVsZW1lbnQpO1xufVxuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHRoZSBjb250YWluaW5nIGhvc3QgY29tcG9uZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gaW5mbyBhYm91dCB0aGUgaG9zdCBjb250YWluZXJcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQpIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCwgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQsIHBhcmVudERlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbWFya3VwID0gaW50ZXJuYWxJbnN0YW5jZS5tb3VudENvbXBvbmVudCh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHBhcmVudERlYnVnSUQpO1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbk1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBjYW4gYmUgcGFzc2VkIHRvXG4gICAqIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwLlxuICAgKi9cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGludGVybmFsSW5zdGFuY2UuZ2V0SG9zdE5vZGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHNhZmVseSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVbm1vdW50Q29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50KTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLnVubW91bnRDb21wb25lbnQoc2FmZWx5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVW5tb3VudENvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG5cbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cbiAgICAgIC8vIFRPRE86IFJlbW92aW5nIHRoZSByZXR1cm4gc3RhdGVtZW50IHNob3VsZCBhZmZlY3QgY29ycmVjdG5lc3M/XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBuZXh0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmx1c2ggYW55IGRpcnR5IGNoYW5nZXMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGludGVybmFsSW5zdGFuY2VcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHRyYW5zYWN0aW9uLCB1cGRhdGVCYXRjaE51bWJlcikge1xuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciAhPT0gdXBkYXRlQmF0Y2hOdW1iZXIpIHtcbiAgICAgIC8vIFRoZSBjb21wb25lbnQncyBlbnF1ZXVlZCBiYXRjaCBudW1iZXIgc2hvdWxkIGFsd2F5cyBiZSB0aGUgY3VycmVudFxuICAgICAgLy8gYmF0Y2ggb3IgdGhlIGZvbGxvd2luZyBvbmUuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnRlcm5hbEluc3RhbmNlLl91cGRhdGVCYXRjaE51bWJlciA9PSBudWxsIHx8IGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyID09PSB1cGRhdGVCYXRjaE51bWJlciArIDEsICdwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IFVuZXhwZWN0ZWQgYmF0Y2ggbnVtYmVyIChjdXJyZW50ICVzLCAnICsgJ3BlbmRpbmcgJXMpJywgdXBkYXRlQmF0Y2hOdW1iZXIsIGludGVybmFsSW5zdGFuY2UuX3VwZGF0ZUJhdGNoTnVtYmVyKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZm9yZVVwZGF0ZUNvbXBvbmVudChpbnRlcm5hbEluc3RhbmNlLl9kZWJ1Z0lELCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGludGVybmFsSW5zdGFuY2UucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGludGVybmFsSW5zdGFuY2UuX2RlYnVnSUQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RSZWNvbmNpbGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSByZXF1aXJlKCcuL0RPTU5hbWVzcGFjZXMnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xuXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IHJlcXVpcmUoJy4vY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbicpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG52YXIgRUxFTUVOVF9OT0RFX1RZUEUgPSAxO1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSA9IDExO1xuXG4vKipcbiAqIEluIElFICg4LTExKSBhbmQgRWRnZSwgYXBwZW5kaW5nIG5vZGVzIHdpdGggbm8gY2hpbGRyZW4gaXMgZHJhbWF0aWNhbGx5XG4gKiBmYXN0ZXIgdGhhbiBhcHBlbmRpbmcgYSBmdWxsIHN1YnRyZWUsIHNvIHdlIGVzc2VudGlhbGx5IHF1ZXVlIHVwIHRoZVxuICogLmFwcGVuZENoaWxkIGNhbGxzIGhlcmUgYW5kIGFwcGx5IHRoZW0gc28gZWFjaCBub2RlIGlzIGFkZGVkIHRvIGl0cyBwYXJlbnRcbiAqIGJlZm9yZSBhbnkgY2hpbGRyZW4gYXJlIGFkZGVkLlxuICpcbiAqIEluIG90aGVyIGJyb3dzZXJzLCBkb2luZyBzbyBpcyBzbG93ZXIgb3IgbmV1dHJhbCBjb21wYXJlZCB0byB0aGUgb3RoZXIgb3JkZXJcbiAqIChpbiBGaXJlZm94LCB0d2ljZSBhcyBzbG93KSBzbyB3ZSBvbmx5IGRvIHRoaXMgaW52ZXJzaW9uIGluIElFLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc3BpY3lqL2lubmVyaHRtbC12cy1jcmVhdGVlbGVtZW50LXZzLWNsb25lbm9kZS5cbiAqL1xudmFyIGVuYWJsZUxhenkgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IudXNlckFnZW50ID09PSAnc3RyaW5nJyAmJiAvXFxiRWRnZVxcL1xcZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuZnVuY3Rpb24gaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpIHtcbiAgaWYgKCFlbmFibGVMYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBub2RlID0gdHJlZS5ub2RlO1xuICB2YXIgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgaW5zZXJ0VHJlZUJlZm9yZShub2RlLCBjaGlsZHJlbltpXSwgbnVsbCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRyZWUuaHRtbCAhPSBudWxsKSB7XG4gICAgc2V0SW5uZXJIVE1MKG5vZGUsIHRyZWUuaHRtbCk7XG4gIH0gZWxzZSBpZiAodHJlZS50ZXh0ICE9IG51bGwpIHtcbiAgICBzZXRUZXh0Q29udGVudChub2RlLCB0cmVlLnRleHQpO1xuICB9XG59XG5cbnZhciBpbnNlcnRUcmVlQmVmb3JlID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAocGFyZW50Tm9kZSwgdHJlZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBEb2N1bWVudEZyYWdtZW50cyBhcmVuJ3QgYWN0dWFsbHkgcGFydCBvZiB0aGUgRE9NIGFmdGVyIGluc2VydGlvbiBzb1xuICAvLyBhcHBlbmRpbmcgY2hpbGRyZW4gd29uJ3QgdXBkYXRlIHRoZSBET00uIFdlIG5lZWQgdG8gZW5zdXJlIHRoZSBmcmFnbWVudFxuICAvLyBpcyBwcm9wZXJseSBwb3B1bGF0ZWQgZmlyc3QsIGJyZWFraW5nIG91dCBvZiBvdXIgbGF6eSBhcHByb2FjaCBmb3IganVzdFxuICAvLyB0aGlzIGxldmVsLiBBbHNvLCBzb21lIDxvYmplY3Q+IHBsdWdpbnMgKGxpa2UgRmxhc2ggUGxheWVyKSB3aWxsIHJlYWRcbiAgLy8gPHBhcmFtPiBub2RlcyBpbW1lZGlhdGVseSB1cG9uIGluc2VydGlvbiBpbnRvIHRoZSBET00sIHNvIDxvYmplY3Q+XG4gIC8vIG11c3QgYWxzbyBiZSBwb3B1bGF0ZWQgcHJpb3IgdG8gaW5zZXJ0aW9uIGludG8gdGhlIERPTS5cbiAgaWYgKHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFIHx8IHRyZWUubm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgJiYgdHJlZS5ub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnICYmICh0cmVlLm5vZGUubmFtZXNwYWNlVVJJID09IG51bGwgfHwgdHJlZS5ub2RlLm5hbWVzcGFjZVVSSSA9PT0gRE9NTmFtZXNwYWNlcy5odG1sKSkge1xuICAgIGluc2VydFRyZWVDaGlsZHJlbih0cmVlKTtcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZSh0cmVlLm5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRyZWUubm9kZSwgcmVmZXJlbmNlTm9kZSk7XG4gICAgaW5zZXJ0VHJlZUNoaWxkcmVuKHRyZWUpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gcmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkTm9kZSwgbmV3VHJlZSkge1xuICBvbGROb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld1RyZWUubm9kZSwgb2xkTm9kZSk7XG4gIGluc2VydFRyZWVDaGlsZHJlbihuZXdUcmVlKTtcbn1cblxuZnVuY3Rpb24gcXVldWVDaGlsZChwYXJlbnRUcmVlLCBjaGlsZFRyZWUpIHtcbiAgaWYgKGVuYWJsZUxhenkpIHtcbiAgICBwYXJlbnRUcmVlLmNoaWxkcmVuLnB1c2goY2hpbGRUcmVlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRUcmVlLm5vZGUuYXBwZW5kQ2hpbGQoY2hpbGRUcmVlLm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSFRNTCh0cmVlLCBodG1sKSB7XG4gIGlmIChlbmFibGVMYXp5KSB7XG4gICAgdHJlZS5odG1sID0gaHRtbDtcbiAgfSBlbHNlIHtcbiAgICBzZXRJbm5lckhUTUwodHJlZS5ub2RlLCBodG1sKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBxdWV1ZVRleHQodHJlZSwgdGV4dCkge1xuICBpZiAoZW5hYmxlTGF6eSkge1xuICAgIHRyZWUudGV4dCA9IHRleHQ7XG4gIH0gZWxzZSB7XG4gICAgc2V0VGV4dENvbnRlbnQodHJlZS5ub2RlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHRoaXMubm9kZS5ub2RlTmFtZTtcbn1cblxuZnVuY3Rpb24gRE9NTGF6eVRyZWUobm9kZSkge1xuICByZXR1cm4ge1xuICAgIG5vZGU6IG5vZGUsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGh0bWw6IG51bGwsXG4gICAgdGV4dDogbnVsbCxcbiAgICB0b1N0cmluZzogdG9TdHJpbmdcbiAgfTtcbn1cblxuRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZSA9IGluc2VydFRyZWVCZWZvcmU7XG5ET01MYXp5VHJlZS5yZXBsYWNlQ2hpbGRXaXRoVHJlZSA9IHJlcGxhY2VDaGlsZFdpdGhUcmVlO1xuRE9NTGF6eVRyZWUucXVldWVDaGlsZCA9IHF1ZXVlQ2hpbGQ7XG5ET01MYXp5VHJlZS5xdWV1ZUhUTUwgPSBxdWV1ZUhUTUw7XG5ET01MYXp5VHJlZS5xdWV1ZVRleHQgPSBxdWV1ZVRleHQ7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NTGF6eVRyZWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NTGF6eVRyZWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZ2V0TGlzdGVuZXIgPSBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcjtcblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhpbnN0LCAnRGlzcGF0Y2hpbmcgaW5zdCBtdXN0IG5vdCBiZSBudWxsJykgOiB2b2lkIDA7XG4gIH1cbiAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRpc3BhdGNoZXMgKG11c3QgYmUgZW50aXJlbHkgY29sbGVjdGVkIGJlZm9yZSBkaXNwYXRjaGluZyAtIHNlZSB1bml0XG4gKiB0ZXN0cykuIExhemlseSBhbGxvY2F0ZSB0aGUgYXJyYXkgdG8gY29uc2VydmUgbWVtb3J5LiAgV2UgbXVzdCBsb29wIHRocm91Z2hcbiAqIGVhY2ggZXZlbnQgYW5kIHBlcmZvcm0gdGhlIHRyYXZlcnNhbCBmb3IgZWFjaCBvbmUuIFdlIGNhbm5vdCBwZXJmb3JtIGFcbiAqIHNpbmdsZSB0cmF2ZXJzYWwgZm9yIHRoZSBlbnRpcmUgY29sbGVjdGlvbiBvZiBldmVudHMgYmVjYXVzZSBlYWNoIGV2ZW50IG1heVxuICogaGF2ZSBhIGRpZmZlcmVudCB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy50cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGV2ZW50Ll90YXJnZXRJbnN0O1xuICAgIHZhciBwYXJlbnRJbnN0ID0gdGFyZ2V0SW5zdCA/IEV2ZW50UGx1Z2luVXRpbHMuZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VUd29QaGFzZShwYXJlbnRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpbnN0LCBpZ25vcmVkRGlyZWN0aW9uLCBldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIEV2ZW50UGx1Z2luVXRpbHMudHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVudCBhXG4gKiBzaW5nbGUgb25lLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBFdmVudFByb3BhZ2F0b3JzXG4gKi9cbnZhciBFdmVudFByb3BhZ2F0b3JzID0ge1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXG4gIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQcm9wYWdhdG9ycztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luUmVnaXN0cnknKTtcbnZhciBFdmVudFBsdWdpblV0aWxzID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblV0aWxzJyk7XG52YXIgUmVhY3RFcnJvclV0aWxzID0gcmVxdWlyZSgnLi9SZWFjdEVycm9yVXRpbHMnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW50ZXJuYWwgc3RvcmUgZm9yIGV2ZW50IGxpc3RlbmVyc1xuICovXG52YXIgbGlzdGVuZXJCYW5rID0ge307XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgRXZlbnRQbHVnaW5VdGlscy5leGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCk7XG5cbiAgICBpZiAoIWV2ZW50LmlzUGVyc2lzdGVudCgpKSB7XG4gICAgICBldmVudC5jb25zdHJ1Y3Rvci5yZWxlYXNlKGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCB0cnVlKTtcbn07XG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIGZhbHNlKTtcbn07XG5cbnZhciBnZXREaWN0aW9uYXJ5S2V5ID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgLy8gUHJldmVudHMgVjggcGVyZm9ybWFuY2UgaXNzdWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzcyMzJcbiAgcmV0dXJuICcuJyArIGluc3QuX3Jvb3ROb2RlSUQ7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIEV2ZW50UGx1Z2luSHViID0ge1xuICAvKipcbiAgICogTWV0aG9kcyBmb3IgaW5qZWN0aW5nIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IEV2ZW50UGx1Z2luUmVnaXN0cnkuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3JlcyBgbGlzdGVuZXJgIGF0IGBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XWAuIElzIGlkZW1wb3RlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGNhbGxiYWNrIHRvIHN0b3JlLlxuICAgKi9cbiAgcHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IF9wcm9kSW52YXJpYW50KCc5NCcsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lcikgOiB2b2lkIDA7XG5cbiAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldID0gbGlzdGVuZXI7XG5cbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS5kaWRQdXRMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgLy8gVE9ETzogc2hvdWxkUHJldmVudE1vdXNlRXZlbnQgaXMgRE9NLXNwZWNpZmljIGFuZCBkZWZpbml0ZWx5IHNob3VsZCBub3RcbiAgICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QuX2N1cnJlbnRFbGVtZW50LnR5cGUsIGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIHJldHVybiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSAmJiBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtrZXldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcikge1xuICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbmV2ZXIgYmUgbnVsbCAtLSB3aGVuIGlzIGl0P1xuICAgIGlmIChiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgdmFyIGtleSA9IGdldERpY3Rpb25hcnlLZXkoaW5zdCk7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVba2V5XTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIERPTSBlbGVtZW50IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICAgKi9cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyQmFuay5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV1ba2V5XSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgUGx1Z2luTW9kdWxlLndpbGxEZWxldGVMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtrZXldO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICAgKiBuYXRpdmUgYnJvd3NlciBldmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIHBsdWdpbnMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nIGFuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiBfcHJvZEludmFyaWFudCgnOTUnKSA6IHZvaWQgMDtcbiAgICAvLyBUaGlzIHdvdWxkIGJlIGEgZ29vZCB0aW1lIHRvIHJldGhyb3cgaWYgYW55IG9mIHRoZSBldmVudCBoYW5kbGVycyB0aHJldy5cbiAgICBSZWFjdEVycm9yVXRpbHMucmV0aHJvd0NhdWdodEVycm9yKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZXNlIGFyZSBuZWVkZWQgZm9yIHRlc3RzIG9ubHkuIERvIG5vdCB1c2UhXG4gICAqL1xuICBfX3B1cmdlOiBmdW5jdGlvbiAoKSB7XG4gICAgbGlzdGVuZXJCYW5rID0ge307XG4gIH0sXG5cbiAgX19nZXRMaXN0ZW5lckJhbms6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbGlzdGVuZXJCYW5rO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luSHViLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC52aWV3KSB7XG4gICAgICByZXR1cm4gZXZlbnQudmlldztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgIGlmICh0YXJnZXQud2luZG93ID09PSB0YXJnZXQpIHtcbiAgICAgIC8vIHRhcmdldCBpcyBhIHdpbmRvdyBvYmplY3RcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgdmFyIGRvYyA9IHRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICBpZiAoZG9jKSB7XG4gICAgICByZXR1cm4gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuICB9LFxuICBkZXRhaWw6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5kZXRhaWwgfHwgMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVUlFdmVudCwgVUlFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljVUlFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqL1xuXG4vLyBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCBFUzY6IHZhciBSZWFjdEluc3RhbmNlTWFwID0gbmV3IE1hcCgpO1xuXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHtcbiAgLyoqXG4gICAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gICAqIHRyYW5zZm9ybSB0aGVzZSB0byBzdHJpbmdzIGZvciBJRSBzdXBwb3J0LiBXaGVuIHRoaXMgdHJhbnNmb3JtIGlzIGZ1bGx5XG4gICAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlO1xuICB9LFxuXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IHZhbHVlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbnN0YW5jZU1hcC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBhZGRMZWFkaW5nU2xhc2ggPSBleHBvcnRzLmFkZExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIGFkZExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aCA6ICcvJyArIHBhdGg7XG59O1xuXG52YXIgc3RyaXBMZWFkaW5nU2xhc2ggPSBleHBvcnRzLnN0cmlwTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbn07XG5cbnZhciBoYXNCYXNlbmFtZSA9IGV4cG9ydHMuaGFzQmFzZW5hbWUgPSBmdW5jdGlvbiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyhcXFxcL3xcXFxcP3wjfCQpJywgJ2knKS50ZXN0KHBhdGgpO1xufTtcblxudmFyIHN0cmlwQmFzZW5hbWUgPSBleHBvcnRzLnN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn07XG5cbnZhciBzdHJpcFRyYWlsaW5nU2xhc2ggPSBleHBvcnRzLnN0cmlwVHJhaWxpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwVHJhaWxpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdChwYXRoLmxlbmd0aCAtIDEpID09PSAnLycgPyBwYXRoLnNsaWNlKDAsIC0xKSA6IHBhdGg7XG59O1xuXG52YXIgcGFyc2VQYXRoID0gZXhwb3J0cy5wYXJzZVBhdGggPSBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBwYXRoIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn07XG5cbnZhciBjcmVhdGVQYXRoID0gZXhwb3J0cy5jcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgIGhhc2ggPSBsb2NhdGlvbi5oYXNoO1xuXG5cbiAgdmFyIHBhdGggPSBwYXRobmFtZSB8fCAnLyc7XG5cbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aCArPSBzZWFyY2guY2hhckF0KDApID09PSAnPycgPyBzZWFyY2ggOiAnPycgKyBzZWFyY2g7XG5cbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gJyMnKSBwYXRoICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcblxuICByZXR1cm4gcGF0aDtcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvUGF0aFV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgLy8gJEZsb3dGaXhNZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2FuRGVmaW5lUHJvcGVydHkuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5NicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTcnLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdID0gcGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCc5OCcsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiBfcHJvZEludmFyaWFudCgnOTknLCBldmVudE5hbWUpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIHJlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsIHJlZ2lzdHJhdGlvbk5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzEwMCcsIHJlZ2lzdHJhdGlvbk5hbWUpIDogdm9pZCAwO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XG4gIC8qKlxuICAgKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAgICovXG4gIHBsdWdpbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAgICovXG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczoge30sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gICAqL1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gICAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAgICogb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHt9IDogbnVsbCxcbiAgLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIF9fREVWX19cblxuICAvKipcbiAgICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICAgKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAgICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAaW50ZXJuYWxcbiAgICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBmdW5jdGlvbiAoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICAgISFldmVudFBsdWdpbk9yZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiBfcHJvZEludmFyaWFudCgnMTAxJykgOiB2b2lkIDA7XG4gICAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICAgIGV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICAgKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICAgKlxuICAgKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBmdW5jdGlvbiAoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IF9wcm9kSW52YXJpYW50KCcxMDInLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMb29rcyB1cCB0aGUgcGx1Z2luIGZvciB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBBIHN5bnRoZXRpYyBldmVudC5cbiAgICogQHJldHVybiB7P29iamVjdH0gVGhlIHBsdWdpbiB0aGF0IGNyZWF0ZWQgdGhlIHN1cHBsaWVkIGV2ZW50LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFBsdWdpbk1vZHVsZUZvckV2ZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSBldmVudC5kaXNwYXRjaENvbmZpZztcbiAgICBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgICAgcmV0dXJuIEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZV0gfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHB1bGxpbmcgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgb3V0IG9mIGRpc3BhdGNoQ29uZmlnIGhlbHBzIEZsb3cgc2VlXG4gICAgICAvLyB0aGF0IGl0IGlzIG5vdCB1bmRlZmluZWQuXG4gICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcblxuICAgICAgZm9yICh2YXIgcGhhc2UgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgICAgaWYgKCFwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1twaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xuICAgICAgICBpZiAocGx1Z2luTW9kdWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHBsdWdpbk1vZHVsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuICAgICAgZm9yICh2YXIgbG93ZXJDYXNlZE5hbWUgaW4gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgICBpZiAocG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgICAgICBkZWxldGUgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBPQlNFUlZFRF9FUlJPUiA9IHt9O1xuXG4vKipcbiAqIGBUcmFuc2FjdGlvbmAgY3JlYXRlcyBhIGJsYWNrIGJveCB0aGF0IGlzIGFibGUgdG8gd3JhcCBhbnkgbWV0aG9kIHN1Y2ggdGhhdFxuICogY2VydGFpbiBpbnZhcmlhbnRzIGFyZSBtYWludGFpbmVkIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1ldGhvZCBpcyBpbnZva2VkXG4gKiAoRXZlbiBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIHdoaWxlIGludm9raW5nIHRoZSB3cmFwcGVkIG1ldGhvZCkuIFdob2V2ZXJcbiAqIGluc3RhbnRpYXRlcyBhIHRyYW5zYWN0aW9uIGNhbiBwcm92aWRlIGVuZm9yY2VycyBvZiB0aGUgaW52YXJpYW50cyBhdFxuICogY3JlYXRpb24gdGltZS4gVGhlIGBUcmFuc2FjdGlvbmAgY2xhc3MgaXRzZWxmIHdpbGwgc3VwcGx5IG9uZSBhZGRpdGlvbmFsXG4gKiBhdXRvbWF0aWMgaW52YXJpYW50IGZvciB5b3UgLSB0aGUgaW52YXJpYW50IHRoYXQgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlXG4gKiBzaG91bGQgbm90IGJlIHJ1biB3aGlsZSBpdCBpcyBhbHJlYWR5IGJlaW5nIHJ1bi4gWW91IHdvdWxkIHR5cGljYWxseSBjcmVhdGUgYVxuICogc2luZ2xlIGluc3RhbmNlIG9mIGEgYFRyYW5zYWN0aW9uYCBmb3IgcmV1c2UgbXVsdGlwbGUgdGltZXMsIHRoYXQgcG90ZW50aWFsbHlcbiAqIGlzIHVzZWQgdG8gd3JhcCBzZXZlcmFsIGRpZmZlcmVudCBtZXRob2RzLiBXcmFwcGVycyBhcmUgZXh0cmVtZWx5IHNpbXBsZSAtXG4gKiB0aGV5IG9ubHkgcmVxdWlyZSBpbXBsZW1lbnRpbmcgdHdvIG1ldGhvZHMuXG4gKlxuICogPHByZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICB3cmFwcGVycyAoaW5qZWN0ZWQgYXQgY3JlYXRpb24gdGltZSlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICAgICAgICArXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLXwtLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICB2ICAgICAgICB8ICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICstLS0tLS0tLS0tLS0tLS0rICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICArLS18ICAgIHdyYXBwZXIxICAgfC0tLXwtLS0tKyAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgKy0tLS0tLS0tLS0tLS0tLSsgICB2ICAgIHwgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgICAgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICArLS0tLXwgICB3cmFwcGVyMiAgfC0tLS0tLS0tKyAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgfCAgICArLS0tLS0tLS0tLS0tLSsgIHwgICAgIHwgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgdiAgICAgdiAgIHwgd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgIHwgKy0tLSsgKy0tLSsgICArLS0tLS0tLS0tKyAgICstLS0rICstLS0rIHwgaW52YXJpYW50c1xuICogcGVyZm9ybShhbnlNZXRob2QpIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHwgbWFpbnRhaW5lZFxuICogKy0tLS0tLS0tLS0tLS0tLS0tPnwtfC0tLXwtfC0tLXwtLT58YW55TWV0aG9kfC0tLXwtLS18LXwtLS18LXwtLS0tLS0tLT5cbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgaW5pdGlhbGl6ZSAgICAgICAgICAgICAgICAgICAgY2xvc2UgICAgfFxuICogICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAqIDwvcHJlPlxuICpcbiAqIFVzZSBjYXNlczpcbiAqIC0gUHJlc2VydmluZyB0aGUgaW5wdXQgc2VsZWN0aW9uIHJhbmdlcyBiZWZvcmUvYWZ0ZXIgcmVjb25jaWxpYXRpb24uXG4gKiAgIFJlc3RvcmluZyBzZWxlY3Rpb24gZXZlbiBpbiB0aGUgZXZlbnQgb2YgYW4gdW5leHBlY3RlZCBlcnJvci5cbiAqIC0gRGVhY3RpdmF0aW5nIGV2ZW50cyB3aGlsZSByZWFycmFuZ2luZyB0aGUgRE9NLCBwcmV2ZW50aW5nIGJsdXJzL2ZvY3VzZXMsXG4gKiAgIHdoaWxlIGd1YXJhbnRlZWluZyB0aGF0IGFmdGVyd2FyZHMsIHRoZSBldmVudCBzeXN0ZW0gaXMgcmVhY3RpdmF0ZWQuXG4gKiAtIEZsdXNoaW5nIGEgcXVldWUgb2YgY29sbGVjdGVkIERPTSBtdXRhdGlvbnMgdG8gdGhlIG1haW4gVUkgdGhyZWFkIGFmdGVyIGFcbiAqICAgcmVjb25jaWxpYXRpb24gdGFrZXMgcGxhY2UgaW4gYSB3b3JrZXIgdGhyZWFkLlxuICogLSBJbnZva2luZyBhbnkgY29sbGVjdGVkIGBjb21wb25lbnREaWRVcGRhdGVgIGNhbGxiYWNrcyBhZnRlciByZW5kZXJpbmcgbmV3XG4gKiAgIGNvbnRlbnQuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBXcmFwcGluZyBwYXJ0aWN1bGFyIGZsdXNoZXMgb2YgdGhlIGBSZWFjdFdvcmtlcmAgcXVldWVcbiAqICAgdG8gcHJlc2VydmUgdGhlIGBzY3JvbGxUb3BgIChhbiBhdXRvbWF0aWMgc2Nyb2xsIGF3YXJlIERPTSkuXG4gKiAtIChGdXR1cmUgdXNlIGNhc2UpOiBMYXlvdXQgY2FsY3VsYXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgRE9NIHVwZGF0ZXMuXG4gKlxuICogVHJhbnNhY3Rpb25hbCBwbHVnaW4gQVBJOlxuICogLSBBIG1vZHVsZSB0aGF0IGhhcyBhbiBgaW5pdGlhbGl6ZWAgbWV0aG9kIHRoYXQgcmV0dXJucyBhbnkgcHJlY29tcHV0YXRpb24uXG4gKiAtIGFuZCBhIGBjbG9zZWAgbWV0aG9kIHRoYXQgYWNjZXB0cyB0aGUgcHJlY29tcHV0YXRpb24uIGBjbG9zZWAgaXMgaW52b2tlZFxuICogICB3aGVuIHRoZSB3cmFwcGVkIHByb2Nlc3MgaXMgY29tcGxldGVkLCBvciBoYXMgZmFpbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb25hbFdyYXBwZXI+fSB0cmFuc2FjdGlvbldyYXBwZXIgV3JhcHBlciBtb2R1bGVzXG4gKiB0aGF0IGltcGxlbWVudCBgaW5pdGlhbGl6ZWAgYW5kIGBjbG9zZWAuXG4gKiBAcmV0dXJuIHtUcmFuc2FjdGlvbn0gU2luZ2xlIHRyYW5zYWN0aW9uIGZvciByZXVzZSBpbiB0aHJlYWQuXG4gKlxuICogQGNsYXNzIFRyYW5zYWN0aW9uXG4gKi9cbnZhciBUcmFuc2FjdGlvbkltcGwgPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgaW5zdGFuY2Ugc28gdGhhdCBpdCBpcyBwcmVwYXJlZCBmb3IgY29sbGVjdGluZyBtZXRyaWNzLiBEb2VzXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxuICAgKiBUaGF0IGNhbiBiZSB1c2VmdWwgaWYgeW91IGRlY2lkZSB0byBtYWtlIHlvdXIgc3ViY2xhc3Mgb2YgdGhpcyBtaXhpbiBhXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cbiAgICovXG4gIHJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhKSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgfSxcblxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcblxuICBpc0luVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyogZXNsaW50LWRpc2FibGUgc3BhY2UtYmVmb3JlLWZ1bmN0aW9uLXBhcmVuICovXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBoZWxwcyBwcmV2ZW50IHRoZSBuZWVkXG4gICAqIHRvIGJpbmQgaW4gbWFueSBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGEgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBiIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYyBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGQgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBlIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIHNwYWNlLWJlZm9yZS1mdW5jdGlvbi1wYXJlbiAqL1xuICAgICEhdGhpcy5pc0luVHJhbnNhY3Rpb24oKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdUcmFuc2FjdGlvbi5wZXJmb3JtKC4uLik6IENhbm5vdCBpbml0aWFsaXplIGEgdHJhbnNhY3Rpb24gd2hlbiB0aGVyZSBpcyBhbHJlYWR5IGFuIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzI3JykgOiB2b2lkIDA7XG4gICAgdmFyIGVycm9yVGhyb3duO1xuICAgIHZhciByZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoXG4gICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgLy8gb25lIG9mIHRoZXNlIGNhbGxzIHRocmV3LlxuICAgICAgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdGhpcy5pbml0aWFsaXplQWxsKDApO1xuICAgICAgcmV0ID0gbWV0aG9kLmNhbGwoc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gSWYgYG1ldGhvZGAgdGhyb3dzLCBwcmVmZXIgdG8gc2hvdyB0aGF0IHN0YWNrIHRyYWNlIG92ZXIgYW55IHRocm93blxuICAgICAgICAgIC8vIGJ5IGludm9raW5nIGBjbG9zZUFsbGAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNpbmNlIGBtZXRob2RgIGRpZG4ndCB0aHJvdywgd2UgZG9uJ3Qgd2FudCB0byBzaWxlbmNlIHRoZSBleGNlcHRpb25cbiAgICAgICAgICAvLyBoZXJlLlxuICAgICAgICAgIHRoaXMuY2xvc2VBbGwoMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuX2lzSW5UcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9LFxuXG4gIGluaXRpYWxpemVBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB0cnkge1xuICAgICAgICAvLyBDYXRjaGluZyBlcnJvcnMgbWFrZXMgZGVidWdnaW5nIG1vcmUgZGlmZmljdWx0LCBzbyB3ZSBzdGFydCB3aXRoIHRoZVxuICAgICAgICAvLyBPQlNFUlZFRF9FUlJPUiBzdGF0ZSBiZWZvcmUgb3ZlcndyaXRpbmcgaXQgd2l0aCB0aGUgcmVhbCByZXR1cm4gdmFsdWVcbiAgICAgICAgLy8gb2YgaW5pdGlhbGl6ZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byBPQlNFUlZFRF9FUlJPUiBpbiB0aGUgZmluYWxseVxuICAgICAgICAvLyBibG9jaywgaXQgbWVhbnMgd3JhcHBlci5pbml0aWFsaXplIHRocmV3LlxuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IE9CU0VSVkVEX0VSUk9SO1xuICAgICAgICB0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9IHdyYXBwZXIuaW5pdGlhbGl6ZSA/IHdyYXBwZXIuaW5pdGlhbGl6ZS5jYWxsKHRoaXMpIDogbnVsbDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICh0aGlzLndyYXBwZXJJbml0RGF0YVtpXSA9PT0gT0JTRVJWRURfRVJST1IpIHtcbiAgICAgICAgICAvLyBUaGUgaW5pdGlhbGl6ZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgaW5pdGlhbGl6ZSB0aGVcbiAgICAgICAgICAvLyByZW1haW5pbmcgd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZVxuICAgICAgICAgIC8vIHRoYXQgdGhlIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVBbGwoaSArIDEpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBlYWNoIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuY2xvc2VbaV1gIGZ1bmN0aW9ucywgcGFzc2luZyBpbnRvXG4gICAqIHRoZW0gdGhlIHJlc3BlY3RpdmUgcmV0dXJuIHZhbHVlcyBvZiBgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzLmluaXRbaV1gXG4gICAqIChgY2xvc2VgcnMgdGhhdCBjb3JyZXNwb25kIHRvIGluaXRpYWxpemVycyB0aGF0IGZhaWxlZCB3aWxsIG5vdCBiZVxuICAgKiBpbnZva2VkKS5cbiAgICovXG4gIGNsb3NlQWxsOiBmdW5jdGlvbiAoc3RhcnRJbmRleCkge1xuICAgICF0aGlzLmlzSW5UcmFuc2FjdGlvbigpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyYW5zYWN0aW9uLmNsb3NlQWxsKCk6IENhbm5vdCBjbG9zZSB0cmFuc2FjdGlvbiB3aGVuIG5vbmUgYXJlIG9wZW4uJykgOiBfcHJvZEludmFyaWFudCgnMjgnKSA6IHZvaWQgMDtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHZhciBpbml0RGF0YSA9IHRoaXMud3JhcHBlckluaXREYXRhW2ldO1xuICAgICAgdmFyIGVycm9yVGhyb3duO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2F0Y2hpbmcgZXJyb3JzIG1ha2VzIGRlYnVnZ2luZyBtb3JlIGRpZmZpY3VsdCwgc28gd2Ugc3RhcnQgd2l0aFxuICAgICAgICAvLyBlcnJvclRocm93biBzZXQgdG8gdHJ1ZSBiZWZvcmUgc2V0dGluZyBpdCB0byBmYWxzZSBhZnRlciBjYWxsaW5nXG4gICAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAgIC8vIHdyYXBwZXIuY2xvc2UgdGhyZXcuXG4gICAgICAgIGVycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgaWYgKGluaXREYXRhICE9PSBPQlNFUlZFRF9FUlJPUiAmJiB3cmFwcGVyLmNsb3NlKSB7XG4gICAgICAgICAgd3JhcHBlci5jbG9zZS5jYWxsKHRoaXMsIGluaXREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgLy8gVGhlIGNsb3NlciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBjbG9zZSB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgLy8gd3JhcHBlcnMgYnV0IHNpbGVuY2UgYW55IGV4Y2VwdGlvbnMgZnJvbSB0aGVtIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAgICAgIC8vIGZpcnN0IGVycm9yIGlzIHRoZSBvbmUgdG8gYnViYmxlIHVwLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQWxsKGkgKyAxKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMud3JhcHBlckluaXREYXRhLmxlbmd0aCA9IDA7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNhY3Rpb25JbXBsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1RyYW5zYWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBWaWV3cG9ydE1ldHJpY3MgPSByZXF1aXJlKCcuL1ZpZXdwb3J0TWV0cmljcycpO1xuXG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIFdlYmtpdCwgRmlyZWZveCwgSUU5K1xuICAgIC8vIHdoaWNoOiAgMSAyIDNcbiAgICAvLyBidXR0b246IDAgMSAyIChzdGFuZGFyZClcbiAgICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICAgIGlmICgnd2hpY2gnIGluIGV2ZW50KSB7XG4gICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvLyBJRTw5XG4gICAgLy8gd2hpY2g6ICB1bmRlZmluZWRcbiAgICAvLyBidXR0b246IDAgMCAwXG4gICAgLy8gYnV0dG9uOiAxIDQgMiAob25tb3VzZXVwKVxuICAgIHJldHVybiBidXR0b24gPT09IDIgPyAyIDogYnV0dG9uID09PSA0ID8gMSA6IDA7XG4gIH0sXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfSxcbiAgLy8gXCJQcm9wcmlldGFyeVwiIEludGVyZmFjZS5cbiAgcGFnZVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVgnIGluIGV2ZW50ID8gZXZlbnQucGFnZVggOiBldmVudC5jbGllbnRYICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxMZWZ0O1xuICB9LFxuICBwYWdlWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdwYWdlWScgaW4gZXZlbnQgPyBldmVudC5wYWdlWSA6IGV2ZW50LmNsaWVudFkgKyBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbFRvcDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG5cbnZhciBXSElURVNQQUNFX1RFU1QgPSAvXlsgXFxyXFxuXFx0XFxmXS87XG52YXIgTk9OVklTSUJMRV9URVNUID0gLzwoIS0tfGxpbmt8bm9zY3JpcHR8bWV0YXxzY3JpcHR8c3R5bGUpWyBcXHJcXG5cXHRcXGZcXC8+XS87XG5cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gcmVxdWlyZSgnLi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uJyk7XG5cbi8vIFNWRyB0ZW1wIGNvbnRhaW5lciBmb3IgSUUgbGFja2luZyBpbm5lckhUTUxcbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lcjtcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAvLyB0aGUgdGFyZ2V0IG5vZGVcbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLnN2ZyAmJiAhKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU4OiBXaGVuIHVwZGF0aW5nIGEganVzdCBjcmVhdGVkIG5vZGUgd2l0aCBpbm5lckhUTUwgb25seSBsZWFkaW5nXG4gIC8vIHdoaXRlc3BhY2UgaXMgcmVtb3ZlZC4gV2hlbiB1cGRhdGluZyBhbiBleGlzdGluZyBub2RlIHdpdGggaW5uZXJIVE1MXG4gIC8vIHdoaXRlc3BhY2UgaW4gcm9vdCBUZXh0Tm9kZXMgaXMgYWxzbyBjb2xsYXBzZWQuXG4gIC8vIEBzZWUgcXVpcmtzbW9kZS5vcmcvYnVncmVwb3J0cy9hcmNoaXZlcy8yMDA0LzExL2lubmVyaHRtbF9hbmRfdC5odG1sXG5cbiAgLy8gRmVhdHVyZSBkZXRlY3Rpb247IG9ubHkgSUU4IGlzIGtub3duIHRvIGJlaGF2ZSBpbXByb3Blcmx5IGxpa2UgdGhpcy5cbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRlc3RFbGVtZW50LmlubmVySFRNTCA9ICcgJztcbiAgaWYgKHRlc3RFbGVtZW50LmlubmVySFRNTCA9PT0gJycpIHtcbiAgICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgICAgLy8gTWFnaWMgdGhlb3J5OiBJRTggc3VwcG9zZWRseSBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIGFkZGVkIGFuZCB1cGRhdGVkXG4gICAgICAvLyBub2RlcyB3aGVuIHByb2Nlc3NpbmcgaW5uZXJIVE1MLCBpbm5lckhUTUwgb24gdXBkYXRlZCBub2RlcyBzdWZmZXJzXG4gICAgICAvLyBmcm9tIHdvcnNlIHdoaXRlc3BhY2UgYmVoYXZpb3IuIFJlLWFkZGluZyBhIG5vZGUgbGlrZSB0aGlzIHRyaWdnZXJzXG4gICAgICAvLyB0aGUgaW5pdGlhbCBhbmQgbW9yZSBmYXZvcmFibGUgd2hpdGVzcGFjZSBiZWhhdmlvci5cbiAgICAgIC8vIFRPRE86IFdoYXQgdG8gZG8gb24gYSBkZXRhY2hlZCBub2RlP1xuICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIG5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBhbHNvIGltcGxlbWVudCBhIHdvcmthcm91bmQgZm9yIG5vbi12aXNpYmxlIHRhZ3MgZGlzYXBwZWFyaW5nIGludG9cbiAgICAgIC8vIHRoaW4gYWlyIG9uIElFOCwgdGhpcyBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSB0ZXh0XG4gICAgICAvLyBpbi1mcm9udCBvZiB0aGUgbm9uLXZpc2libGUgdGFncy4gUGlnZ3liYWNrIG9uIHRoZSB3aGl0ZXNwYWNlIGZpeFxuICAgICAgLy8gYW5kIHNpbXBseSBjaGVjayBpZiBhbnkgbm9uLXZpc2libGUgdGFncyBhcHBlYXIgaW4gdGhlIHNvdXJjZS5cbiAgICAgIGlmIChXSElURVNQQUNFX1RFU1QudGVzdChodG1sKSB8fCBodG1sWzBdID09PSAnPCcgJiYgTk9OVklTSUJMRV9URVNULnRlc3QoaHRtbCkpIHtcbiAgICAgICAgLy8gUmVjb3ZlciBsZWFkaW5nIHdoaXRlc3BhY2UgYnkgdGVtcG9yYXJpbHkgcHJlcGVuZGluZyBhbnkgY2hhcmFjdGVyLlxuICAgICAgICAvLyBcXHVGRUZGIGhhcyB0aGUgcG90ZW50aWFsIGFkdmFudGFnZSBvZiBiZWluZyB6ZXJvLXdpZHRoL2ludmlzaWJsZS5cbiAgICAgICAgLy8gVWdsaWZ5SlMgZHJvcHMgVStGRUZGIGNoYXJzIHdoZW4gcGFyc2luZywgc28gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGVcbiAgICAgICAgLy8gaW4gaG9wZXMgdGhhdCB0aGlzIGlzIHByZXNlcnZlZCBldmVuIGlmIFwiXFx1RkVGRlwiIGlzIHRyYW5zZm9ybWVkIHRvXG4gICAgICAgIC8vIHRoZSBhY3R1YWwgVW5pY29kZSBjaGFyYWN0ZXIgKGJ5IEJhYmVsLCBmb3IgZXhhbXBsZSkuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9taXNob28vVWdsaWZ5SlMyL2Jsb2IvdjIuNC4yMC9saWIvcGFyc2UuanMjTDIxNlxuICAgICAgICBub2RlLmlubmVySFRNTCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhmZWZmKSArIGh0bWw7XG5cbiAgICAgICAgLy8gZGVsZXRlRGF0YSBsZWF2ZXMgYW4gZW1wdHkgYFRleHROb2RlYCB3aGljaCBvZmZzZXRzIHRoZSBpbmRleCBvZiBhbGxcbiAgICAgICAgLy8gY2hpbGRyZW4uIERlZmluaXRlbHkgd2FudCB0byBhdm9pZCB0aGlzLlxuICAgICAgICB2YXIgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICh0ZXh0Tm9kZS5kYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlLmRlbGV0ZURhdGEoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvc2V0SW5uZXJIVE1MLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNi1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQmFzZWQgb24gdGhlIGVzY2FwZS1odG1sIGxpYnJhcnksIHdoaWNoIGlzIHVzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIGJlbG93OlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDEzIFRKIEhvbG93YXljaHVrXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQW5kcmVhcyBMdWJiZVxuICogQ29weXJpZ2h0IChjKSAyMDE1IFRpYW5jaGVuZyBcIlRpbW90aHlcIiBHdVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiAnU29mdHdhcmUnKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuICogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbiAqIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG4gKiBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuICogU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG5cbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGh0bWwuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUgZm9yIGluc2VydGluZyBpbnRvIEhUTUxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG4gIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgZXNjYXBlO1xuICB2YXIgaHRtbCA9ICcnO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgLy8gJ1xuICAgICAgICBlc2NhcGUgPSAnJiN4Mjc7JzsgLy8gbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbDsgdXNlZCB0byBiZSAnJiMzOSdcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICAvLyA+XG4gICAgICAgIGVzY2FwZSA9ICcmZ3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudEVtaXR0ZXJNaXhpbicpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSA9IHJlcXVpcmUoJy4vZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdEV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnQgcGx1Z2dhYmxlXG4gKiAgICBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqICAtIFdlIG5vcm1hbGl6ZSBhbmQgZGUtZHVwbGljYXRlIGV2ZW50cyB0byBhY2NvdW50IGZvciBicm93c2VyIHF1aXJrcy4gVGhpc1xuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXG4gKlxuICogIC0gRm9yd2FyZCB0aGVzZSBuYXRpdmUgZXZlbnRzICh3aXRoIHRoZSBhc3NvY2lhdGVkIHRvcC1sZXZlbCB0eXBlIHVzZWQgdG9cbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXG4gKlxuICogT3ZlcnZpZXcgb2YgUmVhY3QgYW5kIHRoZSBldmVudCBzeXN0ZW06XG4gKlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCAgICBET00gICAgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogICAgICAgfCAgICAgICAgICAgLlxuICogICAgICAgdiAgICAgICAgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxuICogfCAgTGlzdGVuZXIgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICB8ICAgICAgICAgfFBsdWdpbiAgICAgfFxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnxFdmVudFBsdWdpbkh1YnwgICAgICAgICAgICAgICAgICAgIHwgICAgRXZlbnQgICB8XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XG4gKiB8ICBFbWl0dGVyICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHw8LS0tK3xQbHVnaW4gICAgIHwgIHxvdGhlciBwbHVnaW58XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLStcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XG4gKiAgICAgICArICAgICAgICAgICAuICAgICAgICAgICAgICAgICstLS0tLS0tK3xQbHVnaW4gICAgIHxcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxuICogfC0tLS0tLS0tLS0tLS18ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogKy0tLS0tLS0tLS0tLS0rICAgLlxuICogICAgICAgICAgICAgICAgICAgLlxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cbiAqL1xuXG52YXIgaGFzRXZlbnRQYWdlWFk7XG52YXIgYWxyZWFkeUxpc3RlbmluZ1RvID0ge307XG52YXIgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSBmYWxzZTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vLyBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhXG4vLyBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGVcbi8vIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZVxudmFyIHRvcEV2ZW50TWFwcGluZyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyBTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpIHtcbiAgLy8gSW4gSUU4LCBgbW91bnRBdGAgaXMgYSBob3N0IG9iamVjdCBhbmQgZG9lc24ndCBoYXZlIGBoYXNPd25Qcm9wZXJ0eWBcbiAgLy8gZGlyZWN0bHkuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vdW50QXQsIHRvcExpc3RlbmVyc0lES2V5KSkge1xuICAgIG1vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldID0gcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyKys7XG4gICAgYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXSA9IHt9O1xuICB9XG4gIHJldHVybiBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dO1xufVxuXG4vKipcbiAqIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGlzIHVzZWQgdG8gYXR0YWNoIHRvcC1sZXZlbCBldmVudCBsaXN0ZW5lcnMuIEZvclxuICogZXhhbXBsZTpcbiAqXG4gKiAgIEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyKCdteUlEJywgJ29uQ2xpY2snLCBteUZ1bmN0aW9uKTtcbiAqXG4gKiBUaGlzIHdvdWxkIGFsbG9jYXRlIGEgXCJyZWdpc3RyYXRpb25cIiBvZiBgKCdvbkNsaWNrJywgbXlGdW5jdGlvbilgIG9uICdteUlEJy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IF9hc3NpZ24oe30sIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4sIHtcbiAgLyoqXG4gICAqIEluamVjdGFibGUgZXZlbnQgYmFja2VuZFxuICAgKi9cbiAgUmVhY3RFdmVudExpc3RlbmVyOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAgICAgKi9cbiAgICBpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIChSZWFjdEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIFJlYWN0RXZlbnRMaXN0ZW5lci5zZXRIYW5kbGVUb3BMZXZlbChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaGFuZGxlVG9wTGV2ZWwpO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciA9IFJlYWN0RXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgd2hldGhlciBvciBub3QgYW55IGNyZWF0ZWQgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgVHJ1ZSBpZiBjYWxsYmFja3Mgc2hvdWxkIGJlIGVuYWJsZWQuXG4gICAqL1xuICBzZXRFbmFibGVkOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgIGlmIChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnNldEVuYWJsZWQoZW5hYmxlZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGNhbGxiYWNrcyBhcmUgZW5hYmxlZC5cbiAgICovXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIShSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyICYmIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuaXNFbmFibGVkKCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gICAqXG4gICAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAgICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAgICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAgICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gICAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAgICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAgICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gICAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAgKlxuICAgKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gICAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gICAqL1xuICBsaXN0ZW5UbzogZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICAgIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICAgIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BXaGVlbCcpIHtcbiAgICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBuZWVkcyB0byBjYXB0dXJlIGEgZGlmZmVyZW50IG1vdXNlIHNjcm9sbCBldmVudC5cbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3Njcm9sbCcsIHRydWUpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wU2Nyb2xsJywgJ3Njcm9sbCcsIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIuV0lORE9XX0hBTkRMRSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KCd0b3BCbHVyJywgJ2JsdXInLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xuICAgICAgICAgICAgLy8gSUUgaGFzIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudHMgd2hpY2ggYnViYmxlLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEZvY3VzJywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wQmx1cicsICdmb2N1c291dCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nLnRvcEZvY3VzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BFdmVudE1hcHBpbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm90ZWN0IGFnYWluc3QgZG9jdW1lbnQuY3JlYXRlRXZlbnQoKSByZXR1cm5pbmcgbnVsbFxuICAgKiBTb21lIHBvcHVwIGJsb2NrZXIgZXh0ZW5zaW9ucyBhcHBlYXIgdG8gZG8gdGhpczpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy82ODg3XG4gICAqL1xuICBzdXBwb3J0c0V2ZW50UGFnZVhZOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudCcpO1xuICAgIHJldHVybiBldiAhPSBudWxsICYmICdwYWdlWCcgaW4gZXY7XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbnMgdG8gd2luZG93IHNjcm9sbCBhbmQgcmVzaXplIGV2ZW50cy4gV2UgY2FjaGUgc2Nyb2xsIHZhbHVlcyBzbyB0aGF0XG4gICAqIGFwcGxpY2F0aW9uIGNvZGUgY2FuIGFjY2VzcyB0aGVtIHdpdGhvdXQgdHJpZ2dlcmluZyByZWZsb3dzLlxuICAgKlxuICAgKiBWaWV3cG9ydE1ldHJpY3MgaXMgb25seSB1c2VkIGJ5IFN5bnRoZXRpY01vdXNlL1RvdWNoRXZlbnQgYW5kIG9ubHkgd2hlblxuICAgKiBwYWdlWC9wYWdlWSBpc24ndCBzdXBwb3J0ZWQgKGxlZ2FjeSBicm93c2VycykuXG4gICAqXG4gICAqIE5PVEU6IFNjcm9sbCBldmVudHMgZG8gbm90IGJ1YmJsZS5cbiAgICpcbiAgICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvc2Nyb2xsLmh0bWxcbiAgICovXG4gIGVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmIChoYXNFdmVudFBhZ2VYWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBoYXNFdmVudFBhZ2VYWSA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zdXBwb3J0c0V2ZW50UGFnZVhZKCk7XG4gICAgfVxuICAgIGlmICghaGFzRXZlbnRQYWdlWFkgJiYgIWlzTW9uaXRvcmluZ1Njcm9sbFZhbHVlKSB7XG4gICAgICB2YXIgcmVmcmVzaCA9IFZpZXdwb3J0TWV0cmljcy5yZWZyZXNoU2Nyb2xsVmFsdWVzO1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5tb25pdG9yU2Nyb2xsVmFsdWUocmVmcmVzaCk7XG4gICAgICBpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvbG93UHJpb3JpdHlXYXJuaW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEluamVjdGVkIGRlcGVuZGVuY2llczpcbiAqL1xuXG4vKipcbiAqIC0gYENvbXBvbmVudFRyZWVgOiBbcmVxdWlyZWRdIE1vZHVsZSB0aGF0IGNhbiBjb252ZXJ0IGJldHdlZW4gUmVhY3QgaW5zdGFuY2VzXG4gKiAgIGFuZCBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICovXG52YXIgQ29tcG9uZW50VHJlZTtcbnZhciBUcmVlVHJhdmVyc2FsO1xudmFyIGluamVjdGlvbiA9IHtcbiAgaW5qZWN0Q29tcG9uZW50VHJlZTogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgQ29tcG9uZW50VHJlZSA9IEluamVjdGVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZCAmJiBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlICYmIEluamVjdGVkLmdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgaW5qZWN0VHJlZVRyYXZlcnNhbDogZnVuY3Rpb24gKEluamVjdGVkKSB7XG4gICAgVHJlZVRyYXZlcnNhbCA9IEluamVjdGVkO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhJbmplY3RlZCAmJiBJbmplY3RlZC5pc0FuY2VzdG9yICYmIEluamVjdGVkLmdldExvd2VzdENvbW1vbkFuY2VzdG9yLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0VHJlZVRyYXZlcnNhbCguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGlzQW5jZXN0b3Igb3IgZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IuJykgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpc0VuZGlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlVXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoRW5kJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BUb3VjaENhbmNlbCc7XG59XG5cbmZ1bmN0aW9uIGlzTW92ZWlzaCh0b3BMZXZlbFR5cGUpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlTW92ZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wVG91Y2hNb3ZlJztcbn1cbmZ1bmN0aW9uIGlzU3RhcnRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZURvd24nIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcFRvdWNoU3RhcnQnO1xufVxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XG4gICAgdmFyIGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoIDogZGlzcGF0Y2hJbnN0YW5jZXMgPyAxIDogMDtcblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gRXZlbnRQbHVnaW5VdGlscy5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaCh0eXBlLCBsaXN0ZW5lciwgZXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sodHlwZSwgbGlzdGVuZXIsIGV2ZW50KTtcbiAgfVxuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSW5zdGFuY2VzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaEluc3RhbmNlc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSW5zdGFuY2VzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJbnN0YW5jZXMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2UgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogX3Byb2RJbnZhcmlhbnQoJzEwMycpIDogdm9pZCAwO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZGlzcGF0Y2hMaXN0ZW5lciA/IEV2ZW50UGx1Z2luVXRpbHMuZ2V0Tm9kZUZyb21JbnN0YW5jZShkaXNwYXRjaEluc3RhbmNlKSA6IG51bGw7XG4gIHZhciByZXMgPSBkaXNwYXRjaExpc3RlbmVyID8gZGlzcGF0Y2hMaXN0ZW5lcihldmVudCkgOiBudWxsO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cbmZ1bmN0aW9uIGhhc0Rpc3BhdGNoZXMoZXZlbnQpIHtcbiAgcmV0dXJuICEhZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xufVxuXG4vKipcbiAqIEdlbmVyYWwgdXRpbGl0aWVzIHRoYXQgYXJlIHVzZWZ1bCBpbiBjcmVhdGluZyBjdXN0b20gRXZlbnQgUGx1Z2lucy5cbiAqL1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSB7XG4gIGlzRW5kaXNoOiBpc0VuZGlzaCxcbiAgaXNNb3ZlaXNoOiBpc01vdmVpc2gsXG4gIGlzU3RhcnRpc2g6IGlzU3RhcnRpc2gsXG5cbiAgZXhlY3V0ZURpcmVjdERpc3BhdGNoOiBleGVjdXRlRGlyZWN0RGlzcGF0Y2gsXG4gIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcjogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlOiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlLFxuICBoYXNEaXNwYXRjaGVzOiBoYXNEaXNwYXRjaGVzLFxuXG4gIGdldEluc3RhbmNlRnJvbU5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIENvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKTtcbiAgfSxcbiAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKG5vZGUpO1xuICB9LFxuICBpc0FuY2VzdG9yOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmlzQW5jZXN0b3IoYSwgYik7XG4gIH0sXG4gIGdldExvd2VzdENvbW1vbkFuY2VzdG9yOiBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLmdldExvd2VzdENvbW1vbkFuY2VzdG9yKGEsIGIpO1xuICB9LFxuICBnZXRQYXJlbnRJbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICByZXR1cm4gVHJlZVRyYXZlcnNhbC5nZXRQYXJlbnRJbnN0YW5jZShpbnN0KTtcbiAgfSxcbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24gKHRhcmdldCwgZm4sIGFyZykge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLnRyYXZlcnNlVHdvUGhhc2UodGFyZ2V0LCBmbiwgYXJnKTtcbiAgfSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiBmdW5jdGlvbiAoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICAgIHJldHVybiBUcmVlVHJhdmVyc2FsLnRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKTtcbiAgfSxcblxuICBpbmplY3Rpb246IGluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFBsdWdpblV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbi8qKlxuICogQ2FsbCBhIGZ1bmN0aW9uIHdoaWxlIGd1YXJkaW5nIGFnYWluc3QgZXJyb3JzIHRoYXQgaGFwcGVucyB3aXRoaW4gaXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICogQHBhcmFtIHsqfSBhIEZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0geyp9IGIgU2Vjb25kIGFyZ3VtZW50XG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFjayhuYW1lLCBmdW5jLCBhKSB7XG4gIHRyeSB7XG4gICAgZnVuYyhhKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIGlmIChjYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgY2F1Z2h0RXJyb3IgPSB4O1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RFcnJvclV0aWxzID0ge1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGludm9rZUd1YXJkZWRDYWxsYmFjayxcblxuICAvKipcbiAgICogSW52b2tlZCBieSBSZWFjdFRlc3RVdGlscy5TaW11bGF0ZSBzbyB0aGF0IGFueSBlcnJvcnMgdGhyb3duIGJ5IHRoZSBldmVudFxuICAgKiBoYW5kbGVyIGFyZSBzdXJlIHRvIGJlIHJldGhyb3duIGJ5IHJldGhyb3dDYXVnaHRFcnJvci5cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja1dpdGhDYXRjaDogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhdWdodEVycm9yKSB7XG4gICAgICB2YXIgZXJyb3IgPSBjYXVnaHRFcnJvcjtcbiAgICAgIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxufTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLyoqXG4gICAqIFRvIGhlbHAgZGV2ZWxvcG1lbnQgd2UgY2FuIGdldCBiZXR0ZXIgZGV2dG9vbHMgaW50ZWdyYXRpb24gYnkgc2ltdWxhdGluZyBhXG4gICAqIHJlYWwgYnJvd3NlciBldmVudC5cbiAgICovXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgYSkge1xuICAgICAgdmFyIGJvdW5kRnVuYyA9IGZ1bmMuYmluZChudWxsLCBhKTtcbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyBuYW1lO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgYm91bmRGdW5jLCBmYWxzZSk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RXJyb3JVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEVycm9yVXRpbHMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG5cbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuICBpZiAodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuICB9XG5cbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gMyA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50VGFyZ2V0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFdmVudFN1cHBvcnRlZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9pc0V2ZW50U3VwcG9ydGVkLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudE1vZGlmaWVyU3RhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0RXZlbnRNb2RpZmllclN0YXRlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTUxhenlUcmVlID0gcmVxdWlyZSgnLi9ET01MYXp5VHJlZScpO1xudmFyIERhbmdlciA9IHJlcXVpcmUoJy4vRGFuZ2VyJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSByZXF1aXJlKCcuL2NyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24nKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xuXG5mdW5jdGlvbiBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgbm9kZSkge1xuICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRleHQgY29tcG9uZW50cywgd2hpY2ggcmV0dXJuIFtvcGVuLCBjbG9zZV0gY29tbWVudHNcbiAgLy8gZnJvbSBnZXRIb3N0Tm9kZS5cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZVsxXTtcbiAgfVxuICByZXR1cm4gbm9kZSA/IG5vZGUubmV4dFNpYmxpbmcgOiBwYXJlbnROb2RlLmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBgY2hpbGROb2RlYCBhcyBhIGNoaWxkIG9mIGBwYXJlbnROb2RlYCBhdCB0aGUgYGluZGV4YC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHBhcmVudE5vZGUgUGFyZW50IG5vZGUgaW4gd2hpY2ggdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjaGlsZE5vZGUgQ2hpbGQgbm9kZSB0byBpbnNlcnQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gaW5zZXJ0IHRoZSBjaGlsZC5cbiAqIEBpbnRlcm5hbFxuICovXG52YXIgaW5zZXJ0Q2hpbGRBdCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAvLyBXZSByZWx5IGV4Y2x1c2l2ZWx5IG9uIGBpbnNlcnRCZWZvcmUobm9kZSwgbnVsbClgIGluc3RlYWQgb2YgYWxzbyB1c2luZ1xuICAvLyBgYXBwZW5kQ2hpbGQobm9kZSlgLiAoVXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsIGJyb3dzZXJzIHNvXG4gIC8vIHdlIGFyZSBjYXJlZnVsIHRvIHVzZSBgbnVsbGAuKVxuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xufSk7XG5cbmZ1bmN0aW9uIGluc2VydExhenlUcmVlQ2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpIHtcbiAgRE9NTGF6eVRyZWUuaW5zZXJ0VHJlZUJlZm9yZShwYXJlbnROb2RlLCBjaGlsZFRyZWUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgY2hpbGROb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkTm9kZSkpIHtcbiAgICBtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBjaGlsZE5vZGVbMF0sIGNoaWxkTm9kZVsxXSwgcmVmZXJlbmNlTm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZE5vZGUpKSB7XG4gICAgdmFyIGNsb3NpbmdDb21tZW50ID0gY2hpbGROb2RlWzFdO1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZVswXTtcbiAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIGNoaWxkTm9kZSwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvc2luZ0NvbW1lbnQpO1xuICB9XG4gIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGROb2RlKTtcbn1cblxuZnVuY3Rpb24gbW92ZURlbGltaXRlZFRleHQocGFyZW50Tm9kZSwgb3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCByZWZlcmVuY2VOb2RlKSB7XG4gIHZhciBub2RlID0gb3BlbmluZ0NvbW1lbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICBpbnNlcnRDaGlsZEF0KHBhcmVudE5vZGUsIG5vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICAgIGlmIChub2RlID09PSBjbG9zaW5nQ29tbWVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIHN0YXJ0Tm9kZSwgY2xvc2luZ0NvbW1lbnQpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZS5uZXh0U2libGluZztcbiAgICBpZiAobm9kZSA9PT0gY2xvc2luZ0NvbW1lbnQpIHtcbiAgICAgIC8vIFRoZSBjbG9zaW5nIGNvbW1lbnQgaXMgcmVtb3ZlZCBieSBSZWFjdE11bHRpQ2hpbGQuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGFjZURlbGltaXRlZFRleHQob3BlbmluZ0NvbW1lbnQsIGNsb3NpbmdDb21tZW50LCBzdHJpbmdUZXh0KSB7XG4gIHZhciBwYXJlbnROb2RlID0gb3BlbmluZ0NvbW1lbnQucGFyZW50Tm9kZTtcbiAgdmFyIG5vZGVBZnRlckNvbW1lbnQgPSBvcGVuaW5nQ29tbWVudC5uZXh0U2libGluZztcbiAgaWYgKG5vZGVBZnRlckNvbW1lbnQgPT09IGNsb3NpbmdDb21tZW50KSB7XG4gICAgLy8gVGhlcmUgYXJlIG5vIHRleHQgbm9kZXMgYmV0d2VlbiB0aGUgb3BlbmluZyBhbmQgY2xvc2luZyBjb21tZW50czsgaW5zZXJ0XG4gICAgLy8gYSBuZXcgb25lIGlmIHN0cmluZ1RleHQgaXNuJ3QgZW1wdHkuXG4gICAgaWYgKHN0cmluZ1RleHQpIHtcbiAgICAgIGluc2VydENoaWxkQXQocGFyZW50Tm9kZSwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nVGV4dCksIG5vZGVBZnRlckNvbW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoc3RyaW5nVGV4dCkge1xuICAgICAgLy8gU2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIGZpcnN0IG5vZGUgYWZ0ZXIgdGhlIG9wZW5pbmcgY29tbWVudCwgYW5kXG4gICAgICAvLyByZW1vdmUgYWxsIGZvbGxvd2luZyBub2RlcyB1cCB1bnRpbCB0aGUgY2xvc2luZyBjb21tZW50LlxuICAgICAgc2V0VGV4dENvbnRlbnQobm9kZUFmdGVyQ29tbWVudCwgc3RyaW5nVGV4dCk7XG4gICAgICByZW1vdmVEZWxpbWl0ZWRUZXh0KHBhcmVudE5vZGUsIG5vZGVBZnRlckNvbW1lbnQsIGNsb3NpbmdDb21tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlRGVsaW1pdGVkVGV4dChwYXJlbnROb2RlLCBvcGVuaW5nQ29tbWVudCwgY2xvc2luZ0NvbW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShvcGVuaW5nQ29tbWVudCkuX2RlYnVnSUQsXG4gICAgICB0eXBlOiAncmVwbGFjZSB0ZXh0JyxcbiAgICAgIHBheWxvYWQ6IHN0cmluZ1RleHRcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwLCBwcmV2SW5zdGFuY2UpIHtcbiAgICBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgaWYgKHByZXZJbnN0YW5jZS5fZGVidWdJRCAhPT0gMCkge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IHByZXZJbnN0YW5jZS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlcGxhY2Ugd2l0aCcsXG4gICAgICAgIHBheWxvYWQ6IG1hcmt1cC50b1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG1hcmt1cC5ub2RlKTtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2UuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgaW5zdGFuY2VJRDogbmV4dEluc3RhbmNlLl9kZWJ1Z0lELFxuICAgICAgICAgIHR5cGU6ICdtb3VudCcsXG4gICAgICAgICAgcGF5bG9hZDogbWFya3VwLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cDogZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXG5cbiAgcmVwbGFjZURlbGltaXRlZFRleHQ6IHJlcGxhY2VEZWxpbWl0ZWRUZXh0LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLiBUaGVcbiAgICogdXBkYXRlIGNvbmZpZ3VyYXRpb25zIGFyZSBlYWNoIGV4cGVjdGVkIHRvIGhhdmUgYSBgcGFyZW50Tm9kZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzVXBkYXRlczogZnVuY3Rpb24gKHBhcmVudE5vZGUsIHVwZGF0ZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudE5vZGVEZWJ1Z0lEID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocGFyZW50Tm9kZSkuX2RlYnVnSUQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICB2YXIgdXBkYXRlID0gdXBkYXRlc1trXTtcbiAgICAgIHN3aXRjaCAodXBkYXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnSU5TRVJUX01BUktVUCc6XG4gICAgICAgICAgaW5zZXJ0TGF6eVRyZWVDaGlsZEF0KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50LCBnZXROb2RlQWZ0ZXIocGFyZW50Tm9kZSwgdXBkYXRlLmFmdGVyTm9kZSkpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdpbnNlcnQgY2hpbGQnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgdG9JbmRleDogdXBkYXRlLnRvSW5kZXgsXG4gICAgICAgICAgICAgICAgY29udGVudDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ01PVkVfRVhJU1RJTkcnOlxuICAgICAgICAgIG1vdmVDaGlsZChwYXJlbnROb2RlLCB1cGRhdGUuZnJvbU5vZGUsIGdldE5vZGVBZnRlcihwYXJlbnROb2RlLCB1cGRhdGUuYWZ0ZXJOb2RlKSk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICAgICAgICBpbnN0YW5jZUlEOiBwYXJlbnROb2RlRGVidWdJRCxcbiAgICAgICAgICAgICAgdHlwZTogJ21vdmUgY2hpbGQnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiB7IGZyb21JbmRleDogdXBkYXRlLmZyb21JbmRleCwgdG9JbmRleDogdXBkYXRlLnRvSW5kZXggfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTRVRfTUFSS1VQJzpcbiAgICAgICAgICBzZXRJbm5lckhUTUwocGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgICAgICAgaW5zdGFuY2VJRDogcGFyZW50Tm9kZURlYnVnSUQsXG4gICAgICAgICAgICAgIHR5cGU6ICdyZXBsYWNlIGNoaWxkcmVuJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdURVhUX0NPTlRFTlQnOlxuICAgICAgICAgIHNldFRleHRDb250ZW50KHBhcmVudE5vZGUsIHVwZGF0ZS5jb250ZW50KTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVwbGFjZSB0ZXh0JyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLmNvbnRlbnQudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdSRU1PVkVfTk9ERSc6XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSwgdXBkYXRlLmZyb21Ob2RlKTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgIGluc3RhbmNlSUQ6IHBhcmVudE5vZGVEZWJ1Z0lELFxuICAgICAgICAgICAgICB0eXBlOiAncmVtb3ZlIGNoaWxkJyxcbiAgICAgICAgICAgICAgcGF5bG9hZDogeyBmcm9tSW5kZXg6IHVwZGF0ZS5mcm9tSW5kZXggfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTU5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcbiAgbWF0aG1sOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCcsXG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01OYW1lc3BhY2VzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0RPTU5hbWVzcGFjZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cblxudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9jcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIHByb3BUeXBlc0ZhY3RvcnkgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2ZhY3RvcnknKTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Jyk7XG52YXIgUHJvcFR5cGVzID0gcHJvcFR5cGVzRmFjdG9yeShSZWFjdC5pc1ZhbGlkRWxlbWVudCk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgaGFzUmVhZE9ubHlWYWx1ZSA9IHtcbiAgYnV0dG9uOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgaW1hZ2U6IHRydWUsXG4gIGhpZGRlbjogdHJ1ZSxcbiAgcmFkaW86IHRydWUsXG4gIHJlc2V0OiB0cnVlLFxuICBzdWJtaXQ6IHRydWVcbn07XG5cbmZ1bmN0aW9uIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpIHtcbiAgIShpbnB1dFByb3BzLmNoZWNrZWRMaW5rID09IG51bGwgfHwgaW5wdXRQcm9wcy52YWx1ZUxpbmsgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSB2YWx1ZUxpbmsuIElmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogX3Byb2RJbnZhcmlhbnQoJzg3JykgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpIHtcbiAgX2Fzc2VydFNpbmdsZUxpbmsoaW5wdXRQcm9wcyk7XG4gICEoaW5wdXRQcm9wcy52YWx1ZSA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSB2YWx1ZUxpbmsgYW5kIGEgdmFsdWUgb3Igb25DaGFuZ2UgZXZlbnQuIElmIHlvdSB3YW50IHRvIHVzZSB2YWx1ZSBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rLicpIDogX3Byb2RJbnZhcmlhbnQoJzg4JykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiBJZiB5b3Ugd2FudCB0byB1c2UgY2hlY2tlZCBvciBvbkNoYW5nZSwgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgY2hlY2tlZExpbmsnKSA6IF9wcm9kSW52YXJpYW50KCc4OScpIDogdm9pZCAwO1xufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXG59O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gKi9cbnZhciBMaW5rZWRWYWx1ZVV0aWxzID0ge1xuICBjaGVja1Byb3BUeXBlczogZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBvd25lcikge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIHRhZ05hbWUsICdwcm9wJywgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGFkZGVuZHVtID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKTtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgZm9ybSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHsqfSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCBlaXRoZXIgZnJvbSB2YWx1ZSBwcm9wIG9yIGxpbmsuXG4gICAqL1xuICBnZXRWYWx1ZTogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy52YWx1ZUxpbmspIHtcbiAgICAgIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZUxpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCBjaGVja2VkIHN0YXR1cyBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gY2hlY2tlZCBwcm9wXG4gICAqICAgICAgICAgICAgIG9yIGxpbmsuXG4gICAqL1xuICBnZXRDaGVja2VkOiBmdW5jdGlvbiAoaW5wdXRQcm9wcykge1xuICAgIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IGNoYW5nZSBldmVudCB0byBoYW5kbGVcbiAgICovXG4gIGV4ZWN1dGVPbkNoYW5nZTogZnVuY3Rpb24gKGlucHV0UHJvcHMsIGV2ZW50KSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMuY2hlY2tlZExpbmspIHtcbiAgICAgIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWRMaW5rLnJlcXVlc3RDaGFuZ2UoZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQcm9wcy5vbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMub25DaGFuZ2UuY2FsbCh1bmRlZmluZWQsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkVmFsdWVVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9MaW5rZWRWYWx1ZVV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbmplY3RlZCA9IGZhbHNlO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHtcbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBzd2FwcGluZyBvdXQgbW91bnQgaW1hZ2VzIGluIHRoZSBtaWRkbGUgb2ZcbiAgICogdGhlIHRyZWUuXG4gICAqL1xuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBwcm9jZXNzaW5nIGEgcXVldWUgb2YgY2hpbGQgdXBkYXRlcy4gV2lsbFxuICAgKiBsYXRlciBtb3ZlIGludG8gTXVsdGlDaGlsZENvbXBvbmVudHMuXG4gICAqL1xuICBwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBudWxsLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVudmlyb25tZW50OiBmdW5jdGlvbiAoZW52aXJvbm1lbnQpIHtcbiAgICAgICEhaW5qZWN0ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQ6IGluamVjdEVudmlyb25tZW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuJykgOiBfcHJvZEludmFyaWFudCgnMTA0JykgOiB2b2lkIDA7XG4gICAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cCA9IGVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyA9IGVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXM7XG4gICAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIC8vIEFkZGVkIHRoZSBub256ZXJvIHkgY2hlY2sgdG8gbWFrZSBGbG93IGhhcHB5LCBidXQgaXQgaXMgcmVkdW5kYW50XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYSBgcHJldkVsZW1lbnRgIGFuZCBgbmV4dEVsZW1lbnRgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcbiAqIGluc3RhbmNlLiBCb3RoIGFyZ3VtZW50cyBhcmUgZWxlbWVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoaXMgbG9naWMgY2FuXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJldkVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dEVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxuICogQHByb3RlY3RlZFxuICovXG5cbmZ1bmN0aW9uIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICB2YXIgcHJldkVtcHR5ID0gcHJldkVsZW1lbnQgPT09IG51bGwgfHwgcHJldkVsZW1lbnQgPT09IGZhbHNlO1xuICB2YXIgbmV4dEVtcHR5ID0gbmV4dEVsZW1lbnQgPT09IG51bGwgfHwgbmV4dEVsZW1lbnQgPT09IGZhbHNlO1xuICBpZiAocHJldkVtcHR5IHx8IG5leHRFbXB0eSkge1xuICAgIHJldHVybiBwcmV2RW1wdHkgPT09IG5leHRFbXB0eTtcbiAgfVxuXG4gIHZhciBwcmV2VHlwZSA9IHR5cGVvZiBwcmV2RWxlbWVudDtcbiAgdmFyIG5leHRUeXBlID0gdHlwZW9mIG5leHRFbGVtZW50O1xuICBpZiAocHJldlR5cGUgPT09ICdzdHJpbmcnIHx8IHByZXZUeXBlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ3N0cmluZycgfHwgbmV4dFR5cGUgPT09ICdudW1iZXInO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgcHJldkVsZW1lbnQudHlwZSA9PT0gbmV4dEVsZW1lbnQudHlwZSAmJiBwcmV2RWxlbWVudC5rZXkgPT09IG5leHRFbGVtZW50LmtleTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFVuZXNjYXBlIGFuZCB1bndyYXAga2V5IGZvciBodW1hbi1yZWFkYWJsZSBkaXNwbGF5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHVuZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGtleSkge1xuICB2YXIgdW5lc2NhcGVSZWdleCA9IC8oPTB8PTIpL2c7XG4gIHZhciB1bmVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0wJzogJz0nLFxuICAgICc9Mic6ICc6J1xuICB9O1xuICB2YXIga2V5U3Vic3RyaW5nID0ga2V5WzBdID09PSAnLicgJiYga2V5WzFdID09PSAnJCcgPyBrZXkuc3Vic3RyaW5nKDIpIDoga2V5LnN1YnN0cmluZygxKTtcblxuICByZXR1cm4gKCcnICsga2V5U3Vic3RyaW5nKS5yZXBsYWNlKHVuZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiB1bmVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbn1cblxudmFyIEtleUVzY2FwZVV0aWxzID0ge1xuICBlc2NhcGU6IGVzY2FwZSxcbiAgdW5lc2NhcGU6IHVuZXNjYXBlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUVzY2FwZVV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0tleUVzY2FwZVV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgUmVhY3RVcGRhdGVzLmVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnO1xuICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB2YXIgZGlzcGxheU5hbWUgPSBhcmcuY29uc3RydWN0b3IgJiYgYXJnLmNvbnN0cnVjdG9yLm5hbWUgfHwgdHlwZTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpO1xuICBpZiAoa2V5cy5sZW5ndGggPiAwICYmIGtleXMubGVuZ3RoIDwgMjApIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWUgKyAnIChrZXlzOiAnICsga2V5cy5qb2luKCcsICcpICsgJyknO1xuICB9XG4gIHJldHVybiBkaXNwbGF5TmFtZTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQocHVibGljSW5zdGFuY2UpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIE9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBjYWxsZXJOYW1lLiBPdGhlcndpc2Ugd2Ugc2hvdWxkIGJlIHNpbGVudC5cbiAgICAgIC8vIFdlJ3JlIHByb2JhYmx5IGNhbGxpbmcgZnJvbSBlbnF1ZXVlQ2FsbGJhY2suIFdlIGRvbid0IHdhbnQgdG8gd2FyblxuICAgICAgLy8gdGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGlmZWN5Y2xlIG1ldGhvZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjYWxsZXJOYW1lLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGN0b3IgJiYgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnJXMoLi4uKTogQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyAnICsgXCJ3aXRoaW4gYHJlbmRlcmAgb3IgYW5vdGhlciBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzIFwiICsgJ3Nob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyBjb25zdHJ1Y3RvciAnICsgJ3NpZGUtZWZmZWN0cyBhcmUgYW4gYW50aS1wYXR0ZXJuLCBidXQgY2FuIGJlIG1vdmVkIHRvICcgKyAnYGNvbXBvbmVudFdpbGxNb3VudGAuJywgY2FsbGVyTmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBSZWFjdFVwZGF0ZVF1ZXVlIGFsbG93cyBmb3Igc3RhdGUgdXBkYXRlcyB0byBiZSBzY2hlZHVsZWQgaW50byBhIGxhdGVyXG4gKiByZWNvbmNpbGlhdGlvbiBzdGVwLlxuICovXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcob3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IFJlYWN0SW5zdGFuY2VNYXAuZ2V0KHB1YmxpY0luc3RhbmNlKTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgLy8gRHVyaW5nIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyIHRoaXMgd2lsbCBzdGlsbCBiZSBudWxsIGJ1dCBhZnRlclxuICAgICAgLy8gdGhhdCB3aWxsIGFsd2F5cyByZW5kZXIgdG8gc29tZXRoaW5nLiBBdCBsZWFzdCBmb3Igbm93LiBTbyB3ZSBjYW4gdXNlXG4gICAgICAvLyB0aGlzIGhhY2suXG4gICAgICByZXR1cm4gISFpbnRlcm5hbEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWxsZXJOYW1lIE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG5cbiAgICAvLyBQcmV2aW91c2x5IHdlIHdvdWxkIHRocm93IGFuIGVycm9yIGlmIHdlIGRpZG4ndCBoYXZlIGFuIGludGVybmFsXG4gICAgLy8gaW5zdGFuY2UuIFNpbmNlIHdlIHdhbnQgdG8gbWFrZSBpdCBhIG5vLW9wIGluc3RlYWQsIHdlIG1pcnJvciB0aGUgc2FtZVxuICAgIC8vIGJlaGF2aW9yIHdlIGhhdmUgaW4gb3RoZXIgZW5xdWV1ZSogbWV0aG9kcy5cbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gaWdub3JlIGNhbGxiYWNrcyBpbiBjb21wb25lbnRXaWxsTW91bnQuIFNlZVxuICAgIC8vIGVucXVldWVVcGRhdGVzLlxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBUaGUgY2FsbGJhY2sgaGVyZSBpcyBpZ25vcmVkIHdoZW4gc2V0U3RhdGUgaXMgY2FsbGVkIGZyb21cbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQuIEVpdGhlciBmaXggaXQgb3IgZGlzYWxsb3cgZG9pbmcgc28gY29tcGxldGVseSBpblxuICAgIC8vIGZhdm9yIG9mIGdldEluaXRpYWxTdGF0ZS4gQWx0ZXJuYXRpdmVseSwgd2UgY2FuIGRpc2FsbG93XG4gICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGR1cmluZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICBlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MpIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdDYWxsYmFja3MgPSBbY2FsbGJhY2tdO1xuICAgIH1cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcblxuICAgIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW2NvbXBsZXRlU3RhdGVdO1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSB0cnVlO1xuXG4gICAgLy8gRnV0dXJlLXByb29mIDE1LjVcbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS52YWxpZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgICB9XG4gICAgfVxuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0U3RhdGUoKTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xuICAgIHF1ZXVlLnB1c2gocGFydGlhbFN0YXRlKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgZW5xdWV1ZUVsZW1lbnRJbnRlcm5hbDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCBuZXh0Q29udGV4dCkge1xuICAgIGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgLy8gVE9ETzogaW50cm9kdWNlIF9wZW5kaW5nQ29udGV4dCBpbnN0ZWFkIG9mIHNldHRpbmcgaXQgZGlyZWN0bHkuXG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fY29udGV4dCA9IG5leHRDb250ZXh0O1xuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgdmFsaWRhdGVDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgISghY2FsbGJhY2sgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogX3Byb2RJbnZhcmlhbnQoJzEyMicsIGNhbGxlck5hbWUsIGZvcm1hdFVuZXhwZWN0ZWRBcmd1bWVudChjYWxsYmFjaykpIDogdm9pZCAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlUXVldWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RVcGRhdGVRdWV1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50IGluc3RhbmNlLCByZXR1cm4gYSBsaXN0IG9mIGl0cyByZWN1cnNpdmVcbiAgICogb3duZXJzLCBzdGFydGluZyBhdCB0aGUgcm9vdCBhbmQgZW5kaW5nIHdpdGggdGhlIGluc3RhbmNlIGl0c2VsZi5cbiAgICovXG4gIHZhciBmaW5kT3duZXJTdGFjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICBkbyB7XG4gICAgICBzdGFjay5wdXNoKGluc3RhbmNlKTtcbiAgICB9IHdoaWxlIChpbnN0YW5jZSA9IGluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIHN0YWNrLnJldmVyc2UoKTtcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgY2hpbGRJbnN0YW5jZSwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNoaWxkVGFnID09IG51bGwsICd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgcHJvYmxlbWF0aWMgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcblxuICAgIGlmIChwcm9ibGVtYXRpYykge1xuICAgICAgdmFyIGFuY2VzdG9yVGFnID0gcHJvYmxlbWF0aWMudGFnO1xuICAgICAgdmFyIGFuY2VzdG9ySW5zdGFuY2UgPSBwcm9ibGVtYXRpYy5pbnN0YW5jZTtcblxuICAgICAgdmFyIGNoaWxkT3duZXIgPSBjaGlsZEluc3RhbmNlICYmIGNoaWxkSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyID0gYW5jZXN0b3JJbnN0YW5jZSAmJiBhbmNlc3Rvckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG5cbiAgICAgIHZhciBjaGlsZE93bmVycyA9IGZpbmRPd25lclN0YWNrKGNoaWxkT3duZXIpO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJzID0gZmluZE93bmVyU3RhY2soYW5jZXN0b3JPd25lcik7XG5cbiAgICAgIHZhciBtaW5TdGFja0xlbiA9IE1hdGgubWluKGNoaWxkT3duZXJzLmxlbmd0aCwgYW5jZXN0b3JPd25lcnMubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuXG4gICAgICB2YXIgZGVlcGVzdENvbW1vbiA9IC0xO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1pblN0YWNrTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkT3duZXJzW2ldID09PSBhbmNlc3Rvck93bmVyc1tpXSkge1xuICAgICAgICAgIGRlZXBlc3RDb21tb24gPSBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBVTktOT1dOID0gJyh1bmtub3duKSc7XG4gICAgICB2YXIgY2hpbGRPd25lck5hbWVzID0gY2hpbGRPd25lcnMuc2xpY2UoZGVlcGVzdENvbW1vbiArIDEpLm1hcChmdW5jdGlvbiAoaW5zdCkge1xuICAgICAgICByZXR1cm4gaW5zdC5nZXROYW1lKCkgfHwgVU5LTk9XTjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFuY2VzdG9yT3duZXJOYW1lcyA9IGFuY2VzdG9yT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBvd25lckluZm8gPSBbXS5jb25jYXQoXG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGFuZCBjaGlsZCBpbnN0YW5jZXMgaGF2ZSBhIGNvbW1vbiBvd25lciBhbmNlc3Rvciwgc3RhcnRcbiAgICAgIC8vIHdpdGggdGhhdCAtLSBvdGhlcndpc2Ugd2UganVzdCBzdGFydCB3aXRoIHRoZSBwYXJlbnQncyBvd25lcnMuXG4gICAgICBkZWVwZXN0Q29tbW9uICE9PSAtMSA/IGNoaWxkT3duZXJzW2RlZXBlc3RDb21tb25dLmdldE5hbWUoKSB8fCBVTktOT1dOIDogW10sIGFuY2VzdG9yT3duZXJOYW1lcywgYW5jZXN0b3JUYWcsXG4gICAgICAvLyBJZiB3ZSdyZSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgKG5vbi1wYXJlbnQpIGFuY2VzdHJ5LCBhZGQgJy4uLidcbiAgICAgIGludmFsaWRBbmNlc3RvciA/IFsnLi4uJ10gOiBbXSwgY2hpbGRPd25lck5hbWVzLCBjaGlsZFRhZykuam9pbignID4gJyk7XG5cbiAgICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIG93bmVySW5mbztcbiAgICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICAgIHZhciB3aGl0ZXNwYWNlSW5mbyA9ICcnO1xuICAgICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICAgIGlmICgvXFxTLy50ZXN0KGNoaWxkVGV4dCkpIHtcbiAgICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdUZXh0IG5vZGVzJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdXaGl0ZXNwYWNlIHRleHQgbm9kZXMnO1xuICAgICAgICAgIHdoaXRlc3BhY2VJbmZvID0gXCIgTWFrZSBzdXJlIHlvdSBkb24ndCBoYXZlIGFueSBleHRyYSB3aGl0ZXNwYWNlIGJldHdlZW4gdGFncyBvbiBcIiArICdlYWNoIGxpbmUgb2YgeW91ciBzb3VyY2UgY29kZS4nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICc8JyArIGNoaWxkVGFnICsgJz4nO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uJXMgJyArICdTZWUgJXMuJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBvd25lckluZm8sIGluZm8pIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiBTZWUgJXMuJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBvd25lckluZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm87XG5cbiAgLy8gRm9yIHRlc3RpbmdcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZTtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudENoYXJDb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEV2ZW50Q2hhckNvZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvY2F0aW9uc0FyZUVxdWFsID0gZXhwb3J0cy5jcmVhdGVMb2NhdGlvbiA9IHVuZGVmaW5lZDtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZXNvbHZlUGF0aG5hbWUgPSByZXF1aXJlKCdyZXNvbHZlLXBhdGhuYW1lJyk7XG5cbnZhciBfcmVzb2x2ZVBhdGhuYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Jlc29sdmVQYXRobmFtZSk7XG5cbnZhciBfdmFsdWVFcXVhbCA9IHJlcXVpcmUoJ3ZhbHVlLWVxdWFsJyk7XG5cbnZhciBfdmFsdWVFcXVhbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWx1ZUVxdWFsKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlTG9jYXRpb24gPSBleHBvcnRzLmNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciBsb2NhdGlvbiA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIC8vIFR3by1hcmcgZm9ybTogcHVzaChwYXRoLCBzdGF0ZSlcbiAgICBsb2NhdGlvbiA9ICgwLCBfUGF0aFV0aWxzLnBhcnNlUGF0aCkocGF0aCk7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbmUtYXJnIGZvcm06IHB1c2gobG9jYXRpb24pXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgcGF0aCk7XG5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24ucGF0aG5hbWUgPSAnJztcblxuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5zZWFyY2guY2hhckF0KDApICE9PSAnPycpIGxvY2F0aW9uLnNlYXJjaCA9ICc/JyArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uc2VhcmNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBsb2NhdGlvbi5oYXNoID0gJyMnICsgbG9jYXRpb24uaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9uLnN0YXRlID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVVJJRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBVUklFcnJvcignUGF0aG5hbWUgXCInICsgbG9jYXRpb24ucGF0aG5hbWUgKyAnXCIgY291bGQgbm90IGJlIGRlY29kZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGFuIGludmFsaWQgcGVyY2VudC1lbmNvZGluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5KSBsb2NhdGlvbi5rZXkgPSBrZXk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xuICAgIC8vIFJlc29sdmUgaW5jb21wbGV0ZS9yZWxhdGl2ZSBwYXRobmFtZSByZWxhdGl2ZSB0byBjdXJyZW50IGxvY2F0aW9uLlxuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gKDAsIF9yZXNvbHZlUGF0aG5hbWUyLmRlZmF1bHQpKGxvY2F0aW9uLnBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHByaW9yIGxvY2F0aW9uIGFuZCBwYXRobmFtZSBpcyBlbXB0eSwgc2V0IGl0IHRvIC9cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59O1xuXG52YXIgbG9jYXRpb25zQXJlRXF1YWwgPSBleHBvcnRzLmxvY2F0aW9uc0FyZUVxdWFsID0gZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgYS5rZXkgPT09IGIua2V5ICYmICgwLCBfdmFsdWVFcXVhbDIuZGVmYXVsdCkoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L0xvY2F0aW9uVXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpIHtcbiAgdmFyIHByb21wdCA9IG51bGw7XG5cbiAgdmFyIHNldFByb21wdCA9IGZ1bmN0aW9uIHNldFByb21wdChuZXh0UHJvbXB0KSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShwcm9tcHQgPT0gbnVsbCwgJ0EgaGlzdG9yeSBzdXBwb3J0cyBvbmx5IG9uZSBwcm9tcHQgYXQgYSB0aW1lJyk7XG5cbiAgICBwcm9tcHQgPSBuZXh0UHJvbXB0O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwcm9tcHQgPT09IG5leHRQcm9tcHQpIHByb21wdCA9IG51bGw7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgY29uZmlybVRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBJZiBhbm90aGVyIHRyYW5zaXRpb24gc3RhcnRzIHdoaWxlIHdlJ3JlIHN0aWxsIGNvbmZpcm1pbmdcbiAgICAvLyB0aGUgcHJldmlvdXMgb25lLCB3ZSBtYXkgZW5kIHVwIGluIGEgd2VpcmQgc3RhdGUuIEZpZ3VyZSBvdXQgdGhlXG4gICAgLy8gYmVzdCB3YXkgdG8gaGFuZGxlIHRoaXMuXG4gICAgaWYgKHByb21wdCAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHByb21wdCA9PT0gJ2Z1bmN0aW9uJyA/IHByb21wdChsb2NhdGlvbiwgYWN0aW9uKSA6IHByb21wdDtcblxuICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2V0VXNlckNvbmZpcm1hdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGdldFVzZXJDb25maXJtYXRpb24ocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0EgaGlzdG9yeSBuZWVkcyBhIGdldFVzZXJDb25maXJtYXRpb24gZnVuY3Rpb24gaW4gb3JkZXIgdG8gdXNlIGEgcHJvbXB0IG1lc3NhZ2UnKTtcblxuICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZmFsc2UgZnJvbSBhIHRyYW5zaXRpb24gaG9vayB0byBjYW5jZWwgdGhlIHRyYW5zaXRpb24uXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdCAhPT0gZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuXG4gIHZhciBhcHBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFwcGVuZExpc3RlbmVyKGZuKSB7XG4gICAgdmFyIGlzQWN0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgICAgaWYgKGlzQWN0aXZlKSBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gbGlzdGVuZXI7XG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiBub3RpZnlMaXN0ZW5lcnMoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHNldFByb21wdDogc2V0UHJvbXB0LFxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG86IGNvbmZpcm1UcmFuc2l0aW9uVG8sXG4gICAgYXBwZW5kTGlzdGVuZXI6IGFwcGVuZExpc3RlbmVyLFxuICAgIG5vdGlmeUxpc3RlbmVyczogbm90aWZ5TGlzdGVuZXJzXG4gIH07XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlci5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgcHV0dGluZyBoaXN0b3J5IG9uIGNvbnRleHQuXG4gKi9cblxudmFyIFJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBtYXRjaDogX3RoaXMuY29tcHV0ZU1hdGNoKF90aGlzLnByb3BzLmhpc3RvcnkubG9jYXRpb24ucGF0aG5hbWUpXG4gICAgfSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBSb3V0ZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGVyOiBfZXh0ZW5kcyh7fSwgdGhpcy5jb250ZXh0LnJvdXRlciwge1xuICAgICAgICBoaXN0b3J5OiB0aGlzLnByb3BzLmhpc3RvcnksXG4gICAgICAgIHJvdXRlOiB7XG4gICAgICAgICAgbG9jYXRpb246IHRoaXMucHJvcHMuaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgICBtYXRjaDogdGhpcy5zdGF0ZS5tYXRjaFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH07XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wdXRlTWF0Y2ggPSBmdW5jdGlvbiBjb21wdXRlTWF0Y2gocGF0aG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDogJy8nLFxuICAgICAgdXJsOiAnLycsXG4gICAgICBwYXJhbXM6IHt9LFxuICAgICAgaXNFeGFjdDogcGF0aG5hbWUgPT09ICcvJ1xuICAgIH07XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIGhpc3RvcnkgPSBfcHJvcHMuaGlzdG9yeTtcblxuXG4gICAgaW52YXJpYW50KGNoaWxkcmVuID09IG51bGwgfHwgUmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pID09PSAxLCAnQSA8Um91dGVyPiBtYXkgaGF2ZSBvbmx5IG9uZSBjaGlsZCBlbGVtZW50Jyk7XG5cbiAgICAvLyBEbyB0aGlzIGhlcmUgc28gd2UgY2FuIHNldFN0YXRlIHdoZW4gYSA8UmVkaXJlY3Q+IGNoYW5nZXMgdGhlXG4gICAgLy8gbG9jYXRpb24gaW4gY29tcG9uZW50V2lsbE1vdW50LiBUaGlzIGhhcHBlbnMgZS5nLiB3aGVuIGRvaW5nXG4gICAgLy8gc2VydmVyIHJlbmRlcmluZyB1c2luZyBhIDxTdGF0aWNSb3V0ZXI+LlxuICAgIHRoaXMudW5saXN0ZW4gPSBoaXN0b3J5Lmxpc3RlbihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICBtYXRjaDogX3RoaXMyLmNvbXB1dGVNYXRjaChoaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lKVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB3YXJuaW5nKHRoaXMucHJvcHMuaGlzdG9yeSA9PT0gbmV4dFByb3BzLmhpc3RvcnksICdZb3UgY2Fubm90IGNoYW5nZSA8Um91dGVyIGhpc3Rvcnk+Jyk7XG4gIH07XG5cbiAgUm91dGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMudW5saXN0ZW4oKTtcbiAgfTtcblxuICBSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgcmV0dXJuIGNoaWxkcmVuID8gUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbikgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuUm91dGVyLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuUm91dGVyLmNoaWxkQ29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZXIuanMiLCJpbXBvcnQgcGF0aFRvUmVnZXhwIGZyb20gJ3BhdGgtdG8tcmVnZXhwJztcblxudmFyIHBhdHRlcm5DYWNoZSA9IHt9O1xudmFyIGNhY2hlTGltaXQgPSAxMDAwMDtcbnZhciBjYWNoZUNvdW50ID0gMDtcblxudmFyIGNvbXBpbGVQYXRoID0gZnVuY3Rpb24gY29tcGlsZVBhdGgocGF0dGVybiwgb3B0aW9ucykge1xuICB2YXIgY2FjaGVLZXkgPSAnJyArIG9wdGlvbnMuZW5kICsgb3B0aW9ucy5zdHJpY3Q7XG4gIHZhciBjYWNoZSA9IHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gfHwgKHBhdHRlcm5DYWNoZVtjYWNoZUtleV0gPSB7fSk7XG5cbiAgaWYgKGNhY2hlW3BhdHRlcm5dKSByZXR1cm4gY2FjaGVbcGF0dGVybl07XG5cbiAgdmFyIGtleXMgPSBbXTtcbiAgdmFyIHJlID0gcGF0aFRvUmVnZXhwKHBhdHRlcm4sIGtleXMsIG9wdGlvbnMpO1xuICB2YXIgY29tcGlsZWRQYXR0ZXJuID0geyByZTogcmUsIGtleXM6IGtleXMgfTtcblxuICBpZiAoY2FjaGVDb3VudCA8IGNhY2hlTGltaXQpIHtcbiAgICBjYWNoZVtwYXR0ZXJuXSA9IGNvbXBpbGVkUGF0dGVybjtcbiAgICBjYWNoZUNvdW50Kys7XG4gIH1cblxuICByZXR1cm4gY29tcGlsZWRQYXR0ZXJuO1xufTtcblxuLyoqXG4gKiBQdWJsaWMgQVBJIGZvciBtYXRjaGluZyBhIFVSTCBwYXRobmFtZSB0byBhIHBhdGggcGF0dGVybi5cbiAqL1xudmFyIG1hdGNoUGF0aCA9IGZ1bmN0aW9uIG1hdGNoUGF0aChwYXRobmFtZSkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykgb3B0aW9ucyA9IHsgcGF0aDogb3B0aW9ucyB9O1xuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwYXRoID0gX29wdGlvbnMucGF0aCxcbiAgICAgIHBhdGggPSBfb3B0aW9ucyRwYXRoID09PSB1bmRlZmluZWQgPyAnLycgOiBfb3B0aW9ucyRwYXRoLFxuICAgICAgX29wdGlvbnMkZXhhY3QgPSBfb3B0aW9ucy5leGFjdCxcbiAgICAgIGV4YWN0ID0gX29wdGlvbnMkZXhhY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkZXhhY3QsXG4gICAgICBfb3B0aW9ucyRzdHJpY3QgPSBfb3B0aW9ucy5zdHJpY3QsXG4gICAgICBzdHJpY3QgPSBfb3B0aW9ucyRzdHJpY3QgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX29wdGlvbnMkc3RyaWN0O1xuXG4gIHZhciBfY29tcGlsZVBhdGggPSBjb21waWxlUGF0aChwYXRoLCB7IGVuZDogZXhhY3QsIHN0cmljdDogc3RyaWN0IH0pLFxuICAgICAgcmUgPSBfY29tcGlsZVBhdGgucmUsXG4gICAgICBrZXlzID0gX2NvbXBpbGVQYXRoLmtleXM7XG5cbiAgdmFyIG1hdGNoID0gcmUuZXhlYyhwYXRobmFtZSk7XG5cbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHVybCA9IG1hdGNoWzBdLFxuICAgICAgdmFsdWVzID0gbWF0Y2guc2xpY2UoMSk7XG5cbiAgdmFyIGlzRXhhY3QgPSBwYXRobmFtZSA9PT0gdXJsO1xuXG4gIGlmIChleGFjdCAmJiAhaXNFeGFjdCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBwYXRoLCAvLyB0aGUgcGF0aCBwYXR0ZXJuIHVzZWQgdG8gbWF0Y2hcbiAgICB1cmw6IHBhdGggPT09ICcvJyAmJiB1cmwgPT09ICcnID8gJy8nIDogdXJsLCAvLyB0aGUgbWF0Y2hlZCBwb3J0aW9uIG9mIHRoZSBVUkxcbiAgICBpc0V4YWN0OiBpc0V4YWN0LCAvLyB3aGV0aGVyIG9yIG5vdCB3ZSBtYXRjaGVkIGV4YWN0bHlcbiAgICBwYXJhbXM6IGtleXMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXksIGluZGV4KSB7XG4gICAgICBtZW1vW2tleS5uYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9LCB7fSlcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGNoUGF0aDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL21hdGNoUGF0aC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IHJlcXVpcmUoJy4vbG93UHJpb3JpdHlXYXJuaW5nJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IF9wcm9kSW52YXJpYW50KCc4NScpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBSZWFjdENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWFjdFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24oUmVhY3RQdXJlQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlKTtcblJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUmVhY3RQdXJlQ29tcG9uZW50XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RCYXNlQ2xhc3Nlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC4gUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcycpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbCB0aGUgcGVuZGluZyB1cGRhdGVzXG4gICAqIGhhdmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0byB1c2UgYXMgYHRoaXNgIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlQ2FsbGJhY2s6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2spIHt9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cblxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGNoZWNrUmVhY3RUeXBlU3BlYyA9IHJlcXVpcmUoJy4vY2hlY2tSZWFjdFR5cGVTcGVjJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSByZXF1aXJlKCcuL2xvd1ByaW9yaXR5V2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShlbGVtZW50UHJvcHMpIHtcbiAgaWYgKGVsZW1lbnRQcm9wcyAhPT0gbnVsbCAmJiBlbGVtZW50UHJvcHMgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50UHJvcHMuX19zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzb3VyY2UgPSBlbGVtZW50UHJvcHMuX19zb3VyY2U7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnIENoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnIENoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIG1lbW9pemVyID0gb3duZXJIYXNLZXlVc2VXYXJuaW5nLnVuaXF1ZUtleSB8fCAob3duZXJIYXNLZXlVc2VXYXJuaW5nLnVuaXF1ZUtleSA9IHt9KTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChtZW1vaXplcltjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBtZW1vaXplcltjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJztcbiAgfVxuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCkpIDogdm9pZCAwO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyBwcm92aWRlIGltcGxpY2l0IGtleXMuXG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXBvbmVudENsYXNzID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gY29tcG9uZW50Q2xhc3MuZGlzcGxheU5hbWUgfHwgY29tcG9uZW50Q2xhc3MubmFtZTtcbiAgaWYgKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcykge1xuICAgIGNoZWNrUmVhY3RUeXBlU3BlYyhjb21wb25lbnRDbGFzcy5wcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZWxlbWVudCwgbnVsbCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHtcbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbi5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5mbyArPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRTb3VyY2UgPSBwcm9wcyAhPT0gbnVsbCAmJiBwcm9wcyAhPT0gdW5kZWZpbmVkICYmIHByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQgPyBwcm9wcy5fX3NvdXJjZSA6IG51bGw7XG4gICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sucHVzaE5vblN0YW5kYXJkV2FybmluZ1N0YWNrKHRydWUsIGN1cnJlbnRTb3VyY2UpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKSA6IHZvaWQgMDtcbiAgICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vay5wb3BOb25TdGFuZGFyZFdhcm5pbmdTdGFjaygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgY3JlYXRlRmFjdG9yeTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gICAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gICAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudFZhbGlkYXRvcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gUmVhY3QgMTUuNSByZWZlcmVuY2VzIHRoaXMgbW9kdWxlLCBhbmQgYXNzdW1lcyBQcm9wVHlwZXMgYXJlIHN0aWxsIGNhbGxhYmxlIGluIHByb2R1Y3Rpb24uXG4vLyBUaGVyZWZvcmUgd2UgcmUtZXhwb3J0IGRldmVsb3BtZW50LW9ubHkgdmVyc2lvbiB3aXRoIGFsbCB0aGUgUHJvcFR5cGVzIGNoZWNrcyBoZXJlLlxuLy8gSG93ZXZlciBpZiBvbmUgaXMgbWlncmF0aW5nIHRvIHRoZSBgcHJvcC10eXBlc2AgbnBtIGxpYnJhcnksIHRoZXkgd2lsbCBnbyB0aHJvdWdoIHRoZVxuLy8gYGluZGV4LmpzYCBlbnRyeSBwb2ludCwgYW5kIGl0IHdpbGwgYnJhbmNoIGRlcGVuZGluZyBvbiB0aGUgZW52aXJvbm1lbnQuXG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQpIHtcbiAgLy8gSXQgaXMgc3RpbGwgYWxsb3dlZCBpbiAxNS41LlxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IGZhbHNlO1xuICByZXR1cm4gZmFjdG9yeShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRGbGFncyA9IHtcbiAgaGFzQ2FjaGVkQ2hpbGROb2RlczogMSA8PCAwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50RmxhZ3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnRGbGFncy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzMwJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhY2N1bXVsYXRlSW50bztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqL1xuXG5mdW5jdGlvbiBmb3JFYWNoQWNjdW11bGF0ZWQoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hBY2N1bXVsYXRlZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9mb3JFYWNoQWNjdW11bGF0ZWQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgcHNldWRvLWV2ZW50IG1vZHVsZSB0byBoZWxwIGtlZXAgdHJhY2sgb2YgY29tcG9uZW50cyB3YWl0aW5nIHRvXG4gKiBiZSBub3RpZmllZCB3aGVuIHRoZWlyIERPTSByZXByZXNlbnRhdGlvbnMgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50cyBgUG9vbGVkQ2xhc3NgLCBzbyB5b3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEluc3RlYWQsIHVzZSBgQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQoKWAuXG4gKlxuICogQGNsYXNzIFJlYWN0TW91bnRSZWFkeVxuICogQGltcGxlbWVudHMgUG9vbGVkQ2xhc3NcbiAqIEBpbnRlcm5hbFxuICovXG5cbnZhciBDYWxsYmFja1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYWxsYmFja1F1ZXVlKGFyZykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYWxsYmFja1F1ZXVlKTtcblxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fY29udGV4dHMgPSBudWxsO1xuICAgIHRoaXMuX2FyZyA9IGFyZztcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBJbnZva2VkIHdoZW4gYG5vdGlmeUFsbGAgaXMgaW52b2tlZC5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBjb250ZXh0IENvbnRleHQgdG8gY2FsbCBgY2FsbGJhY2tgIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIENhbGxiYWNrUXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiBlbnF1ZXVlKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IFtdO1xuICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB0aGlzLl9jb250ZXh0cyA9IHRoaXMuX2NvbnRleHRzIHx8IFtdO1xuICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludm9rZXMgYWxsIGVucXVldWVkIGNhbGxiYWNrcyBhbmQgY2xlYXJzIHRoZSBxdWV1ZS4gVGhpcyBpcyBpbnZva2VkIGFmdGVyXG4gICAqIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgYSBjb21wb25lbnQgaGFzIGJlZW4gY3JlYXRlZCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5ub3RpZnlBbGwgPSBmdW5jdGlvbiBub3RpZnlBbGwoKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcbiAgICB2YXIgYXJnID0gdGhpcy5fYXJnO1xuICAgIGlmIChjYWxsYmFja3MgJiYgY29udGV4dHMpIHtcbiAgICAgICEoY2FsbGJhY2tzLmxlbmd0aCA9PT0gY29udGV4dHMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNtYXRjaGVkIGxpc3Qgb2YgY29udGV4dHMgaW4gY2FsbGJhY2sgcXVldWUnKSA6IF9wcm9kSW52YXJpYW50KCcyNCcpIDogdm9pZCAwO1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKGNvbnRleHRzW2ldLCBhcmcpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgICBjb250ZXh0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfTtcblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5jaGVja3BvaW50ID0gZnVuY3Rpb24gY2hlY2twb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzID8gdGhpcy5fY2FsbGJhY2tzLmxlbmd0aCA6IDA7XG4gIH07XG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUucm9sbGJhY2sgPSBmdW5jdGlvbiByb2xsYmFjayhsZW4pIHtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NvbnRleHRzKSB7XG4gICAgICB0aGlzLl9jYWxsYmFja3MubGVuZ3RoID0gbGVuO1xuICAgICAgdGhpcy5fY29udGV4dHMubGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgQ2FsbGJhY2tRdWV1ZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cbiAgICovXG5cblxuICBDYWxsYmFja1F1ZXVlLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH07XG5cbiAgcmV0dXJuIENhbGxiYWNrUXVldWU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKENhbGxiYWNrUXVldWUpO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NhbGxiYWNrUXVldWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEZlYXR1cmVGbGFncyA9IHtcbiAgLy8gV2hlbiB0cnVlLCBjYWxsIGNvbnNvbGUudGltZSgpIGJlZm9yZSBhbmQgLnRpbWVFbmQoKSBhZnRlciBlYWNoIHRvcC1sZXZlbFxuICAvLyByZW5kZXIgKGJvdGggaW5pdGlhbCByZW5kZXJzIGFuZCB1cGRhdGVzKS4gVXNlZnVsIHdoZW4gbG9va2luZyBhdCBwcm9kLW1vZGVcbiAgLy8gdGltZWxpbmUgcHJvZmlsZXMgaW4gQ2hyb21lLCBmb3IgZXhhbXBsZS5cbiAgbG9nVG9wTGV2ZWxSZW5kZXJzOiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEZlYXR1cmVGbGFncztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEZlYXR1cmVGbGFncy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG5mdW5jdGlvbiBpc0NoZWNrYWJsZShlbGVtKSB7XG4gIHZhciB0eXBlID0gZWxlbS50eXBlO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAodHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2tlcihpbnN0KSB7XG4gIHJldHVybiBpbnN0Ll93cmFwcGVyU3RhdGUudmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUcmFja2VyKGluc3QsIHRyYWNrZXIpIHtcbiAgaW5zdC5fd3JhcHBlclN0YXRlLnZhbHVlVHJhY2tlciA9IHRyYWNrZXI7XG59XG5cbmZ1bmN0aW9uIGRldGFjaFRyYWNrZXIoaW5zdCkge1xuICBkZWxldGUgaW5zdC5fd3JhcHBlclN0YXRlLnZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZTtcbiAgaWYgKG5vZGUpIHtcbiAgICB2YWx1ZSA9IGlzQ2hlY2thYmxlKG5vZGUpID8gJycgKyBub2RlLmNoZWNrZWQgOiBub2RlLnZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxudmFyIGlucHV0VmFsdWVUcmFja2luZyA9IHtcbiAgLy8gZXhwb3NlZCBmb3IgdGVzdGluZ1xuICBfZ2V0VHJhY2tlckZyb21Ob2RlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBnZXRUcmFja2VyKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpKTtcbiAgfSxcblxuXG4gIHRyYWNrOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmIChnZXRUcmFja2VyKGluc3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWVGaWVsZCA9IGlzQ2hlY2thYmxlKG5vZGUpID8gJ2NoZWNrZWQnIDogJ3ZhbHVlJztcbiAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTtcblxuICAgIC8vIGlmIHNvbWVvbmUgaGFzIGFscmVhZHkgZGVmaW5lZCBhIHZhbHVlIG9yIFNhZmFyaSwgdGhlbiBiYWlsXG4gICAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgICAvLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuICAgIC8vIChuZWVkZWQgZm9yIGNlcnRhaW4gdGVzdHMgdGhhdCBzcHlPbiBpbnB1dCB2YWx1ZXMgYW5kIFNhZmFyaSlcbiAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbCh0aGlzKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGF0dGFjaFRyYWNrZXIoaW5zdCwge1xuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICAgIH0sXG4gICAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9LFxuICAgICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRldGFjaFRyYWNrZXIoaW5zdCk7XG4gICAgICAgIGRlbGV0ZSBub2RlW3ZhbHVlRmllbGRdO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIGlmICghaW5zdCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIoaW5zdCk7XG5cbiAgICBpZiAoIXRyYWNrZXIpIHtcbiAgICAgIGlucHV0VmFsdWVUcmFja2luZy50cmFjayhpbnN0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gICAgdmFyIG5leHRWYWx1ZSA9IGdldFZhbHVlRnJvbU5vZGUoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCkpO1xuXG4gICAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgICB0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHN0b3BUcmFja2luZzogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIoaW5zdCk7XG4gICAgaWYgKHRyYWNrZXIpIHtcbiAgICAgIHRyYWNrZXIuc3RvcFRyYWNraW5nKCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlucHV0VmFsdWVUcmFja2luZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9pbnB1dFZhbHVlVHJhY2tpbmcuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cblxudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gIGNvbG9yOiB0cnVlLFxuICBkYXRlOiB0cnVlLFxuICBkYXRldGltZTogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgZW1haWw6IHRydWUsXG4gIG1vbnRoOiB0cnVlLFxuICBudW1iZXI6IHRydWUsXG4gIHBhc3N3b3JkOiB0cnVlLFxuICByYW5nZTogdHJ1ZSxcbiAgc2VhcmNoOiB0cnVlLFxuICB0ZWw6IHRydWUsXG4gIHRleHQ6IHRydWUsXG4gIHRpbWU6IHRydWUsXG4gIHVybDogdHJ1ZSxcbiAgd2VlazogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gISFzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV07XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHRJbnB1dEVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvaXNUZXh0SW5wdXRFbGVtZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcbiAgY3VycmVudFNjcm9sbExlZnQ6IDAsXG5cbiAgY3VycmVudFNjcm9sbFRvcDogMCxcblxuICByZWZyZXNoU2Nyb2xsVmFsdWVzOiBmdW5jdGlvbiAoc2Nyb2xsUG9zaXRpb24pIHtcbiAgICBWaWV3cG9ydE1ldHJpY3MuY3VycmVudFNjcm9sbExlZnQgPSBzY3JvbGxQb3NpdGlvbi54O1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsVG9wID0gc2Nyb2xsUG9zaXRpb24ueTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3cG9ydE1ldHJpY3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvVmlld3BvcnRNZXRyaWNzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn07XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgaWYgKCEoJ3RleHRDb250ZW50JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvc2V0VGV4dENvbnRlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xuXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICBib3JkZXJJbWFnZVdpZHRoOiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcblxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiB0cnVlLFxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWVcbiAgfSxcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIG91dGxpbmVXaWR0aDogdHJ1ZSxcbiAgICBvdXRsaW5lU3R5bGU6IHRydWUsXG4gICAgb3V0bGluZUNvbG9yOiB0cnVlXG4gIH1cbn07XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHtcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcbiAgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zOiBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvQ1NTUHJvcGVydHkuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdEluc3RydW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0cnVtZW50YXRpb24nKTtcblxudmFyIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGlzQXR0cmlidXRlTmFtZVNhZmUoYXR0cmlidXRlTmFtZSkge1xuICBpZiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICB2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGVbYXR0cmlidXRlTmFtZV0gPSB0cnVlO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgJiYgIXZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgJiYgaXNOYU4odmFsdWUpIHx8IHByb3BlcnR5SW5mby5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSAmJiB2YWx1ZSA8IDEgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBET00gcHJvcGVydGllcy5cbiAqL1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgSUQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmVzY2FwZWQgSUQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZy5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcihpZCk7XG4gIH0sXG5cbiAgc2V0QXR0cmlidXRlRm9ySUQ6IGZ1bmN0aW9uIChub2RlLCBpZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FLCBpZCk7XG4gIH0sXG5cbiAgY3JlYXRlTWFya3VwRm9yUm9vdDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBET01Qcm9wZXJ0eS5ST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcbiAgfSxcblxuICBzZXRBdHRyaWJ1dGVGb3JSb290OiBmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUUsICcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7P3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgcHJvcGVydHkgd2FzIGludmFsaWQuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IERPTVByb3BlcnR5LnByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz1cIlwiJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgICAvLyBgc2V0QXR0cmlidXRlYCB3aXRoIG9iamVjdHMgYmVjb21lcyBvbmx5IGBbb2JqZWN0XWAgaW4gSUU4LzksXG4gICAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBheWxvYWQgPSB7fTtcbiAgICAgIHBheWxvYWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgc2V0VmFsdWVGb3JBdHRyaWJ1dGU6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnICsgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGF5bG9hZCA9IHt9O1xuICAgICAgcGF5bG9hZFtuYW1lXSA9IHZhbHVlO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRJbnN0YW5jZUZyb21Ob2RlKG5vZGUpLl9kZWJ1Z0lELFxuICAgICAgICB0eXBlOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbiBhdHRyaWJ1dGVzIGZyb20gYSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25Ib3N0T3BlcmF0aW9uKHtcbiAgICAgICAgaW5zdGFuY2VJRDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkuX2RlYnVnSUQsXG4gICAgICAgIHR5cGU6ICdyZW1vdmUgYXR0cmlidXRlJyxcbiAgICAgICAgcGF5bG9hZDogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkhvc3RPcGVyYXRpb24oe1xuICAgICAgICBpbnN0YW5jZUlEOiBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShub2RlKS5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxuICAgICAgICBwYXlsb2FkOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCAmJiB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpIHtcbiAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgb3duZXIpO1xuXG4gIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlTGlua2AgcHJvcCBvbiBgc2VsZWN0YCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgIGRpZFdhcm5WYWx1ZUxpbmsgPSB0cnVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RET01Db21wb25lbnR9IGluc3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbGVcbiAqIEBwYXJhbSB7Kn0gcHJvcFZhbHVlIEEgc3RyaW5nYWJsZSAod2l0aCBgbXVsdGlwbGVgLCBhIGxpc3Qgb2Ygc3RyaW5nYWJsZXMpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhpbnN0LCBtdWx0aXBsZSwgcHJvcFZhbHVlKSB7XG4gIHZhciBzZWxlY3RlZFZhbHVlLCBpO1xuICB2YXIgb3B0aW9ucyA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVbJycgKyBwcm9wVmFsdWVbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xudmFyIFJlYWN0RE9NU2VsZWN0ID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHJldHVybiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZSxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgcGVuZGluZ1VwZGF0ZTogZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIGxpc3RlbmVyczogbnVsbCxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdCksXG4gICAgICB3YXNNdWx0aXBsZTogQm9vbGVhbihwcm9wcy5tdWx0aXBsZSlcbiAgICB9O1xuXG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpIDogdm9pZCAwO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0U2VsZWN0VmFsdWVDb250ZXh0OiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIC8vIFJlYWN0RE9NT3B0aW9uIGxvb2tzIGF0IHRoaXMgaW5pdGlhbCB2YWx1ZSBzbyB0aGUgaW5pdGlhbCBnZW5lcmF0ZWRcbiAgICAvLyBtYXJrdXAgaGFzIGNvcnJlY3QgYHNlbGVjdGVkYCBhdHRyaWJ1dGVzXG4gICAgcmV0dXJuIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU7XG4gIH0sXG5cbiAgcG9zdFVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgICAvLyB0aGlzIHZhbHVlIGRvd25cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdhc011bHRpcGxlID0gaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9IEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpO1xuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG4gICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSkpIHtcbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgICB1cGRhdGVPcHRpb25zKGluc3QsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgfVxuICBSZWFjdFVwZGF0ZXMuYXNhcCh1cGRhdGVPcHRpb25zSWZQZW5kaW5nVXBkYXRlQW5kTW91bnRlZCwgdGhpcyk7XG4gIHJldHVybiByZXR1cm5WYWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RW1wdHlDb21wb25lbnQnKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xuXG52YXIgZ2V0TmV4dERlYnVnSUQgPSByZXF1aXJlKCdyZWFjdC9saWIvZ2V0TmV4dERlYnVnSUQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vLyBUbyBhdm9pZCBhIGN5Y2xpYyBkZXBlbmRlbmN5LCB3ZSBjcmVhdGUgdGhlIGZpbmFsIGNsYXNzIGluIHRoaXMgbW9kdWxlXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdGhpcy5jb25zdHJ1Y3QoZWxlbWVudCk7XG59O1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpIHtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdHlwZSByZWZlcmVuY2UgaXMgYSBrbm93biBpbnRlcm5hbCB0eXBlLiBJLmUuIG5vdCBhIHVzZXJcbiAqIHByb3ZpZGVkIGNvbXBvc2l0ZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgdmFsaWQgaW50ZXJuYWwgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNJbnRlcm5hbENvbXBvbmVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdHlwZS5wcm90b3R5cGUubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlY2VpdmVDb21wb25lbnQgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdE5vZGUsIGNyZWF0ZSBhbiBpbnN0YW5jZSB0aGF0IHdpbGwgYWN0dWFsbHkgYmUgbW91bnRlZC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRIYXZlRGVidWdJRFxuICogQHJldHVybiB7b2JqZWN0fSBBIG5ldyBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCdzIGNvbnN0cnVjdG9yLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5vZGUsIHNob3VsZEhhdmVEZWJ1Z0lEKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gUmVhY3RFbXB0eUNvbXBvbmVudC5jcmVhdGUoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4uXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKSA6IF9wcm9kSW52YXJpYW50KCcxMzAnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFNwZWNpYWwgY2FzZSBzdHJpbmcgdmFsdWVzXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpbnN0YW5jZSA9IFJlYWN0SG9zdENvbXBvbmVudC5jcmVhdGVJbnRlcm5hbENvbXBvbmVudChlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKGVsZW1lbnQudHlwZSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGVtcG9yYXJpbHkgYXZhaWxhYmxlIGZvciBjdXN0b20gY29tcG9uZW50cyB0aGF0IGFyZSBub3Qgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbnMuIEkuZS4gQVJULiBPbmNlIHRob3NlIGFyZSB1cGRhdGVkIHRvIHVzZSB0aGUgc3RyaW5nXG4gICAgICAvLyByZXByZXNlbnRhdGlvbiwgd2UgY2FuIGRyb3AgdGhpcyBjb2RlIHBhdGguXG4gICAgICBpbnN0YW5jZSA9IG5ldyBlbGVtZW50LnR5cGUoZWxlbWVudCk7XG5cbiAgICAgIC8vIFdlIHJlbmFtZWQgdGhpcy4gQWxsb3cgdGhlIG9sZCBuYW1lIGZvciBjb21wYXQuIDooXG4gICAgICBpZiAoIWluc3RhbmNlLmdldEhvc3ROb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLmdldEhvc3ROb2RlID0gaW5zdGFuY2UuZ2V0TmF0aXZlTm9kZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UgPSBuZXcgUmVhY3RDb21wb3NpdGVDb21wb25lbnRXcmFwcGVyKGVsZW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5vZGUgPT09ICdudW1iZXInKSB7XG4gICAgaW5zdGFuY2UgPSBSZWFjdEhvc3RDb21wb25lbnQuY3JlYXRlSW5zdGFuY2VGb3JUZXh0KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbmNvdW50ZXJlZCBpbnZhbGlkIFJlYWN0IG5vZGUgb2YgdHlwZSAlcycsIHR5cGVvZiBub2RlKSA6IF9wcm9kSW52YXJpYW50KCcxMzEnLCB0eXBlb2Ygbm9kZSkgOiB2b2lkIDA7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0YW5jZS5tb3VudENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UucmVjZWl2ZUNvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0SG9zdE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLnVubW91bnRDb21wb25lbnQgPT09ICdmdW5jdGlvbicsICdPbmx5IFJlYWN0IENvbXBvbmVudHMgY2FuIGJlIG1vdW50ZWQuJykgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcbiAgLy8gcmVzcGVjdGl2ZWx5LiBJbnN0ZWFkIG9mIHVzaW5nIGV4cGFuZG9zIG9uIGNvbXBvbmVudHMsIHdlIHNob3VsZCBiZVxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcbiAgaW5zdGFuY2UuX21vdW50SW1hZ2UgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuX2RlYnVnSUQgPSBzaG91bGRIYXZlRGVidWdJRCA/IGdldE5leHREZWJ1Z0lEKCkgOiAwO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaW5zdGFuY2VzIHNob3VsZCBmdWxseSBjb25zdHJ1Y3RlZCBhdCB0aGlzIHBvaW50LCBzbyB0aGV5IHNob3VsZFxuICAvLyBub3QgZ2V0IGFueSBuZXcgZmllbGRzIGFkZGVkIHRvIHRoZW0gYXQgdGhpcyBwb2ludC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuX2Fzc2lnbihSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIucHJvdG90eXBlLCBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCwge1xuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3QnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgUmVhY3ROb2RlVHlwZXMgPSB7XG4gIEhPU1Q6IDAsXG4gIENPTVBPU0lURTogMSxcbiAgRU1QVFk6IDIsXG5cbiAgZ2V0VHlwZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFJlYWN0Tm9kZVR5cGVzLkVNUFRZO1xuICAgIH0gZWxzZSBpZiAoUmVhY3QuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIGlmICh0eXBlb2Ygbm9kZS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUmVhY3ROb2RlVHlwZXMuSE9TVDtcbiAgICAgIH1cbiAgICB9XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgbm9kZTogJXMnLCBub2RlKSA6IF9wcm9kSW52YXJpYW50KCcyNicsIG5vZGUpIDogdm9pZCAwO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9kZVR5cGVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0Tm9kZVR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5Q29tcG9uZW50RmFjdG9yeTtcblxudmFyIFJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeTogZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBlbXB0eUNvbXBvbmVudEZhY3RvcnkgPSBmYWN0b3J5O1xuICB9XG59O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgICByZXR1cm4gZW1wdHlDb21wb25lbnRGYWN0b3J5KGluc3RhbnRpYXRlKTtcbiAgfVxufTtcblxuUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24gPSBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IG51bGw7XG52YXIgdGV4dENvbXBvbmVudENsYXNzID0gbnVsbDtcblxudmFyIFJlYWN0SG9zdENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgLy8gVGhpcyBhY2NlcHRzIGEgY2xhc3MgdGhhdCByZWNlaXZlcyB0aGUgdGFnIHN0cmluZy4gVGhpcyBpcyBhIGNhdGNoIGFsbFxuICAvLyB0aGF0IGNhbiByZW5kZXIgYW55IGtpbmQgb2YgdGFnLlxuICBpbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3M6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzcykge1xuICAgIGdlbmVyaWNDb21wb25lbnRDbGFzcyA9IGNvbXBvbmVudENsYXNzO1xuICB9LFxuICAvLyBUaGlzIGFjY2VwdHMgYSB0ZXh0IGNvbXBvbmVudCBjbGFzcyB0aGF0IHRha2VzIHRoZSB0ZXh0IHN0cmluZyB0byBiZVxuICAvLyByZW5kZXJlZCBhcyBwcm9wcy5cbiAgaW5qZWN0VGV4dENvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgYSBob3N0IGludGVybmFsIGNvbXBvbmVudCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY3JlYXRlLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBpbnRlcm5hbCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCkge1xuICAhZ2VuZXJpY0NvbXBvbmVudENsYXNzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIGlzIG5vIHJlZ2lzdGVyZWQgY29tcG9uZW50IGZvciB0aGUgdGFnICVzJywgZWxlbWVudC50eXBlKSA6IF9wcm9kSW52YXJpYW50KCcxMTEnLCBlbGVtZW50LnR5cGUpIDogdm9pZCAwO1xuICByZXR1cm4gbmV3IGdlbmVyaWNDb21wb25lbnRDbGFzcyhlbGVtZW50KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlRm9yVGV4dCh0ZXh0KSB7XG4gIHJldHVybiBuZXcgdGV4dENvbXBvbmVudENsYXNzKHRleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Q29tcG9uZW50KGNvbXBvbmVudCkge1xuICByZXR1cm4gY29tcG9uZW50IGluc3RhbmNlb2YgdGV4dENvbXBvbmVudENsYXNzO1xufVxuXG52YXIgUmVhY3RIb3N0Q29tcG9uZW50ID0ge1xuICBjcmVhdGVJbnRlcm5hbENvbXBvbmVudDogY3JlYXRlSW50ZXJuYWxDb21wb25lbnQsXG4gIGNyZWF0ZUluc3RhbmNlRm9yVGV4dDogY3JlYXRlSW5zdGFuY2VGb3JUZXh0LFxuICBpc1RleHRDb21wb25lbnQ6IGlzVGV4dENvbXBvbmVudCxcbiAgaW5qZWN0aW9uOiBSZWFjdEhvc3RDb21wb25lbnRJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RIb3N0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SG9zdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50U3ltYm9sJyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVGhpcyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50IHNpbmNlIHRoaXMgZmlsZSBpcyBzaGFyZWQgYmV0d2VlblxuICogaXNvbW9ycGhpYyBhbmQgcmVuZGVyZXJzLiBXZSBjb3VsZCBleHRyYWN0IHRoaXMgdG8gYVxuICpcbiAqL1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAoY29tcG9uZW50ICYmIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBLZXlFc2NhcGVVdGlscy5lc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8XG4gIC8vIFRoZSBmb2xsb3dpbmcgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudC4gVGhpcyBtZWFucyB3ZSBjYW4gb3B0aW1pemVcbiAgLy8gc29tZSBjaGVja3MuIFJlYWN0IEZpYmVyIGFsc28gaW5saW5lcyB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIHB1cnBvc2VzLlxuICB0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyc7XG4gICAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZhciBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgICAgaWYgKG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lKSB7XG4gICAgICAgICAgICAgIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3QgeWV0IGZ1bGx5IHN1cHBvcnRlZC4gSXQgaXMgYW4gJyArICdleHBlcmltZW50YWwgZmVhdHVyZSB0aGF0IG1pZ2h0IGJlIHJlbW92ZWQuIENvbnZlcnQgaXQgdG8gYSAnICsgJ3NlcXVlbmNlIC8gaXRlcmFibGUgb2Yga2V5ZWQgUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBLZXlFc2NhcGVVdGlscy5lc2NhcGUoZW50cnlbMF0pICsgU1VCU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCAwKTtcbiAgICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkIG9yIHdyYXAgdGhlIG9iamVjdCB1c2luZyBjcmVhdGVGcmFnbWVudChvYmplY3QpIGZyb20gdGhlICcgKyAnUmVhY3QgYWRkLW9ucy4nO1xuICAgICAgICBpZiAoY2hpbGRyZW4uX2lzUmVhY3RFbGVtZW50KSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSBcIiBJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyBhbiBlbGVtZW50IGNyZWF0ZWQgYnkgYSBkaWZmZXJlbnQgXCIgKyAndmVyc2lvbiBvZiBSZWFjdC4gTWFrZSBzdXJlIHRvIHVzZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0Lic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpO1xuICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBhZGRlbmR1bSArPSAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSBTdHJpbmcoY2hpbGRyZW4pO1xuICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiBfcHJvZEludmFyaWFudCgnMzEnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTVNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RET01TZWxlY3Rpb24nKTtcblxudmFyIGNvbnRhaW5zTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NvbnRhaW5zTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBjb250YWluc05vZGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBub2RlKTtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0ge1xuICBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXM6IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xuICB9LFxuXG4gIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICAgIHJldHVybiB7XG4gICAgICBmb2N1c2VkRWxlbTogZm9jdXNlZEVsZW0sXG4gICAgICBzZWxlY3Rpb25SYW5nZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gUmVhY3RJbnB1dFNlbGVjdGlvbi5nZXRTZWxlY3Rpb24oZm9jdXNlZEVsZW0pIDogbnVsbFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICAgKiByZXN0b3JlIGl0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHBlcmZvcm1pbmcgb3BlcmF0aW9ucyB0aGF0IGNvdWxkIHJlbW92ZSBkb21cbiAgICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gICAqL1xuICByZXN0b3JlU2VsZWN0aW9uOiBmdW5jdGlvbiAocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICAgIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gICAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICAgIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgIGlmIChSZWFjdElucHV0U2VsZWN0aW9uLmhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgICBSZWFjdElucHV0U2VsZWN0aW9uLnNldFNlbGVjdGlvbihwcmlvckZvY3VzZWRFbGVtLCBwcmlvclNlbGVjdGlvblJhbmdlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzTm9kZShwcmlvckZvY3VzZWRFbGVtKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBnZXRTZWxlY3Rpb246IEdldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSBmb2N1c2VkIHRleHRhcmVhLCBpbnB1dCBvclxuICAgKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAgICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAgICogLUByZXR1cm4ge3N0YXJ0OiBzZWxlY3Rpb25TdGFydCwgZW5kOiBzZWxlY3Rpb25FbmR9XG4gICAqL1xuICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHZhciBzZWxlY3Rpb247XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiBpbnB1dC5ub2RlTmFtZSAmJiBpbnB1dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBpbnB1dC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RET01TZWxlY3Rpb24uc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5wdXRTZWxlY3Rpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7P0RPTURvY3VtZW50fSBkb2MgRGVmYXVsdHMgdG8gY3VycmVudCBkb2N1bWVudC5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fVxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykgLyo/RE9NRWxlbWVudCove1xuICBkb2MgPSBkb2MgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50IHx8IGRvYy5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvYy5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0RE9NQ29udGFpbmVySW5mbyA9IHJlcXVpcmUoJy4vUmVhY3RET01Db250YWluZXJJbmZvJyk7XG52YXIgUmVhY3RET01GZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RGZWF0dXJlRmxhZ3MgPSByZXF1aXJlKCcuL1JlYWN0RmVhdHVyZUZsYWdzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBBVFRSX05BTUUgPSBET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRTtcbnZhciBST09UX0FUVFJfTkFNRSA9IERPTVByb3BlcnR5LlJPT1RfQVRUUklCVVRFX05BTUU7XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbnZhciBpbnN0YW5jZXNCeVJlYWN0Um9vdElEID0ge307XG5cbi8qKlxuICogRmluZHMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXJcbiAqIHRoYXQncyBub3QgY29tbW9uIGJldHdlZW4gdGhlIHR3byBnaXZlbiBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgd2hlcmUgdGhlIHN0cmluZ3MgZGl2ZXJnZVxuICovXG5mdW5jdGlvbiBmaXJzdERpZmZlcmVuY2VJbmRleChzdHJpbmcxLCBzdHJpbmcyKSB7XG4gIHZhciBtaW5MZW4gPSBNYXRoLm1pbihzdHJpbmcxLmxlbmd0aCwgc3RyaW5nMi5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1pbkxlbjsgaSsrKSB7XG4gICAgaWYgKHN0cmluZzEuY2hhckF0KGkpICE9PSBzdHJpbmcyLmNoYXJBdChpKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHJpbmcxLmxlbmd0aCA9PT0gc3RyaW5nMi5sZW5ndGggPyAtMSA6IG1pbkxlbjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NRG9jdW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluXG4gKiBhIFJlYWN0IGNvbXBvbmVudFxuICogQHJldHVybiB7Pyp9IERPTSBlbGVtZW50IHRoYXQgbWF5IGhhdmUgdGhlIHJlYWN0Um9vdCBJRCwgb3IgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEdldElEKG5vZGUpIHtcbiAgLy8gSWYgbm9kZSBpcyBzb21ldGhpbmcgbGlrZSBhIHdpbmRvdywgZG9jdW1lbnQsIG9yIHRleHQgbm9kZSwgbm9uZSBvZlxuICAvLyB3aGljaCBzdXBwb3J0IGF0dHJpYnV0ZXMgb3IgYSAuZ2V0QXR0cmlidXRlIG1ldGhvZCwgZ3JhY2VmdWxseSByZXR1cm5cbiAgLy8gdGhlIGVtcHR5IHN0cmluZywgYXMgaWYgdGhlIGF0dHJpYnV0ZSB3ZXJlIG1pc3NpbmcuXG4gIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZShBVFRSX05BTUUpIHx8ICcnO1xufVxuXG4vKipcbiAqIE1vdW50cyB0aGlzIGNvbXBvbmVudCBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gbW91bnRDb21wb25lbnRJbnRvTm9kZSh3cmFwcGVySW5zdGFuY2UsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciBtYXJrZXJOYW1lO1xuICBpZiAoUmVhY3RGZWF0dXJlRmxhZ3MubG9nVG9wTGV2ZWxSZW5kZXJzKSB7XG4gICAgdmFyIHdyYXBwZWRFbGVtZW50ID0gd3JhcHBlckluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5wcm9wcy5jaGlsZDtcbiAgICB2YXIgdHlwZSA9IHdyYXBwZWRFbGVtZW50LnR5cGU7XG4gICAgbWFya2VyTmFtZSA9ICdSZWFjdCBtb3VudDogJyArICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgPyB0eXBlIDogdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUpO1xuICAgIGNvbnNvbGUudGltZShtYXJrZXJOYW1lKTtcbiAgfVxuXG4gIHZhciBtYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQod3JhcHBlckluc3RhbmNlLCB0cmFuc2FjdGlvbiwgbnVsbCwgUmVhY3RET01Db250YWluZXJJbmZvKHdyYXBwZXJJbnN0YW5jZSwgY29udGFpbmVyKSwgY29udGV4dCwgMCAvKiBwYXJlbnREZWJ1Z0lEICovXG4gICk7XG5cbiAgaWYgKG1hcmtlck5hbWUpIHtcbiAgICBjb25zb2xlLnRpbWVFbmQobWFya2VyTmFtZSk7XG4gIH1cblxuICB3cmFwcGVySW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50Ll90b3BMZXZlbFdyYXBwZXIgPSB3cmFwcGVySW5zdGFuY2U7XG4gIFJlYWN0TW91bnQuX21vdW50SW1hZ2VJbnRvTm9kZShtYXJrdXAsIGNvbnRhaW5lciwgd3JhcHBlckluc3RhbmNlLCBzaG91bGRSZXVzZU1hcmt1cCwgdHJhbnNhY3Rpb24pO1xufVxuXG4vKipcbiAqIEJhdGNoZWQgbW91bnQuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50SW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIG1vdW50LlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gbW91bnQgaW50by5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgSWYgdHJ1ZSwgZG8gbm90IGluc2VydCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUoY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgdmFyIHRyYW5zYWN0aW9uID0gUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKFxuICAvKiB1c2VDcmVhdGVFbGVtZW50ICovXG4gICFzaG91bGRSZXVzZU1hcmt1cCAmJiBSZWFjdERPTUZlYXR1cmVGbGFncy51c2VDcmVhdGVFbGVtZW50KTtcbiAgdHJhbnNhY3Rpb24ucGVyZm9ybShtb3VudENvbXBvbmVudEludG9Ob2RlLCBudWxsLCBjb21wb25lbnRJbnN0YW5jZSwgY29udGFpbmVyLCB0cmFuc2FjdGlvbiwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBVbm1vdW50cyBhIGNvbXBvbmVudCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBET00uXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gaW5zdGFuY2UgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLlxuICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gdW5tb3VudCBmcm9tLlxuICogQGZpbmFsXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge1JlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEZyb21Ob2RlKGluc3RhbmNlLCBjb250YWluZXIsIHNhZmVseSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2goKTtcbiAgfVxuICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChpbnN0YW5jZSwgc2FmZWx5KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25FbmRGbHVzaCgpO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBodHRwOi8vanNwZXJmLmNvbS9lbXB0eWluZy1hLW5vZGVcbiAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmxhc3RDaGlsZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBoYXMgYSBkaXJlY3QgUmVhY3QtcmVuZGVyZWQgY2hpbGQgdGhhdCBpc1xuICogbm90IGEgUmVhY3Qgcm9vdCBlbGVtZW50LiBVc2VmdWwgZm9yIHdhcm5pbmcgaW4gYHJlbmRlcmAsXG4gKiBgdW5tb3VudENvbXBvbmVudEF0Tm9kZWAsIGV0Yy5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gZWxlbWVudCBjb250YWlucyBhIGRpcmVjdCBjaGlsZCB0aGF0IHdhc1xuICogcmVuZGVyZWQgYnkgUmVhY3QgYnV0IGlzIG5vdCBhIHJvb3QgZWxlbWVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpIHtcbiAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICBpZiAocm9vdEVsKSB7XG4gICAgdmFyIGluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpO1xuICAgIHJldHVybiAhIShpbnN0ICYmIGluc3QuX2hvc3RQYXJlbnQpO1xuICB9XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSBSZWFjdCBET00gZWxlbWVudCBhbmRcbiAqIGl0IGhhcyBiZWVuIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaGFzIGJlZW4gcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0XG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbm9kZUlzUmVuZGVyZWRCeU90aGVySW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbCAmJiBpc1JlYWN0Tm9kZShyb290RWwpICYmICFSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShyb290RWwpKTtcbn1cblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSk7XG59XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBSZWFjdCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgUmVhY3QgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNSZWFjdE5vZGUobm9kZSkge1xuICByZXR1cm4gaXNWYWxpZENvbnRhaW5lcihub2RlKSAmJiAobm9kZS5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSX05BTUUpIHx8IG5vZGUuaGFzQXR0cmlidXRlKEFUVFJfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0Um9vdEluc3RhbmNlSW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgdmFyIHByZXZIb3N0SW5zdGFuY2UgPSByb290RWwgJiYgUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUocm9vdEVsKTtcbiAgcmV0dXJuIHByZXZIb3N0SW5zdGFuY2UgJiYgIXByZXZIb3N0SW5zdGFuY2UuX2hvc3RQYXJlbnQgPyBwcmV2SG9zdEluc3RhbmNlIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKSB7XG4gIHZhciByb290ID0gZ2V0SG9zdFJvb3RJbnN0YW5jZUluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gIHJldHVybiByb290ID8gcm9vdC5faG9zdENvbnRhaW5lckluZm8uX3RvcExldmVsV3JhcHBlciA6IG51bGw7XG59XG5cbi8qKlxuICogVGVtcG9yYXJ5ICg/KSBoYWNrIHNvIHRoYXQgd2UgY2FuIHN0b3JlIGFsbCB0b3AtbGV2ZWwgcGVuZGluZyB1cGRhdGVzIG9uXG4gKiBjb21wb3NpdGVzIGluc3RlYWQgb2YgaGF2aW5nIHRvIHdvcnJ5IGFib3V0IGRpZmZlcmVudCB0eXBlcyBvZiBjb21wb25lbnRzXG4gKiBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxSb290Q291bnRlciA9IDE7XG52YXIgVG9wTGV2ZWxXcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJvb3RJRCA9IHRvcExldmVsUm9vdENvdW50ZXIrKztcbn07XG5Ub3BMZXZlbFdyYXBwZXIucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRvcExldmVsV3JhcHBlci5kaXNwbGF5TmFtZSA9ICdUb3BMZXZlbFdyYXBwZXInO1xufVxuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkO1xufTtcblRvcExldmVsV3JhcHBlci5pc1JlYWN0VG9wTGV2ZWxXcmFwcGVyID0gdHJ1ZTtcblxuLyoqXG4gKiBNb3VudGluZyBpcyB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgYSBSZWFjdCBjb21wb25lbnQgYnkgY3JlYXRpbmcgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlcihcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuICBUb3BMZXZlbFdyYXBwZXI6IFRvcExldmVsV3JhcHBlcixcblxuICAvKipcbiAgICogVXNlZCBieSBkZXZ0b29scy4gVGhlIGtleXMgYXJlIG5vdCBpbXBvcnRhbnQuXG4gICAqL1xuICBfaW5zdGFuY2VzQnlSZWFjdFJvb3RJRDogaW5zdGFuY2VzQnlSZWFjdFJvb3RJRCxcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhvb2sgcHJvdmlkZWQgdG8gc3VwcG9ydCByZW5kZXJpbmcgUmVhY3QgY29tcG9uZW50cyB3aGlsZVxuICAgKiBlbnN1cmluZyB0aGF0IHRoZSBhcHBhcmVudCBzY3JvbGwgcG9zaXRpb24gb2YgaXRzIGBjb250YWluZXJgIGRvZXMgbm90XG4gICAqIGNoYW5nZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgVGhlIGBjb250YWluZXJgIGJlaW5nIHJlbmRlcmVkIGludG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlbmRlckNhbGxiYWNrIFRoaXMgbXVzdCBiZSBjYWxsZWQgb25jZSB0byBkbyB0aGUgcmVuZGVyLlxuICAgKi9cbiAgc2Nyb2xsTW9uaXRvcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgcmVuZGVyQ2FsbGJhY2spIHtcbiAgICByZW5kZXJDYWxsYmFjaygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlIGEgY29tcG9uZW50IHRoYXQncyBhbHJlYWR5IG1vdW50ZWQgaW50byB0aGUgRE9NIGFuZCByZXBsYWNlIGl0cyBwcm9wc1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwcmV2Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSBhbHJlYWR5IGluIHRoZSBET01cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKi9cbiAgX3VwZGF0ZVJvb3RDb21wb25lbnQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgbmV4dENvbnRleHQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdE1vdW50LnNjcm9sbE1vbml0b3IoY29udGFpbmVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVFbGVtZW50SW50ZXJuYWwocHJldkNvbXBvbmVudCwgbmV4dEVsZW1lbnQsIG5leHRDb250ZXh0KTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKHByZXZDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBuZXcgY29tcG9uZW50IGludG8gdGhlIERPTS4gSG9va2VkIGJ5IGhvb2tzIVxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgZWxlbWVudCB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgaWYgd2Ugc2hvdWxkIHNraXAgdGhlIG1hcmt1cCBpbnNlcnRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnRcbiAgICovXG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICsgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdfcmVnaXN0ZXJDb21wb25lbnQoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNycpIDogdm9pZCAwO1xuXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xuICAgIHZhciBjb21wb25lbnRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIGZhbHNlKTtcblxuICAgIC8vIFRoZSBpbml0aWFsIHJlbmRlciBpcyBzeW5jaHJvbm91cyBidXQgYW55IHVwZGF0ZXMgdGhhdCBoYXBwZW4gZHVyaW5nXG4gICAgLy8gcmVuZGVyaW5nLCBpbiBjb21wb25lbnRXaWxsTW91bnQgb3IgY29tcG9uZW50RGlkTW91bnQsIHdpbGwgYmUgYmF0Y2hlZFxuICAgIC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBiYXRjaGluZyBzdHJhdGVneS5cblxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZSwgY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpO1xuXG4gICAgdmFyIHdyYXBwZXJJRCA9IGNvbXBvbmVudEluc3RhbmNlLl9pbnN0YW5jZS5yb290SUQ7XG4gICAgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFt3cmFwcGVySURdID0gY29tcG9uZW50SW5zdGFuY2U7XG5cbiAgICByZXR1cm4gY29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgYSBSZWFjdCBjb21wb25lbnQgaW50byB0aGUgRE9NIGluIHRoZSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAgICpcbiAgICogSWYgdGhlIFJlYWN0IGNvbXBvbmVudCB3YXMgcHJldmlvdXNseSByZW5kZXJlZCBpbnRvIGBjb250YWluZXJgLCB0aGlzIHdpbGxcbiAgICogcGVyZm9ybSBhbiB1cGRhdGUgb24gaXQgYW5kIG9ubHkgbXV0YXRlIHRoZSBET00gYXMgbmVjZXNzYXJ5IHRvIHJlZmxlY3QgdGhlXG4gICAqIGxhdGVzdCBSZWFjdCBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHBhcmVudENvbXBvbmVudCBUaGUgY29uY2VwdHVhbCBwYXJlbnQgb2YgdGhpcyByZW5kZXIgdHJlZS5cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IENvbXBvbmVudCBlbGVtZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbiB0cmlnZ2VyZWQgb24gY29tcGxldGlvblxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gQ29tcG9uZW50IGluc3RhbmNlIHJlbmRlcmVkIGluIGBjb250YWluZXJgLlxuICAgKi9cbiAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBSZWFjdEluc3RhbmNlTWFwLmhhcyhwYXJlbnRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzM4JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIF9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLnZhbGlkYXRlQ2FsbGJhY2soY2FsbGJhY2ssICdSZWFjdERPTS5yZW5kZXInKTtcbiAgICAhUmVhY3QuaXNWYWxpZEVsZW1lbnQobmV4dEVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NLnJlbmRlcigpOiBJbnZhbGlkIGNvbXBvbmVudCBlbGVtZW50LiVzJywgdHlwZW9mIG5leHRFbGVtZW50ID09PSAnc3RyaW5nJyA/IFwiIEluc3RlYWQgb2YgcGFzc2luZyBhIHN0cmluZyBsaWtlICdkaXYnLCBwYXNzIFwiICsgXCJSZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnKSBvciA8ZGl2IC8+LlwiIDogdHlwZW9mIG5leHRFbGVtZW50ID09PSAnZnVuY3Rpb24nID8gJyBJbnN0ZWFkIG9mIHBhc3NpbmcgYSBjbGFzcyBsaWtlIEZvbywgcGFzcyAnICsgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9vKSBvciA8Rm9vIC8+LicgOiAvLyBDaGVjayBpZiBpdCBxdWFja3MgbGlrZSBhbiBlbGVtZW50XG4gICAgbmV4dEVsZW1lbnQgIT0gbnVsbCAmJiBuZXh0RWxlbWVudC5wcm9wcyAhPT0gdW5kZWZpbmVkID8gJyBUaGlzIG1heSBiZSBjYXVzZWQgYnkgdW5pbnRlbnRpb25hbGx5IGxvYWRpbmcgdHdvIGluZGVwZW5kZW50ICcgKyAnY29waWVzIG9mIFJlYWN0LicgOiAnJykgOiBfcHJvZEludmFyaWFudCgnMzknLCB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdzdHJpbmcnID8gXCIgSW5zdGVhZCBvZiBwYXNzaW5nIGEgc3RyaW5nIGxpa2UgJ2RpdicsIHBhc3MgXCIgKyBcIlJlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIG9yIDxkaXYgLz4uXCIgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNsYXNzIGxpa2UgRm9vLCBwYXNzICcgKyAnUmVhY3QuY3JlYXRlRWxlbWVudChGb28pIG9yIDxGb28gLz4uJyA6IG5leHRFbGVtZW50ICE9IG51bGwgJiYgbmV4dEVsZW1lbnQucHJvcHMgIT09IHVuZGVmaW5lZCA/ICcgVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHVuaW50ZW50aW9uYWxseSBsb2FkaW5nIHR3byBpbmRlcGVuZGVudCAnICsgJ2NvcGllcyBvZiBSZWFjdC4nIDogJycpIDogdm9pZCAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lciB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBuZXh0V3JhcHBlZEVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFRvcExldmVsV3JhcHBlciwge1xuICAgICAgY2hpbGQ6IG5leHRFbGVtZW50XG4gICAgfSk7XG5cbiAgICB2YXIgbmV4dENvbnRleHQ7XG4gICAgaWYgKHBhcmVudENvbXBvbmVudCkge1xuICAgICAgdmFyIHBhcmVudEluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwYXJlbnRDb21wb25lbnQpO1xuICAgICAgbmV4dENvbnRleHQgPSBwYXJlbnRJbnN0Ll9wcm9jZXNzQ2hpbGRDb250ZXh0KHBhcmVudEluc3QuX2NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q29udGV4dCA9IGVtcHR5T2JqZWN0O1xuICAgIH1cblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKTtcblxuICAgIGlmIChwcmV2Q29tcG9uZW50KSB7XG4gICAgICB2YXIgcHJldldyYXBwZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgcHJldkVsZW1lbnQgPSBwcmV2V3JhcHBlZEVsZW1lbnQucHJvcHMuY2hpbGQ7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICB2YXIgcHVibGljSW5zdCA9IHByZXZDb21wb25lbnQuX3JlbmRlcmVkQ29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgICAgIHZhciB1cGRhdGVkQ2FsbGJhY2sgPSBjYWxsYmFjayAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChwdWJsaWNJbnN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgUmVhY3RNb3VudC5fdXBkYXRlUm9vdENvbXBvbmVudChwcmV2Q29tcG9uZW50LCBuZXh0V3JhcHBlZEVsZW1lbnQsIG5leHRDb250ZXh0LCBjb250YWluZXIsIHVwZGF0ZWRDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwdWJsaWNJbnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0Um9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVySGFzUmVhY3RNYXJrdXAgPSByZWFjdFJvb3RFbGVtZW50ICYmICEhaW50ZXJuYWxHZXRJRChyZWFjdFJvb3RFbGVtZW50KTtcbiAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmICghY29udGFpbmVySGFzUmVhY3RNYXJrdXAgfHwgcmVhY3RSb290RWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRTaWJsaW5nID0gcmVhY3RSb290RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHJvb3RFbGVtZW50U2libGluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3RFbGVtZW50U2libGluZyA9IHJvb3RFbGVtZW50U2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaG91bGRSZXVzZU1hcmt1cCA9IGNvbnRhaW5lckhhc1JlYWN0TWFya3VwICYmICFwcmV2Q29tcG9uZW50ICYmICFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZDtcbiAgICB2YXIgY29tcG9uZW50ID0gUmVhY3RNb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudChuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIG5leHRDb250ZXh0KS5fcmVuZGVyZWRDb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY29tcG9uZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmVuZGVycyBhIFJlYWN0IGNvbXBvbmVudCBpbnRvIHRoZSBET00gaW4gdGhlIHN1cHBsaWVkIGBjb250YWluZXJgLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3Rkb20ucmVuZGVyXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFuZCBkZXN0cm95cyB0aGUgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGluIHRoZSBgY29udGFpbmVyYC5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0ZG9tLnVubW91bnRjb21wb25lbnRhdG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgY29udGFpbmluZyBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGNvbXBvbmVudCB3YXMgZm91bmQgaW4gYW5kIHVubW91bnRlZCBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgIGBjb250YWluZXJgXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgLy8gVmFyaW91cyBwYXJ0cyBvZiBvdXIgY29kZSAoc3VjaCBhcyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCdzXG4gICAgLy8gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCkgYXNzdW1lIHRoYXQgY2FsbHMgdG8gcmVuZGVyIGFyZW4ndCBuZXN0ZWQ7XG4gICAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoU3RyaWN0bHkgc3BlYWtpbmcsIHVubW91bnRpbmcgd29uJ3QgY2F1c2UgYVxuICAgIC8vIHJlbmRlciBidXQgd2Ugc3RpbGwgZG9uJ3QgZXhwZWN0IHRvIGJlIGluIGEgcmVuZGVyIGNhbGwgaGVyZS4pXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uICcgKyAnb2YgcHJvcHMgYW5kIHN0YXRlOyB0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciAnICsgJ2lzIG5vdCBhbGxvd2VkLiBJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gJyArICdjb21wb25lbnREaWRVcGRhdGUuIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCc0MCcpIDogdm9pZCAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFub2RlSXNSZW5kZXJlZEJ5T3RoZXJJbnN0YW5jZShjb250YWluZXIpLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgYW5vdGhlciBjb3B5IG9mIFJlYWN0LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBwcmV2Q29tcG9uZW50ID0gZ2V0VG9wTGV2ZWxXcmFwcGVySW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICBpZiAoIXByZXZDb21wb25lbnQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBub2RlIGJlaW5nIHVubW91bnRlZCB3YXMgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCBpc24ndCBhXG4gICAgICAvLyByb290IG5vZGUuXG4gICAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSAmJiBjb250YWluZXIuaGFzQXR0cmlidXRlKFJPT1RfQVRUUl9OQU1FKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSBpbnN0YW5jZXNCeVJlYWN0Um9vdElEW3ByZXZDb21wb25lbnQuX2luc3RhbmNlLnJvb3RJRF07XG4gICAgUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzKHVubW91bnRDb21wb25lbnRGcm9tTm9kZSwgcHJldkNvbXBvbmVudCwgY29udGFpbmVyLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgX21vdW50SW1hZ2VJbnRvTm9kZTogZnVuY3Rpb24gKG1hcmt1cCwgY29udGFpbmVyLCBpbnN0YW5jZSwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKSB7XG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtb3VudENvbXBvbmVudEludG9Ob2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IHZhbGlkLicpIDogX3Byb2RJbnZhcmlhbnQoJzQxJykgOiB2b2lkIDA7XG5cbiAgICBpZiAoc2hvdWxkUmV1c2VNYXJrdXApIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgaWYgKFJlYWN0TWFya3VwQ2hlY2tzdW0uY2FuUmV1c2VNYXJrdXAobWFya3VwLCByb290RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZShpbnN0YW5jZSwgcm9vdEVsZW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSByb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgICAgICByb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuXG4gICAgICAgIHZhciByb290TWFya3VwID0gcm9vdEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICByb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUsIGNoZWNrc3VtKTtcblxuICAgICAgICB2YXIgbm9ybWFsaXplZE1hcmt1cCA9IG1hcmt1cDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBiZWNhdXNlIHJvb3RNYXJrdXAgaXMgcmV0cmlldmVkIGZyb20gdGhlIERPTSwgdmFyaW91cyBub3JtYWxpemF0aW9uc1xuICAgICAgICAgIC8vIHdpbGwgaGF2ZSBvY2N1cnJlZCB3aGljaCB3aWxsIG5vdCBiZSBwcmVzZW50IGluIGBtYXJrdXBgLiBIZXJlLFxuICAgICAgICAgIC8vIGluc2VydCBtYXJrdXAgaW50byBhIDxkaXY+IG9yIDxpZnJhbWU+IGRlcGVuZGluZyBvbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgLy8gdHlwZSB0byBwZXJmb3JtIHRoZSBzYW1lIG5vcm1hbGl6YXRpb25zIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgICAgICAgdmFyIG5vcm1hbGl6ZXI7XG4gICAgICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIuaW5uZXJIVE1MID0gbWFya3VwO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuaW5uZXJIVE1MO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5jb250ZW50RG9jdW1lbnQud3JpdGUobWFya3VwKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRNYXJrdXAgPSBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChub3JtYWxpemVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZkluZGV4ID0gZmlyc3REaWZmZXJlbmNlSW5kZXgobm9ybWFsaXplZE1hcmt1cCwgcm9vdE1hcmt1cCk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gJyAoY2xpZW50KSAnICsgbm9ybWFsaXplZE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKSArICdcXG4gKHNlcnZlcikgJyArIHJvb3RNYXJrdXAuc3Vic3RyaW5nKGRpZmZJbmRleCAtIDIwLCBkaWZmSW5kZXggKyAyMCk7XG5cbiAgICAgICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgYnV0IHRoZSBjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSByZW5kZXJlZCBhIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZSBvciBwcm9wcyBvbiB0aGUgY2xpZW50IGZyb20gdGhlIG9uZSBvbiB0aGUgc2VydmVyLCBvciB5b3VyIHJlbmRlcigpIG1ldGhvZHMgYXJlIGltcHVyZS4gUmVhY3QgY2Fubm90IGhhbmRsZSB0aGlzIGNhc2UgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzIGJ5IHJlbmRlcmluZyBhdCB0aGUgZG9jdW1lbnQgcm9vdC4gWW91IHNob3VsZCBsb29rIGZvciBlbnZpcm9ubWVudCBkZXBlbmRlbnQgY29kZSBpbiB5b3VyIGNvbXBvbmVudHMgYW5kIGVuc3VyZSB0aGUgcHJvcHMgYXJlIHRoZSBzYW1lIGNsaWVudCBhbmQgc2VydmVyIHNpZGU6XFxuJXMnLCBkaWZmZXJlbmNlKSA6IF9wcm9kSW52YXJpYW50KCc0MicsIGRpZmZlcmVuY2UpIDogdm9pZCAwO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdCBhdHRlbXB0ZWQgdG8gcmV1c2UgbWFya3VwIGluIGEgY29udGFpbmVyIGJ1dCB0aGUgJyArICdjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCB5b3UgYXJlICcgKyAndXNpbmcgc2VydmVyIHJlbmRlcmluZyBhbmQgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlICcgKyAnc2VydmVyIHdhcyBub3Qgd2hhdCB0aGUgY2xpZW50IHdhcyBleHBlY3RpbmcuIFJlYWN0IGluamVjdGVkICcgKyAnbmV3IG1hcmt1cCB0byBjb21wZW5zYXRlIHdoaWNoIHdvcmtzIGJ1dCB5b3UgaGF2ZSBsb3N0IG1hbnkgJyArICdvZiB0aGUgYmVuZWZpdHMgb2Ygc2VydmVyIHJlbmRlcmluZy4gSW5zdGVhZCwgZmlndXJlIG91dCAnICsgJ3doeSB0aGUgbWFya3VwIGJlaW5nIGdlbmVyYXRlZCBpcyBkaWZmZXJlbnQgb24gdGhlIGNsaWVudCAnICsgJ29yIHNlcnZlcjpcXG4lcycsIGRpZmZlcmVuY2UpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IGJ1dCB5b3UgZGlkblxcJ3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFdlIGNhblxcJ3QgZG8gdGhpcyB3aXRob3V0IHVzaW5nIHNlcnZlciByZW5kZXJpbmcgZHVlIHRvIGNyb3NzLWJyb3dzZXIgcXVpcmtzLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IF9wcm9kSW52YXJpYW50KCc0MycpIDogdm9pZCAwO1xuXG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHdoaWxlIChjb250YWluZXIubGFzdENoaWxkKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIERPTUxhenlUcmVlLmluc2VydFRyZWVCZWZvcmUoY29udGFpbmVyLCBtYXJrdXAsIG51bGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJbm5lckhUTUwoY29udGFpbmVyLCBtYXJrdXApO1xuICAgICAgUmVhY3RET01Db21wb25lbnRUcmVlLnByZWNhY2hlTm9kZShpbnN0YW5jZSwgY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaG9zdE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICBpZiAoaG9zdE5vZGUuX2RlYnVnSUQgIT09IDApIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgICAgaW5zdGFuY2VJRDogaG9zdE5vZGUuX2RlYnVnSUQsXG4gICAgICAgICAgdHlwZTogJ21vdW50JyxcbiAgICAgICAgICBwYXlsb2FkOiBtYXJrdXAudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE1vdW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xuXG5mdW5jdGlvbiBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KSB7XG4gIHZhciB0eXBlO1xuXG4gIHdoaWxlICgodHlwZSA9IGluc3QuX3JlbmRlcmVkTm9kZVR5cGUpID09PSBSZWFjdE5vZGVUeXBlcy5DT01QT1NJVEUpIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVuZGVyZWRDb21wb25lbnQ7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gUmVhY3ROb2RlVHlwZXMuSE9TVCkge1xuICAgIHJldHVybiBpbnN0Ll9yZW5kZXJlZENvbXBvbmVudDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBSZWFjdE5vZGVUeXBlcy5FTVBUWSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUuanMiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgbWF0Y2hpbmcgYSBzaW5nbGUgcGF0aCBhbmQgcmVuZGVyaW5nLlxuICovXG5cbnZhciBSb3V0ZSA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSb3V0ZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUm91dGUoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSb3V0ZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBtYXRjaDogX3RoaXMuY29tcHV0ZU1hdGNoKF90aGlzLnByb3BzLCBfdGhpcy5jb250ZXh0LnJvdXRlcilcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFJvdXRlLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdXRlcjogX2V4dGVuZHMoe30sIHRoaXMuY29udGV4dC5yb3V0ZXIsIHtcbiAgICAgICAgcm91dGU6IHtcbiAgICAgICAgICBsb2NhdGlvbjogdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCB0aGlzLmNvbnRleHQucm91dGVyLnJvdXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoOiB0aGlzLnN0YXRlLm1hdGNoXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUuY29tcHV0ZU1hdGNoID0gZnVuY3Rpb24gY29tcHV0ZU1hdGNoKF9yZWYsIF9yZWYyKSB7XG4gICAgdmFyIGNvbXB1dGVkTWF0Y2ggPSBfcmVmLmNvbXB1dGVkTWF0Y2gsXG4gICAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgICAgcGF0aCA9IF9yZWYucGF0aCxcbiAgICAgICAgc3RyaWN0ID0gX3JlZi5zdHJpY3QsXG4gICAgICAgIGV4YWN0ID0gX3JlZi5leGFjdDtcbiAgICB2YXIgcm91dGUgPSBfcmVmMi5yb3V0ZTtcblxuICAgIGlmIChjb21wdXRlZE1hdGNoKSByZXR1cm4gY29tcHV0ZWRNYXRjaDsgLy8gPFN3aXRjaD4gYWxyZWFkeSBjb21wdXRlZCB0aGUgbWF0Y2ggZm9yIHVzXG5cbiAgICB2YXIgcGF0aG5hbWUgPSAobG9jYXRpb24gfHwgcm91dGUubG9jYXRpb24pLnBhdGhuYW1lO1xuXG4gICAgcmV0dXJuIHBhdGggPyBtYXRjaFBhdGgocGF0aG5hbWUsIHsgcGF0aDogcGF0aCwgc3RyaWN0OiBzdHJpY3QsIGV4YWN0OiBleGFjdCB9KSA6IHJvdXRlLm1hdGNoO1xuICB9O1xuXG4gIFJvdXRlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNvbXBvbmVudCA9IF9wcm9wcy5jb21wb25lbnQsXG4gICAgICAgIHJlbmRlciA9IF9wcm9wcy5yZW5kZXIsXG4gICAgICAgIGNoaWxkcmVuID0gX3Byb3BzLmNoaWxkcmVuO1xuXG5cbiAgICB3YXJuaW5nKCEoY29tcG9uZW50ICYmIHJlbmRlciksICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIGNvbXBvbmVudD4gYW5kIDxSb3V0ZSByZW5kZXI+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgcmVuZGVyPiB3aWxsIGJlIGlnbm9yZWQnKTtcblxuICAgIHdhcm5pbmcoIShjb21wb25lbnQgJiYgY2hpbGRyZW4pLCAnWW91IHNob3VsZCBub3QgdXNlIDxSb3V0ZSBjb21wb25lbnQ+IGFuZCA8Um91dGUgY2hpbGRyZW4+IGluIHRoZSBzYW1lIHJvdXRlOyA8Um91dGUgY2hpbGRyZW4+IHdpbGwgYmUgaWdub3JlZCcpO1xuXG4gICAgd2FybmluZyghKHJlbmRlciAmJiBjaGlsZHJlbiksICdZb3Ugc2hvdWxkIG5vdCB1c2UgPFJvdXRlIHJlbmRlcj4gYW5kIDxSb3V0ZSBjaGlsZHJlbj4gaW4gdGhlIHNhbWUgcm91dGU7IDxSb3V0ZSBjaGlsZHJlbj4gd2lsbCBiZSBpZ25vcmVkJyk7XG4gIH07XG5cbiAgUm91dGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICB3YXJuaW5nKCEobmV4dFByb3BzLmxvY2F0aW9uICYmICF0aGlzLnByb3BzLmxvY2F0aW9uKSwgJzxSb3V0ZT4gZWxlbWVudHMgc2hvdWxkIG5vdCBjaGFuZ2UgZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuIFlvdSBpbml0aWFsbHkgdXNlZCBubyBcImxvY2F0aW9uXCIgcHJvcCBhbmQgdGhlbiBwcm92aWRlZCBvbmUgb24gYSBzdWJzZXF1ZW50IHJlbmRlci4nKTtcblxuICAgIHdhcm5pbmcoISghbmV4dFByb3BzLmxvY2F0aW9uICYmIHRoaXMucHJvcHMubG9jYXRpb24pLCAnPFJvdXRlPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIG1hdGNoOiB0aGlzLmNvbXB1dGVNYXRjaChuZXh0UHJvcHMsIG5leHRDb250ZXh0LnJvdXRlcilcbiAgICB9KTtcbiAgfTtcblxuICBSb3V0ZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBtYXRjaCA9IHRoaXMuc3RhdGUubWF0Y2g7XG4gICAgdmFyIF9wcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF9wcm9wczIuY2hpbGRyZW4sXG4gICAgICAgIGNvbXBvbmVudCA9IF9wcm9wczIuY29tcG9uZW50LFxuICAgICAgICByZW5kZXIgPSBfcHJvcHMyLnJlbmRlcjtcbiAgICB2YXIgX2NvbnRleHQkcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcixcbiAgICAgICAgaGlzdG9yeSA9IF9jb250ZXh0JHJvdXRlci5oaXN0b3J5LFxuICAgICAgICByb3V0ZSA9IF9jb250ZXh0JHJvdXRlci5yb3V0ZSxcbiAgICAgICAgc3RhdGljQ29udGV4dCA9IF9jb250ZXh0JHJvdXRlci5zdGF0aWNDb250ZXh0O1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcbiAgICB2YXIgcHJvcHMgPSB7IG1hdGNoOiBtYXRjaCwgbG9jYXRpb246IGxvY2F0aW9uLCBoaXN0b3J5OiBoaXN0b3J5LCBzdGF0aWNDb250ZXh0OiBzdGF0aWNDb250ZXh0IH07XG5cbiAgICByZXR1cm4gY29tcG9uZW50ID8gLy8gY29tcG9uZW50IHByb3AgZ2V0cyBmaXJzdCBwcmlvcml0eSwgb25seSBjYWxsZWQgaWYgdGhlcmUncyBhIG1hdGNoXG4gICAgbWF0Y2ggPyBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpIDogbnVsbCA6IHJlbmRlciA/IC8vIHJlbmRlciBwcm9wIGlzIG5leHQsIG9ubHkgY2FsbGVkIGlmIHRoZXJlJ3MgYSBtYXRjaFxuICAgIG1hdGNoID8gcmVuZGVyKHByb3BzKSA6IG51bGwgOiBjaGlsZHJlbiA/IC8vIGNoaWxkcmVuIGNvbWUgbGFzdCwgYWx3YXlzIGNhbGxlZFxuICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHByb3BzKSA6ICFBcnJheS5pc0FycmF5KGNoaWxkcmVuKSB8fCBjaGlsZHJlbi5sZW5ndGggPyAvLyBQcmVhY3QgZGVmYXVsdHMgdG8gZW1wdHkgY2hpbGRyZW4gYXJyYXlcbiAgICBSZWFjdC5DaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSA6IG51bGwgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBSb3V0ZTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuUm91dGUucHJvcFR5cGVzID0ge1xuICBjb21wdXRlZE1hdGNoOiBQcm9wVHlwZXMub2JqZWN0LCAvLyBwcml2YXRlLCBmcm9tIDxTd2l0Y2g+XG4gIHBhdGg6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGV4YWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgc3RyaWN0OiBQcm9wVHlwZXMuYm9vbCxcbiAgY29tcG9uZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgcmVuZGVyOiBQcm9wVHlwZXMuZnVuYyxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMubm9kZV0pLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdFxufTtcblJvdXRlLmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICByb3V0ZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHN0YXRpY0NvbnRleHQ6IFByb3BUeXBlcy5vYmplY3RcbiAgfSlcbn07XG5Sb3V0ZS5jaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWRcbn07XG5cblxuZXhwb3J0IGRlZmF1bHQgUm91dGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Sb3V0ZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Mb2NhdGlvblV0aWxzID0gcmVxdWlyZSgnLi9Mb2NhdGlvblV0aWxzJyk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBQb3BTdGF0ZUV2ZW50ID0gJ3BvcHN0YXRlJztcbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBnZXRIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RUcmFpbmluZy9oaXN0b3J5L3B1bGwvMjg5XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGluY2x1ZGluZ1xuICogcHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQuXG4gKi9cbnZhciBjcmVhdGVCcm93c2VySGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShfRE9NVXRpbHMuY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSAoMCwgX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gISgwLCBfRE9NVXRpbHMuc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSkoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBfRE9NVXRpbHMuZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gKDAsIF9QYXRoVXRpbHMuc3RyaXBUcmFpbGluZ1NsYXNoKSgoMCwgX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gpKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoIWJhc2VuYW1lIHx8ICgwLCBfUGF0aFV0aWxzLmhhc0Jhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gKDAsIF9QYXRoVXRpbHMuc3RyaXBCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGtleSk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUtleSA9IGZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIGtleUxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcFN0YXRlID0gZnVuY3Rpb24gaGFuZGxlUG9wU3RhdGUoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuICAgIGlmICgoMCwgX0RPTVV0aWxzLmlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQpKGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSkpO1xuICB9O1xuXG4gIHZhciBmb3JjZU5leHRQb3AgPSBmYWxzZTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIGtleXMgd2UndmUgc2VlbiBpbiBzZXNzaW9uU3RvcmFnZS5cbiAgICAvLyBJbnN0ZWFkLCB3ZSBqdXN0IGRlZmF1bHQgdG8gMCBmb3Iga2V5cyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxLZXlzLmluZGV4T2YodG9Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxLZXlzLmluZGV4T2YoZnJvbUxvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAoZnJvbUluZGV4ID09PSAtMSkgZnJvbUluZGV4ID0gMDtcblxuICAgIHZhciBkZWx0YSA9IHRvSW5kZXggLSBmcm9tSW5kZXg7XG5cbiAgICBpZiAoZGVsdGEpIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IHRydWU7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpbml0aWFsTG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbihnZXRIaXN0b3J5U3RhdGUoKSk7XG4gIHZhciBhbGxLZXlzID0gW2luaXRpYWxMb2NhdGlvbi5rZXldO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gYmFzZW5hbWUgKyAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxLZXlzLmluZGV4T2YoaGlzdG9yeS5sb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIHZhciBuZXh0S2V5cyA9IGFsbEtleXMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICAgIG5leHRLZXlzLnB1c2gobG9jYXRpb24ua2V5KTtcbiAgICAgICAgICBhbGxLZXlzID0gbmV4dEtleXM7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSAoMCwgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgICgwLCBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcikod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgKDAsIF9ET01VdGlscy5yZW1vdmVFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVCcm93c2VySGlzdG9yeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBjYW5Vc2VET00gPSBleHBvcnRzLmNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBhZGRFdmVudExpc3RlbmVyID0gZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUuYWRkRXZlbnRMaXN0ZW5lciA/IG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG52YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxudmFyIGdldENvbmZpcm1hdGlvbiA9IGV4cG9ydHMuZ2V0Q29uZmlybWF0aW9uID0gZnVuY3Rpb24gZ2V0Q29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjYWxsYmFjayh3aW5kb3cuY29uZmlybShtZXNzYWdlKSk7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpcyBzdXBwb3J0ZWQuIFRha2VuIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gKiBjaGFuZ2VkIHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcyBmb3IgV2luZG93cyBQaG9uZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cbnZhciBzdXBwb3J0c0hpc3RvcnkgPSBleHBvcnRzLnN1cHBvcnRzSGlzdG9yeSA9IGZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5ICYmICdwdXNoU3RhdGUnIGluIHdpbmRvdy5oaXN0b3J5O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYnJvd3NlciBmaXJlcyBwb3BzdGF0ZSBvbiBoYXNoIGNoYW5nZS5cbiAqIElFMTAgYW5kIElFMTEgZG8gbm90LlxuICovXG52YXIgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSA9IGV4cG9ydHMuc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSA9IGZ1bmN0aW9uIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHVzaW5nIGdvKG4pIHdpdGggaGFzaCBoaXN0b3J5IGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQuXG4gKi9cbnZhciBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGV4cG9ydHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBmdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHBvcHN0YXRlIGV2ZW50IGlzIGFuIGV4dHJhbmVvdXMgV2ViS2l0IGV2ZW50LlxuICogQWNjb3VudHMgZm9yIHRoZSBmYWN0IHRoYXQgQ2hyb21lIG9uIGlPUyBmaXJlcyByZWFsIHBvcHN0YXRlIGV2ZW50c1xuICogY29udGFpbmluZyB1bmRlZmluZWQgc3RhdGUgd2hlbiBwcmVzc2luZyB0aGUgYmFjayBidXR0b24uXG4gKi9cbnZhciBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50ID0gZXhwb3J0cy5pc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50ID0gZnVuY3Rpb24gaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgPT09IC0xO1xufTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaGlzdG9yeS9ET01VdGlscy5qcyIsIm1vZHVsZS5leHBvcnRzID0ge1widGl0bGVcIjpcIkJpcmRzIE5lZWQgQSBIb21lIEdvZCBEYW1taXQhXCIsXCJtZXRhZGF0YVwiOlt7XCJuYW1lXCI6XCJkZXNjcmlwdGlvblwiLFwiY29udGVudFwiOlwiQmlyZHMgbmVlZCBhIGhvbWUgb2YgY291cnNlXCJ9LHtcIm5hbWVcIjpcImF1dGhvclwiLFwiY29udGVudFwiOlwiSm9obiBIdW1tZWxcIn0se1wiY2hhcnNldFwiOlwidXRmLThcIn1dLFwiaG91c2VzXCI6W3tcImlkXCI6MSxcInRpdGxlXCI6XCJIb3VzZSB0aXRsZSAxXCIsXCJkZXNjXCI6XCJIb3VzZSBkZXNjIDFcIn1dLFwiZ2FsbGVyaWVzXCI6W3tcImlkXCI6MSxcImhvdXNlSWRcIjoxLFwidGl0bGVcIjpcIkdhbGxlcnkgdGl0bGUgMVwiLFwiZGVzY1wiOlwiR2FsbGVyeSBkZXNjIDFcIn1dLFwicGljc1wiOlt7XCJpZFwiOjEsXCJ0eXBlXCI6XCJHXCIsXCJ4aWRcIjoxLFwidGl0bGVcIjpcIlBpYyB0aXRsZSBmb3IgZ2FsbGVyeSAxXCIsXCJkZXNjXCI6XCJQaWMgZGVzYyBmb3IgZ2FsbGVyeSAxXCIsXCJzcmNcIjpcImh0dHA6Ly92aWEucGxhY2Vob2xkZXIuY29tLzE1MHgyMDAvZmZmLzAwMC5wbmc/dGV4dD1HYWxsZXJ5JTIwMVwifSx7XCJpZFwiOjIsXCJ0eXBlXCI6XCJIXCIsXCJ4aWRcIjoxLFwidGl0bGVcIjpcIlBpYyB0aXRsZSBmb3IgaG91c2UgMVwiLFwiZGVzY1wiOlwiUGljIGRlc2MgZm9yIGhvdXNlIDFcIixcInNyY1wiOlwiaHR0cDovL3ZpYS5wbGFjZWhvbGRlci5jb20vMTUweDIwMC9mZmYvMDAwLnBuZz90ZXh0PUhvdXNlJTIwMVwifV19XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY3JpcHRzL2NvbnRlbnQuanNvblxuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IF9Ccm93c2VyUm91dGVyIGZyb20gJy4vQnJvd3NlclJvdXRlcic7XG5leHBvcnQgeyBfQnJvd3NlclJvdXRlciBhcyBCcm93c2VyUm91dGVyIH07XG5pbXBvcnQgX0hhc2hSb3V0ZXIgZnJvbSAnLi9IYXNoUm91dGVyJztcbmV4cG9ydCB7IF9IYXNoUm91dGVyIGFzIEhhc2hSb3V0ZXIgfTtcbmltcG9ydCBfTGluayBmcm9tICcuL0xpbmsnO1xuZXhwb3J0IHsgX0xpbmsgYXMgTGluayB9O1xuaW1wb3J0IF9NZW1vcnlSb3V0ZXIgZnJvbSAnLi9NZW1vcnlSb3V0ZXInO1xuZXhwb3J0IHsgX01lbW9yeVJvdXRlciBhcyBNZW1vcnlSb3V0ZXIgfTtcbmltcG9ydCBfTmF2TGluayBmcm9tICcuL05hdkxpbmsnO1xuZXhwb3J0IHsgX05hdkxpbmsgYXMgTmF2TGluayB9O1xuaW1wb3J0IF9Qcm9tcHQgZnJvbSAnLi9Qcm9tcHQnO1xuZXhwb3J0IHsgX1Byb21wdCBhcyBQcm9tcHQgfTtcbmltcG9ydCBfUmVkaXJlY3QgZnJvbSAnLi9SZWRpcmVjdCc7XG5leHBvcnQgeyBfUmVkaXJlY3QgYXMgUmVkaXJlY3QgfTtcbmltcG9ydCBfUm91dGUgZnJvbSAnLi9Sb3V0ZSc7XG5leHBvcnQgeyBfUm91dGUgYXMgUm91dGUgfTtcbmltcG9ydCBfUm91dGVyIGZyb20gJy4vUm91dGVyJztcbmV4cG9ydCB7IF9Sb3V0ZXIgYXMgUm91dGVyIH07XG5pbXBvcnQgX1N0YXRpY1JvdXRlciBmcm9tICcuL1N0YXRpY1JvdXRlcic7XG5leHBvcnQgeyBfU3RhdGljUm91dGVyIGFzIFN0YXRpY1JvdXRlciB9O1xuaW1wb3J0IF9Td2l0Y2ggZnJvbSAnLi9Td2l0Y2gnO1xuZXhwb3J0IHsgX1N3aXRjaCBhcyBTd2l0Y2ggfTtcbmltcG9ydCBfbWF0Y2hQYXRoIGZyb20gJy4vbWF0Y2hQYXRoJztcbmV4cG9ydCB7IF9tYXRjaFBhdGggYXMgbWF0Y2hQYXRoIH07XG5pbXBvcnQgX3dpdGhSb3V0ZXIgZnJvbSAnLi93aXRoUm91dGVyJztcbmV4cG9ydCB7IF93aXRoUm91dGVyIGFzIHdpdGhSb3V0ZXIgfTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9pbmRleC5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxudmFyIGlzTW9kaWZpZWRFdmVudCA9IGZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgYSBoaXN0b3J5LWF3YXJlIDxhPi5cbiAqL1xuXG52YXIgTGluayA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhMaW5rLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBMaW5rKCkge1xuICAgIHZhciBfdGVtcCwgX3RoaXMsIF9yZXQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluayk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkNsaWNrKSBfdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcblxuICAgICAgaWYgKCFldmVudC5kZWZhdWx0UHJldmVudGVkICYmIC8vIG9uQ2xpY2sgcHJldmVudGVkIGRlZmF1bHRcbiAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAvLyBpZ25vcmUgcmlnaHQgY2xpY2tzXG4gICAgICAhX3RoaXMucHJvcHMudGFyZ2V0ICYmIC8vIGxldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KSAvLyBpZ25vcmUgY2xpY2tzIHdpdGggbW9kaWZpZXIga2V5c1xuICAgICAgKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIHZhciBoaXN0b3J5ID0gX3RoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcbiAgICAgICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgcmVwbGFjZSA9IF90aGlzJHByb3BzLnJlcGxhY2UsXG4gICAgICAgICAgICAgIHRvID0gX3RoaXMkcHJvcHMudG87XG5cblxuICAgICAgICAgIGlmIChyZXBsYWNlKSB7XG4gICAgICAgICAgICBoaXN0b3J5LnJlcGxhY2UodG8pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaXN0b3J5LnB1c2godG8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgTGluay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICByZXBsYWNlID0gX3Byb3BzLnJlcGxhY2UsXG4gICAgICAgIHRvID0gX3Byb3BzLnRvLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMsIFsncmVwbGFjZScsICd0byddKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgdmFyIGhyZWYgPSB0aGlzLmNvbnRleHQucm91dGVyLmhpc3RvcnkuY3JlYXRlSHJlZih0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8geyBwYXRobmFtZTogdG8gfSA6IHRvKTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdhJywgX2V4dGVuZHMoe30sIHByb3BzLCB7IG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2ssIGhyZWY6IGhyZWYgfSkpO1xuICB9O1xuXG4gIHJldHVybiBMaW5rO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5MaW5rLnByb3BUeXBlcyA9IHtcbiAgb25DbGljazogUHJvcFR5cGVzLmZ1bmMsXG4gIHRhcmdldDogUHJvcFR5cGVzLnN0cmluZyxcbiAgcmVwbGFjZTogUHJvcFR5cGVzLmJvb2wsXG4gIHRvOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSkuaXNSZXF1aXJlZFxufTtcbkxpbmsuZGVmYXVsdFByb3BzID0ge1xuICByZXBsYWNlOiBmYWxzZVxufTtcbkxpbmsuY29udGV4dFR5cGVzID0ge1xuICByb3V0ZXI6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaGlzdG9yeTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHB1c2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICByZXBsYWNlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgY3JlYXRlSHJlZjogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBMaW5rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL0xpbmsuanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdDtiYXNlNjQsdU9vQUFBanFBQUFCQUFJQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUpBQkFBQUFBRXhRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFkVXNFSlFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJRQWJBQmxBR2NBYndBdEFHa0FZd0J2QUc0QWN3QUFBQTRBVWdCbEFHY0FkUUJzQUdFQWNnQUFBQllBVmdCbEFISUFjd0JwQUc4QWJnQWdBREVBTGdBd0FBQUFGQUJzQUdVQVp3QnZBQzBBYVFCakFHOEFiZ0J6QUFBQUFBQUFBUUFBQUFzQWdBQURBREJQVXk4eUR4SUd1QUFBQUx3QUFBQmdZMjFoY080a2w2OEFBQUVjQUFBQWRHZGhjM0FBQUFBUUFBQUJrQUFBQUFobmJIbG1MSWxodkFBQUFaZ0FBT0ZjYUdWaFpBdFlLQ0lBQU9MMEFBQUFObWhvWldFSHh3U0dBQURqTEFBQUFDUm9iWFI0SmdFY0F3QUE0MUFBQUFNd2JHOWpZWUwyUy93QUFPYUFBQUFCbW0xaGVIQUE0d0pOQUFEb0hBQUFBQ0J1WVcxbHBkakR1UUFBNkR3QUFBR3FjRzl6ZEFBREFBQUFBT25vQUFBQUlBQURBLzBCa0FBRkFBQUNtUUxNQUFBQWp3S1pBc3dBQUFIckFETUJDUUFBQUFBQUFBQUFBQUFBQUFBQUFBRVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFBT21SQThEL3dBQkFBOEFBUUFBQUFBRUFBQUFBQUFBQUFBQUFBQ0FBQUFBQUFBTUFBQUFEQUFBQUhBQUJBQU1BQUFBY0FBTUFBUUFBQUJ3QUJBQllBQUFBRWdBUUFBTUFBZ0FCQUNEZ0NPYVg2U1hwSittUi8vMy8vd0FBQUFBQUlPQUI1Z0RwQU9rbjZaSC8vZi8vQUFILzR5QURHZ3dYcEJlakZ6b0FBd0FCQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFFQUFmLy9BQThBQVFBQUFBQUFBQUFBQUFJQUFEYzVBUUFBQUFBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFBQUFBQUFBQUFBQUNBQUEzT1FFQUFBQUFBUUFGLy9VRCt3T0hBQ2dBQUFFMU5DWXJBU0lHSFFFbkppSUhBVEFHRnhZMk1SRWhFVFEyT3dFeUZoVVJJUkV3RmpjMkpqRW5BME1RRVVRUkRxY0pIUXYrSGdvZEhWWUJCQkVSblJFU0FRTmRHeGtLdUFLZnh3NFRGUXhqZ0FnSS9wQW9KaU1KL2tvQkpnNFNFdy8rM0FHMUJ5Y2xKSXdBQlFBQS84QUVBQVBBQUJNQU5BQTRBRHdBUUFBQUFTSU9BaFVVSGdJek1qNENOVFF1QWdNMUl4VXVBeWN6TlNNK0F6Y1ZNelVlQXhjakZUTU9Bd2NiQVFVWEp4Y0hOeWNESlNjQ0FHcTdpMUJRaTd0cWFydUxVRkNMdXo5V1M0VmxRUWh2YndoQlpZVkxWa3VGWlVFSGJtNEhRV1dGU3plWC9xWEV0bXU5VWc2WEFWdkVBOEJRaTd0cWFydUxVRkNMdTJwcXU0dFEvRmh1YmdkQlpZVkxWa3VGWlVFSWIyOElRV1dGUzFaTGhXVkJCd0ZIQVZxWXduaHFVNzFLL3FhWXdnQUFBQUVBQUFBeEJBQURUd0FNQUFBbEVTTTFJUlVqTlNFVkl4RWhCQUI3L3MyYS9zTjdBdXd4QXBtRmhZV0YvV2NBQUFFQU1QL0FBODBEd0FBZUFBQUJJelUwSmlNaElnWVZNQlFWSXlJR0ZSRVVGaGNWSVRVK0FUVVJOaVlqQXhzNkVRcitkd3dQUFV0cVlrVUNUMGRnQW1sTEF3K1dDaEVQREpRQ2FFcitkRVZuQldCZ0JXUklBWTlJWndBQUJRQUxBSHNEOVFMdEFESUFRQUJOQUZrQVpnQUFBUzRCRGdFeERnRXJBU0ltSnpBdUFRWUhEZ0lXTVI0Qk56NERNVDRCTXlFeUZoY3dIZ0lYRmpZM01EWXVBU2NGRlNNVkl6VWpOVE0xTXhVekZRVWlKalUwTmpNeUZoVU9BU00xSWlZMU5EWXpNaFlWRGdFWElpWTFORFl6TWhZVkRnRWpBNlV6ZDJaRENpQU5OZ3doQ2tObWR6TXpKZ1FOQnpJc0ZrQTdLZ2tkREFGR0RCMEpLanRBRml3eUJ3MEZKakw5ODAxUlRVMVRUUUVzRmlBZ0dCY2hBU0lYRmlBZ0dCY2hBU0oxRnlFZ0dCWWlBaUFXQXFwVEtoRXBCd3NMQnlrUktsTlVwb1JTTFRVREFqSTdNUW9ORGdreE96SUNBelV0VW9TbVZGcExUVTFUVFU4R3FDQVdGeUVoRnhZZ21DRVhGeUVnR0JjaFVpSVdGeUVnR0JZaUFBSUFJdi9pQTk0RG5nQVVBQ0VBQUFFaURnSVZGQjRDTXpJK0FqVTBMZ0lqQXdZbU5SRTBOaGNGRmhRSEJRSUFZNjZDUzB1Q3JtTmpyb0pMUzRLdVkxVUdDd29IQVQwSEIvN0RBNTVMZ3E1alk2NkNTMHVDcm1OanJvSkwvVEFFQlFnQjBna0VCZWtFRGdYakFBSUFJUC9iQThZRHBBQU9BQ29BQUFFZUFRY09BeWN3TmpjK0FSY0JKZzRDQnc0RE1RWVdNUmNXTmpFd1BnSTNQZ01uQVUweUppRUtMRkovWFZNNkMxMDRBbmtaY1g1d0dSZE1SelFRRkRnWEpEQk5YaTlIYkVFUEZRRUpKVUUxRURjeklRaEdyaUpBS0FLYkRVTm1iUjBiWWw5R0VpQTBEeE1yU0Y0MFVJOXdTZ3dBQUFNQUFQLzlCQUFEZ3dBYUFDNEFPZ0FBQVNNMU5DWWpJU0lHSFFFaklnWVZFUlFXTXlFeU5qVVJOQ1lqQVNJdUFqVTBQZ0l6TWg0Q0ZSUU9BaWNpSmpVME5qTXlGaFVVQmdQR3REOHMvcklzUDdVWElpSVhBNDBZSWlJWS9qb3hWMEVtSmtGWE1URlhRU1ltUVZjeFBGVlZQRHhWVlFMbkxDeEVSQ3dzSVJmOWhoY2hJUmNDZWhjaC9ad21RVmN4TVZkQkppWkJWekV4VjBFbVhsVThQRlZWUER4VkFBQUFBQU1BQlAvQUEvd0R3QUE4QUVRQVN3QUFBU2NqUGdFeElUQVdGeU1IRkFZZUFSY2VBUmNWSGdFVkZBWUhNQVlWRGdFSERnRXhJVEFtSnk0Qkp6UW1NUzRCTlRRMk56VStBVGMrQWlZMUJUTWVBUmN1QVRjQlBnRTNNeFlHQS93RXVRSUMvWG9DQXJrRUNDMStoQ3RrRUFjSkNRY0hEaDBRTFI0QmhoNHRFQjBPQndjSkNRY1FaQ3VFZmkwSS9FT0ZCeDBabFRFRUFzQVpIUWVGQkRFRFdSc2pLU2tqR3dKT2ZKdE5VajRPQVFkMkN3c1RCd1VCQ0JnUExqWTJMZzhZQ0FFRkJ4TUxDM1lIQVE0K1VrMmJmRTRDSlc1WlhuMXFQdjdiWGxsdVBtb0FCQUFBLyt3RUF3TjhBQllBS2dBM0FFTUFBQUVqRVJRR0l5RVZGQll6SVJjek5UTXlOalVSTGdFakF5RWlCaFVSRkJZN0FSVXpOeUV5TmpVUk5DWUJJelUwTmpjVkRnRWRBVE1WTXlNMU5EWTNGUTRCSFFFekE4YUZFdy8rcWdvU0FVdFZDam9TS0FJcEV1SDlVaElsSlJJOUtYRUIxdzhuSlA1ZWNEZzRIQWtsNG00NE5oMHJTQUpNL3VnU0JyRVFKRXRMSWhJQnJnOGtBVEFiRXY0Y0VoZDBkQmtRQWVRU0cvNkZkREUyQXkwRklSY0VjSFF4TmdNdEJTRVhCQUFBQXdBQS84QUVBQVBBQUE4QUV3QVhBQUFCSXpVaElnWVZFUlFXTXlFUk15YzNBeUVSSVFVaEZTRUVBSW44elJ3b0tCd0RNNG1KaWUvOXZBSkUvazBCSXY3ZUF6ZUpLQno4aUJ3b0FtYUppUHp2QXpTcmlRQUFBQVFBTS8vQUE4MER3QUFRQUJRQUdBQWtBQUFCSVNJR0ZSRVVGak1oTWpZMUVUUW1Jd01oTlNFMUlUVWhOU0VSTXpVekZUTTFNeFV6QTRuODdod29LQndERWh3b0tCeUMvZklDRHYzeUFnNzk5ajJrVHAwK0E4QW9IUHlJSENnb0hBTjRIQ2o4blNsU0tXMEJWVVZGUlVVQUFBQUFCQUF6LzhBRHpRUEFBQkFBVndCY0FHRUFBQUVoSWdZVkVSUVdNeUV5TmpVUk5DWWpCVDRCTXo0Qk14NEJGeDRCRng0QkZ4NEJOekF5TVQ0Qk16SVdGUlFHSXlJbUp6RU9BUWNPQVFjT0FRY09BU011QVNNaUpqYzBOamMrQVRjK0FTY3VBU2NtQmljaUpqY0JJVFVoRlRVaE5TRVZBNG44N2h3b0tCd0RFaHdvS0J6OWN3UU1DUkpQQnd3UkJ3WUtCUVVOQndseUJBRU5MUndvT1Rrb0dDa09IamtkQlFrRkNnOEhDeDBURmk0V0RCQUJEZ29NR0F3ZEVBd0dIUXNQQ1E4T0R3WUNDLzN5QWc3OThnSU9BOEFvSFB5SUhDZ29IQU40SENqekNBa0NBd0VOQ1FjUEJ3WUlBZ1FCQVJjY09TZ3BPQkVSQWdFQ0FRWURCeFVLRGcwQkFSRU1DZzRDQWdZR0Rqa1pEQk1EQXdFQkZnMzlnVE16ZmpNekFBQUFDZ0JMLzljRHVBT25BQ2dBTEFBd0FEVUFPZ0ErQUVJQVJ3Qk1BRkVBQUFFaE1DSXhJZ1lWTUJRVkVUQVVNUlFXTXpvQk1TRXlNRE15TmpVd05ERVJNRFF4TkNZak1DSXhFeUVSSVFFaEZTRTFJUlVoTlRjaEZTRTFOU0VWSVJVaEZTRUJJUlVoTlRVaEZTRTFJVE1WSXpVRGVmMFJBUm9rSkJrQkFRTHZBUUVaSkNRYUFRTDlFZ0x1L1dZQnB2NWFBamo5eUFVQ04vM0pBamY5eVFJei9jMEJFQUVuL3RrQkovN1ovdXY1K1FPbkpCb0JBZnl2QVJva0pCb0JBMUlCR2lUOGNnTk0vVE1xa1NZbTB5b3FaeVd6SlFGa0pTVnNLaXFmbndBQUFBQUlBQUQvd0FRQUE4QUFBd0FIQUJnQUhBQWhBQ1lBS2dBdUFBQUJJelV6S1FFVklSTVJGQVlqSVNJbU5SRTBOak1oTWhZVkJ5RVJJUUVqRlRNMUtRRVZJVFVGSXhVekpTRVZJUUZWWm1ZQnZQNnJBVlh2S0J6OGlCd29LQndEZUJ3b1ZmeXFBMWI5cW1abUFieitxd0ZWL2tSbVpnRzgvcXNCVlFKYVptWUJJdnlJSENnb0hBTjRIQ2dvSEJIOHFnSGVabVptWnMxbVptWUFBQUFDQUpUL3dBTnNBOEFBTXdCQUFBQUJGQVlIRGdFSERnRUhEZ0VISXpVME5qYytBVGMrQVRjK0FUVTBKaWN1QVNNaUJnY09BUWNuUGdFM1BnRXpNaFlYSGdFVkFTSUdGUlFXTXpJMk5UUW1Jd05zRUE4UFFERWpMUWtKQ2dIckJ3Y0hGZzRPUWpNZUhnME5EU1VaR3l3UkVSVUY4UWd6S3l5S1hFaDFMRHc3L29jMlRFdzJOa3hNTmdLdkd6VWFHa0FtSEMwU0VDZ1lEaUEwRXhRa0VCQThLaGt0RmhVaERBd01FaEVRTlNZZVFtMHBLaXNlSGlocVEvNFVURFUyVEV3Mk5Vd0FBZ0FBLzhBRUFBUEFBQThBT3dBQUFUSVdIUUVVQmlNaElpWTlBVFEyTXdFdUF5Y3VBUWNtQmdjT0F3Y0dGak02QVRNY0FSVVVGak15SWpNeU5qVThBVFU2QVRNeU5pY0QzQThWRlEvOFNBOFZGUThDOXlGQlFrRWhCUW9HQmdzRUlVRkNRU0VNREJVY2Zoc1NEVHdVUEEwU0czNGNGUXdNQThBVkQwRVBGUlVQUVE4Vi9hc25UMDlPS0FVRkFRRUZCU2hPVDA4bkRpVjNiSGNNRWhJTWQyeDNKUTRBQUFBQUFnQUEvOEFFQUFQQUFCQUFQQUFBRnlJbVBRRTBOak1oTWhZZEFSUUdJeUVUSGdNWEhnRTNGalkzUGdNM05pWWpLZ0VqUEFFMU5DWWpJaklqSWdZVkhBRVZLZ0VqSWdZWEpBOFZGUThEdUE4VkZRLzhTTUVoUVVKQklRVUtCZ1lLQlNGQlFrRWhEQXdWSEg0YkVnMDhGRHdORWh0K0hCVU1ERUFWRDBFUEZSVVBRUThWQWxVblQwOU9LQVVGQVFFRkJTaE9UMDhuRGlWM2JIY01FaElNZDJ4M0pRNEFBQUFBQlFEcS84QURGZ1BBQUJBQUh3QXJBREFBV0FBQUFTRWlCaFVSRkJZeklUSTJOUkUwSmlNSE16SVdGUlFHS3dFaUpqVTBOak1USWlZMU5EWXpNaFlWRkFZM0lSRWhFUUU2QVRNOEFUVTBOak15SWpNeUZoVWNBUlU2QVRNeUZnY09BUWNPQVNjR0ppY3VBU2NtTmpNQ3hQNTRJakF3SWdHSUlqQXdJdTliQlFVRkJWc0ZCUVVGTGhFWEZ4RVFGeGZGL2xBQnNQN0RDakVMQndRWUNCZ0VCd3N4Q2drRUJCb3lHZ0lFQWdJRUFoa3pHUVVGQ0FQQU1DTDhwQ0l3TUNJRFhDSXdTd1lFQkFZR0JBUUcvSG9YRVJBWUdCQVJGM3NDclAxVUFWWXVLaTRGQmdZRkxpb3VEZ1llUFI4Q0FnRUJBZ0lmUFI0R0RnQUJBQ2Yvd0FQWkE4QUFPQUFBQVRVRkVSUUdNUTRCRlJRV016QXlNVGdCTVRJMk56NEJOVHdCTVJFbEVSUUdNUTRCRlJRV016SXdNVEl3TVRJMk56NEJOVFFtTVJFeEE5ajlRRlZCVzE1Q0FURlJJQ0VoQVpoVlFGdGRRZ0VCTUZJZ0lDSUJBeXlVMy81R0lnY0JYRUZEWFIwZEhrd3NNSllCSG9mK215SUdBbHhCUWw0ZUhSMU1MUytXQVdjQUFBQUdBQnYvd0FQbEE4QUFGd0FqQUNvQU1RQjFBSG9BQUFFaUJoVVVGaGN3RkRFWEhnRXpNalkvQVQ0Qk5UUW1JeEVpSmpVME5qTXlGaFVVQmdFWE1ESXpLZ0UzQnpBaUl6b0JBU2NtQmdjR0ZoOEJFU2MxTUNZaklnWXhGUWNSTno0Qkp5NEJEd0VsSmdZSERnRVZFUlFXRndVV01qTVdNak02QVRjNkFUY2xCVElXTXpJMk56NEJOUkUwSmljQkp4RVhFUUtYVDNBUURvSUZFUWtKRUFXQ0R3OXZUeUV0TFNFZ0xpNytyUUlDQVFJQ0ZnSUNBUUVEQWxFOURob0ZCQXdPRWNVTklDRU14eGdPQ2dRRUdnODMvdDhJRVFjSEJ3NE1BU29CQWdFQ0JBRUNBd0lCQXdFQklBRWhBZ1lDQmdzRkJ3Y09EUDE5ME5BRHdIQlBHelFYQWNvSENRa0h5aGMxRzA5dy92TXVJQ0V0TFNFZ0x2MFBBUUVCQXNNUkJBOE9EaDRFQi8za092Z1pHZmc5QWh3S0JCOE9EdzRFRUZNQ0F3VUZEd245aEF3VUExVUJBUUVCVWxNQkJBTUZFQWdDZlF3VEJQMmlPUUlVTy8zdUFBQUFBZ0JWQUJVRHF3TnJBQThBRXdBQUFTRWlCaFVSRkJZeklUSTJOUkUwSmdNaEVTRURjUDBnR0NNakdBTGdHQ01qSXYwMEFzd0RheU1ZL1NBWUl5TVlBdUFZSS96dkFzd0FBUUFBQURVRUFBTkxBQ1VBQUFrQkRnRWpJaVluQVM0Qk5UUTJQd0UrQVRNeUZoOEJBVDRCTXpJV0h3RWVBUlVVQmdjeEErLzlyd2tWREF3VkNQN0dDQWtKQ0ZFSUZRd01GUW0vQWRjSkZRd01GUWhSQ0FrSkNBS1gvYThKQ0FnSkFUa0pGUXdNRkFsUUNRa0pDYjhCMXdrSUNBbFFDUlVNREJRSkFBSUFCUUFJQkFjRGVBQWtBRGdBQUFFK0FUVTBKaThCTGdFaklnWUhBU2N1QVNNaUJnOEJEZ0VWRkJZWEFSNEJNekkyTndFREVTRVJJVGNoSWdZVkVSUVdNeUV5TmpVUkJ3UDRDQWNIQ0VNSUVRb0xFUWorY3FJSEVnb0tFZ2RFQndnSUJ3RUpCeElLQ2hJSEFmWGkvVFFDWEVUOVZoZ2pJeGdDNEJnalJRTGZDQkVLQ2hJSFJBY0lDQWYrY3FJSENBZ0hSQWNTQ2dvU0IvNzNCd2dJQndIMS9xYit4d0xOUkNJWi9TRVlJeU1ZQVlaRUFBVUFYZi9BQTZNRHdBQUxBQThBSFFBckFEa0FBQUVWSVRVek1qWTFNeFFXTXhjUklSRVhOQ1lqSWdZVkVSUVdNekkyTlJNMEppTWlCaFVSRkJZek1qWTFFelFtSXlJR0ZSRVVGak15TmpVRG8veTY3QjBwNGlrZHYvMFU1QllQRUJVVkVBOFd0eFlQRHhZV0R3OFd0eFVRRHhZV0R4QVZBM3BqWXlrZEhTbXUvUFFEREpzUUZSVVEvaWdRRmhZUUFkZ1FGUlVRL2lnUUZoWVFBZGdRRlJVUS9pZ1FGaFlRQUFNQVl2L0FBNTREd0FBY0FDZ0FQQUFBRXhFVUZqTWhNalkxRVRRbUp6VTBMZ0lyQVNJT0FoMEJEZ0VWSlNFMU5EWTdBVElXSFFFeEJUUTJNeklXRlJRR0J4WUdNU013SmpjdUFUVmlSeklDU2pKSFB5NHFTV0kzU2pkaVNTb3VQd0poL25wclRCaE1hLzdjT1Nnb09pQWZEQmd1R0F3Zkh3R28vcEl6UjBjekFXNHZSZ1dTTjJKSktpcEpZamVTQlVZdmVubE1hMnRNZWZBcE9Ua3BJVGdJS0VaR0tBZzRJUUFBQUFBQ0FHTC93QU9lQThBQUpRQTRBQUFCUGdFN0FUSVdIUUVoRGdFVkVSUVdNeUV5TmpVUk5DWW5OVFF1QWlzQklnNENGVE1URmdZeEl6QW1OeTRCTlRRMk16SVdGUllHQVQ0SlowWVlUR3YrREM0L1J6SUNTakpIUHk0cVNXSTNTamRpU1NwdjVRd1lMaGdNSHlBNktDZzVBU0FDc2tOZGEweDVCVVl2L3BJelIwY3pBVzR2UmdXU04ySkpLaXRKWXpmK0h5aEdSaWdJTnlJcE9Ua3BJVGdBQkFBQUFCVUVBQU5yQUZJQVh3Q3lBTDRBQUFFMUp5NEJKekVtTkQ4Qkp3Y09BU2N4TGdFdkFTTUhEZ0VITVFZbUx3RUhGeDRCQnpnQk1RNEJEd0VWRng0QkZ6RVdCZzhCRnpjK0FSY3hIZ0VmQVRNM1BnRTNNVFlXSHdFM0p5NEJOekUrQVQ4QkJTSW1OVFEyTXpJV0ZSUUdJd1UxSnk0Qkp6RW1OajhCSndjT0FTY3hMZ0V2QVNNSERnRUhNUVltTHdFSEZ4WVVCekVPQVE4QkZSY2VBUmM0QVRFV0ZBOEJGemMyTWhjeEhnRWZBVE0zUGdFM01UWXlId0UzSnk0Qk56RStBVDhCQnlJbU5UUTJNeklXRlJRR0FzRXpEeFlHQmdjWVF6SU9IdzRQRlFVVFh4SUZGZzRQSHc0eFF4Y0hBUVlHRnc4ek13OFhCZ1lCQnhkRE1RNGZEdzRXQlJKZkVnWVZEdzRmRGpKREdBWUJCZ1lXRHpQK29EWk1URFkxVEV3MUFwOGJDQXdEQkFFRURDUWFCeEVJQnd3RENUTUpBd3dIQ0JFSEdpUU1CQU1EREFnYkd3Z01Bd01FRENRYUJ4RUlCd3dEQ1RNSkF3d0hDQkFJR2lRTUJBRUVBd3dJRzdzZEtDZ2RIQ2dvQWRWZ0V3VVdEZzhnRGpKRUdBWUJCZ1lYRHpRMER4Y0dCZ0VHR0VReURpQVBEaFlGRTJBVEJSWU9EeUFPTWtRWUJ3RUhCaFlQTkRNUEZ3Y0dBUWNZUkRJUEh3OE9GZ1lTVTAwMk5rMU5OalpOeURNS0F3c0lDQkVIR3lRTkF3RURCQXdJR3hzSURBUURBUU1OSkJzSEVRZ0lDd01LTXdvREN3Z0lFUWNiSkF3RUF3TU1DQndjQ0F3REF3TU5KQm9JRVFnSERBTUtMQ2dkSFNrcEhSMG9BQUFBQUFJQUFQL0FCQUFEd0FBdkFFZ0FBQUU2QVRNOEF6VTBOak15SWpNeUZoVWNBeFU2QVRNeUZnY09Bd2NPQVNNaUppY3VBeWNtTmpNbElSVWhFU0VSSVRVaElnWVZFUlFXTXlFeU5qVVJOQ1lqQVNNWGF4Y1BDalFTTkFvUEYyc1hFZ3NMR3pnM054d0VDUVVGQ1FRY056YzRHd3NMRWdLVS91SUJGdnlpQVJYKzR4NHJLeDREYmg4cUtoOEIxeko0ZTNneUNoQVFDako0ZTNneUh3d2lRa05DSWdRRUJBUWlRa05DSWd3ZjJGRDlzZ0pPVUNvZS9hSWVLeXNlQWw0ZUtnQUFBQUFFQUFELzhnUUFBNDRBQXdBYkFCOEFOQUFBQVJVaE5RRXlOamMrQVRVMEppY3VBU01pQmdjT0FSVVVGaGNlQVFNMUlSVUJNaFlYSGdFVkVTTVZJVFVqRVRRMk56NEJNeUVETlAyWUFwb0xFd2NJQ0FnSUJ4TUxDeElIQndjSEJ3Y1NqLzVvQWpJZk54WVhGOHo5bU13WEZ4YzJId0xNQTQ3TnpmNHlCd2NJRWdvTEV3Z0lCd2NJQ0JNTENoSUlCd2YrbXYvL0FqSVhGaGMySVA3TnpjMEJNeUEyRnhZWEFBQURBQUQvd0FRQUE4QUFHUUJUQUhjQUFBRTBKaWN1QVNNaUJnY09BUlVVRmhjZUFUTXlOamMrQVRVeEFSUUdCdzRCSXlJbUx3RU9BU01pSmljdUFTY3VBU2N1QVRVME5qYytBVGMrQVRjK0FUTXlGaGNlQVJjZUFSY2VBUlVVQmdjWEhnRVZNUUVqTlRRbUt3RWlCaDBCSXlJR0hRRVVGanNCRlJRV093RXlOajBCTXpJMlBRRTBKZ0xGS1Nnb1lqazVZU2dwS0NncEtHRTVPV0lvS0NrQk93d0xEQndRRUJ3TDB6ZDdSQ3hVS0NoRkhoMHVFUkVSRVJFUkxoMGVSU2dvVkN3c1ZDa29SUjBkTGhFUkVpY20wd3dML2o5bkNBVTBCUWRuQlFjSEJXY0hCVFFGQ0djRkJ3Y0NEemxoS1Nnb0tDZ3BZVGs1WWlncEtDZ3BLV0U1L2dBUUhBd0xEQXdMMHlZbUVSRVJMaDBkUlNrb1ZDd3NWQ2dvUlI0ZExoRVJFUkVSRVM0ZEhrVW9LRlFzUkhzMzB3c2NFQUltWndVSEJ3Vm5Cd1UwQlFobUJnY0hCbVlJQlRRRkJ3QUFBQUFEQUFEL3dBUUFBOEFBR1FCVEFHUUFBQUUwSmljdUFTTWlCZ2NPQVJVVUZoY2VBVE15TmpjK0FUVXhBUlFHQnc0Qkl5SW1Md0VPQVNNaUppY3VBU2N1QVNjdUFUVTBOamMrQVRjK0FUYytBVE15RmhjZUFSY2VBUmNlQVJVVUJnY1hIZ0VWTVFFaUJoMEJGQll6SVRJMlBRRTBKaU1oQXNVcEtDaGlPVGxoS0Nrb0tDa29ZVGs1WWlnb0tRRTdEQXNNSEJBUUhBdlROM3RFTEZRb0tFVWVIUzRSRVJFUkVSRXVIUjVGS0NoVUxDeFVLU2hGSFIwdUVSRVNKeWJUREF2OUpBVUhCd1VCR3dVSEJ3WCs1UUlQT1dFcEtDZ29LQ2xoT1RsaUtDa29LQ2twWVRuK0FCQWNEQXNNREF2VEppWVJFUkV1SFIxRktTaFVMQ3hVS0NoRkhoMHVFUkVSRVJFUkxoMGVSU2dvVkN4RWV6ZlRDeHdRQWlZSEJUUUZDQWdGTkFVSEFBQUFBQUVBV0FBWUE2Z0RhQUFrQUFBbEp6YzJOQzhCSmdZUEFTY21JZzhCQmhRZkFRY0dGQjhCRmpJL0FSY1dNajhCTmpRbkE2ano4d3dNZkF3aERQUHpEQ0VNZkF3TTgvTU1ESHNNSWd6ejh3d2hESHdNRE0zejhnd2lESHdNQVF6eTh3d01mQXdoRFBQekRDSU1ld3dNOC9NTURId01JUXdBQUFFQUFQL0FCQUFEd0FBa0FBQUJJUkUwSmlzQklnWVZFU0VpQmgwQkZCWXpJUkVVRmpzQk1qWTFFU0V5TmowQk5DWWpBOWYrcVJnUnJoRVkvcWtSR0JnUkFWY1lFYTRSR0FGWEVSZ1lFUUpBQVZjUkdCZ1IvcWtZRWE0UkdQNnBFUmdZRVFGWEdCR3VFUmdBQUFFQUFBRkFCQUFDUUFBUUFBQUJNaFlkQVJRR0l5RWlKajBCTkRZeklRUFhFUmdZRWZ4U0VSZ1lFUU91QWtBWUVhNFJHQmdScmhFWUFBQUFBQUlBQVAvQUJBQUR3QUFUQURnQUFBRWlEZ0lWRkI0Q016SStBalUwTGdJVEJ3WWlMd0VIQmlJdkFTWTBQd0VuSmpRL0FUWXlId0UzTmpJZkFSWVVEd0VYRmhRSEFnQnF1NHRRVUl1N2FtcTdpMUJRaTd0K1F3Y1NCNFdGQnhJSFF3Y0hoWVVIQjBNSEVnZUZoUWNTQjBNSEI0V0ZCd2NEd0ZDTHUycHF1NHRRVUl1N2FtcTdpMUQ5VzBNSEI0V0ZCd2REQnhJSGhZVUhFZ2REQndlRmhRY0hRd2NTQjRXRkJ4SUhBQUFDQUFEL3dBUUFBOEFBRkFBNUFBQUJJZzRDRlJRZUFqTXlQZ0kxTkM0Q0l3RVVCaXNCRlJRR0t3RWlKajBCSXlJbVBRRTBOanNCTlRRMk93RXlGaDBCTXpJV0hRRUNBR3E3aTFCUWk3dHFhcnVMVUZDTHUyb0JFUTBKdHcwSlhBa050d2tORFFtM0RRbGNDUTIzQ1EwRHdGQ0x1MnBxdTR0UVVJdTdhbXE3aTFEOTBna050d2tORFFtM0RRbGRDUXkzQ1EwTkNiY01DVjBBQUFBQ0FBRC93QVFBQThBQUZBQWxBQUFCSWc0Q0ZSUWVBak15UGdJMU5DNENJd0VVQmlNaElpWTlBVFEyTXlFeUZoMEJBZ0JxdTR0UVVJdTdhbXE3aTFCUWk3dHFBUkVOQ2Y0S0NRME5DUUgyQ1EwRHdGR0x1bXBxdTR0UVVJdTdhbXE2aTFIOTBna05EQXBjQ1EwTUNsd0FBd0FBQUdNRUFBTWRBQmdBTVFCYUFBQUJNaFlYSGdFVkZBWUhEZ0VqSWlZbkxnRTFORFkzUGdFekVUSTJOejRCTlRRbUp5NEJJeUlHQnc0QkZSUVdGeDRCTXhFeUhnSVhIZ01YRGdNSERnTWpJaTRDSnk0REp6NEROejRETXdJQUhERVZGUlFVRlJVeEhCd3hGUlVVRkJVVk1Sd3dVaUlqSWlJaklsSXdNRklpSXlJaUl5SlNNQ3RTVGtvaklqd3lLUThQS1RJOElpTktUbElySzFKT1NpTWlQRElwRHc4cE1qd2lJMHBPVWlzQ1N4UVZGVEVjSERFVkZSUVVGUlV4SEJ3eEZSVVUvb3dpSXlKU01EQlNJeUlpSWlJalVqQXdVaUlqSWdKR0RCZ2tHQmc0UDBjbkowYy9PQmdZSkJnTURCZ2tHQmc0UDBjbkowYy9PQmdZSkJnTUFBQUVBQUFBQmdRQUEzb0FDUUFrQUVVQVpRQUFBVE15RmhjZUFSMEJKd2NPQVJVVUZoY2VBVE15TmpjbkRnRWpJaVluTGdFMU5EWTNKd0UzQVFjdUFTY3VBU2NPQVNNaUxnSW5MZ01uUGdFM0xnRW5MZ0VuTVFVaUJnY25QZ0V6TWg0Q0Z4NERGdzRCQnljK0FUVTBKaWN1QVNNeEFmc0dIRElVRlJXU3lRME9JeUlqVWpBWk14dElDUThISERFVkZSVURBa2orL2pzRE9Uc0ZJaDBkTFE4dlpUY3JVazVLSXlNOE1pa1BHMWc4RFNVWEdCc0RBZEVXS2hWa0tsMHlLMUpPU2lJak96SXBEeHBRTllnSkNTTWlJbE13QW1NVkZSVXhIQW1WSlJzekdUQlRJaUlqRFE1SUF3SVZGUlF5SEFZUUNVZ0JBVHY4eHpzRklod2RMQThVRXd3WUpCZ1lOMEJISjBSek1BMG1HQmdiQTM0SkNXVVFFQXdZSkJnWU9EOUhKMEZ1TG9nVktoWXdVaU1pSXdBQUFnRkUvOEFDdkFQQUFBb0FGd0FBSlRNUkl6VWhFVE1WSVRVVE1oWVZGQVlqSWlZMU5EWXpBVVJsWlFFVFpmNkl0REZHUmpFeVJrWXlTd0dUaS8zaWk0c0RkVWd6TTBoSU16TklBQWtBQUFBdUJBQURVZ0FjQURnQVZRQnhBSTBBcWdER0FPSUEvZ0FBSlJVVUJnY09BU3NCSWlZbkxnRTlBVFEyTno0Qk93RXlGaGNlQVJVUkZSUUdCdzRCS3dFaUppY3VBVDBCTkRZM1BnRTdBVElXRng0QkFSVVVCZ2NPQVNzQklpWW5MZ0U5QVRRMk56NEJPd0V5RmhjZUFSVUJGUlFHQnc0Qkt3RWlKaWN1QVQwQk5EWTNQZ0U3QVRJV0Z4NEJBUlVVQmdjT0FTc0JJaVluTGdFOUFUUTJOejRCT3dFeUZoY2VBUUVWRkFZSERnRXJBU0ltSnk0QlBRRTBOamMrQVRzQk1oWVhIZ0VWQVJVVUJnY09BU3NCSWlZbkxnRTlBVFEyTno0Qk93RXlGaGNlQVFFVkZBWUhEZ0VyQVNJbUp5NEJQUUUwTmpjK0FUc0JNaFlYSGdFUkZSUUdCdzRCS3dFaUppY3VBVDBCTkRZM1BnRTdBVElXRng0QkFTUUhDUWdUQzdjTUV3Z0lDQWdJQ0JNTXR3c1VCd2tIQndrSUV3dTNEQk1JQ0FnSUNBZ1RETGNMRkFjSkJ3RnVDQWdJRXd1NEN4TUlDQWdJQ0FnVEM3Z0xFd2dJQ1A2U0J3a0hGQXUzREJNSUNBZ0lDQWdURExjTEZBY0pCd0Z1Q0FnSUV3dTRDeE1JQ0FnSUNBZ1RDN2dMRXdnSUNBRnVDQWdJRXd5M0N4UUhDUWNIQ1FjVUM3Y01Fd2dJQ1A2U0NBZ0lFd3U0Q3hNSUNBZ0lDQWdUQzdnTEV3Z0lDQUZ1Q0FnSUV3eTNDeFFIQ1FjSENRY1VDN2NNRXdnSUNBZ0lDQk1NdHdzVUJ3a0hCd2tIRkF1M0RCTUlDQWpTYlF3VENBZ0lDQWdJRXd4dERCTUlDQWdJQ0FnVERBRWxiZ3NVQ0FnSUNBZ0lGQXR1Q3hRSUNBZ0lDQWdVL3RCdERCTUlDQWdJQ0FnVERHME1Fd2dJQ0FnSUNCTU1Ba2x0REJNSUNBZ0lDQWdUREcwTUV3Z0lDQWdJQ0JQKzBHNExGQWdJQ0FnSUNCUUxiZ3NVQ0FnSUNBZ0lGUDdRYlF3VENBZ0lDQWdJRXd4dERCTUlDQWdJQ0FnVERBSkpiUXdUQ0FnSUNBZ0lFd3h0REJNSUNBZ0lDQWdUL3RCdUN4UUlDQWdJQ0FnVUMyNExGQWdJQ0FnSUNCUUJHVzBNRXdnSUNBZ0lDQk1NYlF3VENBZ0lDQWdJRXdBQUFBTUFBQUFWQkFBRGF3QWJBRGdBVkFBQUpSVVVCZ2NPQVNNaElpWW5MZ0U5QVRRMk56NEJNeUV5RmhjZUFSRVZGQVlIRGdFaklTSW1KeTRCUFFFME5qYytBVE1oTWhZWEhnRVZFUlVVQmdjT0FTTWhJaVluTGdFOUFUUTJOejRCTXlFeUZoY2VBUVFBQmdjR0R3bjhWZ2tQQmdjR0JnY0dEd2tEcWdrUEJnY0dCZ2NHRHduOFZna1BCZ2NHQmdjR0R3a0RxZ2tQQmdjR0JnY0dEd244VmdrUEJnY0dCZ2NHRHdrRHFna1BCZ2NHbFZVSkR3WUdCd2NHQmc4SlZRa1BCZ2NHQmdjR0R3Rk5WZ2dQQndZR0JnWUhEd2hXQ0E4SEJnWUdCZ2NQQ0FGVlZRa1BCZ2NHQmdjR0R3bFZDUThHQmdjSEJnWVBBQUFBQWdBQS84QUVBQVBBQUJrQVV3QUFBVFFtSnk0Qkl5SUdCdzRCRlJRV0Z4NEJNekkyTno0Qk5URUJGQVlIRGdFaklpWXZBUTRCSXlJbUp5NEJKeTRCSnk0Qk5UUTJOejRCTno0Qk56NEJNeklXRng0QkZ4NEJGeDRCRlJRR0J4Y2VBUlV4QXNVcEtDaGlPVGxoS0Nrb0tDa29ZVGs1WWlnb0tRRTdEQXNNSEJBUUhBdlROM3RFTEZRb0tFVWVIUzRSRVJFUkVSRXVIUjVGS0NoVUxDeFVLU2hGSFIwdUVSRVJKaWJUREFzQ0R6bGhLU2dvS0NncFlUazVZaWdvS1Nrb0tHSTUvZ0FRSEF3TERBd0wweVltRVJFUkxoMGRSU2tvVkN3c1ZDZ29SUjRkTGhFUkVSRVJFUzRkSGtVb0tGUXNSSHMzMHdzY0VBQUpBQUwvNHdRQUE1MEFQUUJCQUVZQVNnQk9BRklBVndCbkFIb0FBQ1VqSVRjaEV5RXZBakVpSmlNbkxnRWpJZ1lIQmhZZkFSTUhGVE1PQVJVVUZqTXlOalUwSmljekRnRVZGQll6TWpZMU5DWW5Pd0UrQVRVMEppTURNd2NqRlRNSEl6VW5NeFVqRlRNVkl3RXpGU01YRlNNbk13TWlKalUwTmpNeUZoY2VBUlVVQmlNaElpWTFORFkzUGdFek1oWVhIZ0VWRkFZakE0UUIvWnNiQWxGMi9NOFpCUlVDQWdGbkFnVUREUlFEQlE4UFZvQXRFQU1FUkRBdlJBUUQ1UVFEUXpBd1JBUUVHUUVQRmhZUGtLVWtnWGNsVXZ5OHZMeTgvdlBOcXFwOUk2QjNFUmNYRVFnT0JnVUdGeEFCdlJBWUJnWUdEZ2dJRHdVR0JoY1J5a2NCNkdnVkJnRWVBUUVQREE4YkJSbjk1M3NvQ1JRS01FUkVNQW9VQ1FrVUNqQkVSREFLRkFrQkZnOFFGZ0hTZDBCMmRyZDNRSFlCTFhkQWRuYitTaGNSRUJjR0JRWU9DQkVYRnhFSURnWUZCZ1lGQmc0SUVSY0FBQUVCQXYvQUE0Y0R3QUFrQUFBQkZBWUhBUTRCSXlJbUx3RXVBVFUwTmpjSkFTNEJOVFEyUHdFK0FUTXlGaGNCSGdFVkE0Y01EUDVUREI0UkVSNE1NZ3dNREF3QlAvN0JEQXdNRERJTUhSSVNIUXdCclF3TUFjQVJIZzMrVkF3TURBd3lEQjRSRWgwTkFUOEJQdzBkRWhFZERURU1EUTBNL2xRTUhoRUFBQUFBQVFCNS84QUMvZ1BBQUNRQUFCTTBOamNCUGdFek1oWWZBUjRCRlJRR0J3a0JIZ0VWRkFZUEFRNEJJeUltSndFdUFUVjVEQXdCclF3ZUVSRWVERElNREF3TS9zRUJQd3dNREF3eURCMFNFaDBNL2xNTURBSEFFUjROQWF3TURBd01NZ3dlRVJJZERQN0Evc0VNSGhJUkhnd3hEQTBOREFHc0RCNFJBQUVBQUFEQ0JBQURSd0FrQUFBQk1oWVhBUjRCRlJRR0R3RU9BU01pSmljSkFRNEJJeUltTHdFdUFUVTBOamNCUGdFekFnQVJIZzBCckF3TURBd3lEQjRSRWgwTi9zSCt3UTBkRWhFZERURU1EUTBNQWF3TUhoRURSd3dNL2xNTUhoRVJIZ3d5REF3TURBRS8vc0VNREF3TU1nd2RFaElkREFHdERBd0FBQUFBQVFBQUFEa0VBQUsrQUNNQUFDVWlKaWNCTGdFMU5EWS9BVDRCTXpJV0Z3a0JQZ0V6TWhZZkFSNEJGUlFHQndFT0FRSUFFUjROL2xRTURBd01NZ3dlRVJJZERRRS9BVDhOSFJJUkhnd3hEQTBORFA1VURCNDVEQXdCclF3ZUVSRWVERElNREF3TS9zRUJQd3dNREF3eURCMFNFaDBNL2xNTURBQUFBQUVBMWYvQUF5c0R3QUFsQUFBM05EWTNDUUV1QVRVME5qOEJQZ0V6TWhZWEFSNEJGUlFHQndFT0FTTWlKaThCTGdFMU1kVUdCUUdUL20wRkJnWUZNd1VNQndZTUJRSGVCUVlHQmY0aUJRd0dCd3dGTXdVR0ZRY01CUUdUQVpNRkRBY0hDd1UwQlFVRkJmNGlCZ3NIQndzRy9pSUZCUVVGTkFVTUJnQUJBTlgvd0FNckE4QUFKUUFBQVJRR0J3a0JIZ0VWRkFZUEFRNEJJeUltSndFdUFUVTBOamNCUGdFek1oWWZBUjRCRlRFREt3VUcvbTBCa3dZRkJRWXpCUXdHQnd3Ri9pSUZCZ1lGQWQ0RkRBY0dEQVV6QmdVRGF3Y01CZjV0L20wRkRBY0dEQVUwQlFVRkJRSGVCZ3NIQnd3RkFkNEZCUVVGTkFVTEJ3QUFBQUVBQUFDVkJBQUM2d0FsQUFBbElpWW5DUUVPQVNNaUppOEJMZ0UxTkRZM0FUNEJNeklXRndFZUFSVVVCZzhCRGdFak1RT3JCd3dGL20zK2JRVU1Cd1lNQlRRRkJRVUZBZDRHQ3djSEN3WUIzZ1VGQlFVMEJRd0dsUVlGQVpQK2JRVUdCZ1V6QlF3SEJnd0ZBZDRGQmdZRi9pSUZEQVlIREFVekJRWUFBQUFBQVFBQUFKVUVBQUxyQUNVQUFCTXlGaGNKQVQ0Qk16SVdId0VlQVJVVUJnY0JEZ0VqSWlZbkFTNEJOVFEyUHdFK0FUTXhWUWNNQlFHVEFaTUZEQWNHREFVMEJRVUZCZjRpQmdzSEJ3c0cvaUlGQlFVRk5BVUxCd0xyQmdYK2JRR1RCUVlHQlRNRkRBY0dEQVgrSWdVR0JnVUIzZ1VNQmdjTUJUTUZCZ0FBQUFBQ0FBRC93QVFBQThBQUpRQktBQUFCQnc0QkZSUVdId0VIRGdFVkZCWWZBUjRCTXpJMk53RStBVFUwSmljQkxnRWpJZ1lITVFFME5qYytBVGMrQVRNeUZoY2VBUmNlQVJVVUJnY09BUWNPQVNNaUppY3VBU2N1QVRVQm9rUUdCd2NHemMwR0J3Y0dSQVlQQ1FrUEJnRXZCZ1lHQnY3UkJnOEpDUThHL2w0aUl5SmRPenVBUmthQU96dGRJaU1pSWlNaVhUczdnRVpHZ0RzN1hTSWpJZ01OUkFjUENBa1BCczNOQmc4SkNBOEhSQVlHQmdZQkx3WVBDUWtQQmdFdkJnWUdCdjZ6Um9BN08xMGlJeUlpSXlKZE96dUFSa2FBT3p0ZElpTWlJaU1pWFRzN2dFWUFBQUFBQWdBQS84QUVBQVBBQUNRQVNBQUFKVGMrQVRVMEppOEJOejRCTlRRbUx3RXVBU01pQmdjQkRnRVZGQllYQVI0Qk16STJOd0VVQmdjT0FRY09BU01pSmljdUFTY3VBVFUwTmpjK0FUYytBVE15RmhjZUFSY2VBUUplUkFZSEJ3Yk56UVlIQndaRUJnOEpDUThHL3RFR0JnWUdBUzhHRHdrSkR3WUJvaUlqSWwwN080QkdSb0E3TzEwaUl5SWlJeUpkT3p1QVJrYUFPenRkSWlNaWMwUUhEd2dKRHdiTnpRWVBDUWdQQjBRR0JnWUcvdEVHRHdrSkR3YiswUVlHQmdZQlRVYUFPenRkSWlNaUlpTWlYVHM3Z0VaR2dEczdYU0lqSWlJaklsMDdPNEFBQUFBQUFnQUEvOEFFQUFQQUFDVUFTZ0FBRXhjZUFUTXlOajhCRng0Qk16STJQd0UrQVRVMEppY0JMZ0VqSWdZSEFRNEJGUlFXRnpFQklpWW5MZ0VuTGdFMU5EWTNQZ0UzUGdFek1oWVhIZ0VYSGdFVkZBWUhEZ0VIRGdFanMwUUhEd2dKRHdiTnpRWVBDUWdQQjBRR0JnWUcvdEVHRHdrSkR3YiswUVlHQmdZQlRVYUFPenRkSWlNaUlpTWlYVHM3Z0VaR2dEczdYU0lqSWlJaklsMDdPNEJHQVdKRUJnY0hCczNOQmdjSEJrUUdEd2tKRHdZQkx3WUdCZ2IrMFFZUENRa1BCdjVlSWlNaVhUczdnRVpHZ0RzN1hTSWpJaUlqSWwwN080QkdSb0E3TzEwaUl5SUFBZ0FBLzhBRUFBUEFBQ1VBU1FBQUFTY3VBU01pQmc4Qkp5NEJJeUlHRHdFT0FSVVVGaGNCSGdFek1qWTNBVDRCTlRRbUp6RUJNaFlYSGdFWEhnRVZGQVlIRGdFSERnRWpJaVluTGdFbkxnRTFORFkzUGdFM1BnRURUVVFIRHdnSkR3Yk56UVlQQ1FnUEIwUUdCZ1lHQVM4R0R3a0pEd1lCTHdZR0JnYitzMGFBT3p0ZElpTWlJaU1pWFRzN2dFWkdnRHM3WFNJaklpSWpJbDA3TzRBQ0hrUUdCd2NHemMwR0J3Y0dSQVlQQ1FrUEJ2N1JCZ1lHQmdFdkJnOEpDUThHQWFJaUl5SmRPenVBUmthQU96dGRJaU1pSWlNaVhUczdnRVpHZ0RzN1hTSWpJZ0FBQVFBQUFCOEQ2d05oQUI0QUFDVUJOalFuQVNZaUJ3WVVId0VoSWdZVkZCWXpJUWNPQVJVVUZoY1dNamNDZlFGdUZSWCtraFk4RmhVVjhmMURIaXNySGdLOThRb0xDd29XUEJZZkFXMFdQQllCYlJZV0ZUMFY4U3NlSGl2eEN4c09EaHNLRmhZQUFBQUJBQlVBSHdRQUEyRUFId0FBQ1FFR0ZCY0JGakkzTmpRdkFTRXlOalUwSmlNaE56NEJOVFFtSnlZaUJ6RUJnLzZTRlJVQmJoWThGaFVWOFFLOUhpc3JIdjFEOFFvTEN3b1dQQllEWWY2VEZqd1cvcE1XRmhVOUZmRXJIaDRyOFFzYkRnNGJDaFlXQUFFQVgvL0FBNklEcXdBZkFBQUpBU1lpQndFR0ZCY1dNajhCRVJRV016STJOUkVYSGdFek1qWTNOalFuTVFPaC9wTVdQQmIra3hZV0ZUMFY4U3NlSGl2eEN4c09EaHNMRlJZQ1BRRnVGUlgra2hZOEZoVVY4ZjFESGlzckhnSzk4UW9MQ3dvV1BCWUFBUUJmLzlVRG9RUEFBQjhBQUJNQkZqSTNBVFkwSnlZaUR3RVJOQ1lqSWdZVkVTY3VBU01pQmdjR0ZCY3hYd0Z0Rmp3V0FXMFdGaFU5RmZFckhoNHI4UXNiRGc0YkNoWVdBVVAra2hVVkFXNFdQQllWRmZFQ3ZSNHJLeDc5US9FS0N3c0tGandXQUFBQkFJbi94d05wQTdrQURBQUFGd1ltTlJFME5oY0JGZ1lIQWJBUEdCY1BBcm9QQVEvOVNEa0xDeEVEMEJFTEMvNFpDeDBLL2ljQUFBRUFsLy9IQTNjRHVRQU1BQUFCTmhZVkVSUUdKd0VtTmpjQkExRU9HQmNQL1VZUEFROEN1UU81Q3dzUi9EQVJDZ29CNXdzZENnSFpBQUFBQUFFQUJ3QlhBL2tETndBTUFBQVRKall6SVRJV0J3RUdKaWNCQndzTEVRUFFFUXNML2hrTEhRcitKd01SRHhjWEQvMUdEd0VQQXJrQUFRQUhBRWtEK1FNcEFBc0FBQ1VXQmlNaElpWTNBVFlXRndQNUN3c1IvREFSQ3dzQjV3c2RDbkFQR0JjUEFyb1BBUThBQUFFQUFQL0FCQUFEd0FDWUFBQUJKeTRCSXlJR0R3RU9BUlVVRmg4QklSRVhIZ0V6TWpZL0FUNEJOVFFtTHdFdUFTTWlCZzhCRGdFVkZCWWZBUjRCTXpJMlB3RVJJVGMrQVRVMEppOEJMZ0VqSWdZUEFRNEJGUlFXSHdFZUFUTXlOajhCUGdFMU5DWXZBU0VSSnk0Qkl5SUdEd0VPQVJVVUZoOEJIZ0V6TWpZL0FUNEJOVFFtTHdFdUFTTWlCZzhCRVNFSERnRVZGQllmQVI0Qk16STJQd0UrQVRVMEppY0Q5cWdGREFjSEN3VVVCQVVGQkZYKzBGUUZDd2NIREFVVEJRVUZCYWtGQ3djSERBU3BCUVVGQlJRRURBY0hDd1ZVL3NSVkJBVUZCQlFGREFZSERBV29CUVVGQmFnRkRBY0hDd1VVQkFVRkJGUUJPMVFGQ3djSERBVVRCUVVGQmFnRkRBY0hDd1dwQlFVRkJSUUVEQWNIQ3dWVUFUQlZCQVVGQkJRRkRBWUhEQVdvQlFVRkJRSFdxUVVGQlFVVUJBd0hCd3dGVkFFM1ZBVUZCUVVUQlF3SEJ3c0ZxUVVGQlFXcEJRc0hCd3dGRXdVRkJRVlUvc2xWQkF3SEJ3d0ZFd1VGQlFXcEJRd0hCZ3dGcVFVRkJRVVVCQXdIQndzR1ZQN01WQVVGQlFVVEJRd0hCd3NGcVFVRkJRV3BCUXNIQnd3RkV3VUZCUVZVQVRSVkJBd0hCd3dGRXdVRkJRV3BCUXdIQmd3RkFBQUNBQUQvd0FRQUE4QUFFd0NzQUFBQklnNENGUlFlQWpNeVBnSTFOQzRDRXc0Qkl5SW1Md0V1QVRVME5qOEJJeFUzUGdFek1oWWZBUjRCRlJRR0R3RU9BU01pSmk4QkxnRTFORFkvQVQ0Qk16SVdId0UxSXhjZUFSVVVCZzhCRGdFaklpWXZBUzRCTlRRMlB3RStBVE15Rmg4QkhnRVZGQVlQQVRNMUJ3NEJJeUltTHdFdUFUVTBOajhCUGdFek1oWWZBUjRCRlJRR0R3RU9BU01pSmk4QkZUTW5MZ0UxTkRZL0FUNEJNeklXSHdFZUFSVVVCZzhCQWdCcXU0dFFVSXU3YW1xN2kxQlFpN3VnQXdrRkJna0REd1FEQXdSQjh6MEVCUVlGQ1FNUEJBUUVCSUFFQ1FVRkNRU0JBd1FEQkE0RUNRVUZCd1E5OGtBRUF3TUVEd01KQmdVSkE0RUVBd01FZ1FNSkJRWUlCQThFQkFRRVFQSTlCQVlGQlFrRURnUUVCQVNBQkFrRkJRa0VnQVFFQkFNUEJBZ0ZCUWNFUGZFL0JBTURCQThEQ1FZRkNRT0JCQU1EQklFRHdGR0x1bXBxdTR0UVVJdTdhbXE2aTFIOWJRUUVCQVFPQkFnRkJRY0VQZkZBQkFNREJBOERDUVlGQ1FTQUJBUUVCSUFFQ1FVR0NBUVBCQU1EQkVEeFBBUUdCUVVKQXhBREJBUURnUVFKQlFVSkJJQUVCQVFERHdRSUJRVUhCRDN4UUFRRUJBUU9CQWtGQmdnRWdBUUVCQVNBQkFnR0JRa0VEZ1FFQkFSQThUd0VCZ1VGQ1FRT0JBUUVCSUFFQ0FZRkNRU0FBQUFCQUFELzJnUUFBNllBS2dBQUFRY3VBeU1pRGdJVkZCNENNelVpTGdJMU5ENENNeklXRndjT0FSY0ZGalkzRXpZbUJ3TzhWQ0pWWTIwNVpiR0ZUVW1Dc21wRGRsY3pNbGQwUTBKNExWb2ZCQndCSnh3c0JDTURLQjhERGlZc1J6RWFUSVN5WkdXeGhFeWtNMWQxUTBOMVZ6TXpMU2tPTUJQUUZCUWlBV1FpSEE0QUFBQUJBSnYveHdOWEE3a0FEQUFBRndZbU5SRTBOaGNCRmhRSEFjQU9GeGNPQXBjT0QvMXFPUXNMRVFQUUVRb0svaGtMSFFyK0p3QUFBQUlBQVAvQUJBQUR3QUFQQUNBQUFBVVVCaU1oSWlZMUVUUTJNeUV5RmhVaE5DWWpJU0lHRlJFVUZqTWhNalkxRVFHTkd4TCt6UkliR3hJQk14SWJBbk1iRXY3TkV4b2FFd0V6RWhzU0V4c2JFd09rRXhzYkV4TWJHeFA4WEJNYkd4TURwQUFCQUFEL3dBUUFBOEFBRHdBQUJSUUdJeUVpSmpVUk5EWXpJVElXRlFRQUlCZjhiaGNnSUJjRGtoY2dDUmNnSUJjRGtoY2dJQmNBQUFJQUFQL0FCQUFEd0FBVEFDQUFBQUVpRGdJVkZCNENNekkrQWpVMExnSURCaVkxRVRRMkZ3VVdGQWNGQWdCcXU0dFFVSXU3YW1xN2kxQlFpN3ZGQnd3TUJ3RlVCd2YrckFQQVVJdTdhbXE3aTFCUWk3dHFhcnVMVVB6OUJRVUpBZlFKQlFYNkJROEY4d0FBQUFNQUFQL0FCQUFEd0FBVEFDTUFNd0FBQVNJT0FoVVVIZ0l6TWo0Q05UUXVBZ01VQmlzQklpWTFFVFEyT3dFeUZoVVRGQVlyQVNJbU5SRTBOanNCTWhZVkFnQnF1NHRRVUl1N2FtcTdpbEZSaXJ1VkNnZHlCd29LQjNJSEN1b0tCM0lIQ2dvSGNnY0tBOEJRaTd0cWFydUxVRkNMdTJwcXU0dFEvVklIQ1FrSEFWd0hDUWtIL3FRSENRa0hBVndIQ1FrSEFBQUNBQUQvd0FRQUE4QUFFd0FqQUFBQklnNENGUlFlQWpNeVBnSTFOQzRDRXhRR0l5RWlKalVSTkRZeklUSVdGUUlBYXJ1TFVGQ0x1MnBxdW90UlVZdTZUUXdJL3JvSURBd0lBVVlJREFQQVVJdTdhbXE2aTFGUmk3cHFhcnVMVVAxZENBd01DQUZHQ0F3TUNBQUJBQUQvNVFQekE1b0FGZ0FBQ1FFbUJoMEJKU1lHRlJFVUZqY2xGUlFXTndFMk5DY0Q4LzJSRFJiK3dRMFZGUTRCUGhZTkFtNE9EUUhSQWNrS0NSSGE2Z29KRWZ4c0VBb0o1Tk1RQ2drQnZRb2JDZ0FCQUEzLzVnUUFBNXNBRmdBQUFRVTFOQ1lIQVFZVUZ3RVdOajBCQlJZMk5SRTBKZ2NEM2Y3Q0ZnMzlrZzROQW04TkZnRS9EUlVWRGdPYjVOTVFDZ24rUXdrY0N2NDNDZ2tSMnVvS0NSRURsQkFLQ1FBQkFBRC85UVFBQTRvQUpBQUFBU01pQmhVUkFTWUdIUUVsSmdZVkVSUVdOeVVWRkJZM0FSRVVGanNCTWpZMUVUUW1Jd1BkUFE0Vi9mb05GZjdNREJVVkRRRXpGUTBDQmhVT1BROFVGQThEaVJRUC9xY0JmUW9KRU5QaUNna1EvSW9QQ2duZHpROEtDUUZ6L3JJUEZCUVBBMHdQRkFBQUFBQUJBQUQvOWdRQUE0c0FKQUFBQVFVMU5DWUhBUkUwSmlzQklnWVZFUlFXT3dFeU5qVVJBUlkyUFFFRkZqWTFFVFFtQndQZS9zMFZEZjM2RlE0OUR4UVVEejBPRlFJR0RSVUJOQXdWRlEwRGk5M05Ed29KL28wQlRnOFVGQS84dEE4VUZBOEJXZjZEQ2drUTArSUtDUkFEZGc4S0NRQUFBQUFFQUJvQWNBUG1BeVlBRUFBbkFEc0FVd0FBRXhVVUZqTTRBVEV6RVNNaUJoVTRBVEVsRVRBVU1SUUdJeUltTHdFUk56NEJNeklXRlRBVU1SY2VBUlVVQmdjWEZqSTNQZ0UxTkNZbkxnRUhOeDRCRlJRR0J4Y1dNamMrQXpVMExnSW5KaUlIR2lZYWhvWWFKZ0pJRnhBR0N3VDkvUVVLQmhBWFVCMGhJUjBqQ1NNSkhTSWlIUWdqQ1VzeE9Ua3lKUWtqQ1Jrb0hBOE9IQ2daQ1NNSkFqM2xHeVlCWnlZYndQMmNBUkVYQXdPUkFZZVNBd01YRVFHZEhFMHNLMDBkSXdrSkpsNDBORjRtQ1FFS1N6S0ZURXlGTWlVSkNoNUVTMUFyS2xCTFJCNEpDUUFBQUFBREFCc0FjZ1BsQXlnQUZnQXRBR2tBQUJNVk9BRXhGQll6T0FFeE14RWpPQUV4SWdZVk9BRXhKUkU0QVJVVUJpTWlKaThCRVRjK0FUTXlGaFV3RkRFQkhnRVZGQVlQQVE0Qkl5SW1Md0VIRGdFaklpWXZBUzRCTlRRMlB3RW5MZ0UxTkRZL0FUNEJNeklXSHdFM1BnRXpNaFlmQVI0QkZSUUdEd0ViSmh1R2hoc21Ba2tYRVFVTEJQMzlCQXNGRVJjQmZBSURBd0loQWdVREJBVUNSMGNDQmdNREJnSWhBZ0lDQWtkSEFnSUNBaUVDQmdNREJnSkhSd0lGQkFNRkFpRUNBd01DUndJLzVSc21BV2NtRzhEOW13RVFGd01Da2dHSGtnTURHQkFCL29ZQ0JRTUVCUUloQWdNREFrZEhBZ01EQWlFQ0JRUURCUUpIUndNRkF3TUdBaUVDQXdNQ1IwY0NBd01DSVFJR0F3TUZBMGNBQUFBQUJBQUEvOEFFQUFQQUFCWUFMUUJFQUZzQUFBRW1ORDhCSnlZMk55VTJGZ2NERGdFdkFRY0dJaThCQVFjbkppSVBBUVlVSHdFSEJoWVhCUlkySndNdUFRY2xKaUlQQVNjbUJnY0RCaFkzSlQ0Qkx3RTNOalF2QVJNM05pWW5KU1lHRnhNZUFUOEJGeFl5UHdFMk5DOEJBbUlEQTNWRkJRUUhBVmtIQ1FFNUFRb0ZRM1FFQ2dPTkFWWkZkQVFLQTQwREEzVkRCUVFIQVZVSENRRTFBUW9GL1ZrRENnUjBRd1VLQVRrQkNRY0JXUWNFQlVWMUF3T05HVU1GQkFmK3F3Y0pBVFVCQ2dWRmRBUUtBNDBEQTNVQ3J3TUtCSFJFQmdrQ05BRUpCLzZzQndRR1FuUUVCSXorZmtWMUF3T05Bd29EZFVJRkNnRTVBUWtIQVZnSEJBVXpCQVIwUWdZRUIvNnNCd2tCTlFFSkJrUjBCQW9EakFIVVF3VUtBVGtCQ0FqK3FBY0VCVVIwQXdPTUJBb0RkQUFBQUFRQUJQL0RBLzBEdkFBV0FDMEFSQUJiQUFBQkV6NEJId0UzTmpJZkFSWVVEd0VYRmdZSEJRWW1OeE1lQVQ4QkZ4WXlQd0UyTkM4Qk56WW1KeVVtQmhjVEpSY1dNajhCRnhZMk54TTJKZ2NGRGdFZkFRY0dGQmNURndjR0ZoY0ZGalluQXk0QkR3RW5KaUlQQVFZVUZ3SmZPUUVLQlVOMEJBa0VqUU1EZFVVRkJBZitwd2dJQVRRQkNnVkZkQVFLQTQwREEzVkRCUVFIL3FzSENRRTEvWEdNQkFrRWRFTUZDZ0U1QVFnSS9xY0hCQVZGZEFRRUEzUkNCZ1FIQVZVSENRRTFBUW9GUlhRRUNRU01CQVFDTGdGVUNBTUZRblFEQTR3RUNnTjBSUVVLQVRVQkNRZjl5d2NFQlVWMUF3T05Bd29EZFVJRkNnRTVBUWdJL3FoY2pBTURkRUlGQkFjQlZBY0pBVFVCQ2dWRmRBTUtCQUxLZEVJRkNnRTVBUWdJQVZnSEJBVkZkQVFFakFNS0JBQUFBQUFEQUFBQUpnUDdBMW9BTFFCdUFLQUFBQk0xTkRZN0FUSVdGeDRCRng0QkZ4NEJCdzRCQnc0QkJ3NEJCdzRCSXlJbUp5NEJKeTRCSnk0Qkt3RWlKalVGUGdFM1BnRTNGUlFXUHdFMk5DOEJKZ1lkQVE0QkJ3NEJCdzRCQnc0QkJ3NEJCdzRCQnc0Qkt3RWlCaDBCRkJZN0FUSTJOejRCTno0Qk56NEJOejRCTnhjbUJoMEJMZ0VuTGdFbkxnRW5MZ0VqSWdZSERnRUhEZ0VIRGdFSEJoWVhIZ0VYSGdFWEhnRVhGUlFXUHdFMk5DOEJBQWdGOFJveUZ4WW5FUW9TQ1FNQkF3b1NDUWdSQ0FJREFRSUZBd1FGQWdvU0NRc1VDUW9VQy9FRkNBS3hDaE1KQnc0SENRWDVCZ1g2QlFrY05oY1dKaEFkTUJZUUh3OFdLeFVLRXdnSkVRcnhCUWdJQmZJZU9Sa1ZKaEVkTUJZUUhnOFhLeFJRQlFrSkVBa0pFd3NKRXdrQ0JnTURCUUlDQXdFSUVRZ0pFZ29EQVFNSUV3b1JKeFlWTGhnSkJmb0ZCZm9DV29NR0J3c0pDaHNQQ0JNSkJBa0VEUm9ORFJrTkFnVUNBd01EQWd3VkNRb09CUVVGQ0FVdENRd0VBd01CYVFZRUJMSUVDd1MzQkFRR2FnRU9EQXNkRHh3L0lSZ3ZGeUU0RVFrTkJBTUVDQVdEQmdjUERBc2RFQnRBSUJnd0ZpRTRFb3NFQkFacEFRVUVCUTRLQ1JVTUFnTURBd0lGQWcwWkRRMGFEUVFKQXdvVENBOGJDUWtMQVdrSEJBU3lCQXNFdHdBQUFRQUEvOW9FQUFPbUFDb0FBQk1YUGdNek1oNENGUlFPQWlNMU1qNENOVFF1QWlNaUJnY1hIZ0VIQlFZbUp3TW1OaGRFVkNKVlkyMDVaYkdGVFVtQ3NtcERkbGN6TWxkMFEwSjRMVm9mQkJ6KzJSd3NCQ01ES0I4RERpWXNSekVhVElTeFpXV3hoRXlrTTFkMVEwTjFWek16TFNrT01CUFFGQlFpQVdRaUhBNEFBQUFBQWdBQS84QUVBQVBBQUNVQVN3QUFKUTRESXlJdUFpY0hCaVkzRXo0QkZ3VVdCZzhCSGdFek1qNENOejRCRng0QkJ4TUhMZ01qSWc0Q0J3WVdGeFkyTno0RE16SVdGd2NPQVJjRkZqWTNFelltQndPMUpWOXZlMEUwWlY1V0pGTWVKd01pQkNzYkFTRWJCQjlPTFdvNExGVk5RUmtUUWhzY0RSSUpVeVJXWG1VMFFYdHZYeVVTREJ3Y1FoTVpRVTFWTERocUxVNGZCQnNCSVJzckJDSURKeDZqTlZVNkh4UW9PU1FsRGhzaEFWMGhFeFBMRXk4T0l5QWlGU2s2SkJ3TUVoSkNHd0twSlNVNEtCUWZPbFEyRzBFVEVnd2NKVGtwRlNJZ0l3NHVGTXNURXlFQlhTRWJEZ0FBQUFBQkFSVC93QUxzQThBQUhBQUFBU01WTXhFekVUTTNJekEwTlRRMk16b0JNVFV3SWlNaUJoVWNBVEVCZjJ0cnpwQVBueEllR0ZkOEVuUnJBbkd2L2Y0Q0JLMUpHaDRiczJSaFZEWUFCQUFBLzhBRUFBUEFBQXNBUXdCYUFHMEFBQUVqRlNNMUl6VXpOVE1WTXdFVURnSWpJaTRDTlRRMk56NEJOeTRCTlRRMk53NEJJeUl1QWpVME5qYytBVE1oQnlNZUFSVVVCZ2NPQVJVVUZoOEJIZ0VWQXo0Qk5UUXVBaU1pQmdjT0FSVVVIZ0l6TWpZM0V6UW1KeVlpSXlJR0J3NEJGUlFXTXpJMk5RUUFoMFdHaGtXSC9vb3ZYSWRYU20xSEl5MDhQNWN1RHhvSUJnd1dDalpVT2g0aUxEcUpOd0VjV0ZFWFJrY3JEUmtZQ3pFdFJjZ1lDaFVyUVNvYk5CQVNEQlFxUUN3Wk14QnRSMDBJRFFvS1d5b1hYb0p0WW1ZQnQ0ZUhRb2VIL3NVdlcwZ3NJRFpHSlNSY0l5Y1VBeElxSHhFWERBRUJKRHhMSnk5a0pUQVhOaE5SVFVwVElRMGZGaFlhQ1NZbFVVWUJmQmMxRWlWV1NqSVZGQlUzR2lKVFNURVpFUDVRTTBnMkFRY09DRHRIU0Z4VFBnQUFBQUFGQUJyLzFnUG1BNk1BUUFCK0FKa0FxUUM4QUFBVEVUUTJOVDRCTno0Qk56NEJOejRCTXlFeUZqTWVBUmNlQVJjZUFSY2VBUlVSRkFZVkRnRUhEZ0VIRGdFSERnRUhJUzRCSXk0Qkp5NEJKeTRCSnk0Qk5TVWpQQUUxTGdFbkxnRW5MZ0VuTGdFakppSUhEZ0VIRGdFSERnRUhEZ0VWQmhRWEhnRVhIZ0VYSGdFWEhnRXpGalkzTWpZM1BnRTNQZ0UxUGdFM0l4UU9BaU1pTGdJMU5ENENNekF5TVRJZUFoVTRBVEVITWpZMU5DWWpJakF4SWdZVkZCWVhBVG9CTXpJV0ZSUUdJeW9CSXk0Qk5UUTJOeG9CQVFRSEVFazdJRVFqQnc4SUFVQUNCUUljT1JzK1doa09Dd0VCQVFFQkJBY1FTVHNnUkNJSUR3ait3QUlGQWh3NUd6NWFHUTRMQVFFQkEzVUJBUUlEQXhVU0dVTWxLMVlySzFVckhEb2NIRElVSGhzQ0F3SUJBUUVEQXdJV0VSbERKU3RXS3l0Vkt4OC9IelZIRGdRR0FnRUJsU2RFV3pRMFcwUW5KMFJiTkFFelcwUW4ra0pnWGtJQlExOWVRd0VEQVFFQkdDSWlHQUVCQVJjaElSY0JIUUZBQWdVQ0hEa2JQbG9aRGdzQkFRRUJBUVFIRUVrN0lFUWlDQThJL3NBQ0JRSWRPQnMrV2hvTkN3RUJBUUVCQVFFRUJ4QkpPeUJFSWdnUENLQWVQUjRkT1IwY01oUWVHd0lEQWdFQkFRTURBaFlSR1VNbEsxWXJLMVVySERvY0hESVVIaHNDQXdJQkFRRURCUWcrTkJBakV6RmpNVFJiUkNjblJGczBORnRFSnlkRVd6U2lYMEZFWUY5RFExNEJBZUFpR1JnaUFTSVhHQ0lCQUFNQUFQL0FCQUFEd0FBTEFBOEFNd0FBRXhRR0l5SW1OVFEyTXpJV0F5TVJNd0VqRVRNd1BBSTFORFl6TWhZVkhBTXhNekE4QWpVMExnSWpJZ1l4TlRINlNUUTBTVWswTkVrUzFOUUJVc3ZMUVQ4N09kSWxRbHMzYkdFRFFqUktTalEwU2tyKzlmMVZBcXY5VlZKemVpaEhVVTlKSlhwMFZGUi9tVVJGWmtNaGNGd0FBQUVBZFAvREE0d0R3QUJRQUFBQklnNENGUlFXRnhZMk56NEJOelltSnk0Qk5UUStBak15SGdJVkZBNENJeUltTno0Qk5UUW1JeUlHRlJRV01UQU9BZ2NHRmhjVUZqYytBVGMrQVRFZUFUTXlQZ0kxTkM0Q0l3SVlhWjFxTkRvK0NoRUNBd2NEQWdNSUVoVXBTMnRETzFzK0lSc3hSU291T2dzT0ppY29MME1URkJzWUJCRU9BUXNEQkZNVEJTUVFVREJIZFZNdU5XR0tWQVBBUkdxRFBreDhHUVFJQ3djZ0NBc01DaFU0SmpobVRTOGlQVkl4UDNKVk1rSXZPSEFwSkRSWFFTb3pWMjlwRWtlUUNRVUNCQVoxUmhPT0hTdzliSlJXUVhwZU9BQUFBUUFBQUNBRUFBTmdBRGtBQUFFT0FRYytBVGNPQVFjdUFTTWlEZ0lYTGdNbkRnRWVBUmN1QVNjR0ZoY09BU2NlQVJjT0F5Y2VBek15UGdJblBnRTNCQUFjUFNBaE1Bd2ZReVFjVUMwelZUa1hDMEY3Ym1BbkZBc1JMQ01hTUJVQ1gwd1hNQmdVYTBVaFNrOVRLaU5NVVZZc2t1T1pUQVVmTlJVQy9nMFJBeE04SlJJYUJ4NGtMRWhkTVFNaU9VNHdKRTlMUXhnQkRndEplQThHQXdVK1VnSWFKUllIQlJZakdBMXdzOTl2RmpjZ0FBQUFBUUFBQUNNRUFBTmRBRWNBQUFFZUFSVWNBUWNPQXdjT0F5TWlKaThDTGdFaklnWUhKejhCUGdFM01qWXpNaFlYSGdFWEhnRVhIZ0V6TWpZM1BnRTNORFkxTkNZaklnWUhQZ016T2dFekEydEtTd0VCSERSTk1qUmhXRkFsTFVzZUtpb1hNUnNGS0NJeFMwc3lTeG9FQndNMlFnMElEQVVFQ0FRUkpoVVBNU0FnSWdNQkl5TVJKaFFTTlVWV013TUdBd05kQWxSVEJRd0ZJMU5mYkQwL1h6OGdUVTZOamt4TkZoYzZQejRvS3dNQlRVMHNSeHNjSmd0SVNTOHZNVWdYQlFrRUlCOEhCemRVT0J3QUN3QlovOEFEcHdQQUFBOEFHQUFoQUR3QVZRQ0VBSklBd2dEU0FPd0JDQUFBSlRVMEppTWlCZ2NWSGdFek1qWTFNVGN6TlRRbUl5SUdGU1VWSXhFakVTTTFNeGNSSXpVT0FTTWlKaWN1QVQwQk14VWNBUmNVRmpNeU5qYzFNeGNWRkFZSERnRWpJaVluRlNNUk14VStBVE15RmhjZUFSVVhGUndCQnc0QkJ3NEJJeUltSnk0QlBRRTBOamMrQVRNeUZoY2VBUjBCSXhVVUZqTXlOamN3TkRjOEFUMEJNd0VWRkFZaklpWTlBVFEyTXpJV0FUUW1KeTRCSnk0Qkp5NEJJeUlHQnc0QkJ3NEJCdzRCRlJRV0Z4NEJGeDRCRng0Qk16STJOejRCTno0Qk56NEJBVGNqQnljakZ6QVdGeDRCRnhVek5SYzFOQ1luTGdFaklnWUhEZ0VkQVJRV0Z4NEJNekkyTno0QkZ6TVJJeFVPQVNNaUppYzhBVDBCSXhVVUZoY2VBVE15TmpjVk1RSjBDd3NIREFZR0RBY0xDNDR6RFEwTURmNUlQVGs4c3BzMER4ME9EUkFEQXdJekFRWUZDQkFJTk1JREFnVVVFQTRhRERRMERCb09FQlFGQWdQQkFRRUdCUW9mRkJRZ0N3Z0lDQWdMSGhRVUhnb0lDR1lORFFrTUFnRTAvcVVNRFF3TURBd05EQUdhQndjRUVRd05IUkUwbjJwcW5qUVJIZ3dORUFRSUJ3Y0lCQkFOREIwUk5KOXFhcDQxRVIwTURSQUVDQWY5dTBVNUtDZzhFZ2tKRFJJRU9kOElDUXNlRXhNZUN3Z0lDQWdMSGhNVEhnc0pDSXMwTkFnUkJ3WUdBVFFDQXdRUURRNGRFSUI1RkJNR0JxMEdCaE1TWGhzVEZCUVRzamIrdXdGRk5tSCs1aDRSRVFzS0J4UVAzOUFKQ2dFRkJnd00xMVZ4RkJ3SUVCQVFEeHNCZTN3UUR4QVFDQjBVWkFZTUVBWUlEd2NRRHc0UENpSVdaQlloQ3c0UER3NExJUlk3TWhRVENnb0RBZ01HQkJBQ2UzZ1VGQlFVZUJRVUZQM0hSR1FnRVJ3TUN3MENCZ1lHQmdJTkN3d2NFU0ZsUWtSa0lCRWNDd3dOQWdZR0JnWUNEUXdMSEJFZ1pBSTU1SmFXTlJzYUtEMFZtNXMrWkJZaUN3NFBEdzRMSWhaa0Z5RUxEdzRPRHdvaVJnRWQyZ3dNQndZQkNnblI0UThWQndvS0VSRWZBQUFDQUFEL3dBUUFBOEFBRXdBeEFBQUJJZzRDRlJRZUFqTXlQZ0kxTkM0Q0V6QWlJeUlHRlJ3Qk1UTUhJeEVqRVNNMU16QTBOVFEyTXpvQk1SVXhBZ0JxdTR0UVVJdTdhbXE3aTFCUWk3c2lOQThSQzE4SlZueEFRRUZGQzBvRHdGQ0x1MnBxdW90UlVZdTZhbXE3aTFEK3lCQVREeXhuL3NvQk5Ha2dNem84YXdBQUFBQUZBQUQvd0FRQUE4QUFFZ0FtQUZnQVpRQjRBQUFCRGdFaklpWTFORFkzUGdFek1oWVZGQVlIQlJRT0FpTWlMZ0kxTkQ0Q016SWVBZ0UwSmk4QkxnRTFORFkzUGdFMU5DWW5NemNqSWdZSERnRVZGQll6TWpZM0RnRVZGQllYRGdFSERnRVZGQll6TWpZMU55TTFJeFVqRlRNVk16VXpOUVVpSmlNaUJnY09BUlVVRmpNeU5qVTBKaWNCM1FvZkR6VXlDQW9LSUJBek5BWU9BaU5RaTd0cWFydUxVRkNMdTJwcXU0dFEvbFVwSEIwSERnNElHaXNxRGpFMXF5RlRJeHNVUjBFR0RnY0VCUkFKSEZzbUpCdFZXV3B3M2xFcVVWRXFVZjZTQlFnR0JqY1pEamxQUWpzOUtpOENDZ29QWnlrUUlRME1EV29yQ3lBT1NtcTZpMUZSaTdwcWFydUxVRkNMdS83N0tURVhGZ1lRRFE0U0NCUXlMUzR4Q3lFT0hSWTlIQzlRQVFFSERnc1NHZ3NDREJjVk9CWXRSMkE2dlZKU0oxSlNKM0lCQlFnRkpDc3JOekVtSHlzaEFBVUFBUC9BQkFBRHdBQUxBQ01BTXdCSEFGZ0FBQUUwTmpNeUZoVVVCaU1pSmlVVUJpTWlKalUwTmpjakZSUVdNeUV5TmowQkl4NEJGVGNqSWdZZEFSUVdPd0V5TmowQk5DWUZGQTRDSXlJdUFqVTBQZ0l6TWg0Q0p6UW1JeUVpQmhVUkZCWXpJVEkyTlJFQmx6MHNLejQ5TEN3OUFSRmlSa1ppQXdNd0RBa0JlZ2tNTUFNREZUOEpEQXdKUHdrTURBRTZVSXU3YW1xN2kxQlFpN3RxYXJ1TFVPOGxHdjVjR2lVbEdnR2tHaVVCd0N3OVBTd3JQajRyUm1KaVJnc1ZDdWNKREF3SjV3b1ZDOUlNQ1Q4SkRBd0pQd2tNMG1xNmkxRlJpN3BxYXJ1TFVGQ0x1MmdhSlNVYS9sd2FKU1VhQWFRQUFBQUVBQUQvd0FRQUE4QUFFd0FYQUNNQVBnQUFBU0lPQWhVVUhnSXpNajRDTlRRdUFnRWpFVE1uSWlZMU5EWXpNaFlWRkFZQkl6QTBOVFFtSXlJR0ZSd0JNU01STXhVd05qTXlGaFVjQVRFQ0FHcTdpMUJRaTd0cWFydUxVRkNMdS84QWNIQTRIQ2NuSEJzbkp3SEVjQjRnSVNOc2JEUTZPVXNEd0ZDTHUycHF1b3RSVVl1NmFtcTdpMUQ4N3dGc01DY2NIQ2NuSEJ3bi9tU1lKeWNyTENZcWxRRnNNVHhIU2ttZEFBQUFBZ0FBLzhBRUFBUEFBQk1BWGdBQUFTSU9BaFVVSGdJek1qNENOVFF1QWdNaUppY3dCZ2NPQVFjR0pqVXVBVGMrQXpFd0pqVTBOak15RmhVVUJnY0dGak15TmpVMEppTWlCaFVVRmhjZUFRY09BUWNPQVNjdUFUVTBQZ0l6TWg0Q0ZSUU9BaU1DQUdxN2kxQlFpN3RxYXJxTFVWQ0x1em9kTVFrV0F3c3lBd0lHQVFnS0FnOFFEQXNvSEJrWEZ3Z0hJeHd5UGt4SFVWNE5Dd1VCQVFJRUFnRUtCaVVrSUQ5ZlB6TlRPeUFjTWtjcUE4QlFpN3RxYXJ1TFVGQ0x1MnBxdTR0US9YY2FFbFlNS1VjRUFnRURCbFlyQ3o5RE5COFpLRFFmRmhsRElod29jRXc3VFdkREZ5SU1CZ2NIQlJNRUJ3VUREMG91Sms5QUtTSTVTU2MxV1VFa0FBQUNBQUQvd0FRQUE4QUFFd0JEQUFBQklnNENGUlFlQWpNeVBnSTFOQzRDRXhZT0FpTWlKaWNXTmpjdUFTY1dOamN1QVRjZUFUTXVBVGNlQVJjbU5qTXlGaGMrQVRjT0FRYytBVGNPQVFjQ0FHcTdpMUJRaTd0cWFydUxVRkNMdTRBRExGaUNWRE5lS0RCZEppZytDdzRjRENzMkFRd2JEeWdWR0MyQVRBNUpPaG91RUJVbUVnY2NFaElqRUF3ZkVRUEFVSXU3YW1xNmkxRlJpN3BxYXJ1TFVQNTRRSUJuUUIwWkJSa2VBUzhrQXdJRENVVXFCd2diWFNrM1F3UTRYQlVSQkE4S0ZTSU1Bd2tIRWg4TkFBQUFBZ0FBLzhBRUFBUEFBQk1BVlFBQUFTSU9BaFVVSGdJek1qNENOVFF1QWhNT0FRY09BU01pSmk4Q0xnRWpJZ1lISno4QlBnRTNNall6TWhZWEhnRVhIZ0VYSGdFek1qWTNQZ0UzUEFFMU5DWWpJZ1lIUGdFek9nRXpIZ0VWSEFFVkFnQnF1NHRRVUl1N2FtcTdpMUJRaTd2SkFqODhQMm9ySEMwU0dSa09IUkFFRnhVZExTMGVMUkFDQkFJZ0tBZ0VCd01EQlFJTEZnMEpIUlFURkFJVkZBc1hEQlpUUGdJREFpd3RBOEJRaTd0cWFydUxVRkNMdTJwcXU0dFEvb1VxY2tsTVRDOHVWVlV1TGc0Tkl5VWxHQm9DQVM0dUd5b1JFQmNIS3l3Y0hSMHJEZ01GQXhNVEJRUkRRd0V6TWdNSEF3QUFBQXdBQVAvQUJBQUR3QUFPQUJnQUlRQTlBRllBaGdDVUFNVUExUUR2QVFvQkhnQUFBVFUwSmlNaUJnY1ZIZ0V6TWpZMU56TTFOQ1lqSWdZZEFTVVZJeFVqTlNNMU14Y1ZJelVPQVNNaUppY3VBVDBCTXhVY0FUTVVGak15TmpjMU16RVhGUlFHQnc0Qkl5SW1KeFVqTlRNVlBnRXpNaFlYSGdFVkZ4VWNBUWNVQmdjT0FTTWlKaWN1QVQwQk5EWTNQZ0V6TWhZWEhnRWRBU01WRkJZek1qWTNNRFExTmpROUFUTVZBeFVVQmlNaUpqMEJORFl6TWhZVE5DWW5MZ0VuTGdFbkxnRWpJZ1lIRGdFSERnRUhEZ0VWRkJZWEhnRVhIZ0VYSGdFek1qWTNQZ0UzUGdFM1BnRTFBVGNqQnljakZ6QVdGeDRCRnhVek5SYzFOQ1luTGdFaklnWUhEZ0VkQVJRV0Z4NEJNekkyTno0QkZ6TTFJeFVPQVNNaUpqVWlORDBCSXhVVUZoY2VBVE15TmpjVkJSUU9BaU1pTGdJMU5ENENNekllQWdKR0J3Y0VCd1FFQndRSEIxVWVCd2dJQi83NEpTSWthMTBmQ1JJSUNBb0NBUUVlQVFNRUJBb0ZIM1FCQWdNTUNRa1BDQjhmQnhBSkNRd0RBZ0YwQVFRREJoSU5EQklIQlFVRkJBY1RDd3dTQmdVRlBRZ0hCZ2NCQVIvUUNBY0hDQWdIQndqMkJBVUNDZ2dIRWdvZlgwQS9YeUFLRWdjSUNnSUVCUVVFQWdvSUJ4SUtIMkEvUDJBZkNoSUhDQWtEQkFYK295b2pGeGtrQ3dZRkNBc0NJb1lGQlFjU0N3d1NCZ1VGQlFVR0Vnd0xFZ2NGQlZNZkh3VUpCUU1FQVI4Q0FRTUpDQWdTQ1FHR1VJdTdhbXE3aTFCUWk3dHFhcnVMVUFFQVNRc01CQU5vQkFNTEN6a1BEQXdNREE5N0ljUERJVHVwRWdvTEJ3WUVEUWlHZkFZR0JBTUhCNEV6UXd3UkJRb0tDZ2tRNUVzSkNnb0tCUkVNUEFRR0NnUUZDUVFKQ2drSkJoUU9PdzRVQmdrSkNRa0dGQTRqSGd3TEJnWUNBUUVFQXdvQkFYMUlEQXdNREVnTURBeitxeWs4RXdvUkJ3Y0lBUU1FQkFNQkNBY0hFUW9VUENncFBCTUtFUWNIQ0FFRUF3TUVBUWdIQnhFS0V6d3BBU3lKV2xvZ0VCQVhKUTFjWENVOERoUUdDUWtKQ1FZVURqd05GQWNKQ1FrSkJoUXBxNE1IQ0FRRUJnWitpQWdOQkFZSEN3b1NUbXE2aTFGUmk3cHFhcnVMVUZDTHV3QUFBZ0FBLzhBRUFBT3ZBRFlBUndBQUFSY1JNQVlqS2dNaklpWW5KalkxTkNZMU5EWTFOQ1kxTkRZMU5DWTFORFl6SVM0Qkp5NEJOejRCRng0REZ4NERGd1VqSWdZVkVSUVdPd0V5TmpjVE5pWWpBczFKamxFb2RuZHBIUmNxRHhBUk5CZ3hKaVl3SEFFdEF5c1JGUnNiSVZrTkJ4SVdGd3dXUFR3ekRRRWlqd2dPRGdneENBOENWZ0VKQ1FHRE9QNitTU0FpSVNrR0JpMGZIeDBNREJZcktoZ0hDQnd2TGlNdlRpOHZiQ0FuRXhnTVBrbEZFaUpsWWs0TEZROEkvbjBJREF3SUFZVUlEUUFDQUFELzBRUUFBOEFBTmdCSEFBQUJKeEV3TmpNNkF6TXlGaGNXQmhVVUZoVVVCaFVVRmhVVUJoVVVGaFVVQmlNaEhnRVhIZ0VIRGdFbkxnTW5MZ01uSlRNeU5qVVJOQ1lyQVNJR0J3TUdGak1CTTBtT1VTaDJkMmtkRnlvUEVCRTBHREVtSmpBYy90TURLeEVWR3hzaFdRMEhFaFlYREJZOVBETU4vdDZQQ0E0T0NERUlEd0pXQVFrSkFmMDRBVUpKSUNJaUtBWUdMUjhmSFF3TUZpc3FHQWdISEM4dUpDNU9MeTlzSUNjVEdBdytTVVVTSW1WaVRnc1ZEd2dCZ3dnTURBaitld2dOQUFRQUFBQUtCQUFEZkFBYUFCOEFKQUFvQUFBQklTSUdGUkVVRmpzQkZSUVdOejRETVNFeU5qVVJOQ1lqQlNFVklUVUJJVFVoRlNVaE5TRUR2UHlJSENnb0hHY2REUUUwUERFQ1JSd29LQno4N3dJaS9kNEJtZjVuQVprQkVmMVdBcW9EZkNnZC9kNGNLTGtRQmdnQ1BrbzlLQndDSWgwb3EwUkUvcXRFUkloRUFBQUFBQUVBQVAvNkJBQURiZ0ErQUFBQklnWUhEZ0VIRGdFSERnRUhMZ0VuTGdFbkxnRW5MZ0VqSWdZSERnRVZGQllYSGdFWEhnRVhIZ0VYSGdFWEFSNEJNekkyTndFK0FUVTBKaWN1QVNNQzhoSWpFaElqRUE4ZENnb1lDd29WRFFvZEVBOGpFaElrRWtCbEpDWWxCZ2dIRUFjSUZBb0tFQVVGQndVQlpnVUxDQWdMQlFGbVF6OGtKQjVsUXdOdUJnZ0ZFZ3NLRkFjS0Vnb0tGQWdLRVFvTEVBY0dDQ1FrSTJOREVpZ1VGU01ORHhzTURSUUZCUVlEL3FRRkJRVUZBVmxEZ0VCQVl5TWtKQUFBQVFBSC84QUQ5Z085QURJQUFBRXVBUzhDTGdFbk1TTU9BUThDRGdFSEJoWWZBUU1HRmhjZUFUc0JNalkvQVJjZUFUc0JQZ0UzUGdFbkF6YytBU2NEOWdnaUYvMTBDaU1YQ2hVaUNuSDhGeVVGQ0EwUHVTMENEeElLR1EwS0NBOEk0ZUVJRkEwT0NoUUhFaElGTExnS0N3Y0NQaGNlQlNidkZCa0RBeGtVN3lZQ0lSY1hLeEM3L3ZJWEt3MEtDZ1VGZjM4RkJRTUdDQTByRndFTnZ4QXVGQUFBQUFBREFBQUFTQVFBQXpjQUR3QVRBQjhBQUFFaElnWVZFUlFXTXlFeU5qVVJOQ1lIQ1FFaEFSRUJIZ0V6TWpZM0FSRWhBN3o4aUJ3b0tCd0RlQndvS0hIK21mNlpBczc4N2dHTkJoQUlDQkFHQVkzOHFnTTNKeHo5bUJ3b0tCd0NhQnduVmY2YUFXYjl2QUlRL25NR0JnWUdBWXo5OFFBQUFBQUNBQUFBS0FQNUE0TUFFd0FyQUFBbEZTRVJNemNqSWdZVkVSUVdNeUV5TmowQkJ3RURKZ1lkQVRBT0FnYytBekVWRkJZL0FUWTBKd0x2L1lob2Qrb3RQejh0QW8wdFAzWUJDdklIREpHOHN5Tkp2YWwwREFmeENBZnJUUUdMZHo4dC9sOHNQejhzem5ZQm1BRUFCUVVKYmlsdHY1Vk9VQ0lDYXdrR0J2a0ZEd1lBQUFBQ0FGQUFFQU93QTNBQUpnQlJBQUFCUGdFM1BnRWVBUmNITGdFSERnRVBBUVlVRnhZeVB3RWVBVGNIRGdFaUppY3VBVFEyUHdFQkJ6WVdGemMyTWhjV0ZBOEJCaUluTGdFbkJ4NEJGeDRCRnhZMk56NEJQd0UrQVRRbUp5NEJJZ1lIQVFnT0h4RXVabUZWSG1BVVhETVRKQSs0S2lvcWR5azVKMUVwZlNobGFXVXBLQ2dvS0xnQkpIMHBVU2M1S1hjcUtpcTRLbmNwQ2hBRllBZ1FDaHBCSnpGbUxSRWZEcmdvS0Nnb0tHWnBaU2dDVEE0WENSb01Gem90WUM4d0RBUVREN2dxZGlvcUtqa1BEUU45S0Nnb0tDbGxhV1VvdUFFa2ZRTU5EemtwS1NwM0tiZ3FLZ2tZQzE4TUZBb2FKZ2tNRGhnSkdBNjNLV1ZwWlNncEtDZ29BQUFBQUFRQUFQL0FCQUFEd0FBS0FBNEFJZ0F6QUFBQk54RWhFUmNlQVRNeU5oTWhGemNGRkE0Q0l5SXVBalUwUGdJek1oNENKelFtSXlFaUJoVVJGQll6SVRJMk5SRUNDKzcrQU80RENnVUZDY24rVXRmWEFUQlFpN3RxYXJ1TFVGQ0x1MnBxdTR0UTFCZ1IvZXNRR0JnUUFoVVJHQUZhN2Y3RUFUenRCQVFFQVJIWDE2ZHF1NHRRVUl1N2FtcTdpMUJRaTd0SUVSY1hFZjZPRVJjWEVRRnlBQUFEQUFEL3dBUUFBOEFBRXdBbUFENEFBQUVpRGdJVkZCNENNekkrQWpVMExnSVRGQVlqSVNJbVBRRTBOanNCQnlNVklUVTNOd2NHSmowQk1BNENCejRETVRVME5oOEJGaFFIQWdCcXU0dFFVSXU3YW1xN2kxQlFpN3RzSmh2K2VSc21KaHVNUno4QmUwZFprUVFJUldWeUxCVnNjRmNIQlpFRUJBUEFVSXU3YW1xN2kxQlFpN3RxYXJ1TFVQMDlHaVltR3ZzYUprZnRMa2VmbGdNREJrQUJGREF2V1hOQkdVSUZBd09hQXdrREFBTUFBUC9BQkFBRHdBQVRBRFFBV3dBQUFTSU9BaFVVSGdJek1qNENOVFF1QWdNR0lpY21ORDhCUGdFM05oWVhCeTRCQnc0QkR3RUdGQmNXTWo4QkhnRTNCd0VIRGdFSERnRW5MZ0VuTGdFbk54NEJGeFl5UHdFMk5DY21JZzhCTGdFSE56WXlGeFlVQndJQWFydUxVRkNMdTJwcXU0dFFVSXU3Z3kyQkxpMHRhUWNTQ1RWMklqY0xOUndMRlFob0dCZ1lReGdnRmk0WFJ3RU9hQWdTQ1JvNkhCWWxEZ1lKQkRZRENRVVlReGhvR0JnWVF4Z2dGUzhYUnkyQkxpMHRBOEJSaTdwcWFydUxVRkNMdTJwcXVvdFIvUVV1TGkyQkxtZ0lEUVVkSERNMkdoc0dBd3NJYUJoREdCY1hJQWdIQWtjQkRXZ0lEUVVPQ0FjRkZROEdDd2MyQncwRkdCaG9HRU1YR0JnZ0NRY0NSeTR1TG9BdUFBQUJBQUQvd0FRQUE4QUFLZ0FBQVE0Qkl5SW1KeTRCTlRRMk56WXVBaU1pRGdJeEZCNENGeDRETXpBK0FqVTBMZ0lIQXU4eklqUXpaak0wVlZVMEdTWk5XaGthUmtBdE1FMWlNaktSbXBJelFFMUFRbHBiR2dGYU5GVlZORE5tTXpRaU14cGJXa0pBVFVBemtwcVJNakppVFRBdFFFWWFHVnBOSmhrQUJBQ0svOEFEZGdQQUFBMEFGd0FqQUM4QUFBRWpOVFFtSXlJR0hRRWpBeUVESlRRMk16SVdIUUVoTlFNaUpqVTBOak15RmhVVUJpRWlKalUwTmpNeUZoVVVCZ05Xb1dwTFMycWhJQUxzSVA0YlZEczdWUDdpRWhZZUhoWVZIaDRCTGhZZUhoWVZIaDRDclY1TGFtcExYdjBUQXUxZU8xTlRPMTVlL3ZjZUZSVWVIaFVWSGg0VkZSNGVGUlVlQUFBQUFRQUFBRWdFQUFNNEFDQUFBQUVuTGdFbk5TTU9BU01pSmljakZRNEJEd0VYTng0QkZSRWhFVFEyTnhjM0p3T3BXaEFtRkhvUVNpNHZTZzk2RmlrUXNxSklBZ0lDS1FJQlJLSlhBcVpvRWhVQ0FTazFOU2tCQVJVVHpuMVRCUTBIL2tzQnRRWUxCVTk5WlFBQUJ3QUEvK1FFQUFPY0FDY0FUd0JmQUhBQWZRQ0pBSTBBQUFFak56NEJOVFFtSXlJR0R3RW5MZ0VqSWdZVkZCWWZBU01pQmhVUkZCWXpJVEkyTlJFMEppTVRGQVlqSVNJbU5SRTBOak1oSnk0Qk5UUTJNeklXSHdFM1BnRXpNaFlWRkFZUEFTRXlGaFVSQVNFaUJoVVJGQll6SVRJMk5SRTBKaE1VQmlNaElpWTFFVFEyTXlFeUZoVVJOeklXRlJRR0l5SW1OVFEyTXljME5qTXlGaFVVQmlNaUpnVVhCelVEZnJJWURRODRLQk1qRFYxY0RTTVRLRGdQRFJpeU4weE1Od0w3Tmt4TU5qb2dHdjBGR2lJaUdnRllqUVFFRUFzRkNnT05qUVFLQlFzUUJBU05BVmdhSVA3RC9uQXlTVWt5QVpBelNFZ3BPaVgrYlNZd05TVUJreVkxZ0JjaElSY1lJU0VZT0NBWUZ5RWhGeGdnL2x5RmhRTGtGdzBpRXlnM0R3MWNYQTBQT0NjVElnMFhUemIrQnpaTVREWUIrVFpQL1lJYUlDQWFBZmthSTQ0RENnWUxEd1FFalkwRUJBOExCZ29EamlNYS9nY0IrVWd6L3dBelNFZ3pBUUF6U1A2REpUVXlKUUVISlRVMkp2Nys0eUVYR0NFaEdCY2hZaGNoSVJjWElTRkJhMnZXQUFBQUJ3QUEvK1FFQUFPY0FDY0FUd0JnQUhBQWZBQ0lBSlVBQUFFak56NEJOVFFtSXlJR0R3RW5MZ0VqSWdZVkZCWWZBU01pQmhVUkZCWXpJVEkyTlJFMEppTVRGQVlqSVNJbU5SRTBOak1oSnk0Qk5UUTJNeklXSHdFM1BnRXpNaFlWRkFZUEFTRXlGaFVSQVNFaUJoVVJGQll6SVRJMk5SRTBKaU1URkFZaklTSW1OUkUwTmpNaE1oWVZGeFFHSXlJbU5UUTJNeklXSnpRMk16SVdGUlFHSXlJbUJUTVZJelV6TlRNVk16VXpGUU4rc2hnTkR6Z29FeU1OWEYwTkl4TW9OdzROR0xJMlRVMDJBdnMyVEV3Mk9pQWEvUVVhSVNFYUFWaU5CQVFRQ3dVS0JJMk5Bd29GQ3hBRUJJMEJXQm9nL3NQK2NESklTRElCa0ROSVNETmNPaVgrYlNVeE5TWUJraVkxdUNFWEZ5RWhGeGNoY0NFWEZ5RWhGeGNoL3VzVjF4UklIMGNDNUJjTkloTW9OdzRPWFYwTkR6Z25FeUlORjA4Mi9nYzJURXcyQWZrMlQvMkNHaUFnR2dINUdpT09Bd29HQ3c4RUJJMk5CQVFQQ3dZS0E0NGpHdjRIQWZsSU0vOEFNMGhJTXdFQU0waitneVUxTWlVQkJ5VTFOaVpYR0NFaEdCY2hJWU1YSVNFWEZ5RWhhWnFhRkJRVUZBQUFCd0FBLytRRUFBT2NBQ2NBVHdCZ0FIRUFmUUNKQUxrQUFBRWpOejRCTlRRbUl5SUdEd0VuTGdFaklnWVZGQllmQVNNaUJoVVJGQll6SVRJMk5SRTBKaU1URkFZaklTSW1OUkUwTmpNaEp5NEJOVFEyTXpJV0h3RTNQZ0V6TWhZVkZBWVBBU0V5RmhVUkFTRWlCaFVSRkJZeklUSTJOUkUwSmlNVEZBWWpJU0ltTlJFME5qTWhNaFlWRVRjVUJpTWlKalUwTmpNeUZpYzBOak15RmhVVUJpTWlKZ2N3RkJVVUJnY09BU3NCSWlZMU5EWXpNRFk5QVFjVk1CUVZGQVlIRGdFak1UZ0JNU0ltTlRRMk16QTJQUUUzRlFOK3NoZ05EemdvRXlNTlhGME5JeE1vT0E4TkdMSTJUVTAyQXZzMlRFdzJPaUFhL1FVYUlTRWFBVmlOQkFRUUN3VUtCSTJOQXdvRkRBOEVCSTBCV0JvZy9zUCtjREpJU0RJQmtETklTRE5jT2lYK2JTVXhOU1lCa2lZMXVDRVhGeUVoRnhjaGNDRVhGeUVoRnhjaDZRb0pDQmNOQVJJYUdSSVljUWtKQ1JZT0Vob1pFaGZEQXVRWERTSVRLRGNPRGwxZERRODRKeE1pRFJkUE52NEhOa3hNTmdINU5rLzlnaG9nSUJvQitSb2pqZ01LQlFzUUJBU05qUVFFRHdzR0NnU05JeHIrQndINVNEUC9BRE5JU0RNQkFETkkvb01sTlRJbEFRY2xOVFltL3Y2cUZ5RWhGeGdoSVlNWElTRVhGeUVocWlvTkRCVUpDQWdhRWhJYUFnbGpKVThxRFF3VkNBZ0lHUk1TR1FJS2VqMkxBQUFIQUFELzVBUUFBNXdBSndCUEFHQUFjUUI5QUlrQXFBQUFBU00zUGdFMU5DWWpJZ1lQQVNjdUFTTWlCaFVVRmg4Qkl5SUdGUkVVRmpNaE1qWTFFVFFtSXhNVUJpTWhJaVkxRVRRMk15RW5MZ0UxTkRZek1oWWZBVGMrQVRNeUZoVVVCZzhCSVRJV0ZSRUJJU0lHRlJFVUZqTWhNalkxRVRRbUl4TVVCaU1oSWlZMUVUUTJNeUV5RmhVUk54UUdJeUltTlRRMk16SVdKelEyTXpJV0ZSUUdJeUltQnhVVUJnY1ZJelV1QVQwQk5EWTdBVEEwTVRRMk93RXlGaDBCTXpJV0ZRTitzaGdORHpnb0V5TU5YRjBOSXhNb09BOE5HTEkyVFUwMkF2czJURXcyT2lBYS9RVWFJU0VhQVZpTkJBUVFDd1VLQkkyTkF3b0ZEQThFQkkwQldCb2cvc1ArY0RKSVNESUJrRE5JU0ROY09pWCtiU1V4TlNZQmtpWTF1Q0VYRnlFaEZ4Y2hjQ0VYRnlFaEZ4Y2g5aGtTbGhJWkd4UVBCQU5qQXdRUEV4c0M1QmNOSWhNb053OE5YRndORHpnbkV5SU5GMDgyL2djMlRFdzJBZmsyVC8yQ0dpQWdHZ0g1R2lPT0F3b0dDdzhFQkkyTkJBUVBDd1lLQTQ0akd2NEhBZmxJTS84QU0waElNd0VBTTBqK2d5VTFNaVVCQnlVMU5pYisvcXNZSVNFWUZ5RWhneGNoSVJjWElTR0NhQk1hQVJvYUFSb1RhQk1iSndNRUJBTW5HeE1BQUFzQUFQL2tCQUFEbkFBbUFFNEFYd0J3QUgwQWlRQ29BS3dBd1FEVEFPZ0FBQUVqTno0Qk5UUW1JeUlHRHdFbkxnRWpJZ1lWRkJZZkFTTWlCaFVSRkJZeklUSTJOUkUwSmhNVUJpTWhJaVkxRVRRMk15RW5MZ0UxTkRZek1oWWZBVGMrQVRNeUZoVVVCZzhCSVRJV0ZSRUJJU0lHRlJFVUZqTWhNalkxRVRRbUl4TVVCaU1oSWlZMUVUUTJNeUV5RmhVUk54UUdJeUltTlRRMk16SVdGU2MwTmpNeUZoVVVCaU1pSmdVekZRNEJJeUltTlRRMk16SVdId0VqTlM0Qkl5SUdGUlFXTXpJMk56RTNNeFVqTnpNVkl6VU9BU01pSmowQk14VVVGak15TmowQk55SUdCelVqRlRNMUhnRXpNalkxTkNZakZ5TTFORFl4TXpVME5qRXpNaFlkQVRNeUZoMEJBMzZ5R0EwUE9DZ1RJZzVjWFEwakV5ZzNEZzBZc2paTlRUWUMrelpNVEFRZ0d2MEZHaUVoR2dGWWpRUUVFQXNGQ2dTTmpRTUtCUXdQQkFTTkFWZ2FJUDdEL25BeVNFZ3lBWkF6U0VnelhEb2wvbTBsTVRVbUFaSW1OYmdoRnhjaElSY1hJWEFoRnhjaElSY1hJZjRNSmdZaUdCMG5KeDBZSVFZQkpnTU9DUTRURXc0SUR3TTBJeU9DSXlFR0VRa1lIU01JRUFzTmVnc1RCeVFpQ0JRTEdpVWxHaG94QWdjQ0d3RUJCd0VCQXVRWERTSVRLRGNQRFYxZERRODRKeE1pRFJkUE52NEhOa3hNTmdINU5rLzlnaG9nSUJvQitSb2pqZ01LQmdzUEJBU05qUVFFRHdzR0NnU05JeHIrQndINVNEUC9BRE5JU0RNQkFETkkvb01sTlRJbEFRY2xOVFltL3Y2cUZ5RWhGeGdoSVJpYkZ5RWhGeGNoSWR3QkZob29IUjRvR1JjQkFRWUtGaEFQRlFrSGtMNkZoUXNIQmlBYVRVMEZGQTRMVFFJSEIwVytEUWNJS0J3ZEtHWTVBUUVJQVFFQkFRZ0JBVGtBQUJNQUFBQkFCQUFEUUFBZUFDSUFOZ0JJQUYwQWJRQjlBSTBBblFDdEFMMEF6UURTQU9JQThnRUNBUklCSWdFeUFBQUJNd2NPQVNNaUpqVTBOak15RmhjVkl5Y3VBU01pQmhVVUZqTXlOamMxRnpNUkl4Y1VCaU1pSmowQkl4VVVGak15TmpjVk16VWpCUlFHSXlJbUp4VWpFVE1WUGdFek1oWVZKelFtS3dFMU5DWXJBU0lHSFFFaklnWWRBVE0xRXhFVUJpTWhJaVkxRVRRMk15RXlGZ0UwSmlzQklnWWRBUlFXT3dFeU5qVTFOQ1lyQVNJR0hRRVVGanNCTWpZMU5UUW1Ld0VpQmgwQkZCWTdBVEkyTlRVMEppc0JJZ1lkQVJRV093RXlOalUxTkNZckFTSUdIUUVVRmpzQk1qWTFOVFFtS3dFaUJoMEJGQlk3QVRJMk5RRVJJUkVoTnpRbUt3RWlCaDBCRkJZN0FUSTJOVFUwSmlzQklnWWRBUlFXT3dFeU5qVTFOQ1lyQVNJR0hRRVVGanNCTWpZMU5UUW1Ld0VpQmgwQkZCWTdBVEkyTlRVMEppc0JJZ1lkQVJRV093RXlOalUxTkNZckFTSUdIUUVVRmpzQk1qWTFBVDgxQVFjd0l5azRPQ2tpTUFnMEFRUVVEUk1iR3hNTUZRVktNVEc0RXc4WUNUTXBJZzBYQ1RBeUFRYzBKaEFjQ3pBeUN4c1BKalExQVFFTEFnRWxBZ0VLQVFKRjdVczMvUVEyVEV3MkF2dzNTL3hjREFnVkNBd01DQlVJREF3SUZRZ01EQWdWQ0F3TUNCVUlEQXdJRlFnTURBZ1ZDQXdNQ0JVSURBd0lGUWdNREFnVkNBd01DQlVJREF3SUZRZ01BeW44OWdNS1hBd0lGQWtNREFrVUNBd01DQlFKREF3SkZBZ01EQWdVQ1F3TUNSUUlEQXdJRkFrTURBa1VDQXdNQ0JRSkRBd0pGQWdNREFnVUNRd01DUlFJREFGOEFTQWtPQ29xT1NRaEFRRUlEaDRYRlI4TkNnRkJBUTdBRHhRZEJtMXRKQzRLQ1ErN1hTazVEQW9TQVE1aUNRczVLU0VDQVFzQkFnSUJDd0VDVUZBQkF2NEdOa3hNTmdINk5VOVAvZFFJREF3SUZBa01EQWw3Q0F3TUNCVUpDd3NKZXdnTURBZ1VDUXdNQ1hvSkRBd0pGQWtNREFsN0NBd01DQlVJREF3SWV3a01EQWtVQ1F3TUNmM05Bb1Q5ZkVjSURBd0lGQWtNREFsN0NBd01DQlVKQ3dzSmV3Z01EQWdVQ1F3TUNYb0pEQXdKRkFrTURBbDdDQXdNQ0JVSURBd0lld2tNREFrVUNRd01DUUFJQUFML3dBUUFBOEFBSmdBcUFDNEFNZ0EzQUQwQVFnQk5BQUFCSVNVK0FTOEJMZ0VuTGdFaklnWWpCUTRCSHdFZUFURUdGQlVSRkJZeklUSTJOUkUwSmlNSEl6Y3pJUWNqTnlNSEl6VWxKemNYQnlVSEp6Y1hJd1UzRndjbkFTRWlKalVSSVJFVUJpTURzdjVxQVhjZkl3WVdBeEVOQ1JZTEJBZ0UvT0FnSXdjV0FnMEZRRG9DMWpwVUxpQjNvV0dnL3JkZ3FXR25ZUzRCS29xamlxTUI1YUNKcDRJQi9Nb2RpbzRaQXhyOVFnNG1Bems1RGdKblZBWTJIbTBQR2dnR0J3R2ZCalFlYndjRkNCUUwvaTA1V2xvNUFkTWZJcTFjWEZ4Y1hJdGJJVm9pWkNGYUlWWTBCMXdlYy8wOEl4OEJSZjY3SUNJQUFBUUFBQUFtQkFBRFdnQWtBQzhBT2dBK0FBQUJJelUwSmlzQklnWWRBU00xTkNZckFTSUdIUUVqSWdZVkVSUVdNeUV5TmpVUk5DWWpKVFEyT3dFeUZoMEJJelVoTkRZN0FUSVdIUUVqTlFFaEVTRUR6VWdvRytjYkxDZ3JHK2NiS1VnVkhoNFZBNW9XSFIwVy9vOERBdXdDQS9iK1VnTUM3QUlEOWdNSy9KQURjQUxVUXhzb0tCdERReHNvS0J0REdSYjl0QlVlSGhVQ1RCWVpPZ0VEQWdKall3RURBZ0pqWS8xZ0FoOEFBQUFBQXdBQS84QUQvZ1BBQUVZQWdnQ1pBQUFCTGdFckFTSUdCeTRESnk0Qkp5NEJKeTRCSXlJR0J3WVdGeDRCRnlNaUJoVVVGaGNPQVJVVUZoY09BUlVVRmhjR0ZoY2VBVE1oTWpZM0hnRTdBVEkyTnhNMkppY0JJdzRCSXlvREl5SW1KeVkyTlRRbU5UUTJOVFFtTlRRMk5UUW1OVFEyTXlFdUFTY3VBVGMrQVRNeUZoY2VBUmNlQXhjZUFURXpFUk1ERGdFckFTSW1OVEE4QWpVME5qTTZBVE15RmdjRDdBMG1Gbm9PR3cwTU5qa3ZCQWdXQndvTkJ3NDFJaWRPR3lJREpBUUtCWlZDVGdjR0JnY1FDd01ER0EwQ0JRc1lTU3NCWURKTkd4QXhHaWtuTlFkSkJBa04vdnN3RVVJeEltUm5XUmtUSkE0TkRpd1VLU0FnS1JnQkFRTWtEeElYRnhJdkV3c1JCQXNuRXhRNE5TZ0RBZ290eWtvQkRRY3BEUk1MQ2dad0R3Y0lBUUdqRUJNSEJ4WlZXRWNIREVZWElpZ05HaDBtSUNoM1VBd1dDRTlBRkNFTkRCOFRIQ2dPQ1JVTkhTMFFFU29ZTWpZZkVoVWNOQjRCUXhVcEVQNmhEeWdnSEJ3bUJRVW1HaG9ZQ2dvU0pDUVNCd1lYSnljYklVc29KMkFhRlJVSEJ4V1NIaDFYVkVFR0JoTCt5d0VrL3JzSER4TUhZbmRuQlFvRENnY0FBd0FBLzhBRC9nUEFBRVVBZ1FDWUFBQUJBeTRCS3dFaUJnY3VBU01oSWdZSERnRVhEZ0VWRkJZWERnRVZGQllYRGdFVkZCWTdBUTRCQnc0QkZ4NEJNekkyTno0Qk56NEJOejRETng0Qk93RXlOamMrQVFVak1BWUhEZ01IRGdFSERnRWpJaVluSmpZM1BnRTNJU0ltTlRRMk5UUW1OVFEyTlRRbU5UUTJOVFFtTno0Qk16b0RNeklXRnpNUk15b0JJeUltTlR3RE1UUTJPd0V5RmhjVEZnWWpBLzVKQnpVbktSb3hFQnROTXY2Z0swa1lDd1VDRFJnREF3c1FCd1lHQjA1Q2xRVUtCQ1FESWh0T0p5STFEZ2NOQ2djV0NBUXZPVFlNRFJzT2VoWW1EUTBKL3VVdENnSURKelk0RkJNbkN3UVJDeE12RWhjWEVnOGtBLzcvR0NrZ0lDb1ZMUThORGlRVEdWcG1aQ013UWhJdnZBOXdCZ29MRXcwcEJ3MEJTZ0VJQndJckFVTWVOQndWRWg4Mk1oZ3FFUkF0SFEwVkNRNG9IQk1mREEwaEZFQlBDQllNVUhjb0lDWWRHZzBvSWhkR0RBZEhXRlVXQndjVEVCQXBEeElHQmtGVVZ4MGVraFVIQnhVVkdtQW5LRXNoR3ljbkZ3WUhFaVFrRWdvS0Z4c2FKZ1VGSmh3Y0lDZ1Avc3NEQ2dWbmQySUhFdzhIL3JzSENnQUFBQUFHQUFELzJ3UUFBNlVBQkFBSkFBNEFMZ0JMQUZBQUFCTWhGU0UxTlNFMUlSVTFJVFVoRlJNaUpqVVJORFl6SVRJV0ZSRVVCaU1oRGdFSERnRUhEZ0VyQVNJbVBRRXpKeDRCT3dFY0FSVXpQZ0UzSVRJMk56NEJOUkUwSmlNaElnWVZFUmNUSVRVaEZiQUJIZjdqQWRQK0xRS2cvV0FQVldwcVZRS0NWV3BxVmY2RUN4Y0xFU01SQ3lBU0hDRXVGRzRFT2pBN0hDSkdJZ0doS1RnS0FnSThNLzErTXp3Qlh3S2cvV0FCY1NJaVZTSWk3eUlpL2Naa1ZRRzNWbVJrVnY1VFZtMEpIZzRWS0JRT0RDd2hVNjh2TVNKYklpcFRJaWdrQ0JJS0FiRTNNek0zL2s4UUFSUWlJZ0FBQUFrQUFQL2lCQUFEbmdBM0FGa0Fjd0IzQUhzQWdBQ0ZBS2dBeXdBQUFSRTBKaU1oSWdZVkVSUVdPd0VlQVJjZUFSY2VBVHNCTWpZOUFUTVZGQlk3QVJVVUZqc0JNalkzUGdFM1BnRTdBVEkyUFFFMEppY0ZIQUVWSXk0Qkp5TWlKaWN1QVRVUk5EWXpJVElXRlJFVUJoVWNBUlVPQVNNaEJSUUdLd0VPQVFjalBBRTFJeUltUFFFek1qWTNNeklXSFFFQklSVWhGVE1WSXdVaEZTRTFOU0VWSVRVM0xnRTFORFkzUGdFM1BnRXpNaFlYRmhRSERnRUhEZ0VISGdFVkZBWXJBU0ltSnlNdUFUVTBOamMrQVRjK0FUTXlGaGNXQmdjT0FRY09BUWNlQVJVVUJpTXhJaVluQTVwZ1RmMi9UVjlmVFNJS0ZRb1BJQThMSEJBWkhpb3BSVGdJTFI0TkVCMEtDQkVKQXdZRFNEaElPQzc5NnhrZlB4NUVKVElKQWdJMkxnSkJMellCQkRVci9wZ0NNeDhaYWhFaEVSQlFHaHl3T0VRR0VSa2YvalFCQVA4QTRlSCt3Z0drL2x3Q1B2M0NtQWtLQ0FjSEZ3NFVFQVVGQ0FNR0FnRUZCUThWQlJNYUd4TUJEaGNLa2dvSkJ3Z0hGZzhURVFRRkNBUUdBUUlCQkFVUUZBVVNHeHNVRGhnSkFha0JUazFhV2szK2ZVMWpCeHdNRXlRU0RBd29Ia29TTjBjSUhpd09EQW9WQ3dNTFJ6ZDhNVU1IblI5U0h5ZEtIeVFnQ0E4SkFZY3hMaTR4L25rREJRSUJBZ0VxTEZvYUhCY2tGeGNzRHh3YU96MDBGaHA4QWtjZVhSL1lIaDU4SHg5ckNSWU5EaG9MQ3hRSkRBWUVBd2NMQkFJREJRc1RCd0ViRXhNY0NRZ0pGZzBPR2dzTEZBa01CZ1FEQndzRUFnTUZDeE1IQVJzVEV4d0pDQUFHQUFELy9RUUFBNE1BRXdBb0FEVUFUd0JjQUdFQUFBRTBMZ0lqSWc0Q0ZSUWVBak15UGdJSElpNENOVFErQWpNeUhnSVZGQTRDSXpVaUpqVTBOak15RmhVVUJpTUJOVFFtSXlFaUJoMEJJeUlHRlJFVUZqTWhNalkxRVRRbUl5VTBOak1oTWhZZEFTRXdORFVCRVNFUklRTHZKa0ZYTVRGWFFTWW1RVmN4TVZkQkp1OHFTemdoSVRoTEtpcExPQ0FnT0VzcU5rMU5OalpOVFRZQkR6NHMvcllzUHJjWUlpSVlBNHdZSWlJWS9Zb0dCUUZLQkFMK3BmNytBMlQ4bkFGeU1WZEJKaVpCVnpFeFYwRW1Ka0ZYbkNBNFN5b3JTamdoSVRoS0t5cExPQ0JMVERZMlRVMDJOa3dCOXl3c1JFUXNMQ0VYL1lZWElTRVhBbm9YSVVFRUNRUUZjbFVaL1NNQ1R2MnlBQUFBQUFZQUJQL0FBL3dEd0FCU0FJOEFxUUMwQU00QTJRQUFBU2N1QVNzQlBBRXhOaVluTGdFaklTSUdCdzRCRnpBVUZTTWlCZzhCRGdFZUFSY2VBUmN3RmhVZUFSVU9BUWNPQVFjR0ZoY2VBVE1oTWpZM1BnRW5MZ0VuTGdFbk5EWTNNRFl4UGdFM1BnSW1Kd0VPQVFjeERnRVZGQllYTUJZWEhnRVhIZ0V4SVRBMk56NEJOejRCTVQ0Qk5UUW1KekV1QVNjdUFqWTFOek11QVRFaE1BWUhNeGNVRmc0QkJ4TWpJZ1lWRGdFSERnRUhCaFlYSGdFek1qWTNQZ0VuTGdFakJ6NEJOejRCTnpNV0JnY2xMZ0VuTkNZckFTSUdCd1lXRng0Qk16STJOejRCSnk0Qkp5Y3pIZ0VYSGdFWExnRTNBL3dEQXg4VWJBRUlDQWdVQy8yK0N4UUlDQWdCYkJRZkF3TURBVEIyZENGTUZ3SURCQThjRFMwaEFnVUVCd2dZRFFGY0RSZ0lCd1FGQWlFdERSd1BCQU1DRjB3aWMzWXdBUVArd2laWEVBZ0hDQWNGQVF3YURpa2EvcVFhS1E0YURBRUZCd2dIQ0JGV0ozWndLQWNEcGdJQ0FrSUNBcVlEQnlod2Q5TjNCZ29FRUEwRUN3WUJCQVFDQlFJREJRT0dNUVFCQ1FlT0FRTUNEQkFGV0FJbVcvNFVEUkFFQ2daM0J3a0JCREdHQXdVREFnVUNCQVFCQmdzRW1Wa0VFQXdDQXdKY0pnSURPaFVWR1FnRUN4UUlDQWdIQ0FnV0N3SUpHUlVXRUZsNWowWTZQQThCQVJBekRnb1lEUzA2QmcwY0RBc09EZ3NNSEF3R09pNE5HQW9OTkJFQkR6dzdSbzU2V1JEK2NVazNEUVpxQ2dvUkJnUUJDQllPS1RFeEtRNFdCd0VGQmhFS0NXc0dEVGRKUm9sdVJRSVhJU0VoSVJjQlJtNkpSZ0YyQ1FkSFNDb1BKQllGQ3dNQkFRSUNjR1UrQndubkJnb0ZLRWRCSjA1UUhpcElSd2NKQ1FjK1pYQUNBZ0VCQXdzRkZpUVBwMEZIS0FVTEJWQk9Kd0FBQlFBei84QUR6UVBBQUJBQUZBQVlBQndBS2dBQUFTRWlCaFVSRkJZeklUSTJOUkUwSmlNUklSRWhBU0VWSVRVaEZTRWxJUkV6TlRNVk16VXpGVE1SSXdPSi9PNGNLQ2djQXhJY0tDZ2MvTzRERXYxd0FnNzk4Z0lPL2ZJQmdQNkFQNk5QbmorT0E4QW9IUHlJSENnb0hBTjRIQ2o4UkFONC9Rd3FwU3FWQVZWRlJVVkYvcXNBQUFVQU0vL0FBODBEd0FBUUFCUUFHQUFjQUdNQUFBRWhJZ1lWRVJRV015RXlOalVSTkNZakVTRVJJUUVoRlNFMUlSVWhBUlFHSXlJbUp5TU9BUWNpQmdjT0FRY09BU2NpSmlNaUpqYzBOamMrQVRjK0FTY3VBU2NtSWlNaUpqYytBVGMrQVRNZUFSY2VBUmNlQVJjZUFUY3dNalUrQVRNeUZoVURpZnp1SENnb0hBTVNIQ2dvSFB6dUF4TDljQUlPL2ZJQ0R2M3lBZzQ1S1JjcURRRWRPUjRGQ1FRTER3Y0xIUklYTGhjTEVBRU9DZ3dZREI0UURRWWRDdzhKRHc0UEJnUU1DUkpQQnd3U0J3VUtCZ1FOQndseUJRRU1MaHNwT1FQQUtCejhpQndvS0J3RGVCd28vRVFEZVAwTUtxVXFBVzRwT2hJU0FnSUNCZ01JRlFvUERRRUJFZ3NLRUFFQ0JnWVBPaGtNRkFJREZ3MElDUUVCQXdFTkNRY1FCd1lIQXdNQ0FRRVdIVG9wQUFBQUFBVUFNLy9BQTgwRHdBQVFBQlFBR0FBY0FEc0FBQUVoSWdZVkVSUVdNeUV5TmpVUk5DWWpFU0VSSVFFaEZTRTFJUlVoQVJVVUJnY1ZJVFV1QVQwQk5EWTdBVHdCTlRRMk93RXlGaDBCTXpJV0ZRT0ovTzRjS0NnY0F4SWNLQ2djL080REV2MXdBZzc5OGdJTy9mSUIyaW9lL3ZvZktqQWlGZ2tHcVFZSkZpSXdBOEFvSFB5SUhDZ29IQU40SENqOFJBTjQvUXdxcFNvQnFMQWdMZ1FyS3dRdUlMQWlNQWNqRmdZSkNRWkFNQ0lBQlFBVS84QUQ2QVBBQUMwQVJBQmdBSGtBa2dBQUV4NERNekkyTno0Qk54NEJId0VlQVRNeU5qOEJOaVl2QVM0Qkp6NEJKeTRESXlJR0J3NERGd1UzUGdFek1oWWZBUjRCRHdFT0FTTWlKaThCTGdFM0FUNEJNekllQWhjV0JnY09BUWNPQVNNaUxnSW5KajRDTndjT0FSY2VBVE15TmpjK0FUYytBU2N1QVNNaUJnY09BUWNYUGdFM1BnRXpNaFlYRmdZSERnRUhEZ0VqSWlZbkpqWTNGQkpFV0dvNUhqc2NCdzRHQVJBTitRMGdFUlFrRFZrYUJCejVDeDBQRndNVkUwTlphamtlT2gxRmFUd0tHQUlvV1FRTUJnVUtCUGtKQVFoWkJBd0dCUW9FK1FrQkNQN0pHREFZTDFkSk53OFVCeG9hVmpnWE1SZ3ZWMGszRHhRSk1WWTVhaE1GRGhoMFNCTWxFaXBDRkJRRkR4ZDFTQk1rRWl0Q0ZCa1JPaVlQSVJBL1p4UU5CQklST2lVUUlSQS9aaFVOQlJFQjJUaGJRU01LQ2dNRkF4SWhEZWdNRFJFT1pSNVBHdWdMREFJOWdUODNXMEVrQ2dvWlluK1JTTDFsQlFVRUJPZ0pHUWxsQlFVRUJPZ0pHUWtDVWdnSkhqVkxMVHAzTmpaUEZBZ0pIVFpMTFR0NGFGRVV1Q3BiTEVWV0J3WVBQU2txV3l0R1ZRWUdEejBwRFNVMURRWUZTejBtVUNVa05RMEdCa3c5SmxBa0FCQUFCUC9oQS84RG53QTZBSGNBZXdDQUFJUUFpQUNNQUpBQWxBQ1lBSjBBb2dDbkFLd0F2QURQQUFBQkxnRWpJU2N1QVM4QktnRWpKeTRCSXlJR0J3WVdGekl3TVJjVEJ3NEJGUmNVRmhjZUFUTXlOamN6SGdFek1qWTNQZ0UxTkNZbkV6WW1Kd01oQnlFeUZoVVVCaXNCSGdFVkZBWWpJaVkxTkRZM0l4NEJGUlFHSXlJbU5UUTJOeU1uTndNbkxnRTNQZ0V6TWhZekh3RVdNaGMxSHdJaEF4TWpGVE1uTlRNSEl4Y2pGVE1uTlRNSEF5TVZNeWNqTlRNWEl4VXpKeU0xTXljMUl4Y3pKeFVqSnpNRE16VWpGemNqSnpNVkJ6UTJNeklXRng0QkZSUUdJeUltTlNFME5qYytBVE15RmhjZUFSVVVCaU1pSmpVRDlnY1VDLzFYRVFNU0RCMEJBUUZaQmc0SElEUUpDeVlsQVNoaElRSUJBUVFFQTE5Q1BWc0tRQXBiUFVCZEJ4WWJFUTV1QWdRSG92MzhGd0lXRGhJU0RoWURBenNwS2pzRUE4Z0RCRHNxS1RzREF3NEJKMjVNRFF3REJCRUxBZ1VDQmxRQkFRSVNCQllDeDJjWG9vSnRjaFZkWkhsYVJVa1ZiN2EyRll1TEZiYTJGWXVMeHNVZnBoV0FGWlZxZjU0ZmFsa1ZibjhWRGdjTkJRVUZGQThPRlFHRUJRVUZEUWNIREFVRkJSUU9EeFFDL2drS1JRd1RBd2thQWdJbkh5VkhEQXYrWkZ3RUNBVTJCdzBHUVZ0Tk9qcE5WVDhNTFJzVkpRMEJ4UXNXQ1A0Y01CUU5EUlFJRWdrcE96c3BDUklJQ0JJSktUczdLUWtTQ0NOckFkTVdCQmNOQ3cwQkFoZ0JBUUVHRWx2K1NnRjRneFZZV0RxREZWaFlBUmFERlZpU2d4VllPNE9EYlZoWS91dURneFZZV1BjUEZBVUZCUTBIRGhRVURnY05CUVVGQlFVRkRRY09GQlFPQUFBQUNBQVRBRFVENEFNMkFBMEFIUUFoQUVnQVZRQm9BSHNBamdBQUpSUUdNU0V3SmpVME5qRWhNQllESVNJR0ZSRVVGak1oTWpZMUVUWW1BeUVSSVFjbUJqRU9BU3NCSWlZbkxnRUhCaFl4SGdFM1BnRXhQZ0U3QVRJV0Z4NEJGeFkyTnpBMkp3Y1ZJeFVqTlNNMU16VXpGVE1YSWlZMU5EWXpNaFlWT0FFeEZBWWpPQUV4TlNJbU5UUTJNeklXRlRnQk1SUUdJemdCTVJjaUpqVTBOak15RmhVNEFURVVCaU00QVRFRDRCNzhieDRlQTVFZVdmemtFeDBkRXdNY0ZCc0JIQ2I5Q0FMNDRDZGJCQXNGRlFZTEJBVlZKeWNJQXhNUkVUWUVDUVo5QlFvRUF6TVJFUk1DQ0NiTEhCd2hJUndjZGdrTURBa0pEQXdKQ1F3TUNRa01EQWsxQ1F3TUNRa01EQWxXR1FnSUdSZ0lDQUxJSGhUOTBoTVpHUk1DTGhRZS9iWUNCSzlBSlFNRUJBTURJajlBY1JFVkFnRThBd1VGQXdRNEFRSVVFWEkvSWg0Y0hDRWNIRU1NQ1FrTURBa0pERG9OQ0FrTURBa0lEUjhNQ1FrTURBa0pEQUFFQUFBQUpnUUFBMW9BRXdBa0FEQUFOQUFBSlNFaUpqVVJORFl6SVRJV0hRRWpOU0VSSVJVQkVSUUdLd0VpSmpVUk5EWTdBVElXRlFNMEppTWlCaFVVRmpNeU5oTWhFU0VDYXYzTEZoOGZGZ05FRmg5SS9PSUNJZ0dXSHhiZ0ZpY25GdUFXSDQ4T0NRb09EZ29KRG1iL0FBRUFyQjRWQWtjVkh4OFZkR0Q5NFVjQmovNGtGU1FrRlFIY0ZSNGVGZjR4Q2c0T0Nna09EZ0hpL2x3QUFBQUFDUUFBLytFRCtnT2ZBRTBBVWdDRkFKSUFuZ0NxQUxZQXVnREhBQUFCTGdFaklnWUhMZ0VuTGdFaklpWW5OVFFtS3dFaUJoVVJGQlk3QVRJMk5SRWVBVE15RmhjZUFSY3VBU014SWdZSERnSVdGeDRCTXpvQk56STJOek1lQVJjNkFUTXlOamMrQVM0Qkp3RWpFVE1SSlE0Qkl5b0JJeTRCTVM0Qkt3RWlCZ2N3QmdjcUFTTWlKaWN3SmpjK0FUTXlGakVlQVRzQk1qWTNNRFl6TWhZWEZnWXhKVE1WSXhVak5TTTFNelV6RlFVVUJpTWlKalUwTmpNeUZpY1VCaU1pSmpVME5qTXlGaFVVQmlNaUpqVTBOak15RmdFekVTTURORFl6TWhZVkZBWWpJaVkxQThnYlRDMGlOdzRDRmg0VU5pRllhaFlqRnVrV0hCd1c2UllqSUd0Tkd5a1FGeE1DRGpnakxVd2JIUmdGQndJSE9pb0NCUU1LUGpxTk9qNEtBd1VDS2pvSUFRY0ZHQjM5Uk1URUFyRUVGaFVCQWdJWFNRUVBCNmNIRHdSSkZ3RURBUlVXQkFvMEZqSVhJUzRGRUFZZEJoQUZMeUFYTXhVMEN2N0dBeWN1SnljdUFTWVJDd3dSRVF3TEVVY1JDd3dSRVF3TEVSRUxEQkVSREFzUi9WMGVIaTBoRnhnaElSZ1hJUUZsTEM4VkNSOVZJaFlYWXlhQkZSc2JGZnltRmg0ZUZnS2lLVWdSRWhwS0hna2JNU3d3WDA0M0J5NDJBUnBEUXhvQk5pMEhOazllTC83RUF5NzgwaTRWR3dKUUJRY0hCVkFDR3hXWlZTUWFHd1FHQmdRYkdpUlZtY1F1SmlZdUp5Y1pEQkVSREF3UUVCNE1FUkVNREJBUVd3c1JFUXNNRVJFQmJQNElBbmtZSVNFWUZ5RWhGd0FBQUFBTEFEci93QVBHQThBQUR3QWZBQ3dBT0FCRkFGSUFid0NRQUpRQW1RQ3BBQUFCSmdZSEJpWW5KalkzUGdFWEZnWUhJVFlXRnhZMk56WW1KeTRCQndZV0Z4Y1VCaU1pSmpVME5qTXlGaFVuTkNZaklnWVZGQll6TWpZWEZBWWpJaVkxTkRZek1oWVZKelFtSXlJR0ZSUVdNekkyTlFjT0FTTTVBU0ltSnk0Qk5URTJGaGNlQVRNeU5qYytBUmN6RkFZSEFSRVVCZ2NWSVRVdUFUVVJORDRDT3dFMU5EWXpJVElXSFFFek1oNENGU1VoTlNFQklSVWhOUk0wSmlNaElnWVZFUlFXTXlFeU5qVUMwUkI0RFFNTEFnSUJCQkYvRkFFQkF2NWVFSGdOQXdzQ0FnRUVFSDhWQVFFQ2xSa1NFaGtaRWhJWkdBc0lDQXNMQ0FnTDVoa1NFaGtaRWhJWkdBc0lDQXNMQ0FnTEh3OHlHaG96RGdzRkFnWU1EREVhR2pFTUN3Y0JBUVVMQVd0WFFmMmtRVmNmTmtncUV5SVpBV0laSWhRcFNEWWYvWklCVVA2d0FaUCtLZ0hXbWs0Mi9mNDJUazQyQWdJMlRnSDJIUk1LQWdjREJBZ0NEQkVuQXdjQ0hSTUtBZ2NEQkFnQ0RCRW5Bd2NDU1JRY0hCUVRIQndURWdjTEN3Y0lDZ29LRkJ3Y0ZCTWNIQk1TQndzTEJ3Z0tDZ2k2Q2dzTENnZ1FBUUlCQmdZS0NnWUdBUUlCRUFnQlQvNk5SbXNRWUdBUWEwWUJjeWxKTmg5cUdTSWlHV29mTmtrcHBvTDh2ams1QWhzM1RVMDMvb3MyVGs0MkFBQUxBRlgvM2dPckE2SUFIQUFpQUNnQU9RQkdBRklBWHdCckFIc0Fpd0NpQUFBQkl6VTBKaU1oSWdZZEFTTWlCaFVSRkJZWEZTRTFQZ0UxRVRRbUl5RTFJUlVoTlFFVklUVWhGVGNVQmlNaElpWTFFVFEyTXlFeUZoVVJKU0lHRlJRV016STJOVFFtSXhVaUpqVTBOak15RmhVVUJqY2lCaFVVRmpNeU5qVTBKaU1WSWlZMU5EWXpNaFlWRkFZbkJpWVhKalkxTVRBMk56RWVBUWN4TnlZMk56RWVBVGtCRkJZSE5nWW5NUWMrQVJjeE1oWVhGaFFIQmlZbklnWUhEZ0UxUGdFM0F2QVNJUmIrc2hZaEVrMXVVajBDT0QxU2JrMytjZ0U4L3NRQmV2NUlBYmlQU0RQK0lETklTRE1CNEROSS9qVVJGeGNSRUJnWUVBZ0tDZ2dIQ2dxNUVCZ1lFQkVYRnhFSENnb0hDQW9Lb1U4OEFRRUJrUXdGQmg1K0hRWUZESkFCQVFFOFQzd0dMUmNRSWdjSEF3TVpJU0VkQmdZT0FnWUdBd2RqRnlFaEYyTnVUZjZqUTJRUFcxc1BaRU1CWFUxdVczc2cvU3dWTlNDOE0wbEpNd0ZkTWtsSk12Nmo3Qm9TRXhvYUV4SWFMQW9IQndvS0J3Y0tMQm9TRXhvYUV4SWFMQW9IQndvS0J3Y0tQaEFSQWdJR0FnZ2NBU1VIQVFjbUFSMExBZ1lCQVJBUzJRWU5BUWtPRFFRQ0FoTUJEd01DQVFJRkRnWUFBQUFRQURyL3dBUEdBOEFBSUFBbEFDc0FQQUJNQUZ3QWFRQjFBSUlBamdDdEFQWUJBZ0VTQVNJQkxnQUFBU00xTkNZaklTSUdIUUVqSWc0Q0ZSRVVGaGNWSVRVK0FUVVJOQzRDSXlFMUlSVWhBUlVoTlNFVk54UUdJeUVpSmpVUk5EWXpJVElXRlJFQk5oWVhIZ0VIRGdFbkxnRUhMZ0UzQlNZR0J3WW1KeVkyTno0QkZ4WUdCd1VpQmhVVUZqTXlOalUwSmlNVklpWTFORFl6TWhZVkZBWTNJZ1lWRkJZek1qWTFOQ1lqRlNJbU5UUTJNeklXRlJRR0J6RW1CZ2NPQVNNaUppY3VBUWN4QmhZWEhnRXpPUU15TmpjK0FTYzNJakFqTUNZSE1BWWpJaVl4SmdZeElnWWpKeFVYSGdFeE1oWVhIZ0VYSGdFWEhnRTNQZ0UzUGdFM1BnRXpNaFlYSGdFWEhnRVhGalkzUGdFM1BnRTNQZ0V6TURZL0FUVUhCU0ltTlRRMk14NEJGUlFHRnc0QkJ3NEJKeTRCTVRZeUZ4NEJCeGNHSmljdUFTY21OamMyTWhjd0JnYzNCaVkxTkRZM01oWVZGQVlDL3hNaUdmNmVHU0lUS2tnMkgxZEJBbHhCVng4MlNDcitXUUZRL3JBQmt2NHNBZFNaVFRmK0FqZE1URGNCL3paTi9hc1VmeEVEQVFJQkRBTU5keEVCQVFFQm94RjNEUU1MQWdJQkF4Ri9GQUVCQWY3SUVoa1pFaElaR1JJSUN3c0lDQXNMeGhJWkdSSVNHUmtTQ0FzTENBZ0xDd1VCQnd3TE1Sb2FNUXNNQndFQkJRc1BNeGthTWc4TEJRR21BUUdjWmdrREF3bG1uQUVDQVhGdkFRSUpCd0VDRFFVRkVoTVRLUkVSSmdvS0dBTUVCd1FFQndRREdBb0tKaEVSS1JNVEVnVUZEUUlCQndrQ0FXOXovZklHQndnRkJnY0l6UTRnQ2dvMklTRUVBMDRKQzJNSzhTRTJDZ29nRGdwakN3bE9CQVVoT2dZSUJ3WUZDQWNERzJvWklpSVphaDgyU0NyK2pVWnJFR0JnRUd0R0FYTXFTRFlmWVlMOUlSYzVJc1kyVFUwMkFYTTNURXczL28wQk15Z1JEUUlJQXdRR0Fna1VIUUlHQXdzZEZBa0NCZ1FEQ0FJTkVTZ0RCZ0l0R3hRVUd4c1VGQnN2Q3djSEN3c0hCd3N2R3hRVUd4c1VGQnN2Q3djSEN3c0hCd3VPQWdJR0JRb0tCUVlDQWdFUUNBb0xDd29JRUFIakNDQURBeUFJQVIwckdRSUJFUWdITkEwTkVnVUZBd0VDRlJBUE1RZ0lBd01JQ0RFUEVCVUNBUU1GQlJJTkRUUUhDQkVCQVJvckhCb0RBZ0VDQVFNQkFnSXVOaUFFQkFNS0MyZ2VBUUVUSlZjS0F3UUVJRFlsRXdFQkhtZ0xoZ0VDQWdFREFRSUJBZ01BQUFBSkFEci93QVBHQThBQUlBQWxBQ3NBUEFDUEFMRUF2Z0RnQU8wQUFBRWpOVFFtSXlFaUJoMEJJeUlPQWhVUkZCWVhGU0UxUGdFMUVUUXVBaU1oTlNFVklRRVZJVFVoRlRjVUJpTWhJaVkxRVRRMk15RXlGaFVSSlFZbUJ3NEJKeTRCTnpRMk1UNEJOejRCRnhZR0R3RW5NQ1luSmdZSEJoWVhGalkzTmhZWEhnRXpNalkzUGdFWEhnRTNQZ0VuTGdFSERnRXhCeWN1QVRjMkZoY2VBUmN3RkJVV0JnY0dKaWNtQmljVEpnWUhEZ0VuSWdZWEhnRXpGalkzRGdFVkZCWXpNalkxTkNZblBnRVhQZ0VuQnhRR0l5SW1OVFEyTXpJV0ZTY0dKaWN1QVFjR0ZoYzJGaGNPQVJVVUZqTXlOalUwSmljZUFUY3lOamMySmlNSElpWTFORFl6TWhZVkZBWWpBd0FVSWhuK25oa2lFeXBJTmg5WFFRSmNRVmNmTmtncC9sZ0JVUDZ3QVpMK0xBSFVtVTAyL2dFM1RFdzNBZjgyVGY1K04xRWJGeVFlSHhBRUFRTVVFaFVhQlFVQ0FnSUNEQWdER2dRRUNRd2FRQjBPSGdzR0lCc2FJUVlMSFE0ZFFSa05DQVFGR1FRSUN3SUNBZ0lFQlJvVkVoVUVCUThmSFNVWEcxQTN4UXM2SEJVWkV3TURBUUlLQmdJTUNBVUZHUklSR2hRUEdqTUlBZ01FVEFzSENBc0xDQWNMblJJWkZSMDVDd1FEQWdnekdnOFVHaEVTR1FVRkNBd0NCZ29DQVFNRVF3Z0xDd2dJQ3dzSUF4dHFHU0lpR1dvZk5rZ3EvbzFHYXhCZ1lCQnJSZ0Z6S2tnMkgyR0MvU0VYT0NIR05rMU5OZ0Z6TjB4TU4vNk5EQmtiQmdRSkRBdy9Id0VDRVIwTUR3Y0hCeGNJRGdNVkF3RVNFQXNZREJnMUJnTUdBUUVYR0FFQ0JnTUZOQmdNR0F3UEVnRURGUVFPQ1JjR0NBY09EQjBSQWdFZlBnNE1DQVFGSEJnQkZ4WVZFUTBHQVFzRUJRWUJBUUVHRHdrVUd4c1VFUm9ERUIwaEF4TUpSd2dLQ2dnSEN3c0hKUUVHRFJFVkZna1RBeUVkRUFNYUVSUWJHeFFKRHdZQkFRRUdCUVFMTndvSUJ3c0xCd2dLQUFBQURBQTYvOEFEeGdQQUFDQUFKUUFyQUR3QVNBQlVBR0FBYkFCOEFJd0E2d0VyQUFBQkl6VTBKaU1oSWdZZEFTTWlEZ0lWRVJRV0Z4VWhOVDRCTlJFMExnSWpJVFVoRlNFQkZTRTFJUlUzRkFZaklTSW1OUkUwTmpNaE1oWVZFU1VpQmhVVUZqTXlOalUwSmdjaUpqVTBOak15RmhVVUJqY2lCaFVVRmpNeU5qVTBKZ2NpSmpVME5qTXlGaFVVQmlVK0FSY2VBUWNPQVNjbUJnY3VBVGNsTGdFSEJpWW5KalkzTmhZWEZnWUhGeTRCSXk0Qkp5WUdGeDRCRnc0QkJ3NEJJeW9CSXk0Qkp6QWlNU2MrQVRjMkpnY09BUWNxQVFjT0FSVWNBUlVlQVJjV05qY3lKalV5RmpNZUFSY2VBUmNlQVRNeU5qYytBVGMrQVRjK0FUY1VCaGNVRmpjK0FUYzhBVFUwSmljSERnRWpJaVluTGdFbk5EWTNGalkzS2dFakxnRW5MZ0UxSGdFWEZqSXpNalkzTWpZekhBRUhGQVlIRkFZSERnRUhEZ0VIS2dFakhnRTNIZ0VYRGdFSEF3QVVJaG4rbmhraUV5cElOaDlYUVFKY1FWY2ZOa2dwL2xnQlVQNndBWkwrTEFIVW1VMDIvZ0UzVEV3M0FmODJUZjRZRVJrWkVSSVlHQklIQ3dzSENBc0x3aElZR0JJUkdSa1JDQXNMQ0FnS0N2N1lDM1FSQkFJQkFRa0REVzRLQWdJQkFYUU1iZzBEQ1FJQkF3TVJkQTBCQWdFWkFnTUNCeE1IQWdnRkFnY0RDUlFMR0RZZEF3WUNNVmtpQVFZREJRRUdDQU1IRXdZQ0JBSUNBZ0VLQ1FJQ0FRRUNBUVlEQVFJQkFnb1NGRlFuTGtjUkR3d0VBZ0lDQWdVQ0FnRURBUW9LQVFJRFRBOURLUzFJRFFJRUFRUUNGU2NRQWdZREdURUdCZ0ViU2ljS0ZRb2FOUmtFQ1FRQkFRRUJBUUVDQWdRcUZ3SUNBUXdpRVFJQ0FRSUZBd01iYWhraUlobHFIelpJS3Y2TlJtc1FZR0FRYTBZQmN5cElOaDloZ3YwaEZ6Z2h4alpOVFRZQmN6ZE1URGYramZvYkZCTWJHeE1VR3k4TEJ3Y0xDd2NIQ3k4YkZCTWJHeE1VR3k4TEJ3Y0xDd2NIQ3pzc0dRa0JDQU1FQ1FJSEZTSUJCZ1FVSWc4R0FnZ0VCQWNDQ0JNc0F3WUNzZ0VCQVFNRkFna0dBd1FCQXdRQ0JBTUJEQWNDQVFNQkJnb0NCQUlCQVFFREFnRUNBUU1WQlFFQkFRWUVBZ2NPQnhndkVCQU9EZzBMTFJzSER3Y0JBUUVFQmdFQkFRRUVGUU1CQWdFQkJBRjlDdzBPREFFRUFnZ0pBZ0VCQXdJSkN3c2FCZ1lKQVFFRUJRSUJCQUlEQndNREJRSUVCd01IQ0FFQ0FnRUNCd1FGQndJQUFBQUFEUUE2LzhBRHhnUEFBQ0FBSlFBckFEd0FTUUJWQUhvQWh3Q2RBS1FBeHdFRUFUc0FBQUVqTlRRbUl5RWlCaDBCSXlJT0FoVVJGQllYRlNFMVBnRTFFVFF1QWlNaE5TRVZJUUVWSVRVaEZUY1VCaU1oSWlZMUVUUTJNeUV5RmhVUkpTSUdGUlFXTXpJMk5UUW1JeFVpSmpVME5qTXlGaFVVQmlVbUJnY09BUWNPQVJjZUFUY3lOamNPQVJVVUZqTXlOalUwSmljK0FUYytBUmMrQVNjSEZBWWpJaVkxTkRZek1oWVZKeFFHSnk0Qkp5NEJCeVkwTnpZV0Z4NEJGeDRCQndNK0FURXdGamNsRGdFSElpWW5KaFlYRkFZVktnRXhGUlFHRng0QkZ4NEJQZ0UzTmlZbk1UNEJCd2M2QVRNZUFSVXdOamMrQVRjZUFURXdOamMrQVRjV0ZERXdOamMrQVRjeUZoY2NBUlVPQVNNaUppYzhBVFUrQVRjZUFSY2VBVEV3SmpjNkFUTUhKalF4TUFZSElpWTFKalEzSGdFek1qWTNGQllWRmdZSERnRUhMZ0V4TUJRSERnRWpMZ0V4TUJRSEJpSWpMZ0V4RkFZSEtnRWpBd0FVSWhuK25oa2lFeXBJTmg5WFFRSmNRVmNmTmtncC9sZ0JVUDZ3QVpMK0xBSFVtVTAyL2dFM1RFdzNBZjgyVGY0V0VSa1pFUklaR1JJSEN3c0hDQXNMQVM4TE94MFdHUk1FQXdFQ0N3VUNDQVVGQlJrUkVoa1ZEd0VEQVJ3NENRSURCRmNMQ0FjTURBY0lDNklMQmdZa0Zob3ZEUUVGRFRBYUZob1RCQVlCZlFVSEJRc0JQRGFBTXg0cEdSSUZDUU1DQ0FNQ0FRc0NDbUp3WGdVTUFnSVFDeFhwQlEwR0FnVUZCQXdZREFRQkJRUU5HUTBHQndVSUR3Z0VCUUUwZVRNVkpRNEJBd01KRXdzRUJnRUVCZ3dIS0FFRUF4UWFCQUVQS3hzeGREUUJBUVFEQmhnUUF3VUVEQndPQXdVRkRCa01CQU1FQWc0YkRBTWJhaGtpSWhscUh6WklLdjZOUm1zUVlHQVFhMFlCY3lwSU5oOWhndjBoRnpnaHhqWk5UVFlCY3pkTVREZitqZnNjRXhRYkd4UVRIQzhLQ0FjTEN3Y0lDbnNSS1JnUkF3VUJEQU1FQXdJQkFRY1BDUlFiR3hRUkdnTUJBZ0VWTlIwREVnZHBDQW9LQ0FjTEN3Y3NCUVVCQVFrUUVpTVpBdzhHRGhZU0R3a0RBUXNFL3RBQ0hod0JqUmdUQVFRRUJBd0dDaDBEQXdFa0RBWUVBUUlDQkFvS0ZFb1JDeFlKUHdNS0NCQUdBUUlDQmhBUkJ3SUVBd1VTRlFZQ0JRSUlCQWNRQnc0SkFRRUZDd1lEQ1FNQkFnRUdEdzhHVUFZTENnWURBUVlTQmdFQ0NBd0RDUVVGQ1FJRUJRSUhEaEVGQWdJSERoRUZBUVlNQmdrRUFBQUFBQXdBT3YvQUE4WUR3QUFnQUNVQUt3QThBRWtBVlFCaUFHNEFoQUNhQUwwQTZnQUFBU00xTkNZaklTSUdIUUVqSWc0Q0ZSRVVGaGNWSVRVK0FUVVJOQzRDSXlFMUlSVWhBUlVoTlNFVk54UUdJeUVpSmpVUk5EWXpJVElXRlJFbElnWVZGQll6TWpZMU5DWWpGU0ltTlRRMk16SVdGUlFHTnlJR0ZSUVdNekkyTlRRbUl4VWlKalUwTmpNeUZoVVVCaWNPQVNNaUppY3VBUWN1QVRjMkZoY2VBUmN5RmdjM1BnRTNQZ0VYRmdZSEpnWUhEZ0VqSWlZbkpqWXpId0VPQVNNaUppYzNKZ1l4Tnh3Qk1SUVdGeDRCRlQ0Qk56NEJOVEEwTlJjd0pnY1hGQVlIRkRZSERnRUhEZ0V4TUNZbkxnRW5OQlkxTGdFMUxnRTFIZ0V6TVRvQk16b0JNekV5TmpjVUJnY0RBQlFpR2Y2ZUdTSVRLa2cySDFkQkFseEJWeDgyU0NuK1dBRlEvckFCa3Y0c0FkU1pUVGIrQVRkTVREY0IvelpOL2hjU0dSa1NFUmtaRVFnTEN3Z0hDd3ZGRVJrWkVSSVpHUklIQ3dzSENBc0xrUUlLQlFVZ0ZCdzFDUUlCQVFzNkhCVWtDUU1DQWtrSkpCVWNPZ3NCQVFJSk5Sc1VJUVVGQ2dJQ0FnTlBCd3hHS2lwR0RBY1pCUVlLR2hoUkFWQVlHZ29HQlJrREh3RWJBUU1IQmhKUVVCSUdCd01hQVI4QkFSQkFKZ0VDQVFFQ0FTWkFFQUVCQXh0cUdTSWlHV29mTmtncS9vMUdheEJnWUJCclJnRnpLa2cySDJHQy9TRVhPQ0hHTmsxTk5nRnpOMHhNTi82Titoc1VGQnNiRkJRYkx3c0hCd3NMQndjTEx4c1VGQnNiRkJRYkx3c0hCd3NMQndjTFNBTUdCQVlJRUEwQ0J3TVZCZ29JQndFSkJBMEJCd2dLQmhVREJ3SU5FQWdHQkFZREJBbkRCZ01KQ1FNR0F4NEZBUUVQTlF3SkFnRUJBZ2tNTlE4QkFRVWVBekVHQndJRkF3SUlCd01IQXdNSEF3Y0lBZ01GQWdjR0Jnd0VBZ2tKQWdRTUJnQUFBQUFNQURyL3dBUEdBOEFBSUFBbEFDc0FQQUJJQUZRQVlBQnNBSHdBakFES0FPWUFBQUVqTlRRbUl5RWlCaDBCSXlJT0FoVVJGQllYRlNFMVBnRTFFVFF1QWlNaE5TRVZJUUVWSVRVaEZUY1VCaU1oSWlZMUVUUTJNeUV5RmhVUkpTSUdGUlFXTXpJMk5UUW1CeUltTlRRMk16SVdGUlFHTnlJR0ZSUVdNekkyTlRRbUJ5SW1OVFEyTXpJV0ZSUUdKVDRCRng0QkJ3NEJKeVlHQnk0Qk55VXVBUWNHSmljbU5qYzJGaGNXQmdjWExnRW5QZ0UzTWhRVkhnRTNQZ0UxTGdFSElnWVhIZ0VYRGdFSERnRUhCaVluSWdZSEJoWVhIZ0UzTXo0Qk54NEJGeDRCTXpJMk56NEJOelkwSndjT0FRY0dKaWN1QVNjK0FUY2VBUmMwSmljK0FUY2VBUmNXRkFjREFCUWlHZjZlR1NJVEtrZzJIMWRCQWx4QlZ4ODJTQ24rV0FGUS9yQUJrdjRzQWRTWlRUYitBVGRNVERjQi96Wk4vaFlSR1JrUkVoa1pFZ2NMQ3djSUN3dkdFaGtaRWhFYUdoRUlDd3NJQ0FzTS90TVNidzhEQWdJQ0NnTU1hUTRCQVFFQmNncHJEQU1KQVFFREF4QnhDd0VDQWswSUl4a0dDd1FCQVFZRUJBVURHQkVDQVFJRUJ3TUtMaE1aTnhNU0d3c0hEQUVDQ2dZR0lnNEJFaU1SREJFSUN4b1ZCUXNGRVJ3SEJ3Y1NCaFVORkJZT0J3OEtCUklMREIwUEhRd0RDd2NXSGdjRUJRTWJhaGtpSWhscUh6WklLdjZOUm1zUVlHQVFhMFlCY3lwSU5oOWhndjBoRnpnaHhqWk5UVFlCY3pkTVREZitqZnNjRXhRY0hCUVRIQzhLQ0FjTEN3Y0lDaThjRXhRY0hCUVRIQzhLQ0FjTEN3Y0lDa0FzRXdnQkNBTUVDUUVHRHlFQkJnUVJKQTRJQWdrRUJBZ0NDaEl2QkFZQzNSSVZDQWdPQndJQkJBVUJBUVlFRVFvQkJBRUJCQU1PS3c0UkdRSUNBZ0VCQXdZRUFnSUlBZ0lLQ0FnWERCQWNBUU1HR3hJUUlBMDFEeFVGQnhNVkNoVUlCZ3NCQWc0UEZSUURCUTRCQnhFT0NSY01BQUFBQUJJQUFQL0FCQUFEd0FCRUFGRUFYd0JqQUdjQWVBQ0RBSkFBblFDcEFMWUF3d0RRQU53QTZRRDFBUXNCRHdBQUFTTWlCaDBCRGdFSERnRWRBUlFXRng0QkZ4VVVGanNCRkFZeElUQTBOVE15TmowQlBnRTNQZ0UzUGdFOUFUUW1KeTRCSnk0Qkp6VTBKaXNCTlRRbUl5RWlCaDBCQXlNaUpqVThBVFUwTmpzQkZRRXlGaFVjQVJVaFBBRTFORFl6QXhVak5RRWhOU0VURVJRR0l5RWlKalVSTkRZeklUSVdGUk1VQmlzQk5UTXlGaDBCTnhRR0t3RTFNeklXRlJ3QkZTVTBKaU1pQmhVVUZqTXlOalVISWlZMU5EWXpNaFlWRkFZbElnWVZGQll6TWpZMU5DWWpGU0ltTlRRMk16SVdGUlFHSXpVaUJoVVVGak15TmpVMEppTVZJaVkxTkRZek1oWVZGQVlsSWdZVkZCWXpNalkxTkNZakZTSW1OVFEyTXpJV0ZSUUdCU01pQmdjT0FSOEJIZ0U3QVRJMlB3RTJOQ2N1QVFjakp6TUJGMlFzT0E4VUJSSVZHQllGRVFzNExBd0JBb1FNTERnRkNBUUdCZ01aRlJJV0Fna0lCUWtGT2lwa0tUMys4eWM1dXcwSEF3TUhEUUlzREF6K3dBd0k2eUlDbFA0TEFmVnhDd3Y5VlFzTURBc0Nxd3NMTGdNSkZoY0lBeUlFQnd3TUJ3VCtHMFl4TVVaR01URkdkeXM5UFNzclBUMEJGakZHUmpFeFJrWXhLejA5S3lzOVBTc2lNVEVpSWpFeElna05EUWtKRFEzK3RpSXhNU0lpTURBaUNRNE9DUWtORFFFSzV3TUZBZ0lCQVJZQkJnUzlCQVlCRlFFQ0FnVWhxd3pEQXprNUxIQUlHQkFNSnhtSUhDb0tDeEFHWkMwNUdVeEVJVGt0WXdJSEF3WUxCUXd0RjRjWEtnMElFUWdGQndOdktqc3RHVUUwSmkzK0dnTUhJa2doQ0FTaEFpZ0pDQVkvSFJ4Q0JBVU0vcWZ5OHYzalJRSHYva3NOQ2dvTkFrb05DZzRKL200SkEvSURDZG9pQ0FPaEF3a2hSeUtXTWtWRk1qRkdSakZvUFNzclBUMHJLejNmUlRJeFJVVXhNa1hlUENzclBUMHJLenk2TUNNaU1EQWlJekJIREFrSkRRMEpDUXhITUNNaU1EQWlJekJIREFrSkRRMEpDUXp3QWdNQ0JnTTRCQVFFQkRrREJRSURBamtpQUE0QUNBQUxBL2dEZFFCSEFGY0FZd0I1QUlrQWxRQ3JBT2tCQ3dFYkFTVUJUd0ZmQVlFQUFBRVdCZ2NPQVNNR0ppY3VBU2NPQVFjT0FTY2lKaWN1QVRjK0FSY3lGaGNlQVRNK0FUY25MZ0UxTkRZM1BnRXpNREl4T2dFek1oWVZGQVlQQVI0QkZ6STJOejRCTXpZV0Z6Y0dKaWN1QVNjME5qYzJGaGNlQVFjbk1qWTFOQ1lqSWdZVkZCWTNOQ1lqSWdZSFBnRXpNaFlWRkFZSE1oWXpNalluQlE0Qkp5WTJOejRCRng0QkZRNEJCeWMwSmlNaUJoVVVGak15TmpjdUFTTWlCaFVHRmpNeU5qTXVBVFUwTmpNeUZoY0ZMZ0VuTGdFM1BnRXpNaFlYSGdFWFBnRTNQZ0V6TWhZWFBnRTNQZ0V6TWhZWEZnWUhEZ0VQQVE0REJ3NEJCeFVoTlM0Qkp5NEJKeTRCTHdFM0hnRVhQZ0UzSWlZbkxnRTNQZ0VYSGdFWFBnRTNMZ0VuTGdFaklnWUhCaFlYTno0Qk55NEJKeUlHQndZV0Z4NEJOd0V3TkRVbkJ4d0JNU0VUTGdNbkxnRWpNU0lHQnc0QkJ6Z0JNUTREQng0REZ4NEJGemNYUGdFM1BnTTNOejRCSnk0Qkl5SUdCeDRCRnpJMk56Y3VBU01pQmdjT0FRY2VBUmMrQVRNMkZoY1dCZ2NPQVNNZUFSYytBVGMrQVNjQ1p3TUVCZ1FTQ2dNSEF3a2RDZ3NkQ1FNR0JBb1JCUVVFQWdFRUF3SUdBd1FMQnhBZ0F3RWxLQkFOQ3g4UUFRRUJBU0k1TFNrQkF5RVBCd3dEQXdZREFnUUJpaWM4SEIwUEFSRXdKa0VQRGcwbVpRa0xDd2tJQ3d0REhSVU5GUWNHRVFrVEdoZ1NBZ1FCRlIwQi9zNGNQQ2NuRGcwUVFTWXdFUUVQSFFjTUNBZ0xDd2dJREF3R0ZnMFVIUUVkRlFFRUFSRVlHaElLRUFiKzV3MHlGaFlmRVE5U09Bb1VDd29VQ0JBb0dTZGdPRnFNS2dnVUNnc1VDamhTRHhFZkZoWXlEUWdHR0IwaERnMGlELzVSQnc0SUNTMGNEaFVGQ0NBREJRSURCZ1FLRkFnTkJ3Y0dHQThIRHdjRkRRY0xHaEFHRFFjYU1Bd1daZzRjQWdZREJBMEdDUXdFQkFNSEJ4RUhBZGVRcEFFMHBBRUtGQjRXSUhaUE1WUWhHaWNNRVJrUkNRSUZGaHNkREJRakJhYVlEU1lMQ0JrYkdBWW9DQVFFQXd3SkJnNEZBd1lDQnhFR1hRd3dHZ2NOQmhFYkN3Z05CZ2NRQ0E4WEJnWUhEZ2dVQ2dRR0FnSUdCQTVtRmdGSEJRc0dCZ2dCQVFFREVBME5FQU1CQVFFSUJnWUxCUU1EQVFVR0NBWUJGZ1lvQno0TkNBMEVCUVVVRHc1QkF5Z0dGZ0VHQ0FZRkFRTURpQThtRVJBWUVnczdEZ3dpRlJabUQxRUxCd2dMQ3dnSEN3VVdIdzBNQndrZEZCUWNBUUVnRnk0UkpnOFBaaFlWSWd3T093c1NHQkE3Q0FzTENBY0xDeFlNRFI4V0Z5QUJBUndVRkIwSkI0QUdIUm9aVkQwOFF3SURBZ01DRVJzTEVSSXVMQUlEQWdNQ1F6dzlWQmthSFFZRUtscFFQZzhORndabmNnTU5CZ1l4VGlkVktRUStBZ01CRUNZVkJ3WUtIQThQRUFFQkJRUVJJQTRCQlFRQkFpQXJVa0lJV2dzV0N3UUZBUWdKQ1E0RkJRVUIvZklzRlFNRUZTc0JnQXhKV1ZnYkl5WVBEd3NlRXh0TVMwSVJMVmxMTkFnTkR3SUpDQVFPQ3dneVIxVXNrQVVRQ1FrSkJ3VUxGd3NFQlVBcklBSUJCQVVCRHlNU0JRWUJFUThRSFFvR0J4TWtEd0lFQWdoQ1VnQUFBQllBQXYvWEEvd0RxUUE4QUY4QXB3QzRBTmtBNmdEOUFRUUJEd0VmQVM4Qk93RklBVmdCWndGMEFZQUJqUUdaQWVNQ0JRSVlBQUFCTGdFbk5UWW1Md0V1QVNNcUFTTXVBU2MxTGdFak1Tb0JEd0VPQVFjT0FSY1VGaFVPQVI4QkhnRWZBamNlQVJjUEFRVS9BVDRCUHdFMkppY0RCaUlqSWlZbkpTNEJKeTRCUHdFK0FUTXlGaGNGSGdFWEhnRVBBVEFHRlE0QkJ5VUdKaThCUEFFMVBnRTNQZ0UzSlRZV0h3RXFBU01pQmc4QkxnRWpJZ1lIRGdFSERnRVBBUVlpSnlJbUl3NEJCd1lXRng0Qk16STJOejRCTno0QlB3RTJGaGNlQVRNUEFUY3dKZ2NPQVRFK0FUYzJGaGN4TWhZeEp3NEJNUzRCTlQ0Qk93RXlGak1XTWo4QlBnRTNQZ0UzTmhZWEhBRUhNQVlISlRJV014Y2VBUThCSnpVK0FUYytBVE1sUGdFL0FUSTJNeklXSHdFRkxnRW5KalkzRXljeE53Y3hCeGMzSGdFWEJUZ0JNUWNsQVNJbU5UNEJOell5Rng0QkJ3NEJCemNtTmpjK0FSY2VBVGNXQmdjR0ppY1hGaVluSmdZSElqWTNOaFlISmpZWEhnRUhCaVlIRGdFMUJSWUdJeTRCQnlJbU5UUTJOellXRnljdUFUYzJNaGNlQVFjT0FTY3VBUmNHRmhjV05qYzJKaWNtQmdjM0RnRW5MZ0UzUGdFWEhnRVhGalkzTmlZbkpnWUhCaFlYTng0QkJ3NEJKeTRCTno0QkZ5SUdGeDRCRnc0QkJ3WW1KemdCTVRnQk1TNEJKeTRCSno0Qk56STBKeVlHQndZV0Z4WTJOekEyTng0QkZ4UUdCdzRCRng0Qkh3RVdOamMrQVRjVUZoVVVGak15TmpVMkppY0hMZ0VuT0FFVkxnRW5NQ1l4TGdFNUFqUTJGekEySnpBV0Z6RVVGakV3QmljM0JpWW5MZ0VuSmpZM0hnRVhNQlkzRGdFSEErSUxIeElKTGluR0JRb0ZBUUlCRWtndUJqa2xCQWdEeUJRaURBd0tBd0V6TndraEJ6d3FBUXZCQ0JVT0F3d0IxUTBES3o0S0t3Z09GS1FEQmdNRkNBWCt6eEFjQ1FvR0F5OEdMeDRFQ1FVQk1SQWNDUW9HQkM0QkNTWVgvWkFqT1FZakFSVVNCeEFJQVRRak9RVVFBUU1DS1VBSUF3VU9DZ01IQkFZTUJna1RDUVlJRlFvR0RRWVpEd1FGQVFZRENRZ0RCUU1MRUFjS0ZCRVJDeGNNQmd3R0N0TE1LeG9WSkF3ZERoMGlCUUVDUkNndUFnSURDQWNEQlFvRkN4Y0lCd29WQ2dZTEJRZ0xCUUV1S0FFb0FRTUN4UXdOQXd6K0FnWUVBeEFLL2pFRUNRYkhBUU1CQ2hFQkIvNy9BUU1DQVFNREtnZkhDcmIwQndVS0JnRXhCdjY1L3VjQ0FpTXVCQUVKQWdJREFRVTdJWndDQVFJQ0NRRUdPQ01CQVFJZ1JBaGVCQkFPR1FzSUNRNEtDaWpQQVNNTUN4VUpDQkFXREFzQ1pnRURBUU5JQ2dJRkFnTU1UQUw3QVFFQkRsRUxBZ0VCQWdjQ0NFMEZBdzBNREJRREFnd01EQlFES3dFSUJnVUdBUUVKQlFZRmNnc1ZBZ01OQ3d3VkFnTU5EQXNGQmdFQkNRVUZCZ0VCQ1JrQ0FRSUNBd0lDQmdNZU14Y1hKUTRNQ1FVREJnTUJBUXNTQXdFQ0F3SUZBUUVCQVFNREFRRUNBUVlHSXg4QlNUa0VBd1lDQVFNREF3UUJEd3VGQ3hBRkF3WUNBUVVGTGhFQkJDc09BU01kWVFjNER4QStCQU1EQVE0dUd6NGNBUXNHQWdzU0hRb0NLVVlKS1FFQktqY0lBU1l3QVI4REZSRVFKeE1CQVFFYVp6elFNRW9TQlVnZUVSNE5FVVZpU2c0UVJpL09KRVlmL21ZQkFRRkFBeE1PRHlFUTNoMG1BUUZBQXhNT0R5RVEzZ0lCRnlFSDJnWXFJdUFDQXdJWEtRNEZCZ0V3QmlvalpUUW9Dd1lJQVFFQkJRSUVCd0VCQVFFQkFSME9FUm9IQkFZQkFRSUlBd1VJQXdNQkFRRUJBakVoWkFRRkJBd1RDZ01GQ3dnQkhnWUZBUWNEQkFNQkFRRUJBZ2NFQWdVQkFnSUdBZ01CQ2diVUFTa0RGQXc1TmdFS0d4TUtEWlVFQmdFZkFRNExLU2tKRkEwR0N3WDl5aXdmTGgyT0tBSUVBVUFtUlFIMEJBSUdKZ2tDQVFFRkFnd25BVDBDQlFJQ0F3SUlGZ1VCQlFFSkV3cGtEUTBFQmhJQkdnUUZDakVSRmdJQkZRSUNEZzRIRWc2VkF3UVlHZ01IQWdNRUFRTWRIeXdCQkFJZENBSUZBd0lFQVFjQlZBMFdBZ01QRFEwV0FnTVBEUU1GQlFFQkNRVUVCZ0VCQ1VvQ0R3ME1GZ01DRHcwTUZnTTNBUWdGQlFZQkFnZ0ZCUVZRQWdFQkJBRUJBUUVIQWdVRkRnWUdCUVFCQWdFQ0FRTURDd01FQVFFQ0F3SUJBd1VEQVFRQ0NpSVRFaUFHQVE1YkRnRUVBZ0VEQVFNRUF3TUxDZ0pvQXdZRUFRSUVBZ0VGQndNSEVnUURCeElCQVF3SEt3Y0lBd01TREFnUkJBY1FCZ2NEQ1JNRkFBQUFBQUlBQUFBSkJBQURkd0JGQUlVQUFBRTBKaWN1QVNjdUFTY3VBU2N1QVNNaUJnY09BUWNPQVFjT0FRY09BU01pSmljdUFTY3VBU2N1QVNjdUFTTWlCZ2NPQVFjT0FRY09BUWNPQVJVVUZoY0pBVDRCTlRFekZBWUhBUTRCSXlJbUp3RXVBU2N1QVNjdUFTY3VBU2N1QVRVME5qYytBVE15RmhjZUFSY2VBUmNlQVJjK0FUYytBVGMrQVRjK0FUTXlGaGNlQVJVMUE3Y0dCZ2NQQ2drWURRNGJEUTBjRHc4Z0VSRWdEZzhZQ3dvUkJ3VU9DUWtPQlFjUkNnc1lEdzRnRVJFZ0R3OGNEUTBiRGcwWUNRb1BCd1lHTlRZQlRBRkxOalpKUVVMK25BVU5Cd2NOQmY2YkF3Z0ZCUThMQ3hNSkNROEhCZ2NrSlNSa1FCSWtFaE1pRUJBYkRBc1dDZ29XQ3d3YkVCQWlFeElrRWtCa0pDVWtBbXdYS0JJU0hBb0xFUWNHQ1FJQ0F3Z0hCeElMQ3hVSkNoSUlCZ1lHQmdnU0Nna1ZDd3NTQndjSUF3SUNDUVlIRVFzS0hCSVJLUmN3WmpYK3dBRS9ObVl3UUlCQy9xb0dCUVVHQVZjREJ3VUdFZzROSEE0UEloVVVKeE0vWXlNakpBWUdCeEFMQ2hRSkNSTUxDeE1KQ1JRS0N4QUhCZ1lrSXlOalB3RUFBZ0FFLzhBRC9BUEFBRGNBZGdBQUFTNEJMd0l1QVNjckFRY09BUThDRGdFSEJoWWZBUU1HRmhjZUFUc0JOejRCUHdFWEhnRTdBVGM3QVQ0Qk56NEJKd00zUGdFbkFSNEJGeE1GTWhZWEZnWVBBUk1VQmdjT0FTTWlNREVpSmlNbEJRWWlCekFpTVRBbU1TSW1KeTRCTlJNbkxnRTNQZ0V6SlJNK0FUY3dNakV6TUJZWEEvd0hKQmYrY2dvbEZRSUtCQlVqQ1hIK0dDTUhCd3NRdWl3RUVSSUtHZzRFQmdnT0IrTGpDQlVMQWdRQ0Fnc1VDQklSQkN5NkR3c0gvZ3NDQWdHQ0FTSUVCZ0VCQWdMU01nTURBUVFCQVFJRUFmNzgvdjBCQXdFQkFRSUVBUVFDTWRJQ0FnRUJCZ1FCSW9FQ0JnTUJBUVVDQWo4V0h3UW04eFFaQWdFQ0dSVHlKd1FmRmhjc0ViMys4eGNxRGdnSkFRRUVCSDE4QlFZQkFnZ0hEU3NXQVE2K0VDMFdBVHNCQXdMKzdDd0dCQVFJQXRmKzBRVUhBZ0lCQVkrUEFRRUJBUUVDQ0FRQkw5Y0RDQVFEQmkwQkZBTUVBUUVCQUFBQUJBQUEvOEFFQUFQQUFCQUFGQUFvQUZBQUFBRWhJZ1lWRVJRV015RXlOalVSTkNZakF5RVJJU2NWSXpVaEVUTVZJeUltTlJFME5qTWhNaFlWQXpvQk16d0JOVFEyTXpJaU16SVdGUndCRlRvQk16SVdCdzRCQnc0Qkp3WW1KeTRCSnlZMk13UEMvWTBaSlNVWkFuTVpKU1VaRVAydEFsUGxTLzNKZ3BFWkl5TVpBbFVaSTk0UVNoQUxCeVFOSkFjTEVFb1FEQWdJSmswbUF3WURCQVlESmswbUNBZ01BeG9uRy8wckhDY25IQUxWR3lmOCtRSzF1Q0lUL1d0UEpSb0N0QnNsSlJ2OTdVWS9SZ2NMQ3dkR1AwWVZDUzVjTHdNREFRRURBeTljTGdrVkFBQUFCQUFBLzhBRUFBUEFBQkFBRlFBcEFEWUFBQmNoTWpZMUVUUW1JeUVpQmhVUkZCWXpOeEVoRVNFREVUUTJNeUV5RmgwQkl6VWhFVE1WSXlJbU5RVUdKalVSTkRZZkFSWVVEd0hwQXRRY0p5Y2MvU3djSnljY0R3SzIvVXI0SlJzQ3N4c2xULzFyRXlJYkpRSHpCQWNIQk1jRUJNZEFKUmtDY3hrbEpSbjlqUmtsVGdKVC9hMEJJUUpWR1NNakdaR0MvY2xMSXhtUEF3TUZBU1VGQXdPU0F3a0RqZ0FFQUFEL3dBUUFBOEFBRXdBa0FEQUFQQUFBRXhFME5qTWhNaFlkQVNNMUlSRXpGU01pSmpVQkVSUUdJeUVpSmpVUk5EWXpJVElXRlFjaEVUNEJIZ0VYSGdFM0VRTXlOalUwSmlNaUJoVVVGZ0FsR3dLekd5VlAvV3NUSWhzbEJBQW5IUDBzSENjbkhBTFVIQ2RTL1VvY1ZXQmhKMVNiYnNrd1EwTXdMMFJFQVM4Q1ZSa2pJeG1SZ3YzSlN5TVpBVUg5amhrbEpSa0NjaG9sSlJvUC9wUXNLQUVuSVVnUUFRRzQvc1ZETUM5RFF5OHdRd0FJQUFEL3dBUUFBOEFBQ3dBWUFDVUFNUUE5QUVrQVZRQmlBQUFCRkFZaklpWTFORFl6TWhZRElnWVZGQll6TWpZMU5DWWpBU0ltTlRRMk16SVdGUlFHSXlVMEppTWlCaFVVRmpNeU5oTVdGQWNHSWljbU5EYzJNZ0VHRkJjV01qYzJOQ2NtSWhNR0lpY21ORGMyTWhjV0ZBRW1JZ2NHRkJjV01qYzJOQ2NDZWp3cktqdzhLaXM4WnlNeU1pTWtNaklrQWEwYkpTVWJHaVltR3YwTlBDb3JQRHdyS2p4Z0hoNGVWUjRlSGg1VkFmMFhGeGMvRnhZV0Z6OUVEeXNQRHc4UEt3OFAvYmNlVlI0ZUhoNVZIaDRlQTFrcVBEd3FLenc4L09jeUpDTXlNaU1rTWdFTUpob2JKaVliR2laQUt6dzhLeW84UEFHYUhsVWVIaDRmVkI0Zi9ZQVdRQmNXRmhkQUZoY0IzZzhQRHlvUER3OFBLdjRPSGg0ZVZSNGVIaDVWSGdBQUJBQXdBQVFEM2dOL0FCVUFLd0JBQUZZQUFDVUJMZ0VqSWdZSEFRNEJGeDRCTXlFeU5qYzJKaWNISVNJbUp5WTJOd0UrQVRNeUZoY0JIZ0VIRGdFakpUTVRORFkxTkNZbkxnRWpJZ1lIRGdFVkhBRVZFdzRCRlJRV0Z4NEJNekkyTno0Qk5UUW1KeTRCQndQVS9xY1ZQaUVrUEJUK3BCVUVFZzlES1FLMUtVTVNEd1VVZFAxTEZSNEhDQVFLQVZrS0hRd1FHUXNCV0FzRUNBVWRGUDZQTEJ3REJnZ0hFUTBORkFVSEJnMEhCZ1lIQ0JRS0NoUUhDQVlHQ0JJcEVOOENWU1FuSnlUOXF5UlFIeDhwS1I4ZlVDUjBCdzBOSHhJQ1ZSSVRFeEw5cHhJYkRRMEhxZ0ZCQ0E0Q0NoUUlCd1lHQndnVkRBTU5CZjZuQnhRS0NoUUlCd1lHQndnVUNnb1VCdzBERUFBQUFBQUdBRkwvemdPNEE3WUFQQUJJQUlZQXh3RFRBUkVBQUFFdUFTTWlCZ2NPQVFjVkZCWVhNaFl6T2dFekRnRUhEZ0VkQVI0QkZ3NEJGUlFXTXpJMk5UUW1KejRCTnpVME5qVXdOamMrQVRjK0FUVTBKaWNESWlZMU5EWXpNaFlWRkFZVERnRUhEZ0VIRGdFSE1BWUhCaVl4TlRRMk56NEJOejRCTno0Qk5UUW1KeTRCSXlJR0J3NEJCekFHSnk0Qk1UNEJOejRCTXpJV0Z4NEJGUlFHQndVdUFTY3VBU01pQmdjT0FROEJGUVlXRnc0QkJ4VUhGUlFXRlE0QkJ3WVdGeDRCRng0Qk16STJOelkwSno0QlB3RTFNRFF4UGdFM1BnRTNQZ0UzTmlZbkF3NEJKeTRCTno0QkZ4NEJOdzRCQnc0QkJ3NEJCdzRCQnpBR0p5NEJNVFUrQVRjK0FUYytBVGMrQVRjMkppY3VBU2NtQmdjT0FRY3dCaWN1QVRFK0FUYytBUmNlQVJjZUFRY0NUeWRlTzBwMEppUXRDQ1ZkQ2hBSUJRY0ZCUWNGQlFJQ0RBb1FFbGxBUUZvVUVnc0xBZ1FQR2lZd0RROFBORFhSSkRFeEpDUXlNc0VLS2lFWEhnVUZCZ01VTURFZUFRTUZDd2dLS2lFVUVRa0lCUmdQRWg0S0NnOENJRFk0RXdVakhCMWJQVEZOSENZb0Nnb0JNeFE5SmhVb0Voa3JGUjR1RUFNRENFTUlDZ01EQXdvUUJRVUZDd3drRndnUENDbEJDZ1VGQlFZREF3TUxDaHdxRHhBVUJRMFFIOElGS0JRVkZnVUZLQlFYRnFBREN3b0lJaGNTRlFVRkNnSVVIQjhOQWdrR0JRc0hDQ0FaRUJBQ0F3RUZBZzhLQ2hRSUJ3OEZHQjhlQndvZkZCVTdKQndxRUJjTUNBT0RHUm9uSkNSY09RWUxVZzBFQ2hRTEVpMFpKZ2dYQ2hRdkhFQmFXa0FjTlJVS0dBb09DZ3NERkJVY014Y2FNeG85WlNUOU9qRWtKREV4SkNReEFic1NLUm9TSHd3TEdSQWpBZ1VxQ3hRakRRMFlDd29vSEJBZUVBd1lDQVVGQ3cwS0lCb2NDQWNpSzBjWkhSMFVGQnBIS3hJakVOTVhJd29GQlFvS0VqUWtCQU1GVFI4S0dSQUhEUTRGQndVS0dnOFhMaGNWSFFVQ0FUSW1FQ0lQQlFzRkF3Y0RBd1VEREJjTUVDTVNLVkFrL284VUZ3WUZKeFFWRmdVRkpjNEtGQWdIRkFvSURBZ0ZEd29RQlFZZ0J3MFRCUWdMQlFVUUNnVVBDd2NQQlFVSkF3TUJCUVlSRHdrTURSWVpKQW9OQVFvSUdROFZMaGtBQUFBREFBQUFKZ1FBQTFvQUN3QVlBRXdBQUFFMUlSVWpOU0VWSXhFaEVRRWlKalUwTmpNeUZoVVVCaU1URGdFSERnRUhEZ0V4SXpVME5qYytBVGMrQVRjK0FUVTBKaWN1QVNNaUJnY09BUWNuUGdFM1BnRXpNaFlYSGdFVkZnWUhBNXIrek16K3pHWUVBUDM1SENnb0hCd29LQnkxQ0NNWkVoa0ZCUVdXRWdJREV3VUlKaG9QRXdZSENCRU5EUmtLQndzQ2Z3WWFGeGRJTUNjOUZ4OGZBZ2dJQXRHSmlZbUovVlVDcS8yUEtSd2NLQ2djSENrQlVnd2pGUThXQ3djaUJ4SWJDZ29VQndnaEZRMFlDd29UQlFVSUNRZ0hIUklSSkRnVUZ4WVFEeFE1SkE4YkVBQUVBQUFBSmdRQUExb0FDd0FYQURNQVB3QUFBVFVoRlNNMUlSVWpFU0VSQlRRMk16SVdGUlFHSXlJbUFURVVKaWN1QVNNaUJnY09BU2N4SmpZM1BnRXpNVElXRng0QkZSRWlKalUwTmpNeUZoVVVCZ09hL3N6TS9zeG1CQUQ4L1RBaUlUQXdJU1F1QWRBTEZ4VmJNVEJjRkJjTUF3SU5GQnhlTVRCYkhCUUVJVEV4SVNFeE1RTFJpWW1KaWYxVkFxdm9KRFUxSkNRMU0vN0RBd01LQ2hVU0RRb0RBd01aRFJRT0RoUVBGd01CQ2pVa0pEVTFKQ1l6QUFBQUFBSUFjUUErQTRrRFBnQmRBRzhBQUFFT0FROEJEZ0VWRkJZek1qWTNQZ0UxTkNZbkxnRWpJZzRDRlJRZUFqTXlOamMrQVRjWERnRUhEZ0VqSWlZbkxnRTFORFkzUGdNek1oNENGUlFHQnc0Qkl5SW1KeTRCTlE0Qkl5SW1OVFErQWpNeUZoYzNNelVEUGdFMU5DWWpJZ1lIRGdFVkZCWXpQZ0VDNFFVUkJUY0NBUXNORFIwTUlpWTJNQjlSTVVaMVZDNHJUbTFESkVZZUdpc2VOeVFySWk1ZE1GK1JOak16TnpZZlJsSmNOVTZDWGpVdEtTUlZMaG9uQ2dNRUdqY21RMDBqTzFBdEppc1NDbWExRUJNZEZ4a3VFUkFUR2hvWkxRS1FEVUFQeGdnTUJ3b09EZ29aV3pNOVpod1NGQ3hRYmtOQWFFb3BDZ3NIRkJST0ZSUUtEUTgwTmpHSlRWS05OUjh1SHc4dlZYUkZQbkFwSkNRVER3VUtEUjBhV2swNVkwb3JGeHdmQS83Mkgwc2ZIQ0VpSHg5SEh5UWtBeVFBQUFZQVZQL2FBNmtEb3dBRkFBc0FFUUFYQU1RQXlRQUFKU01YTXpVbklRY1ZNemNqRVRNbkl4VVhKUWN6RlRjMUF6d0JOVFFtSnk0Qkp5NEJOVHdCTlR3RE5UUTJOejRCTno0Qk5Ud0JOVHdCTlNZaUl5b0JJeUlHQnc0QkJ3NEJJeW9CSXlvQkl5SW1KeTRCSnk0Qkl5b0JJeW9CQnhRR0ZSd0JGUlFXRng0QkZ4NEJGUndCRlJ3REZSUUdCdzRCQnc0QkZSd0JGUlFXRng0QkZ4NEJNem9CTnpJV0Z4NEJGeDRCRlFZVUZSUVdGeDRCRng0QkZ6WXdOejRCTno0Qk5Ud0JOVFEyTno0Qk56WXlNem9CTXpJMk56NEJOejRCTlNjSEp4RWhBM2FSTTVFei9SUTJrVGFSa1RPVU5nS09OcFF6Z2dFQ0JBa0ZBZ0lDQWdRSUJBTUNBZ01CSWtRaUF3UUNCQXNFQXdRRUJRc0dNbVV5QXdZQ0JRb0VBZ1FESTBjakFRTUJBUUlCQmdvRkFnSUNBUVVMQlFJQ0FnRVNKUklCQXdJR0N3VUdDQU1FV1FZQ0FnRUNBaEFnRUFFQ0FRRUJFU0VSQWdFQkFRWmRCUUVFQVFjT0J3SUVBaElrRWdFQ2pabWFBVE5oUG9nM05JcytBd0ZCaXpiQlFZQTJpLzFsSTBZakFnTUNCQWdFQWdVREJBY0VBamRET1FRREF3SUVDQVFDQlFRZ1FpQUNBd0lCQWdJRkNnVUNBZ0lEQlFrRkFnSUJBUUVCSVVRaEFnUUJCUXNGQWdVREJnc0ZBVFZBT0FRQkFnRUZDd1VDQkFJaVJDSUNCQUVUSlJJQkFnRURCQVZaQlFJRkF3Y01Cd01FQWhFZ0VBRUNBUUVCRVNJUkFnTURCdzhIQWdNQkJsMEZBZ0lCRXlRVEFRTUNSSnljQVRNQUFBQUFBd0FBLzhBRUFBUEFBQk1BR2dBbUFBQUJJZzRDRlJRZUFqTXlQZ0kxTkM0Q0F5TTFCeWMzTXdFVkl6VWpOVE0xTXhVekZRSUFhcnVMVUZDTHUycHF1NHRRVUl1NzNuUW1SR1o0QVdwNGQzZDRkd1BBVUl1N2FtcTdpMUJRaTd0cWFydUxVUDA2OWlablp2N2FkM2Q0ZDNkNEFBQUZBQUFBTFFRQUF6NEFBd0FIQURVQU9nQS9BQUFCSVJFaEFTRVJJUUV1QVRjMkZoY2VBUWN6SmpZM1BnRVhGZ1lITUFZeE16NEJKeTRCQnc0QkJ5NEJKeVlHQndZV0Z6TXdKakVGSXhFaEVRVWhFU0VSQWpjQnlmNDMvY2tCay81dEFUQkFLd2dIVFRFdU9nV0ZCVG91TGswS0NDdEFBMlljRndvUGdFZ3BRQklTUUNsS2dROEtGaGxxQXdIeTZ3SEovYlgrU3dHVEFUdis4Z0VPL3ZJQ2pCb3dFaElIRlJRY0tTa2VFaFVFRWhJeEdRY3BMaG9tRVJ3U0xSb2FNQkljRVNrWExpa0hCLzd6QVEwRC92WUJDZ0FBQUFZQUlnQXJBOTREU0FBYkFEa0FWUUJ4QUk4QXF3QUFKUlVVQmdjT0FTTWhJaVluTGdFOUFUUTJOejRCTXlFeUZoY2VBUkVWRkFZSERnRWpJU0ltSnk0QlBRRTBOamMrQVRNaE1oWVhIZ0VWTVJFVkZBWUhEZ0VqSVNJbUp5NEJQUUUwTmpjK0FUTWhNaFlYSGdFQkZSUUdCdzRCS3dFaUppY3VBVDBCTkRZM1BnRTdBVElXRng0QkVSVVVCZ2NPQVNzQklpWW5MZ0U5QVRRMk56NEJPd0V5RmhjZUFSVXhFUlVVQmdjT0FTc0JJaVluTGdFOUFUUTJOejRCT3dFeUZoY2VBUVBlQmdZR0RnajltUWdPQmdZR0JnWUdEZ2dDWndnT0JnWUdCZ1lHRGdqOW1RZ09CZ1lHQmdZR0RnZ0Nad2dPQmdZR0JnWUdEZ2o5bVFnT0JnWUdCZ1lHRGdnQ1p3Z09CZ1lHL1BBR0JnWU9DRndJRGdZR0JnWUdCZzRJWEFnT0JnWUdCZ1lHRGdoY0NBNEdCZ1lHQmdZT0NGd0lEZ1lHQmdZR0JnNElYQWdPQmdZR0JnWUdEZ2hjQ0E0R0JnYWpVQWdPQmdZR0JnWUdEZ2hRQ0E0R0JnWUdCZ1lPQVRaUENBNEdCZ1lHQmdZT0NFOElEZ1lHQmdZR0JnNElBVDlRQ0E0R0JnWUdCZ1lPQ0ZBSURnWUdCZ1lHQmc3OWUxQUlEZ1lHQmdZR0JnNElVQWdPQmdZR0JnWUdEZ0UyVHdnT0JnWUdCZ1lHRGdoUENBNEdCZ1lHQmdZT0NBRS9VQWdPQmdZR0JnWUdEZ2hRQ0E0R0JnWUdCZ1lPQUFBQUFBY0FIUC80QStRRGhnQk1BRkVBWGdCckFIY0FoQUNVQUFBQkxnRWpJZ1lITGdFbkxnRWpJaVluTlRRbUt3RWlCaFVSRkJZN0FUSTJOUkVlQVRNeUZoY2VBUmN1QVNNaUJnY09BaFlYSGdFek1qWXpQZ0UzTXg0QkZ6SVdNekkyTno0QkxnRW5BU01STXhFRElpWTFORFl6TWhZVkZBWWpBUlVqRlNNMUl6VXpOVE1WRnhjaUpqVTBOak15RmhVT0FTY2lKalUwTmpNeUZoVU9BU01YSWlZMU5EWXpNaFlWT0FFeEZBWWpBN1FaU1NvYU1oWUNGUjBUTWlCVFpSVWlGZDRWR2hvVjNoWWhIMlZKR1NjUEZ4RUNEVFVpS2trWkhCWUZCZ0lITnlnQ0JRSUtPemVHTnpzS0F3VUNKemNJQVFZRUZ4ejlHaUFnRkJZZkh4WVdJQ0FXQWNrbUtpWW1LaWFUQ3hBUUN3d1FBUThNQ3hBUUN3d1FBUkFMUkFzUUVBc0xFQkFMQVdrcUxROE9IVkVoRlJWZkpIb1ZHQmdWL05FVkhSMFZBb0FtUlJBUkdVWWRDUmt1S3kxYVN6UUdMRE1CQVJaRFF4WUJBVE1yQnpOTFdTMy9BQUhqL2gwQ0toOFdGaUFnRmhZZi9vd3BJU0VxSlNVQlVoQUxDeEFRQ3dzUVNoQU1DeEFRQ3d3UUtCQU1DeEFRQ3d3UUFBQUFBQWNBci8vY0ExQURuZ0FXQUJvQVFRQk9BR0VBZEFDSEFBQUJJU0lHRlJFVUZqTWhPQUV6TWpZMU5EQTFFelFtSXhNaEVTRURKZ1l4RGdFckFTSW1KeTRCQndZV01SNEJOejRCTVQ0Qk93RXlGaGNlQVJjV05qY3dOaWNIRlNNVkl6VWpOVE0xTXhVekZ5SW1OVFEyTXpJV0ZUZ0JNUlFHSXpnQk1UVWlKalUwTmpNeUZoVTRBVEVVQmlNNEFURVhJaVkxTkRZek1oWVZPQUV4RkFZak9BRXhBdUQrUUM1RFF5NEJ3QUVzUUFOQ0xpejk1UUliYnlkWkJBc0ZGUVlLQlFSVkppY0lBeElSRVRZRENnWjdCUW9FQXpNUUVSTUNDQ2JHSFNBZEhTQWRjZ2dORFFnSkRBd0pDQTBOQ0FrTURBazBDQTBOQ0FrTURBa0Rua0F0L1JZc1AwQXNBUUVDNXkxQS9PY0NtdjdzUHlZREJBUURBeU0vUDNBUkV3RUJPd1FGQlFRRU53RUJGQkJ3UHlFZEhCd2hIQnhFREFrSkRBd0pDUXc2REFnSkRBd0pDQXdmREFrSURBd0lDUXdBQUFQLy9mL0FCQUFEd0FBWEFDZ0FRQUFBQVNjM0x3RUhKd2NuRHdFWEJ4Y0hId0UzRnpjWFB3RW5BVE1WRkFZSERnRXJBU0ltSnk0QlBRRVREZ0VqSWlZbkxnRTFORFkzUGdFek1oWVhIZ0VWRkFZRUFHWXZraU9TWjNDUU01a2VjR1l3a3lLVFpuR1BNSm9mL2tGVkFRSURBZ0k2QXdVQ0F3Uk9CeEVLQ2hBSUNBWUdDQWdRQ2dvUkJ3Z0dCZ0dsY0pBdm1oOXhaaStTSTVKbmNKQXZtaDl4WmkrU0k1SUJXWEVVSlJJU05UTVVFaVVVY2Y2SkJnZ0dDQVVTQ3dvVEJRVUlCUWdGRXdvTEVBQUFBQVFBQUFBRUJBQURmQUFRQUNBQU1RQkNBQUFCTkRZeklUSVdIUUVVQmlNaElpWTlBU0UwTmpNaE1oWWRBUlFHSXlFaUpqVUJORFl6SVRJV0hRRVVCaU1oSWlZOUFTRTBOak1oTWhZZEFSUUdJeUVpSmowQkFsa29IQUVmSENnb0hQN2hIQ2o5cHlnY0FSOGNLQ2djL3VFY0tBSlpLQndCSHh3b0tCeis0UndvL2Fjb0hBRWZIQ2dvSFA3aEhDZ0ROeDBvS0IzYUhDZ29ITm9kS0NnZDJod29LQnoreVIwb0tCM2RIU2dvSGQwZEtDZ2QzUjBvS0IzZEFBQUFBd0FBQUNZRUFBTmFBQ0lBS2dBdkFBQWxJVFVoTWpZMUVUUW1JeUVpQmhVUkZCWXpJUlVoTUFZVkZCWXhJVEEyTlRZbU1RRWhFU0V3UEFJWElSRWhFUVBsL21NQll4UWlJaFQ4dFJVcEp4Y0JYUDVqSHg4RHdoOERIdnluQXUvOUVVUUNaLzJaYXlJNkZBSkxGUjhmRmYyMUZEb2lDUmthQ1FrYUhBWUNxdjNlcTgycVJQNW1BWm9BQUFBR0FBTUFNUVA5QTFNQURRQWVBQ0lBSndBc0FERUFBQ1VoTUFZVkZCWXhJVEEyTlRRbUpTRXlOalVSTkNZaklTSUdGUkVVRmpNVElSRWhFeUVSSVJFRk14VWpOVFV6RlNNMUE5NzhSQjhmQTd3ZkgveUNBMEFWR3hzVi9NQVZIeDhWRkFNWS9PaElBWmIrYWdIaHA2ZW5wM1VKR1JvSUNCb1pDVGNYRlFKSUZCOGZGUDI0RlJjQ1gvM2xBZFArZEFHTTc1MmQ3NTJkQUFZQUlnQnlBOTRESVFBTEFDb0FOZ0JWQUdFQWV3QUFBUlFHSXlJbU5UUTJNeklXQnc0Qkl5SW1KeUlHQnhRV0ZSUUdCeDRCTVJVeU5qOEJQZ0UzTlRBbUp5VVVCaU1pSmpVME5qTXlGZ2MwTmpVdUFTTU9BU01pSmljT0FRY1ZNQllmQVI0QkZ6VStBVGN1QVRVRkZBWWpJaVkxTkRZek1oWUhEZ0VqSWlZbklnWUhGVEFXSHdFZUFUOEJQZ0UzTlRBbUp3TjFSVEV4UlVVeE1VVTFEeUVSRVNFUEJBb0hBUnNYY3lZY09oNFJFaVFTS0hiK04wVXhNVVZGTVRGRklBRUdDZ1lQSUJJUklROFhnZ1VvSWhBWk9pRUViaWNYR3dFZ1JUQXhSVVV4TUVVNURoNFFFUjRPRFpJRktDTVFNb3RPRUJJa0VpaDVBcXd4UlVVeE1FVkZ0d2NJQ0FjQkFRSURBaUU1RkE2QUh3a0tCZ2NTQzJsNUJZY3hSVVV4TUVWRndBSUVBUUVCQndnSUJ3RXFVMmtWRFFVSURBSWZUamtHRkRvaEJ6RkZSVEV3UlVYQ0JnY0hCaVZaYVJVTUJoQU1HUVlIRWd0cGV3TUFBQVFBTWdDd0E4NEN6Z0JPQUZvQWFBQjBBQUFCTGdFbkxnRWpCeUlHQnljd0ppY3VBVEVoTUNZSERnRXhCelFtSXljaUJnY09BUWNHRmpzQkRnRUhGQVlkQVJ3Qk1SVVVGanNCTWpZOUFTRVZGQlk3QVRJMk5SRThBU2N1QVNjelBnRW5CU0ltTlRRMk16SVdGUlFHSnpVM01EWTNJUjRCTVI4QkZTRUZJaVkxTkRZek1oWVZGQVlEemdFRUFRUUlDVDhKQ2dHRUNRa0lEdjZVRGdrRkNJWU1DRDBKQ0FRQkJBRUVFQWdtRFEwREFnd0lqQWtNQWZ3TUNZd0lEQUlDRGcwbUNCQUUvUGthSVNNWUdTSWlOSTRFQXdGMUF3UnFKdjFmQXBRYUlTTVlHU0lqQWljSENBb0lEQWtFQlgwSEJBTUJBUVVFQlg4SEFna01DQW9JQndvS0VTUVBBZ01DQndnTTZRZ01EQWdrSkFnTURBZ0JBZ0lGQWc4akR3SUxDdGtrR3hzbEpSc2JKTEFpaUFNQkFRTmtJU1d3SkJzYkpTVWJHeVFBQUFBQURBQWpBQmdEM3dOMEFCc0FPQUJWQUhJQWp3Q3NBTWtBNWdFREFTQUJQUUZhQUFBbElTSW1KeTRCUFFFME5qYytBVE1oTWhZWEhnRWRBUlFHQnc0QkpTSUdCdzRCSFFFVUZoY2VBVE1oTWpZM1BnRTlBVFFtSnk0Qkl5RWxJU0ltSnk0QlBRRTBOamMrQVRNaE1oWVhIZ0VkQVJRR0J3NEJJeVVxQVFjT0FSMEJIQUVYSGdFeklUSTJOejRCUFFFMEppY21JaU1oSlNFaUppY3VBVDBCTkRZM1BnRXpJVElXRng0QkhRRVVCZ2NPQVNNbElnWUhEZ0VkQVJRV0Z4NEJNeUV5TmpjK0FUMEJOQ1luTGdFaklRTWpJaVluTGdFOUFUUTJOejRCT3dFeUZoY2VBUjBCRkFZSERnRWpKeUlHQndZVUhRRWNBUmNlQVRzQk1qWTNQZ0U5QVRRbUp5NEJLd0UzSXlJbUp5NEJQUUUwTmpjK0FUc0JNaFlYSGdFZEFSUUdCdzRCSXljcUFRY09BUjBCSEFFWEhnRTdBVEkyTno0QlBRRTBKaWNtSWlzQk55TWlKaWN1QVQwQk5EWTNQZ0U3QVRJV0Z4NEJIUUVVQmdjT0FTTW5JZ1lIQmhRZEFSd0JGeDRCT3dFeU5qYytBVDBCTkNZbkxnRXJBUU9YL2dnUEdnb0tDd3NLQ3hrUEFmZ09HZ29MQ3dzTENocjkrZ0lDQWdFQkFRRUNBZ0lCK0FFREFRSUJBUUlCQXdIK0NBSDQvZ2dQR2dvS0N3c0tDeGtQQWZnT0dnc0tDd3NMQ2hvTy9nZ0NBZ0lCQVFJQ0FnSUIrQUVEQVFJQkFRRUNBd0grQ0FINC9nZ1BHZ29LQ3dzS0N4a1BBZmdPR2dzS0N3c0xDaG9PL2dnQ0FnSUJBUUVCQWdJQ0FmZ0NBZ0VDQVFFQkFnTUIvZ2pZWEE4YUNnb0xDd29MR1E5Y0Rob0tDd3NMQ3dvYURsd0NBZ0lDQWdJQ0Fsd0JBd0VDQVFFQ0FRTUJYRnhjRHhvS0Nnc0xDZ29hRDF3T0dnc0tDd3NMQ2hvT1hBSUNBZ0VCQWdJQ0Fsd0JBd0VDQVFFQkFnTUJYRnhjRHhvS0Nnc0xDZ29hRDF3T0dnc0tDd3NMQ2hvT1hBSUNBZ0lDQWdJQ1hBSUNBUUlCQVFFQ0F3RmNHQW9MQ2hvT1VBNGFDZ3NMQ3dzS0dnNVFEaG9LQ3dxZkFRSUJBd0ZRQVFNQkFnRUJBZ0VEQVZBQkF3RUNBWjhMQ2dzWkQwOFBHZ29LQ3dzS0Nob1BUdzhaQ3dvTG53SUNBZ0pQQWdJQ0FRRUJBUUlDQWs4Q0FnSUNvQXNLQ2hvT1VBNGFDd29MQ3dzS0dROVFEaG9LQ3dxZkFRRUNBd0ZRQVFNQkFnRUJBZ0lDQVZBQ0FnRUNBZnprQ2dzS0dnNVFEaG9MQ2dzTEN3b2FEbEFPR2dvTENwOEJBZ0VEQVZBQkF3RUNBUUVDQVFNQlVBRURBUUlCbndzS0N4a1BUdzhhQ2dvTEN3b0tHZzlQRHhrTENndWZBZ0lDQWs4Q0FnSUJBUUVCQWdJQ1R3SUNBZ0tnQ3dvS0dnNVFEeGtMQ2dzTEN3b2FEbEFPR2dvTENwOEJBUUlDQWxBQkFnSUNBUUVDQWdJQlVBRURBUUlCQUFBT0FJUC8vUU4xQTV3QUlBQmtBSDBBamdEMkFVNEJYZ0Z1QVlZQm5nSEJBZVFDRndKS0FBQTNORFk3QVRJMlBRRTBOak1oTWhZZEFSUVdPd0V5RmgwQkZBWWpJU0ltUFFFeE16UTJPd0V5TmowQk5EWXpJVElXSFFFVUZqc0JNaFlkQVJRR0l5RWlKajBCSXhVVUZqTWhNalk5QVRRbUt3RWlKajBCTkNZaklTSUdIUUVVQmlzQklnWVZNd0UyTWg4QkhnRWZBUllHSXlFcUFTTWhJaVkvQVQ0QlB3RVhKaUlQQVFZV015RXlOaThCTGdFdkFTY1hQZ0V6TWhZZkFSNEJId0l4TXlNeE93RW5GVE1uRnpVakZ6VXdCaWNoS2dFaklTb0JPUUVITXpVSE1UTXhJek0vQWo0QlB3RW5CdzRCRHdFT0FRY09BUlVVRmpNZUFUTWhPZ0V6SVRJMk56STJOVFFtSnk0Qkx3RXVBUzhCTGdFaklnWUhGeGMzTGdFaklnWVBBUTRCQnhRR0ZSUVdNeDRCTXlFeU5qY3lOalUwSmljdUFTOEJMZ0V2QVFjWEhnRWZBakV6SXpFN0FTY1ZNeWNYSnpFWEp6QUdJeUVpSmprQkJ6TW5CekU3QVNNelB3SStBVE15RmhjM0FUTXlGaFVSRkFZckFTSW1OUkUwTmlFek1oWVZFUlFHS3dFaUpqVVJORFloT2dFek1oWVZIQUVWRkFZaktnRWpJaVkxUEFFMU5EWXpPZ0V6TWhZVkhBRVZGQVlqS2dFaklpWTFQQUUxTkRZaEZUTXlGaFVSRkFZckFTSW1OUkUwTmpNMUlnWVZFUlFXT3dFeU5qVVJOQ1lyQVFVVk16SVdGUkVVQmlzQklpWTFFVFEyTXpVaUJoVVJGQlk3QVRJMk5SRTBKaXNCQlJVNkFUTXlGaFVjQVJVVUJpTXFBU01pSmpVOEFUVTBOak0xSWdZVkhBRVZGQll6T2dFek1qWTFQQUUxTkNZaktnRWpGeFU2QVRNeUZoVWNBUlVVQmlNcUFTTWlKalU4QVRVME5qTTFJZ1lWSEFFVkZCWXpPZ0V6TWpZMVBBRTFOQ1lqS2dFamhRUURKUU1GQkFNQ2VBTUZCQU1tQWdVRkF2MGZBd1FCQXdNbEJBVUVBZ0o0QXdNRkJDWUNBd01DL1I4REF3TUZCQUxoQXdVRkF5WUNCQVVEL1ljRUJRTURKUVFGQWdGckJRNEZrd1VPQlpRRkFnYit4Z1lRQnY3R0JnRUZrd1VPQlpNWUJRNEYyZ1VCQmdISUJnRUVRUVVPQllJWUF3RUZBd01GQXBNRkRnV1RBd0VCQVFFQ0FnSUJBUUVDQXY3R0JoQUcvc1lCQWdFQkFRRUJBUUVDa3dVT0JaUUZsQVFPQlpRQkFnRUJBUU1CQWdNQ0FUb0dFQVlCT2dJREFnRURBUUVCQWdHVUJRMEZsQU1IQkFRSEF3SVlBZ01IQkFRSEE5c0JBZ0VDQXdJQkF3SUJ5QUlEQWdFREFRRUJBZ0ZCQlE0RmdnU0NCUTBGUVFNQkFRRUJBZ0lDQVFFQkFRRUMvamdCQWdFQ0FRRUJBUUlCQVFMYkFRVURBd1VDQXY3M0tBY0tDZ2NvQndvS0Fkb25Cd29LQnljSUNnciswUW9UQ2djTEN3Y0tFd29IQ3d1aUNoUUpDQW9LQ0FrVUNnY0tDdjdRS0FVSUNBVW9CUWdJQlFrTURBa29DUXdNQ1NnQjB5Y0ZDQWdGSndZSUNBWUpEUTBKSndrTkRRa24vc2tLRXdvR0NBZ0dDaE1LQmdnSUJna05EUWtLRXdvSkRRMEpDaE1LbXdvVUNRWUlDQVlKRkFvRkNBZ0ZDUXdNQ1FvVUNRa05EUWtKRkFwRUF3UUZBdzBEQlFVRERRTUZCQU0rQXdRRUF6NERBd1VFRFFNREF3TU5CQVVEQXo0Q0F3TUNQajREQmdZRFBnUUZBd01OQkFVRkJBMERBd1VFQTFBRUJHUUVDUVJrQkFVRkJHUUVDUVJrSlFNRGxRUUZCUU10QXdvRFdTVURBUUlDQVdVRENnTmxBZ0lDQWdFQkFRRUJBUUlDQWdFQlpRTUtBMlVIWlFNS0EyVUJBZ0VCQWdJQ0F3RUJBUUVEQWdJQ0FRRUNBV1VEQ2dObEFnSUNBZ1FsQXdJQ0FnS1ZBUUlCQVFJQ0FnTUJBUUVCQXdJQ0FnRUJBZ0VzQkFrRFdRWlpCQWtETFFJQ0FnSUJBUUVCQVFFQ0FnSUJBWllCQVFFQkEvN1BDd2YrdXdnS0NnZ0JSUWNMQ3dmK3V3Z0tDZ2dCUlFjTEN3ZFdtVllJQ2dvSVZwbFdCd3NMQjFhWlZnZ0tDZ2hXbVZZSEN3UUlCdjY3QmdnSUJnRkZCZ2dJRFFuK3V3a05EUWtCUlFrTkJBUUlCdjY3QmdnSUJnRkZCZ2dJRFFuK3V3a05EUWtCUlFrTkJBUUlCbGFaVmdZSUNBWldtVllHQ0FnTkNWYVpWZ2tORFFsV21WWUpEUVFFQ0FaV21WWUdDQWdHVnBsV0JnZ0lEUWxXbVZZSkRRMEpWcGxXQ1EwQUFBQUNBRDBBTUFQREF4OEFEZ0FkQUFBQkZBNENCelUrQVQwQkl4RWhFU0VVRGdJSE5UNEJQUUVqRVNFUkE4TXlXWHRLVVUvREFYUDk3VEpaZTBsUVQ4TUJjd0dzVjRkZ053ZWFFSFZYSHdGYS9vMVhoMkEzQjVvUWRWY2ZBVnIralFBQ0FESC82Z1BQQTVZQVZBQmdBQUFCTlNjdUFTY3hKalkvQVNjSERnRW5NUzRCTHdFakJ3NEJCekVHSmk4QkJ4Y2VBUWM0QVRFT0FROEJGUmNlQVJjeEZnWVBBUmMzUGdFWE1SNEJId0V6Tno0Qk56Z0JNVFlXSHdFM0p5NEJOekUrQVQ4QkJTSW1OVFEyTXpJV0ZSUUdBODlERkIwSUNBRUpIMWhCRWlvVEV4d0hHSHdZQnh3VEV5a1RRRmtmQ1FFSUNCNFRRME1USGdnSUFRa2ZXVUFUS1JNVEhBY1lmQmdISFJNVEtCTkJXQjhKQVFnSUhoTkQvakZHWkdSR1JtUmtBWUYrR0FjZEV4TXFFMEZhSHdrQkNBZ2VFMFZGRXg0SUNBRUpIMXBCRXlvVEV4MEdHWDRaQnh3VEV5b1RRVm9mQ1FFSUNCNFRSVVFVSGdnSUFRa2ZXa0VUS2hNVEhBY1piV1ZIUjJWbFIwZGxBQUFIQURFQTh3UFBBbzBBQndBUEFCZ0FJQUFyQUljQWtnQUFBUmNPQVFjblBnRUhGdzRCQnljK0FRVUhMZ0VuTng0QkZ5Y0hMZ0VuTng0Qkp4NEJGd2N1QVNjK0FUY0JNQzRDSnc0RE1TYytBemN1QVNjeEJ3NEJKeU11QVQ4QkRnRUhMZ0VuTng0QkZ6YytBUjhCSGdFUEFSNEJGejRCTnljbU5qOEJOaFlmQVQ0Qk54Y09BUWN1QVNjWEZnWUhJd1ltTHdFT0FRY2VBeGNIRXljK0FUY2VBUmNPQVFjRGhpNEdEQVl3Qnd3cU1BWU5CekFIRGYxMk1BY05CakFHRFFjeE1BWU1CaTRIREVRSERnWXVBUU1CQmd3R0F6WXFXNUpvYUpKYktsQTdibVZjS1RGdVBnWUNDQU1CQkFJQ0VBTUVBZ3NVQ3pFRUNRUUdBZ2dEQVFRQ0FnWVVnbXBxZ2hRR0FnSUVBUU1JQWdZRUNRUXhDeFFMQWdRREVBSUNCQUVEQ0FJR1BtNHhLVnhsYmp0UVN5NEdEZ2NHREFZQkF3RUNieDRFQ0FNZUJBY1lId01IQkI4REJ3b2ZCQWNESHdRSEF4c2VBd2dFSGdRSEtRUUpCQjRCQWdFTEZRditaZ2djTlMwdE5Sd0lFUklsSkNNUkZqTWVDd01DQWdJSUF4d0VDQVFGQ2dVZ0F3UUNDd1FDQWdFQ0J3UUxDMEl0TFVJTEN3UUhBZ0VDQWdRTEFnUURJQVVLQlFRSUJCd0RDQUlDQWdNTEhqTVdFU01rSlJJUkFXc2VCQWtFQ3hVTEFRSUJBQUFBQkFBYy85c0Q2UU9vQUJvQUlnQXZBRWdBQUFFeUhnSVZGQTRDSXlJdUFqVTBNREUwUGdJek1qQXhBemNWTXhFakJ4Y1hNeFV6TlRNMUl6VWpGU01WQXlJT0FoVVVIZ0l6TWo0Q05UZ0JNUzRESXpFQ0FsR05hajA5YW8xUlVZMXFQVDFwamxBQnpSMVlXMDQwMGx0YlcxdGJXd1Zsc1lSTVRJU3haV1d4aEUwQlRJU3haUU5IUFdxT1VWQ09hajA5YW81UUFWR05hajMrZ2gyN0FUcE9Ua05iVzF0YVdsc0NJazJFc1dSbHNZUk5UWVN4WldTeGhFMEFBQUFFQURQL3dBUE5BOEFBRUFBdkFEUUFPUUFBQVNFaUJoVVJGQll6SVRJMk5SRTBKaU1CTkRZN0FUd0JOVFEyT3dFeUZoMEJNeklXSFFFVUJnY1ZJVFV1QVQwQkFTRTFJUlUxSVRVaEZRT0ovTzRjS0NnY0F4SWNLQ2djL2JJd0loY0pCcWtIQ1JZaU1Db2YvdmtmS2dITS9mSUNEdjN5QWc0RHdDZ2MvSWdjS0NnY0EzZ2NLUDdkSWpBSEl4WUdDUWtHUURBaXNTQXVCQ3dzQkM0Z3NmMm9LU2wrS1NrQUFBQUdBQUQvd0FRQkE4RUFIQUFnQURVQU9RQTlBRUVBQUFFaERnRVZPQUV4RVRnQk1SUVdNemdCTVNFNEFURXlOamNSTGdFbkF5RVJJUWNuTGdFaklnWUhJd0VQQVQ4QkFUNEJOVFFtSnljWEJ5Y0hKemNYTnljM0Z3TzgvSWdjS0NnY0EzZ2NLQUVCS0J3UC9LY0RXWkZkQ0JZTURCVUlBZjZ0QnpyckZnRkZCd2tKQ01zczlDd2VKUnBwTHl6MEt3UEJBU2djL0lnY0tDZ2NBM2djS0FIOFV3Tlo4RjBJQ1FnSS9xd0g2enNXQVVVSUZRd01GUWdCTFBNcnNTZGZhU1lyOUN3QURRQkYvOXNEdXdPb0FBOEFGQUFaQUI0QUlnQW5BQ3dBTUFBMUFEb0FQZ0JPQUY0QUFBRWhJZ1lWRVJRV015RXlOalVSTkNZRElSRWhFUUV6RlNNMU93RVZJelU3QVJVakJUTVZJelU3QVJVak5Uc0JGU01GTXhVak5Uc0JGU00xT3dFVkl3RXpNaFlkQVJRR0t3RWlKajBCTkRZaE16SVdIUUVVQmlzQklpWTlBVFEyQTNuOURoc25KeHNDOGhzbkp4djlEZ0x5L1d5TWpOV01qTnlNalA1UGpJelZqSXpjakl6K1Q0eU0xWXlNM0l5TS9sMVlCZ2dJQmxnR0NBZ0IwRmNHQ0FnR1Z3WUpDUU5KSWhqOUJ4Z2pJeGdDK1JnaS9NMEMrZjBIQW5xTWpJeU1qRVdNakl5TWpFU01qSXlNakFORkNBYTFCZ2dJQnJVR0NBZ0d0UVlJQ0FhMUJnZ0FEQUJELzlrRHVnT3BBQThBRkFBWkFCMEFJZ0FuQUNzQU1BQTFBRG9BU2dCYkFBQUJJU0lHRlJFVUZqTWhNalkxRVRRbUFTTTFNeFUxSXpVekZUVWpOVE1USXpVekZUVWpOVE1WTlNNMU14TWpOVE1WTlNNMU14VTFJelV6RlFFek1oWWRBUlFHS3dFaUpqMEJORFloTXpJV0hRRVVCaXNCSWlZOUFUUTJNd041L1E0YktTa2JBdkliSmliOTI0eU1qSXlNak5pTmpZMk5qWTNkalkyTmpZMk4vYzFaQmdnSUJsa0dDQWdCMFZrR0NRa0dXUVVKQ1FVRFJpRVkvUWNZSXlNWUF2a1lJZjBialkzT2pZM1RqZjNTalkzT2pZM1RqZjNTalkzT2pZM1RqWTBCcHdrR3RnWUpDUWEyQmdrSkJyWUdDUWtHdGdZSkFBQUFCd0JNQUZFRDRBTTFBRDRBZEFDS0FLQUFzZ0RFQU5ZQUFDVWlMZ0luTGdFbkxnSTJOejRCTno0Qk56RTJGaGNlQVJjVkhnRUhEZ0VIRGdFSERnRUhEZ0VIRkJZWEhnRVhNUjRCRnhZR0R3RU9BUWNPQVNNVERnRUhEZ0VIQmhZWEhnRVhIZ0kyTno0Qk56NEJKeTRCSnk0Qkp5NEJOelEyTno0Qk56NEJOejRCTlRRbUp5NEJKeTRCSXdFVUZqTXdNakUrQVRjMEppTTRBU01pQmhVaUZERTFGQll6TURJeFBnRTFOQ1lqT0FFeEpnWVZNQlFWQlFZV0Z6b0JNVDRCTnk0Qkl5SUdGVGdCQnlJR0ZSUXdNUlFXTXo0Qk5UWW1JekFpRXhZMk56QTBNVFFtSnlJR0J3WVdNeFl5QWdRblQwMU5KU005Rnh3ZUF4Z1pKM1JRUUpCYkhWUXNFeUlRRWhFQkFSUVRCeGtPREJ3RUJnUUJCQVFMY2lNdEtnZ0xCeEVCSkdaRlFJQS9YMWFHUEVocElpb0ZMeFEwSGo2QWc0VkVQVmtnQ3dVR0J4OFlEWk1TRVFvQkRCSUdHUlFNR0FZSUNRY0hEQm9QSjB3Yi9td25Hd0ViSmdFbkd3RWFKd0VuR3dFYkppY2JHeWNCM3dFbUd3RUJHeVlCQVNZY0d5YWRHeWNvR3hvbUFTWWJBUmNiS0FFbkd4c21BUUVrR3dFQlVRb1VIaFFUTlNBbFQxRlJKenhiSWhvYkFRRUhEUVlSREFFTkl4SVRJZzBGRGdjSEVBTUVCd0lCQmdRSEtBb09MQk1iUHlFQk8xSWJHaGtDc1FJWUdSNVNOVUdEUHhzdUR5SWtCeGNhR0VnekZpZ1FFQmdIQkRBUURoc0tDaDBPQkE0TUJnOERCUTBIQmd3RkNnMEVEUVgrVUJzbkFTWWJHeWNsR3dMYUd5Y0JKeHNiSmdFbUd3RUJ2UnNtQVFFbUd4c25KeHN5SmhzQkhDVUJKUnNiSndFTkFTWWJBUnNuQVNZYUd5Z0JBQUFBQmdCS0FKY0Qxd000QURJQVVRQnFBSUFBbVFDdkFBQUJNaFlYSGdFWEZnWUhEZ0VIRGdFSERnRVhIZ0VYSGdFWEhnRVhIZ0VIRGdFSERnRXVBU2N1QVNjdUFUYytBVGMrQVRjQk9BRXhGQll6TWpBeFBnRTNPQUV4TkNZak9BRXhNQ0l4SWdZVkZEQVZOUlFXTXpJd01UNEJOelFtSXpnQk1UQWlNU0lHRlJ3Qk1RVXdGREVVRmpNd01qTXlOamN1QVNNaUJoVTRBVEVIT0FFeElnWVZNQlF4RkJZek1qWTFNRFF4TkNZak1DSXhFekl3TXpJMk5UZ0JNVFFtSXlJR0J6QVVNUlFXTXdKbEhGVXRFaUFPR3dRY0RSME9DeFVKRXdNVURSMFJIVHdkRlNNTUZ3TVRKbXBDU1pDUWpVWWpPaFkyQmpBcmVVZERrbHYrV0NrY0FSd29BU2tkQVJ3b0tSd0JIU2NCS1IwQkhDZ0IrQ2djQVFFY0tBRUJLQjBkS0tZZEtDZ2RIU2twSEFFWkFRRWNLU2dkSENrQktCd0RPQVVPQmhBTEZUY1RDUTRJQmcwSERpUVFDeEFHQ2c4SUJoZ1JIVG9mUFZZWkhSa0hLQ1VUTWg5SW5VdENXQjRjR1FMK0hod3BBU2djSFNrb0hBRUI1aHdwQVNnZEhDa29IQUVCeHdFY0tDZ2RIU2twSFRRcEhBRWRLQ2dkQVJ3cEFSc25IUjBwS0J3Q0hDZ0FBZ0FnLzl3RDNnT1RBQjBBT2dBQUFRTStBVGMrQVRjK0FUYzJGaGNXRnhZR0J3NEJCdzREQnlJR0J3TUdKaWN1QVNjQ0F5NEJKeVkyTnpZV0Z4NEJGeElUSGdFWEZnWUhBVm1BTDFrdFI0OUhIVGtjTFRZTktTZ0xFQ1UxYmpncFVsSlRLUTBhRUNJWExBd0ZDQU5aV1FJREFRWVpIQm9zQ1F3VkMwZEhBd1FDQWdrakFVa0IvZ1lNQkFVRUJ3TVlDeEVaTDU2ZUtETVFHQ2tKQmdjRkJBUUdBdjZUQmd3VkNoWU1BV1lCWlFZTUJpQXVCd2NjSGl4WUxQN2ovdU1KRkFvQ01RZ0FBQUFLQUZmLzJ3T3RBNmdBU0FDQkFKVUFxd0RCQU0wQTR3RHZBUVVCSVFBQUFTNEJKeW9CSnpVMEppY3VBU014SWdZSERnRVZCaFVjQVJVd0ZCVWlCZ2NPQVFjT0FSVVJGQllYSGdFZkFSUVdNeUU0QVRFeU5qYytBU2M4QVRFMVBBRTFQZ0UxRVRRbUp3TU9BU01oSWlZakxnRTlBVFExTkRZM1BnRTFQQUUxTkRZM1BnRTNQZ0V6TWhZWEhnRVZGQlVVRnhRVkhnRVhIZ0VYRmdZZEFSUUdCd2NHS2dFbUl6d0JOUll5TXpjeUZqY3hIZ0VIQXlZR0J3WW1KeTRCTlRRMk56NEJGeFlVRlJRR0J5RTJGaGNXTmpjMk5EVTBKaWN1QVFjT0FSVVVGaGNYRkFZaklpWTFORFl6TWhZSE5EQXhOQ1lqSWdZVkZCWXpPQUV4T0FFek1qWTFGeFFHSXlJbU5UUTJNeklXQnpRd01UUW1JeUlHRlJRV016Z0JNVGdCTVRJMk5RY09BU014SWlZbkxnRTNNVFlXRng0Qk16STJOejRCRnpFV0JnY0RlUnBFS0FNTEJoNGhEb1VRR0h3UUp3MEJCUW9HSWtRZUdCd1BJUk13SEFFTENRSU1CQWdEQlFNQlBsSVFKQm9lU1NqK09RUUhCRHBBUURvSlNnSVNCeEFJSGtFaUpFZ2pCU0VCSFVNYkhpb0hCZ01JSFdzQmZLT2dKQXdaRGJFK2drQUJBd01QRW9FTkJBd0NBUUVEQWhLSUZnRUJBZjQrRW9BT0JBd0NBUUlDRW9rVkFRRUNBYUFiRXhNYkd4TVRHeG9MQ1FnTURBZ0JDQXY0R3hNVEhCc1VFeHNhREFnSkRBd0pDQXdpRHpjYkhEWVFEQVlCQWdjTkREVWNIRFVNREFnQkFRWU1Bc29hSGdFQlRoUXVDd1FGQlFRSk1SVWlJZ0VDQWdJQkFRRURGaDhhUWliK3hDOVVKUlVjQlQ4SURBUUNCaFVjQVFJR0FnWUREMlZCQVQ4c1dDYjl3Q0VQQVFwWU9LVlNVamhZQ2dFSUFRRS9GZzRzQkFJQ0FRTURCQU1CQkEwTkRpOHZCd2dCQncwUE5TSWZSQi9ES1V3aGhnRUJCQ2dNQVFFQ0FRMG9BZ0lWSHhVS0FnY0VBUU1CQXdVQkRSTXJBUUlDQWdNQ0h4VUtBZ2NFQVFNQkF3VUJEUk1yQVFJQ0FnTUNUeFVlSGhVVkhoNENBUWtNREFrSURBc0lFeFVlSGhVVkhoNENBUWtNREFrSURBc0l4d3NNREFzSkVRRUNBZ1lIQ2dzR0JnSUNBUklJQUFBQUFBVUFHd0F5QStVREx3QVNBQ3NBT2dCTEFGVUFBQUU0QVRFeU5qVTBKaU1pQmhVNEFURVVGak1ERlNVM0p5NERCdzRCQnc0QkJ5NEJKeVlPQWdjVkJTRXdCaFVVRmpFaE1EWTFOQ1l4SlNFeU5qVVJOQ1lqSVNJR0ZSRVVGak0zSWpZMUVTRVJGQll4QVg4YkppWWJHeVltRy9vQ09jWUxCVGhOVmlVcFZCWUtGUXNPTGhZWVNFVTJCUU5EL0hBZEhRT1FIUjM4cXdNYUZCa1pGUHptRkNBZ0ZCSUJBUUx6QVFJOEpoc2JKaVliR3liK3Z5WUVEQWtXZTM5ZEN3dGxKUklsRXhnM0R4RXJSa29QSElzR0dCa0dCaGtZQmpnVkV3SXRGQjhmRlAzVEV4VS9EUWdCN2Y0SEJBVUFCZ0FnQUZvRDJRTWpBREFBYUFCMkFJa0FtUUNzQUFBQkxnRWpNU0lHQnc0Q0ZoY2VBVE02QVRNK0FUY3pIZ0VYRmpJek1qWTNQZ0V1QVNjdUFTTWlCZ2NPQVNNaUppY0JEZ0VqSWlZakxnTXhMZ0VuSXlJR0J3NEJCeUlqSWlZbk1DWStBVGMrQVRNeUZqRWVBVHNCTWpZM1BnRXpNaFlYSGdJR01RRXpGU01WSXpVak5UTTFNeFV6QlJRR0l5SW1OVFEyTXpJd01USVdGVGdCTVNjNEFURVVCaU1pSmpVME5qTXlGaFVWT0FFeEZBWWpJaVkxTkRZek9BRXhNaFlWQWVVVlV6VkRjeWdySkFjS0FneFdQd1FIQkE5ZVZ0TldYZzhFQndRK1Z3d0NDZ2dqS3lseVF6UlJGZ1lOQndZTUJRR1pCaUllQWdRQ0VURXVJQWNVQy9zTUV3Y0laeUlFQXg4aUJRb0VIU2NoU3lNeFJRa1ZDeW9NRlFrSlBERWpTeUVuSFFNSi9pa0ZPVVk2T2tZMEFZTVpFaEVaR1JFQkVSbHFHUklSR1JrUkVoa1pFaEVaR1JFU0dRTHNEeWhLUWtlT2RsSUxSRkFCSjJSbEpnRUJVRVFMVVhXTlIwTkdJUTBEQkFNQy9oTWdLUUVCSnkwbENBa0JDZ2NJY0FNb0lEOW1mMEEySnlrR0NBZ0dCeUluTmtCL1pqOEJKa1U2T2tVNk9pY1JHUmtSRWhrWkVqOFJHUmtSRWhrWkVuVVNHUmtTRWhrWkVnQUxBQmNBQWdQbkE0Z0FMUUJlQUhnQWlRQzJBTU1BMWdEcEFQOEJGUUVvQUFBQkl6YytBVFU0QVRFdUFTTWlCZzhCSnk0Qkl5SUdGVGdCTVJRV0h3RWpEZ0VIRVJRV015RXlOalVSTGdFbkV4UUdJeUVpSmpVUk5EWXpJU2N1QVRVNEFURTBOak00QVRFeUZoOEJOejRCTXpJV0ZUZ0JNUlFHRHdFaE1oWVZFUUVoTUNJeElnWVZPQUV4RlJRV016QXlNeUV5TmowQk5DWWpFeFFHSXlFaUpqMEJQZ0V6SVRJV0hRRW5KZ1l4RGdFckFTSW1KeTRCQndZV01SNEJOejRCTVQ0Qk16Z0JNVE00QVRFeUZoY2VBUmNXTmpjaU5pY0hGU01WSXpVak5UTTFNeFV6RnlJbU5UUTJNeklXRlRnQk1SUUdJemdCTVRVaUpqVTBOak15RmhVNEFURVVCaU00QVRFWE9BRXhJaVkxTkRZek1oWVZPQUV4RkFZak9BRXhKUlFHSXlJbU5UUTJNemdCTVRnQk1USVdGVGdCTVNjME5qTXlGaFVVQmlNNEFURWlKalU0QVRFRGFxb1hEQThCTkNZVElReFlXQXdoRXlVMURnd1hxak5KQVVvekF0WXpTZ0ZKTXpjZkdQMHFHQjRlR0FGSGhnTUVEd29GQ2dPR2hnTUtCUW9QQkFPR0FVY1lILzdTL29VQk1FUkVMd0VCQVhzd1IwY3dWalVrL29Ja0x3RXlKQUYrSkRHQkpGRUVDZ1VUQlFvRUJFNGpJZ2NDRVE4UU1RTUpCWEVGQ1FNRExoQVBFUU1CQ0NPMUhCd1hGeHdjYUFnTEN3Z0lDd3NJQ0FzTENBZ0xDd2d3Q0FzTENBZ0xDd2dCVHlBV0ZoOGZGaFlnYXg4V0ZoOGZGaFlmQXRrVkRDRVRKVFVPRFZkWERRNDFKaEloREJVQlNUUCtIek5HUmpNQjRUTkpBZjJpR0NBZ0dBSGhHQ09GQkFrRkNnOEVCSWFHQkFRUEN3VUpBNFVrR1A0Z0FkOUVNUE13UTBJeDh6QkUvcGNrTVM4aitpTXpOQ1QxeWpraEF3TURBd01mT2psbkR4TUNBVFVEQXdNRUF6SUJBUklRWmpvZkdod2NIQjBkUEFzSUNBc0xDQWdMTlFzSUNBc0xDQWdMSFF3SUNBc0xDQWdNR1JZZkh4WVdJQ0FXa3hZZkh4WVdJQ0FXQUFBQUFBTUFHdi9UQStjRG9BQVVBQ3dBUXdBQUJTSXVBalUwUGdJek1oNENGUlFPQWlNUk9BRXhJZzRDRlJRZUFqTXlQZ0kxTkM0Q0l4TStBVFUwSmk4QkVUUW1JeUlHRlJFWEhnRXpNalkzQWdCa3NZUk5UWVN4WldTeWhFeE5oTEZsVTVKdFB6OXRrbE5Va20wL1AyMlNWTjRGQmdvSXBCNFZGUjNJQnhBS0N4VUhMVXlFc21SbHNZUk5UWVN4WldTeWhFd0RlRDl0azFOVGttMUFRRzJTVTFPVGJULzlrZ1lSQ1F3VUI0Z0JEQlVkSFJYK3hLWUdCZ29KQUFBQUFnQVhBQnNENVFOWkFBWUFDZ0FBRXhjVE53VVRBUUVuQ1FFWHZEWGZBU2ZYL0RJQktRc0NMLzNjQWVwaS9wUFdoZ0x1L3BIKzRwOEJlZjNvQUFBQUFBVUF1UC9kQTBZRHFnQWpBRElBUUFCSkFJWUFBQUV5SGdJVkZBWUhPQUV4RkFZak9BRXhJVGdCTVNJbUp5NEJOVFErQWpNNEFURVRNaFlWRkFZaklTSW1OVFEyTXlFVk1oWVZGQVlqSVNJbU5UUTJNeGNVQmlzQklpWTFNd01PQXhVVUZoY2VBUmNVRmhjT0FSVVVGaGNPQVJVVUZoY2VBVHNCTWpZM1BnRTFOQ1luUGdFMU5DWW5QZ0UxUGdFM1BnRTFOQzRDSnpFQi96ZGhTQ3BiREJBTC92QUpEd0lYVVNwSVlUZUZDeEFRQy83MkN4QVFDd0VLQ3hBUUMvNzJDeEFRQy9ra0lsMGtJK3AwUTNkWk5DUVVFQnNGQmdVRUJBVUVCQVVmR1FvOUtHb29QUWthSUFZRUJBVUVCQVVHQlJzUUZDUTBXSGRFQTIwcVNHRTNiVlYyQ3hBTENITmdiVGRoU0NyOWdROExDeEFRQ3dzUFdRNExDd3NMQ3dzT1VoWWhJUllEWndFeldYZERSRllqSFRzdkNoUUpCeE1LQ3hVSkNCUUxIQ3dLSlRBd0pBb3RIQXNVQ2dnVUN3b1RDUWdUQ2k4N0hpSldSRVIyV1RNQkFBQUVBTlQvMXdNc0E2WUFIUUFyQURrQVFnQUFBVEllQWhVVUJnYzRBVEVVQmlNNEFURWhJaVluTGdFMU5ENENNeE15RmhVVUJpTWhJaVkxTkRZekJUSVdGUlFHSXlFaUpqVTBOak1GRkFZckFTSW1OU0VDQUQ1dVVTOW5EaEVOL3M0TkVBRVpYQzlTYlQ2V0RCSVNEUDdVRFJFUkRRRXNEUkVSRGY3VURSRVJEUUVaS2lacEp5Z0JDQU9tTDFGdVBucGdoZ3dTRHdlQmJYbytibEV2L1RBUkRRd1NFZ3dORVdVUERBME5EUTBNRDF3WkpTVVpBQUFBQkFDVy85MERhUU9xQUJzQU13QlRBR0VBQUFFeUhnSVZGQVlIQXc0Qkl5SW1Kd011QVRVMFBnSXpPQUV4RVRJK0FqVTBMZ0lqSWc0Q0ZSUXdNUjRETXhFNEFURWlEZ0lWRkJZWEpqSVZFeDRCTXpJMk54TStBVFUwTGdJbk1SRWlKalUwTmpNeUZoVVVCaU14QWdBL2IxTXdHUmoyQVFZREF3WUIrQllaTUZOdlB5cExOeUVoTjBzcUtrczNJUUVnTjBzcVM0UmlPUjhiQVFIMkNSOFNFaDRLOWhzZU9HS0VTejFYVnowK1ZsYzlBM0V3VTI4L0xsVWovb0VDQXdNQ0FZRWpVeTQvYjFNdy9nSWdPRW9yS2tvNElDQTRTaW9CS2tvNElBSTJPR09EU3paa0tnRUIvb0VPRWhJT0FYOHFZemRMZzJNNEFmNEJWejArVjFjK1BWY0FBQUFDQUpQLzJRTm1BNlVBSGdBdUFBQUJPQUV4SWc0Q0ZSUVdGeVl3TXhNZUFUTXlOamNUUGdFMU5DNENJeEVpSmpVME5qTXlGaFU0QVRFVUJpTUIvVXVFWWprZkd3RUI5Z2tmRWhJZUN2WWJIamhpaEVzOVYxYzlQVmRYUFFPbE9XS0VTelprS2dIK2dBNFJFUTRCZ0Nsa05rdUVZam4rQWxZK1BWZFhQVDVXQUFrQVMvL1pBN2dEcVFBb0FDMEFNUUExQURrQVBRQkJBRVVBU1FBQUFTRXFBVEVpQmhVY0FURVJIQUV4RkJZek1ESXpJVEF5TVRJMk5UQTBOUkV3TkRVMEppTXdJakVGTXhVak5RRWhOU0UzSVRVaE55RTFJVFVoTlNFMUlUVWhOU0UxSVRVaE5TRURldjBRQVFFWkpDUVpBUUVDOEFFWkpDUVpBZjFuK2ZrQnB2NWFBYWFXL2NRQ1BBWDl4QUk4L2NRQ1BQM0VBanorMUFFcy90UUJMQU9wSkJrQkFmeXVBUUVaSkNRWkFRRURVZ0VCR1NTWG1wcjlZaVZDS2tJbFFpcENKVUlxUWlVQUJnQ3EvK0lEVFFPZkFCWUFQUUJMQUZnQWF3QitBQUFCSVNJR0ZSRVVGak1oTURJek1qWTFOREF4RXpRbUl3TU9BU2N1QVRFdUFTY2pEZ0VIRGdFSEJpWW5NQ1kzTmhZeEhnRVhNejRCTno0QkZ4WUdNU2N6RlNNVkl6VWpOVE0xTXhVekZ4UUdJeUltTlRRMk14NEJGUWNVQmlNaUpqVTBOak00QVRFeUZoVTRBVEUxRkRBeEZBWWpJaVkxTkRZek9BRXhNaFlWQXQzK1FDNUZSUzRCd0FFQkxEOERRaTRsQXhJUkVUWURDZ1Y3QmdvREJESVJFUklEQ0NjbVdRVUtCaFFHQ2dVRVZTWW5DT2NCSEJ3ZEhSd2J2Z3dKQ1F3TUNRa01OQXdKQ1F3TUNRa01EQWtKREF3SkNRd0RuejR0L1JZc1BEOHNBUUxtTFQ3OXhSRVVBZ0U3QkFRQkFRUUVCRGNCQWhRUmNEOC9Kd01FQVFFRUF3UWlQejV3a0J3aElSd2RIUklKREF3SkNBMEJEQWdiQ1F3TUNRa01EQWs2QVFnTkRRZ0pEQXdKQUFBQUJBQWQvKzBENEFPTUFEWUFSZ0NEQUpZQUFBRVVCZ2NPQVFjT0FRY09BUWNqTlRRMk56NEJOejRCTno0Qk5UUW1KeTRCSXlvQkl5SUdCdzRCQnljK0FUYytBVE15RmhjZUFSVUJJZ1lWRkJZek1qWTFMZ0VqT0FFeEp4NEJGUlFHQnc0QkJ3NEJCeFFHRlJRV0Z3Y25MZ0UxUEFFMVBnRTNQZ0UzUGdFbkxnRW5KaUlIRGdFSERnRVhCeVkyTno0Qk56NEJGeDRCRndNT0FSVVVGak15TmpVMEppY3VBU01pQmdjRDRBNE1EVGdxSHlZSUNBZ0J6QVlHQnhJTUREb3NHaG9NQ3dzaEZRRUJBUlVtRGc4U0JORUhMQ1VtZDFBL1pTWTBNLzY2TGtKQ0xpOUNBVUV2NVFJREFnTUVHaFVQRWdNQkFnS0dBZ1FGQVFZRkJoc1dEUWtEQXcwS0NSY09EeGNHQndNRGpnWUtFaEpITkNsSUhTa3pDNFFZSHkwZklDMENBUWNwR2dVTEJnS2ZHUzhVRlRnaEdTWVFEaUlWREJ3c0VSSWZEUTh6SlJVbkV4SWVDZ29MRVE0T0xpRWFPbDRqSlNVYUdTTmNPLzVXUVM4dVFrSXVMMEhrQnhFSkNCRUlFQzhlRmlFTEJRa0ZDQThJSmdnTkhCQUJBZ0VOR0FzTUxDRVRIZ3dMRWdVRkJBUVNEQXdpRmhjblJoNGZNQThNQWdvTU15Yitxd2dvR2lBdExTQUdDd1VZSHdJQkFBQUFBQUVBR0FCUkE5VURJd0FYQUFBSkFRWW1QUUV3TGdJbkhnTXhOVFEyRndFZUFRY0QxZjdpQ1E2czM5UXBWK0RIaWc0SkFSNElBUWtCZ2Y3UUJ3Y0xnVEdDNHJGZFh5Y0Rmd29IQnY3WkJ4SUdBQUFBQUFjQUhRQTJBK2tET0FBTkFCNEFSUUJWQUdnQWRBQ0hBQUFsRkFZeElUQW1OVFEyTVNFd0ZnTVJGQVlqSVNJbU5SRTBOak1oTWhZVkJTWUdNUTRCS3dFaUppY3VBUWNHRmpFZUFUYytBVEUrQVRjekhnRVhIZ0VYRmpZM01EWW5CeUlHRlJRV016STJOVFFtSXpnQk1UVWlCaFVVRmpNeU5qVTRBVEUwSmlNNEFURUhOU01WSXhVekZUTTFNelUzSWdZVkZCWXpNalkxT0FFeE5DWWpPQUV4QStrZC9HNGRIUU9TSFNrbEUvenJFeHNiRXdNVkV5WCsyeWRaQlFvR0ZRVUxCQVJXSmlZSEF4TVFFVFlFQ1FaOEJRb0RCRE1RRVJNQ0NDWlBDUXdNQ1FrTURBa0pEQXdKQ1F3TUNaQWhIQndoSEtrSkRRMEpDQTBOQ0ZjWkNBZ1pHQWtKQXBmOTBoUVlHQlFDTGhNZkh4UEJRQ1lEQlFRRUF5TS9RSEVSRkFFQlBBUUVBUUVFQkFRNEFRSVZFWEUvTncwSUNRME5DUWdOT2d3SkNRd01DUWtNSUJjWElSd2NJUUVOQ1FnTkRRZ0pEUUFGQUIzLzF3UERBNlVBRkFBcUFEVUFUd0I0QUFBQkZUSVdGeDRCRnhZVUJ3NEJCejRCTno0Qk16VXhJZ1lIRGdFeEhnRXpNajRDTnpZbUp5NEJJekVQQVM0Qkp3NEJNUlkyTndFT0FRY09BUWNPQXdjdkFqNEROejRCTno0Qk56Y2lEZ0lIRGdNeEJoWXhGeDRCTXpnQk1USXdNVEErQWpjK0F5Y3VBU000QVNNeEFSQUtFQWNUSUFVQ0RnNWZjUk1xRmdRa0Z5WTVDRHBURFJvTVRteEhKd2tpSnpJTUhSQXlNd2tSQlRCQVFXVW1BcjRERnh3aFh6d2pSMEUyRUI4V0F4RTFPVFlSR0dVMlFFOFREQjl3ZEdjWEYweEhOQkF1T0JJTkFRRXdUVjR2Um0xQUVCVURDQVFCQVJzcUJ3VU5IQXNFRXhjV1h3b2VYRU1NSkNvMUdLNUhBUUVrTVRJT05rRWtDUXVrT3hJaUVIWXhCUTRPQTRnTU5DNHplMEluU2o4d0R4d1ZBeGRIUzBRVkcySXVOVEVHTFVoaVl4c2NZV0JHRWdzMEN3VXFTRjgwVDQ5d1N3c0NBUUFBQUFBQkFBQUFBUUFBSlFSTGRWOFBQUFVBQ3dRQUFBQUFBTlFhY2RJQUFBQUExQnB4MHYvOS84QUVCd1BCQUFBQUNBQUNBQUFBQUFBQUFBRUFBQVBBLzhBQUFBUUEvLzMvK1FRSEFBRUFBQUFBQUFBQUFBQUFBQUFBQUFETUJBQUFBQUFBQUFBQUFBQUFBZ0FBQUFRQUFBVUVBQUFBQkFBQUFBUUFBREFFQUFBTEJBQUFJZ1FBQUNBRUFBQUFCQUFBQkFRQUFBQUVBQUFBQkFBQU13UUFBRE1FQUFCTEJBQUFBQVFBQUpRRUFBQUFCQUFBQUFRQUFPb0VBQUFuQkFBQUd3UUFBRlVFQUFBQUJBQUFCUVFBQUYwRUFBQmlCQUFBWWdRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFXQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFGRUJBQUFBQVFBQUFBRUFBQUFCQUFBQWdRQUFRSUVBQUI1QkFBQUFBUUFBQUFFQUFEVkJBQUExUVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBVkJBQUFYd1FBQUY4RUFBQ0pCQUFBbHdRQUFBY0VBQUFIQkFBQUFBUUFBQUFFQUFBQUJBQUFtd1FBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQTBFQUFBQUJBQUFBQVFBQUJvRUFBQWJCQUFBQUFRQUFBUUVBQUFBQkFBQUFBUUFBQUFFQUFFVUJBQUFBQVFBQUJvRUFBQUFCQUFBZEFRQUFBQUVBQUFBQkFBQVdRUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFjRUFBQUFCQUFBQUFRQUFGQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFpZ1FBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQ0JBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUJBUUFBRE1FQUFBekJBQUFNd1FBQUJRRUFBQUVCQUFBRXdRQUFBQUVBQUFBQkFBQU9nUUFBRlVFQUFBNkJBQUFPZ1FBQURvRUFBQTZCQUFBT2dRQUFEb0VBQUFBQkFBQUNBUUFBQUlFQUFBQUJBQUFCQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUF3QkFBQVVnUUFBQUFFQUFBQUJBQUFjUVFBQUZRRUFBQUFCQUFBQUFRQUFDSUVBQUFjQkFBQXJ3UUEvLzBFQUFBQUJBQUFBQVFBQUFNRUFBQWlCQUFBTWdRQUFDTUVBQUNEQkFBQVBRUUFBREVFQUFBeEJBQUFIQVFBQURNRUFBQUFCQUFBUlFRQUFFTUVBQUJNQkFBQVNnUUFBQ0FFQUFCWEJBQUFHd1FBQUNBRUFBQVhCQUFBR2dRQUFCY0VBQUM0QkFBQTFBUUFBSllFQUFDVEJBQUFTd1FBQUtvRUFBQWRCQUFBR0FRQUFCMEVBQUFkQUFBQUFBQUtBQlFBSGdCYUFMd0ExQUVDQVk0QnhBSUdBbG9DeWdNcUExWURrQVFnQkpBRTNnVkFCWlFGNkFaa0Jxd0hYQWVBQjc0SUdBaHNDTUlKRWdvY0NuNEswZ3Q2REE0TVNneUFESjRNOUExQ0RYb04vQTZVRHJvUUhCQ1lFUlFSd0JJQUVqNFNmaEs4RXZvVE9oTjZFN29VTGhTZ0ZSSVZoQlc0RmV3V0lCWlVGbkFXamhhcUZzUVhuaGlPR05BWTdCa2VHVG9aY0JtNkdmQWFHaHBFR29BYXZCc3VHN29jVWh6cUhkWWVHQjZPSHJRZlRpQlVJSlloQmlGZ0ljWWpMQ051SkJRa2ppVGtKV1lsemlaSUo4WW9LaWlPS05BcE5DbUdLY0lxQkNxR0t0WXJMaXU2Sy9nc1FDeDJMVHd1Q0M3OEw5NHhFREtTTXc0elpqUTROUWcxZmphVU54dzRVamlXT1N3NWhEcGVPNEk4TkR5RVBaQStnRDllUVFKQ1ZFUDRSYVJHNUVneVNacEx3azdJVDVKUVFGQ3lVUVJSWGxId1VuaFQvbFJ3Vk01VmFsWjJWckJYR2xnS1dOWlpmbG5rV2tKYWlGclVXNEpjSWwzNllOQmhBR0dLWW5CaXptTWlZNFJrQ0dTR1pheG1mbWJpYUZwbzBHbXNhd1pyWkd1RWJEUnNrRzBTYlZKdHRtNVliekp2WEhBR2NLNEFBQUFCQUFBQXpBSkxBQllBQUFBQUFBSUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEZ0N1QUFFQUFBQUFBQUVBQ2dBQUFBRUFBQUFBQUFJQUJ3QjdBQUVBQUFBQUFBTUFDZ0EvQUFFQUFBQUFBQVFBQ2dDUUFBRUFBQUFBQUFVQUN3QWVBQUVBQUFBQUFBWUFDZ0JkQUFFQUFBQUFBQW9BR2dDdUFBTUFBUVFKQUFFQUZBQUtBQU1BQVFRSkFBSUFEZ0NDQUFNQUFRUUpBQU1BRkFCSkFBTUFBUVFKQUFRQUZBQ2FBQU1BQVFRSkFBVUFGZ0FwQUFNQUFRUUpBQVlBRkFCbkFBTUFBUVFKQUFvQU5BREliR1ZuYnkxcFkyOXVjd0JzQUdVQVp3QnZBQzBBYVFCakFHOEFiZ0J6Vm1WeWMybHZiaUF4TGpBQVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXdiR1ZuYnkxcFkyOXVjd0JzQUdVQVp3QnZBQzBBYVFCakFHOEFiZ0J6YkdWbmJ5MXBZMjl1Y3dCc0FHVUFad0J2QUMwQWFRQmpBRzhBYmdCelVtVm5kV3hoY2dCU0FHVUFad0IxQUd3QVlRQnliR1ZuYnkxcFkyOXVjd0JzQUdVQVp3QnZBQzBBYVFCakFHOEFiZ0J6Um05dWRDQm5aVzVsY21GMFpXUWdZbmtnU1dOdlRXOXZiaTRBUmdCdkFHNEFkQUFnQUdjQVpRQnVBR1VBY2dCaEFIUUFaUUJrQUNBQVlnQjVBQ0FBU1FCakFHOEFUUUJ2QUc4QWJnQXVBQUFBQXdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3R5bGVzL2ZvbnRzL2xlZ28taWNvbnMuZW90XG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3Q7YmFzZTY0LGlyb0FBS0M1QUFBQkFBSUFBQUFBQUFJQUFBQUFBQUFBQUFBQkFKQUJBQUFBQUV4UXJ3QUFvRW9BQUZBQUFBQUFBQUFBQUpNQUFBQUFBQUFBYjE1MlR3QUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDSUFUQUJ2QUhZQVpRQmtBQ0FBWWdCNUFDQUFkQUJvQUdVQUlBQkxBR2tBYmdCbkFBQUFEZ0JTQUdVQVp3QjFBR3dBWVFCeUFBQUFKQUJXQUdVQWNnQnpBR2tBYndCdUFDQUFNUUF1QURBQU1BQXlBQ0FBTWdBd0FEQUFOZ0FBQURJQVRBQnZBSFlBWlFCa0FDQUFZZ0I1QUNBQWRBQm9BR1VBSUFCTEFHa0FiZ0JuQUNBQVVnQmxBR2NBZFFCc0FHRUFjZ0FBQUFBQUFBRUFBQUFSQVFBQUJBQVFSa1pVVFdEVGVXOEFBQUVjQUFBQUhFZEVSVVlCRkFBRUFBQUJPQUFBQUNCUFV5OHlTRDFOVWdBQUFWZ0FBQUJnWTIxaGNOQitMZTRBQUFHNEFBQUI0bU4yZENBS0hndlRBQUFEbkFBQUFDeG1jR2R0VTdRdnB3QUFBOGdBQUFKbFoyRnpjQUFBQUJBQUFBWXdBQUFBQ0dkc2VXYlZzazJzQUFBR09BQUFvOGhvWldGa0Mrd3ovZ0FBcWdBQUFBQTJhR2hsWVE0ZUE2c0FBS280QUFBQUpHaHRkSGlWZkNieUFBQ3FYQUFBQTV4c2IyTmh0R1RjL2dBQXJmZ0FBQUhRYldGNGNBSURBV01BQUsvSUFBQUFJRzVoYldXWlNMK3RBQUN2NkFBQUJmUndiM04wRzg5QklnQUF0ZHdBQUFMSGNISmxjRW4yT09JQUFMaWtBQUFBOG5kbFltYkVrRmRmQUFDNW1BQUFBQVlBQUFBQkFBQUFBTXc5b3M4QUFBQUF3UkJoa0FBQUFBRFRoWFVQQUFFQUFBQU9BQUFBR0FBQUFBQUFBZ0FCQUFFQTVnQUJBQVFBQUFBQ0FBQUFBd0xnQVpBQUJRQUVCWm9GTWdBQUFSb0ZtZ1V5QUFBRDBBQm1BZ0FBQUFJQUFBQUFBQUFBQUFDZ0FBQ3ZVQUFBU2dBQUFBQUFBQUFBU0V3Z0lBQkFBQTM3QWdabS9tWUFBQWh0QkNnQUFBQ1RBQUFBQUFSeEJ1NEFBQUFnQUFFQUFBQURBQUFBQXdBQUFCd0FBUUFBQUFBQTNBQURBQUVBQUFBY0FBUUF3QUFBQUN3QUlBQUVBQXdBRFFCK0FMUUEvd0ZUQVhnQ3hnTGNJQW9nRkNBYUlCNGdJaUFtSUM4Z09pQmZJS3doSWlYOCt3TC8vd0FBQUEwQUlBQ2dBTFlCVWdGNEFzWUMzQ0FBSUJBZ0dDQWNJQ0lnSmlBdklEa2dYeUNzSVNJbC9Qc0IvLy8vOWYvai84TC93Zjl2LzB2OS92M3A0TWJnd2VDKzRMM2d1dUMzNEsvZ3B1Q0M0RGJmd2Ryb0JlUUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQmdBQUFRQUFBQUFBQUFBQkFnQUFBQUlBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFEQkFVR0J3Z0pDZ3NNRFE0UEVCRVNFeFFWRmhjWUdSb2JIQjBlSHlBaElpTWtKU1luS0NrcUt5d3RMaTh3TVRJek5EVTJOemc1T2pzOFBUNC9RRUZDUTBSRlJrZElTVXBMVEUxT1QxQlJVbE5VVlZaWFdGbGFXMXhkWGw5Z1lRQ0Zob2lLa3BlZG9xR2pwYVNtcUtxcHE2eXVyYSt3c3JTenRiZTJ1N3E4dlFCeVpHVnAzSGVnY0d2amRtb0FoNWtBY3dBQVp3QUFBQUFBQUd4N0FLZTVnR051QUFBQUFHMTgzV0tCaEpiQnd0VFYyZHJXMTdnQXdNTUE0dC9nNWVZQWVOamJBSU9MZ295SmpvK1FqWlNWQUpPYm5Kb0F4TVZ4QUFBQWVRQUFBQUFBQUFRRG9nWU1BRzhBeHdBdkFFVUFWQUJnQUh3QWlRQ1dBSm9BRFFCZ0FGSUFZQUJ1QUdJQVR3QmRCUkd3QUN5d0FCTkxzRXhRV0xCS2RsbXdBQ00vR0xBR0sxZzlXVXV3VEZCWWZWa2cxTEFCRXk0WUxiQUJMQ0Rhc0F3ckxiQUNMRXRTV0VValdTRXRzQU1zYVJnZ3NFQlFXQ0d3UUZrdHNBUXNzQVlyV0NFaklYcFkzUnZOV1J0TFVsaFkvUnZ0V1JzakliQUZLMWl3Um5aWldOMGJ6VmxaV1JndHNBVXNEVnhhTGJBR0xMRWlBWWhRV0xBZ2lGeGNHN0FBV1Myd0J5eXhKQUdJVUZpd1FJaGNYQnV3QUZrdHNBZ3NFaEVnT1M4dHNBa3NJSDJ3Qml0WXhCdk5XU0N3QXlWSkl5Q3dCQ1pLc0FCUVdJcGxpbUVnc0FCUVdEZ2JJU0ZaRzRxS1lTQ3dBRkpZT0JzaElWbFpHQzJ3Q2l5d0JpdFlJUkFiRUNGWkxiQUxMQ0RTc0F3ckxiQU1MQ0F2c0FjclhGZ2dJRWNqUm1GcUlGZ2daR0k0R3lFaFdSc2hXUzJ3RFN3U0VTQWdPUzhnaWlCSGlrWmhJNG9naWlOS3NBQlFXQ093QUZKWXNFQTRHeUZaR3lPd0FGQllzRUJsT0JzaFdWa3RzQTRzc0FZcldEM1dHQ0VoR3lEV2lrdFNXQ0NLSTBrZ3NBQlZXRGdiSVNGWkd5RWhXVmt0c0E4c0l5RFdJQyt3Qnl0Y1dDTWdXRXRUR3lHd0FWbFlpckFFSmtramlpTWdpa21LSTJFNEd5RWhJU0ZaR3lFaElTRWhXUzJ3RUN3ZzJyQVNLeTJ3RVN3ZzByQVNLeTJ3RWl3Z0w3QUhLMXhZSUNCSEkwWmhhb29nUnlOR0kyRnFZQ0JZSUdSaU9Cc2hJVmtiSVNGWkxiQVRMQ0NLSUlxSElMQURKVXBrSTRvSHNDQlFXRHdid0ZrdHNCUXNzd0JBQVVCQ1FnRkx1QkFBWXdCTHVCQUFZeUNLSUlwVldDQ0tJSXBTV0NOaUlMQUFJMEliWWlDd0FTTkNXU0N3UUZKWXNnQWdBRU5qUXJJQklBRkRZMEt3SUdPd0dXVWNJVmtiSVNGWkxiQVZMTEFCUTJNanNBQkRZeU10QUFBQUFBRUFBZi8vQUE4QUFnQkVBQUFDWkFWVkFBTUFCd0F1c1FFQUx6eXlCd1FHN1RLeEJnWGNQTElEQWdidE1nQ3hBd0F2UExJRkJBYnRNcklIQmhYOFBMSUJBZ2J0TWpNUklSRWxJUkVoUkFJZy9pUUJtUDVvQlZYNnEwUUV6UUFBQUFJQWxnQUFBVWdIY3dBSUFBOEFPUUN5QndBQUt3R3dFQyt3QU5hMEJCRUFGd1FydEFVUkFCY0VLN0FETXJNSkJBQUlLN0VNRHVteEVRRXJzUXdKRVJLeEJ3STVPUUF3TVRjME54WVhGUVlqSWhNUkZ4RUhJeWFXVVZnSkd5bFVEbUVQR2podE56Y2xOelZLQkY0REZUajdEeE1uQUFBQUFBSUFnd1NvQWZvR3FBQUpBQk1BUXdDeUF3SUFLN1FTQkFBSUJDdXlBUUlBSzdBTU03TUlFZ01JS3dHd0ZDK3dBTmEwQlJFQUhnUXJzQVVRc1FvQks3RVFEK214RlFFckFMRUlFaEVTc0JBNU1ERVROVFl6TWhjQ0t3RWlOeEl6RmhVR0R3RWpJb01JSTBvVUp4d2JLOUViVkRkSURBNE5Od1lySzFJMy9wbEVBUWdVRjVQaURnQUNBQzhBZlFTcUJaRUFRUUJMQVF3QXNna0JBQ3V3RnpPeUZnRUFLN0laQVFBcnNDMHZzRE16c1VRSTZiQTdNckl0UkFvcnMwQXRNUWtyc2tRdENpdXpRRVE1Q1N1d1FDK3hBZ1BwQWJCTUw3QTgxckFGTXJGQ0QrbXdEREt3UWhDeEJ3N3BzQWN2c0RNenNnZENDaXV6UUFjQUNTdXdCeEMwTGhFQU1nUXJzRUlRc1NvQks3RVFSakl5c1NJUDZiRVdHakl5c2lJcUNpdXpRQ0lZQ1N1d0dUS3dJaEN3RlNEV0ViRVNEdW13RWkreEZRN3BzVTBCSzdBMkdyb0ZZY0E2QUJVckNyQVdFTEFYd0FTeEdnUDVBckFhTGdHd0Z5NndRQm9Cc1JJOEVSS3lCaXd3T1RrNXNCVVJ0Uk1tS1N0RlNTUVhPUUN4UkMwUkVySWhLemM1T1Rtd1FCR3pIQ0FmUmlRWE9iQUNFclFBUFQ1SVNTUVhPVEF4RXpjWE16STFOeWMyT3dFeUZSTXpOajBCQXpjWEJ4YzNGeFVIRlJjek1qY1hCUWNYQmlzQkx3RWpOeWNISXhVVUJ5TWlKd2NqSWljME54WXpOelVuQmdVbUJSUTdBVGMxQXlNR0ZTODNqSHVaREJvVUZSd2JEamlKR3pnM0RoeW1OOTBOSzNRK04vN3NEUTBUSlJvUERnd2FHbU5ES3lrYkRtQ21SQ3RFYU1rYUdseit5amNDTnltTUdnNE10UU5vS1E1VVV0RTNLLzYwRXlVY0FXY2NLWHpzRGlrM0hYM3BHeWxoYm05aURpbnNIQTVVU0FxbURrVWxJU3R2dEJ3Y0R3ODMzaDBiQVRFVk1RQUFBQU1BZVFBQUF5RUhGd0F3QURZQVFBQ3pBTEl0QUFBcnNoSUNBQ3V5TWdFQUs3RU1CK215R1FFQUs3TWJMVElJSzdRZUZ3d1NEU3V4SGdmcEFiQkJMN0FBMXJBTk1yRUhEK213TVRLekVRY0FDQ3V4RkJIcHNBY1FzUWtCSzdRM0R3QWdCQ3V3TnhDeFBBRXJzU1FSNmJNYkpEd0lLN1FhRHdBZ0JDdXhRZ0Vyc1JRUkVSSzJBd1FNRUJZeU5DUVhPYkFKRWJRWEhoOGdNeVFYT2JBM0VyRWRMems1c0R3UnN5SW5LaXdrRnprQXNSNHRFUkt5TkRrL09UazVzQmNSc0JBNU1ERVROanNCRndZZEFSWXpOUUlqSnpVME53TTNGaDBCQmpNRUVRY2pOQ1VqQnhVUUZ4WVZGQThCRlJZWEJnY2pJaWNrRXhjekp5TUhFeEk3QVRZOUFUUW5JM2tqTVE0TUdqbDdMWGxpZnpvcFJnNWlBWU1PS2Y3ZE53M043dEZFRFJvWUh3eEFFdjdiWWtRUUhSb2R6eTBsSFpudEd3SjcraXMyWW03QkRBTDZtQ2xGVWdFWkhSTVdPTVpkL3ZZcnY0RVBEdjZpaGZUVmIyQU9VbDRFUGdiNGt3T2tWSXNjL2l2OThTRnJLYWpNQUFNQWlRQUtBbHdHL2dBTUFCTUFHZ0JnQUxJT0FnQXJzQVV6c0JrdnNSVUo2YkFTTHdHd0d5K3dBTmF3RFRLeEN4SHBzQXNRc1FNQks3RUhFZW13RnpLeEhBRXJzUXNBRVJLeER4STVPYkFERWJJSkVCUTVPVG13QnhLeEZSazVPUUN4RlJrUkVyQUJPYkFTRWJBSk9UQXhOelVTRXpRM014VUNBeUlWQndNM014Y1VCeVlCTnpNWEZBY21pZHVPU3g5bzFSMHZTamdyTjBZNUFTRTNLVGRET2g5TEFpNERwNFk1SmZ6by9SeXNKd1pwTnpjbElSWDZVVGc0SkI4U0FBTUFnUUQyQStjR2d3QWVBQ1VBTFFDZ0FMSUdBZ0Fyc1N3SjZiQWNMN0VmQSttd0dDK3hGZ2Jwc0JNeUFiQXVMN0FDMXJFS0R1bXdDaEN4S2dFcnNRZ1A2YkFJRUxFUEFTdXhHZy9wc2hvUENpdXpRQm9ZQ1N1eUR4b0tLN05BRHhFSks3RXZBU3V4Q2dJUkVyUUdJQ0lvTENRWE9iQXFFYkFwT2JBSUVyQU1PYkFQRWJBVE9RQ3hIeHdSRXJBQU9iQVlFYlVDQ2hFTUdTSWtGem13RmhLeEVoUTVPYkFzRWJJRUNDZzVPVGt3TVJNMk5RTTFOak1XRlJBREZCTXpNaE0wSnpVM0Z6TTNGeFVIRlJBaEl5STNNelVuSXlJSEV4SXpOaE0wSnlLQitHOGxjNlp2VkNsWUNIdHZlMVJnRHQzK2ZZdDd3WHdPR2lVdktDRXpIeGxHTXdGSStxVUNzME9tUGJ2KzJmNXpUUDhBQVdreElUY2REUTBOTnplYS9uRnViMFNtQkJyK09pY0JKTU0xQUFBQkFFb0VtQUQyQm1BQUNRQXFBTElFQWdBcnRBa0VBQWtFS3dHd0NpK3dBdGEwQmhFQUhnUXJzUXNCSzdFR0FoRVNzQWs1QURBeEV6UTNFak1XRlFJSEkwb2dNaVUxWlJ3TEJNTTVOUUV2R2pqK3FCNEFBQUFBQVFBdC8vZ0NWZ2VIQUJNQUl3Q3lFZ0FBS3dHd0ZDK3dBTmF4Q1EvcHNna0FDaXV6UUFrRkNTdXhGUUVyQURBeEV6VVFOek1WRkFjREZSQUJId0UzRnhVR0l5QXQzUjE3S3dFakRDdHZEQkpkL3VJRWdjTUJycFVNSjlIK3RMYitHZjNkRVJwRkRneC9BQUFBQVFCS0FBb0NFQWNkQUE4QUdBQ3lBZ0lBS3dHd0VDK3dETmF4Qmc3cHNSRUJLd0F3TVJNME56SVhBQkVDSXljMU5oRTFFQUZLTjFBUUFTOXFxaW5kL3NNR3ZEd2x6LzF6L2xqOThROHBvd0ZPTndGeEFxb0FBQVFBUkFGdEF6MEZzZ0FuQUMwQU5BQTVBSVFBc2dVQkFDdXlFZ0VBS3dHd09pK3dIOWEwR2hFQUd3UXJzQkF5c0JvUXNCa2cxaEcwS2hFQUV3UXJzQ292dEJrUkFCTUVLN0FhRUxFM0R1bXdOeSt5R2pjS0s3TkFHaFVKSzdBYUVMQU9JTllSdEFzUkFESUVLN0FMTDdRT0VRQXlCQ3V4T3dFcnNUY3FFUkswSUNNdU1qVWtGem13Q3hHd0hUbXdEaEt3RnprQU1ERWJBVFVuTmpjWE1oY3pNamN6RmhjR0hRRVVId0VWRkE4QkZSY0dLd0VtSnpjbUx3RWpJZ01tRXpJOUFTTWlOeFk3QVRjbkl6Y1hNelVqUk4xRUFqVU5JU1FQTTRGRUhoazNwU3ZkRGlrSVNnNGRHdzhyRFE0T0YvNUYzVlFkSTNjSUlSME1LU2szR3c0T0FoSUNEeWw5UnljT1lPc0lQYUpZR3gwTU54MGZNMFhldEVVSVBXQkdpdzMrM3d3QlRGUWJibEpHR293ZE53QUJBRklCQUFOS0JJTUFIQUJPQUxJSkFRQXJzQnd2c1FNRDZiSWNBd29yczBBY0dBa3JBYkFkTDdBRjFyRU1EdW15QlF3S0s3TkFCUUFKSzdFZUFTdXhEQVVSRXJNSkdSb2JKQmM1QUxFREhCRVNzaEFUR3prNU9UQXhFelUwT3dFM05TYzJOeGNIRlJRekpSY1ZGQVVWRXdZckFTWVNJd1ZTcGxSRERCTXhOd3dwQVJRYi9zSTRFeFlkWUJZbC91QUM1U2tiRG94UlNpVWJwVzhkSFNzTUp4OE8vbjFHUWdHVkhRQUFBUUNML21BQldnR05BQXNBSFFBQnNBd3ZzQURXdEFjUkFCUUVLN1FIRVFBVUJDdXhEUUVyQURBeEV4STFKemMxTWhjQ0t3RWlpMkVOS1JrNVRGb01IZjZIQVkydGxTc01RLzBXQUFFQVpBTFBBdkFEZ1FBSEFDWUFzQVV2c1FNSDZRR3dDQyt4QUFFcnRBVVJBQWNFSzdFSkFTc0FzUU1GRVJLd0FUa3dNUk0xSlRNWEZRUUhaQUpVRFN2K2plRUMrRVZFS1NrcE53QUJBTFlBQUFGV0FLNEFCZ0FxQUxJRkFBQXJ0QUlNQUJnRUt3R3dCeSt3QU5hMEF4RUFHZ1Fyc1FnQkt3Q3hBZ1VSRXJBQk9UQXhQd0V6RnhRSEpyWThLemxLT1dCT1RqTXRHd0FBQVFCNUFBWUNVQVhOQUF3QUpnQUJzQTB2c0FEV3NRc1I2YkFMRUxFREFTdXhCdzdwc1E0Qks3RURDeEVTc0FrNUFEQXhOelVTRXpRM014VUNBeUlWQjNuSnJrTWRpOEVkSmhRNEFaRURaMkFwRy8wQy9lcDlHd0FBQUFBQ0FDZi83Z0pxQmRzQUNRQVVBQzhBc2dnQUFDdXhEQVBwQWJBVkw3QUExckVLRCttd0NoQ3hEd0Vyc1FVUDZiRVdBU3V4RHdvUkVyQUhPUUF3TVJNMUFpVWtFeEFGSXlJVEVCY3pNaE1RTHdFR0F5Y2xBUWdCQ2xiKzdBejJKWmtkeHlPWU42d2xBbWhJQXVGS09mMlUvTW1EQXdiOS9wWUM2Z0hSU3gwbi9nb0FBQUFCQUQ4QUFBRjdCa1FBRHdBMUFMSUxBQUFyc2dFQ0FDc0JzQkF2c0E3V3RBa1JBQndFSzdJT0NRb3JzMEFPRFFrcnNSRUJLN0VKRGhFU3NRY0xPVGtBTURFVE56TVhCeFVVRXhjVkZBY2lKemMwUHljck9CdW1KMUl4SXhBR0p4MDRWRktsL0E0cERuVWpLVkxaQUFBQUFRQWovL29DVEFZakFCVUFRZ0N5RFFBQUs3SURBZ0Fyc3hRTkF3Z3JBYkFXTDdBQTFyUVRFUUF5QkN1eEZ3RXJzUk1BRVJLeERnODVPUUN4RkEwUkVySUpCdzQ1T1Rtd0F4R3dFVGt3TVJNMkVqY1dFUUlETmpjekZ4UUZKelVBSnlJREJ5SWpLWk0rYmtWaGtwMFBLZjZMYndFVmZWQVFLU1VFTWRVQkdRUWovdVA5S2Y1NUViQXBwbjBkREFVN0gvNTlIUUFBQUFBQkFEY0FGd0o3QmFZQUpnQndBTElnQVFBcnNRSUs2YklGQVFBcnNCVXZzUVlJNmJBbEx3R3dKeSt3Rzlhd0FESzBGeEVBTWdRcnNDTXlzQmNRc1IwQks3RUVFZW13QkJDeEV3RXJzUWtPNmJFb0FTdXhGeHNSRXJRTEVRNGlKU1FYT2JFRUhSRVNzUUlHT1Rtd0V4R3dGVGtBc1FJZ0VSS3dCRGt3TVJNU014WVZGQU16TWhVUUFTWTFJelkzRndBUk5DY2lEd0VqSmljU1BRRW5OU0lIRnhRSEpqZG55RVpnUSt6K04wTVBHeDBwQVZwaHNrY3BIUnNjK1E1aUd3OVNLd1A2QWF3VlMxVCttZnIreGY3QkNEMUFCQTBCQXdFWU0wcmRLd2c5QWFxM053NFArZzhvS1FvQUFBRUFOLy82QWNjR2RRQWVBRXdBc2hnQUFDdXlDd0lBS3dHd0h5K3dIZGF4QmhIcHNBWVFzUWtCSzdBYk1yRVBEdW13RWpLeElBRXJzUVlkRVJLeUFoNGNPVGs1c0FrUnNRUWFPVG13RHhLeUN4UVlPVGs1QURBeEV6WXpNaGNIRXhjek54QXpNaGNERVRNV0J4VUhGd1lyQVNZMUV3Y25FamNYTFNVaEd3d3JSQ3RTSUFrYkRtK0xEeXNjR3gwM0U4YzNEZ1dZUlVWUy9URXJLd1ArUnY3cy9aTWRpWm5lUTFRZE53R2tGU3NEUmdBQUFBRUFQZ0F4QXJJR1hBQWlBRllBc2dZQ0FDdXdJQyt4RHdqcEFiQWpMN0FCMXJBV01yRU1EK213REJDeEhRRXJzUk1PNmJFa0FTdXhEQUVSRXJNQ0dCa2lKQmM1c0IwUnRBb0VEUnNnSkJjNUFMRVBJQkVTc0EwNXNBWVJzUUlLT1Rrd01SSUNNelF6TWlVWEZRWUZCaEVYTXpjek1oTVZBZ1FuTlRjMU1oYzJFelVtSXlJSFB3SThibTBCUWh4Sy9tVkVEUTZYRDkwcHBQN2RSeEFiVk1KdEdZMHhyQUpjQXZoaXBoME9kNE9GL3I5OUd2NjFEZjZ3YXBjYkVBMW5Ld0UwSE5GVUFBQUFBZ0JFLytrQ1JBWVNBQlVBSWdCYUFMSVVBQUFyc2dNQ0FDdTBEaDhVQXcwcnNRNEo2UUd3SXkrd0FOYXhDUS9wc0FrUXNSc0JLN0VSRCtteEpBRXJzUnNKRVJLekJnd1VGaVFYT2JBUkViQU9PUUN4SHhRUkVySU1DeGc1T1RteEF3NFJFckFHT1RBeEV6VVFPd0V5RndZZEFSUVRNeEl6RmgwQkVBOEJJamNXT3dFeUV6VTBKeU1pQXhkRVlCMGVDbEVwR2luNlJzOUc2K3NLSHlsVUd5a1BYaXNPQTlsaUFkZEhkWS82NVA3SEFib2lUTUgrUW5jZCtrY0JrMjlIQy82WlJ3QUFBQUFCQUJmLzhBS1JCU3NBSGdCN0FMSVZBQUFyc2dVQkFDdXhHZ2Jwc2djQkFDdXdBak95QndFQUs3TWRGUWNJS3dHd0h5K3dHZGEwRWc4QUlBUXJzUXdPTWpLd0VoQ3pGeElURGl1MEZ4RUFGd1Fyc0JjdnRCTVJBQmNFSzdFZ0FTdXhHUmNSRXJFVkdqazVzQklSc0FjNXNCTVNzd2dMRFJBa0Z6a0FzUjBWRVJLeERCYzVPVEF4RXpVM0Zqc0JNamN6RnhVR0F6TUhGUmNIRlJjR0l5SW5FaE1qQnljSEpoYzNOMkFkdklFcEtUY2JEdzhQRHpnYlZDVWdKQ0VPK0N0dlVRU1RIVGNjWUNrT2JmMW5EUndwUnNBNGJrTUJBZ05RS1E0T0hRQUFBQU1BUkFBR0FrUUdMUUFSQUJvQUlnQTFBTElFQWdBcnNBMHZzUndENlFHd0l5K3dBTmF4R2hIcHNTUUJLN0VhQUJFU3NBODVBTEVFSEJFU3RBc1FGQmNoSkJjNU1ERVROQ1UvQVJZZEFRSVZGaGNDSXlJMUV5WTNGQmN6RXpVakJoVVRGekkzTlRRbkJrUUJrUTRwT041dktVREdiMitCTzJJYml3NzZOeDE1RUZKQkJLcmJmUkFiRGtSSS9YdFd4ckQreEtZQi91ZisyV1lCMVdJOXJ2dnpHckkzWTI0eEFBSUFJZi82QXA0RndRQWFBQ1VBa3dDeURnQUFLN0lqQVFBcnNRSUo2YklXQVFBcnNnQUJBQ3UwSFJrT0FnMHJzUjBJNlFHd0ppK3dBTmF4R3hIcHNCc1FzUk1CSzdFVkh6SXlzUXNQNmJBSk1yTWJFeEFPSzdRTkVRQWJCQ3V4SndFcnNSQWJFUkt6RnhrZEl5UVhPYkFURWJBVU9iQUxFcklFQXc0NU9UbXdEUkd3Q2prQXNSa09FUkt4Q1JBNU9iQWRFYkFLT2JFQ0l4RVNzUU1IT1Rrd01STVNJUmMzTXpJVkJoRXpCeEVYQnlJbk56VVRKemMxSXdZaklqY1dNeklUTlNZckFRWUhJWXNCSTBOR0hTbEdEZzRwTnpncER3NE9EaDEwa3NKdUt6aXVaZzVHVW4xVUEvb0JyQTRwT0tqK0xRNzkxNlkzVkdBcEFicFVwaHVZcGtVQmRCMHBMY3NBQUFBQ0FJa0I2UUZNQkJJQUNBQVFBRVVBc2dJQkFDdXhCd3ZwQWJBUkw3QUExclFGRVFBWkJDdXdCUkN3RGlEV0ViUUpFUUFlQkN1d0NTKzBEaEVBSGdRcnNSSUJLN0VGQ1JFU3N3SUdDdzhrRnprQU1ERVROamNXSFFFSEl5SVRORGNXSFFFSEpva0VYME1uRUVJTFIwUkVSd1BCS3lZU1RCQW4vcGRPRXhFWUt6Z1RBQUFDQURIOWR3RmlBekVBREFBVEFDTUFBYkFVTDdBTjFyUVJFUUFiQkN1eEZRRXJzUkVORVJLekFnUUZBeVFYT1FBd01STTJFU2MzTlJjSEZ3SWpGU1lUTkRjV0ZRY21NZDBhS1VVT0RqUEhOMkJHVkN0di9hQ1hBaXV5S3cwcE4rejlnd3dVQlY0bEl4OVBLeXNBQUFBQUFRQjNBUjBDdWdRVUFCQUFKUUN5QkFFQUt3R3dFUyt3QU5hMENoRUFDQVFyc1JJQks3RUtBQkVTc1FZSk9Ua0FNREVUTkRjMkpSWVZGQUVIQlJVSElpVW1KM2VKVUFFek4vNmFEZ0YwS1NmKzNDZU9BazVESzNmaERDc1kvdWxHOXlzcHp4d1BBQUFDQUx3QStBTmNBbzhBQndBUEFFUUFzQTB2c1FzSDZiQUZMN0VEQitrQnNCQXZzQURXdEF3UkFBY0VLN0VSQVN1eERBQVJFckVFQ0RrNUFMRUxEUkVTc0FrNXNBVVJzUUFIT1Rtd0F4S3dBVGt3TVJNMUpUTVhGUVFQQVRVbE14Y1ZCQWU4QWxJUEtmNk4zeUVDVWc0cC9vM2ZBZ1pFUlNrcEt6ZTZSVVlyS1NrM0FBQUJBRTRCZ3dLdUJOc0FFZ0F1QUFHd0V5K3dEZGEwQ2hFQUZnUXJzQW9Rc1JJQks3UUlFUUF5QkN1eEZBRXJzUW9ORVJLeEJoQTVPUUF3TVJNMU5EYzFNaGNFRlJRRkZBY25OVFEzTmpWT055bkJBVC8rd1dGZ3RNOEViVGNsQmd6TmkzMUQraDhuR3pjdk01WlVBQUFBQWdDeUFEOENVZ2J5QUJ3QUpnQnVBTElNQWdBcnNnVUNBQ3V3SlMreEh3dnBBYkFuTDdBYjFyQUtNckVURCttd0NESzBGUkVBSGdRcnNCMGcxaEcwSWhFQUdRUXJzQk1Rc1FRQks3RVBFZW14S0FFcnNSTWJFUkt5QWhjZk9UazVzQlVSc2lBa0pUazVPYkFpRXJBR09RQ3hEQjhSRXJFSkZ6azVNREVUTkRjU1BRRW5JZzhCSnhJN0FUSVZGQU1IRlJZWEJnY2pKaWMzRUJNMU56TVdGUlFqRlNheXBvc3JKemtwTjJSY0hYM1JLUWdoRWpJT0hSb09ERVlwTjFJNUE4RTNiZ0VIVkdBcjNSMHBBWGZSYmY1RW1JbkFFVGtiQ0VCU0FSTDlKUTVFR3pjM0RSTUFBQU1BTGYrREJCSUZsZ0FMQUNZQUt3QjdBTElKQUFBcnNRNEQ2YkliQVFBcnRCUWdDUnNOSzdFVUEra0JzQ3d2c0NuV3NSNFA2YkllS1FvcnMwQWVIUWtyc0I0UXNTTUJLN1FIRVFBZEJDdXhMUUVyc1I0cEVSSzBDZ2tjRmlVa0Z6bXdJeEd5QlJNUk9UazVBTEVVRGhFU3NRMFhPVG13SUJHeUVSWW9PVGs1c0JzU3Noa2hLVGs1T1RBeEV6VVFKVEkxTWhNUUJTTUVFd0lGTXpJM0JnY2pJalVBRWpjMEZ6TVhCeEl6TnpZVEVDVUVFd0lsRXdJdEFkMk81WlgrSlJiOStLTnFBWEV2c0dnWUh6YzQvbTgzMjBJcEt3Z2xWa2M2RnY2Yy90ZVZtUUV0Q2lNQitFTUN6M0ViL1p2ODA0RWRBNHo5R0JUSURncG0vdlFFRjFZY0FocDkvU1FWcUFFR0FjdGlKZjVsL1hUTEFhWUJiUUFDQUJUL2ZRTGpCcVVBRkFBZUFFUUFzaFFBQUN1d0NqT3lCQUlBSzdFZEJPa0JzQjh2c0EzV3NCZ3lzUWdPNmJRSkVRQWVCQ3V4SUFFcnNRZ05FUkt4Q2hvNU9RQ3hIUlFSRXJJQURoWTVPVGt3TVRjU0V4SXpNaGNXR3dFSEl5Y1JKeU1FQndJSEl4TVhKRDBCTnljbUl5SVVSSnBtdHdjSGxRWXJSUjBwRGczK3RSODFHemUwUkFFVURpSW5LMWdqQWc0Q2V3SDVBUVQ2cFA1RkRDa0NBTThwWS80SkJnTHBOVDBoK3JTTHBnQUFBQUFEQUF6L21BTG5CeEFBSFFBbkFEQUFod0N5SEFBQUs3SUpBZ0Fyc0E4enNoVUJBQ3V4SkFQcHNnY0JBQ3NCc0RFdnNBTFdzQWN5c1NjTzZiQW9NcklDSndvcnMwQUNCUWtyc0NjUXNTSUJLN0VYRWVtekVSY2lDQ3V4S3hIcHNDc3ZzUkVSNmJFeUFTdXhKd0lSRXJBYk9iQXJFYlFLRFJRa0V5UVhPUUN4SkJ3UkVySWVLQ2s1T1RteENSVVJFcklyTFM4NU9Ua3dNUmMyRVRRMUp6VTNFanNCRmhVek5qY3lGeFFERlRjeUZ4QUJCZ2NqSmhNek1oTTNOQ01FSFFFUk13QTNKaWNpQndNTVVDa3BCa1lwUmd4L2JIY2gwM3RtTS83Z3NMY3BLNllQc09zZGIvNjBKd0ZNQmhnZmk2UVRGOXdDUnh3Y0poRnVBeWNyUTFBUXRISCtzaEFRM2Y3ay9wL250Z3dCRkFJZGI5MTVnU3NCSlFGTzN6OEd6djZmQUFBQUFRQWwvK2NDNFFiTkFCb0Fad0N5R0FBQUs3RVJBK215RVJnS0s3TkFFUlFKSzdJRUFnQXJzUWtENlFHd0d5K3dBTmF4RGc3cHNnNEFDaXV6UUE0SENTdXdEaEN4RkFFcnRCVVBBQ0FFSzdFY0FTdXhEZ0FSRXJBYU9iQVVFYkVKR0RrNXNCVVNzQVE1QUxFSkVSRVNzQm81TURFVEVBRTJNeFlkQVJRakJnTUNFUlVTTXhjek5oTXpGUUlqSWdNbEFVVzFibFI5NjFhZUc2WXJVazlsS1VpdzZvMEJ5d0pXQWMvZEhSb2RHM3YrNnY3Ry9uME8vbUlPSXdFcEQvNVVBVnNBQUFJQUNQKzJBdGtHNlFBU0FCd0FVUUN5RUFBQUs3SUlBZ0Fyc1JvRzZiSUdBZ0FyQWJBZEw3QUQxckVjRCttd0hCQ3hGd0Vyc1F3TzZiRWVBU3V4SEFNUkVySU9FeFE1T1Rtd0Z4R3hCZ2c1T1FDeEdoQVJFcklEREJNNU9Ua3dNUmNURWhNMU5ETVdNd1FSRmhVUUFRWWpJalUzTXpZVE56VUNJeUlWQ0ZJZEhHOWtYUUVVQXYzRkZUMDRtZ3p3c2gwMS9HTUdBVm9CcUFLaWw3U0xsLzdQSEJ6K1F2MmZpVVQ2andIKzdGUUJXTUVBQUFFQUsvL2RBcFFHelFBaUFFMEFzaUVBQUN1eEd3UHBzZ2tDQUN1eUVBRUFLN0FUTXdHd0l5K3dCTmF4RUEvcHNoQUVDaXV6UUJBTUNTdXhKQUVyc1JBRUVSS3lGeGdaT1RrNUFMRVFHeEVTc3dJQUhCOGtGemt3TVRjVEp6WTFBelFqTkNVV0hRRVVCUU1WRkRNbEZ4VVVCUU1WRkRNbEZ4WVZGQVVpSzBRcE53NGRBWU5HL3NBS0p3RUlEUDdGTjI0QmN4Z0Iva21IOGdKU1JXazlBVjZLYmtnVEdDa3JQUDRkUmh3Y0RnNDNPUDJnRzVlWFZBRUJHSmdBQVFBSS82d0Mxd2M3QUNRQW53Q3lKQUFBSzdJTUFnQXJzaEFDQUN1eEZBcnBzaGtCQUN1eUF3RUFLN0lZQVFBcnNoMEJBQ3V5SHdFQUt3R3dKUyt3QjlheEZ3L3BzaGNIQ2l1elFCY1NDU3V5QnhjS0s3TkFCd1FKSzdOQUJ3b0pLN0VtQVN1d05ocTZEMExCMkFBVkt3cXdHQzRPc0J3UUJiQVlFTEVmRXZtd0hCQ3hHUkw1c0I4UXN4MGZIQk1yQTdNWUdSMGZMaTR1THJCQUdyRVhCeEVTc2drTURUazVPUUF3TVJjU0VTWTFORDhCRVRjbk5EY1hNell6RnhVVUJRWVZBeGNsRnhVVUJ4UUhJZ01IRlFjSW1HRmhEZzRyWXd5TDEwd3AvdnJERGc0QkZSelFVaVZLRGxJZEFnc0J2aDhuSURRM0FRVGRTQ2MzREVNM0RDVWhQYjMrMFNsRUd4d2ZKUnNRL05OaWpEY0FBUUFqLzc0QzZRYkpBQjRBTlFDeUhRQUFLN0VQQStteUJRSUFLN0VJQitteUZ3RUFLd0d3SHkrd0FOYXhEUTdwc2cwQUNpdXpRQTBIQ1N1eElBRXJBREF4RXpVUUFUWXpGaDBCSUFNQ0ZSRVNNeElSTlRRdkFUUWxNaGNIRndJakpDTUJHcWkvUmY1YlVtODN0YVdsRHdFVkpTQmlIVVRSL3NNQjEyOENUUUdlbUJFWUsvNTUvcCs4L3V2K2NRRVZBWEpJb0QwbllnMUViN1Q4dHBJQUFBSC85ditlQXZBR29nQW1BRGdBc2hnQUFDdXdKRE95QmdJQUs3QVJNd0d3Snkrd0R0YXhGUS9wc2c0VkNpdXpRQTRaQ1N1eEtBRXJBTEVHR0JFU3NRd2ZPVGt3TVFjVEp6SVRFanNCRnhVaUF4Y2tOUkl6TnhZVkJnTUNLd0VuRXlNM05UY25CQlVERlFjaU5RcFNHMElnUGpFTU9FcENLd0ZNSHpVcFJsSWZFazRQS1NrT0RnOFAvb3c0TnlrckF0MVVBb2NCRlRnYy9POE9HUjRDNkJBU0dZLzlIZjBJS1FHUkRJek9EeHRVL1pKU0t6Y0FBQUFCQUMvLzhBRkFCbFlBRWdBNEFMSVJBQUFyc2djQ0FDc0JzQk12c0FEV3RCQVJBQnNFSzdBUUVMRUVBU3UwQ1E4QUlBUXJzUlFCSzdFUUFCRVNzUUVPT1RrQU1ERTNOaEk3QVRVMk16SVZGQWNHQWhFWEZRY2lMeDExS0IwT0N5RUlISEFiUkR0U0lRWE1Ed2hOSkRYTC9VeitaVlFiTndBQkFCMEFBQUloQnU0QUV3QXdBTElTQUFBcnNRUUk2YkFFRUxFUUJ1bXlDd0lBS3dHd0ZDK3dCOWF4RGcvcHNSVUJLd0N4Q3dRUkVyQUJPVEF4UHdFekZqc0JNaE0xRXpZN0FRY0RBaU1VSXlZZERpa2hNMUtrSGdVYUt4c1BCQ0RMZTR2Qk41Z0RUQXdDbnBpWS9TdjhtaHNaQUFFQUgvOTFBdTRHbGdBY0FGSUFzaHNBQUN1eUZRQUFLN0VUQnVteUJBSUFLN0FOTXdHd0hTK3dBdGF4Q0EvcHRCRVJBQllFSzdFZUFTdXhDQUlSRXJJRUdCbzVPVG13RVJHeUJna1hPVGs1QUxFRUV4RVNzZ2dYR0RrNU9UQXhGeklUQXpjV0Z3Y1JNd0ExTmpNWEJnRVZFak1WQnlJREl3TUhJeUlmTVRFT1JTMExIU2tCVERzek9HSCtwbmZKUnFhbURrWU1OeU5VQThjQytpa1BLYy85TWdKRjJ6aEdoZjBRS2Y0QU53d0I0LzJ1RGdBQUFBQUJBRWIvN0FLTEJzTUFGQUJLQUxJU0FBQXJzUTBKNmJJRkFnQXJBYkFWTDdBQzFyRUpEK215Q1FJS0s3TkFDUVlKSzdFV0FTdXhDUUlSRXJJRkN3MDVPVGtBc1EwU0VSS3hBQkE1T2JBRkViRUNEems1TURFM0VoRUROak1YQnhNVkVBTVZGek0zRnhRaElqVkdiZ1lPT0RjckNEY2IrWW9jL2Y0M0l3RWZBaTBESERncndmNW16djY2L21nTUhTa3BmRGNBQVFBdi83NERwQWJGQUM0QVlBQ3lMZ0FBSzdJSUFnQXJzaElDQUNzQnNDOHZzQUhXc0FNeXNTc1A2YkFyRUxFZUFTdXhHQTdwc2g0WUNpdXpRQjRjQ1N1eE1BRXJzU3NCRVJLeEtDazVPYkFlRWJFTkZqazVzQmdTc0JzNUFMRUlMaEVTc3cwT0dpQWtGemt3TVRjVEl6YzFFQ2MyTnpNV0V4WVRNeE0xSnpRek5SWVZFeFVVQnlNbk56VVFBeU1DQXdjaUF3SW5JeGNWRUNzQkx6Y09EaWtiSFNsRllVVlNLN0lNUkZSZ0tSMHBEMVFOVkdCVVRCU1lLUTRPVkNrRUFqY050QUtUV0VBRUJQNW1nLzZzQTB3cFZEY1BJVUw2WTJGSEN4dlBLd0pXQWRIKy9QMTBLQUZtQWMwbHovcjhtUUFBQUFFQU5mL1ZBM01HM3dBdEFJUUFzaUVBQUN1eUN3SUFLN0VYR1RNekFiQXVMN0FEMXJFQkNESXlzU2NQNmJNZUF3QU9LN1FxRVFBZUJDdXdKeEN4RlFFcnRCa1JBRElFSzdJWkZRb3JzMEFaSGdrcnNTOEJLN0VEQUJFU3NBSTVzQ2NSc3dZTEtTc2tGem14RlNvUkVySVRJeVU1T1Rtd0dSRzBFQkVVR2hza0Z6a0FzUXNoRVJLeUVCRWFPVGs1TURFM0V5YzNFVFEzTlNjMU5qTXlFeFlURnpNMUF6Y25OamN5RlFjWEV3Y1hCZ2NqSWdNQUp5SURGd2NUQnlNaU5SME9EamMzR3pjOXJsU21id3hNRFEwTExVTWFDRVVPR3hzZEtUTnkvcTVBSlJJT0RoMHBEMHB0QVpFT1JnSkVwVlFiUmlrMy9rYWkvZUhkbHdRVHdFWXBEb2xVNGZ2WE42WkFCZ0dnQTZvYy9pdkNmZjVVTndBQ0FDc0FBQUw2Qmd3QURnQWFBRjRBc2cwQUFDdXhFUWZwc0JZdnNRTU42YklERmdvcnMwQURCUWtyQWJBYkw3QUIxckVhRCttd0doQ3hFd0Vyc1FvUDZiRWNBU3V4R2dFUkVyRVBHRGs1c0JNUnRRZ01EUkVERmlRWE9RQ3hFUTBSRXJBTU9iQVdFYkFLT1RBeEV6VVNNelEzTXpJWEJCRVFCUWNpQXhJeklCRTFBaU1pQXhjVksyQnZmUTVNSXdFRy91dUw0d1lwemdFK1NObTJYZ3dCeDZZREJpdHVmY3o5L3YzNXJnd0NEUDVHQW9rM0FsVDg3QTRQQUFJQU8vLzBBc1VHcGdBVUFCd0Fad0N5RHdBQUs3SURBZ0Fyc0FVekFiQWRMN0FTMXJFVkQrbXdEVEt3RlJDd0RDRFdFYkVSRWVtd0VTK3hEQkhwc0JVUXNSZ0JLN0VIRHVteEhnRXJzUklSRVJLeEVBSTVPYkFNRWJFRER6azVzUmdWRVJLeENRUTVPUUN4QXc4UkVyRVZHams1TURFVE5qVTNGemNFRlJBQkJoVVJGd1lISnlNVE5UUVRNd0EzTkNNaUZUc3BVamkwQVNQK0RoMFBFek1wRGl0U0tRRkxLOUhPQmRkSVVEY3BEQnpjL3Y3K2EwaXkvc05TVmljcEJKZTBQdjNSQVFqcHo4OEFBQUlBSndBQUEzTUdzZ0FZQURJQVhnQ3lGZ0FBSzdFYkIrbXlCUUlBSzdFSUNPa0JzRE12c0FEV3RCa1BBRFlFSzdBWkVMRW5BU3UwREE4QU5nUXJzVFFCSzdFWkFCRVNzQmc1c0NjUnRnTUdDUWdURmc0a0Z6a0FzUnNXRVJLd0ZEbXdDQkd5RVJNdk9UazVNREVUTlJBQk56TVhGQWNWQUJFVkZBTVdGd2NpSndZUEFTSUROeEl6TmpVMEFUVTNNeklUTXpZVEFpc0JJZ2NqSnpjaklnTW5BVCtLSENkU0FTOUROWEU0SkhXZ1BYdlJSRGd2MSt2KytCMGFIOXNQS0E5amVnOGdDUm9SRVJHTmh3STFIUUtMQWFvckt4WWhEUDczL21NZDd2N3dpVlJHbU5rRUd3RjFSZjZZZmFaREFaSXJHdjU5U2dGaUFoMDNRMGI4d2dBQ0FCVC9OUUs2Qmg4QUlBQXJBSWtBc2g4QUFDdXdGak95Q3dJQUs3RW9CK2tCc0N3dnNBSFdzQVl5c1J3UjZiQWhNckFjRUxRRUVRQVpCQ3V3QkMrd0FET3dIQkN4QWcvcHNBSXZzQndRc1NVQks3RU9FZW14TFFFcnNRSUJFUkt3Qnptd0hCR3lDQWthT1RrNXNDVVN0QW9SR1NJUUpCYzVzQTRSc1JNV09Ua0FzU2dmRVJLMEJBNFJHU0lrRnptd0N4R3dCemt3TVQ4QkV5STFOajBCTnpNWE56TXlGUUlGRlJJZkFSVUhJZ3NCSXhVWEVDc0JJaE1YTXdBOUFTY2pJZ2NERkNzYlJqZ3JER0w0TjN0MC92SCtlVGRGVnIrWEt4QklKeUNQR3h3QlBEZ01tNGdNU29rRDR6aFVLRzhwR3pqRC9uTzJLLzBPVEF3M09BSCtBVm9PNmY1dUEzVWRBUmZiUlRoOS9vc0FBQUFCQUVMKy9nTHdCdU1BSGdCckFMSWRBQUFyc2dRQUFDdXlEUUlBSzdFVUNPbXpFaDBOQ0NzQnNCOHZzQURXdEFNUEFEWUVLN0FERUxFS0FTdXhGeEhwc0JjUXNRY0JLN0VhRHVteElBRXJzUW9ERVJLd0JUbXdGeEd3SFRtd0J4S3dGVG13R2hHd0dUa0FzUklkRVJLeUFnb1hPVGs1TURFWE5qc0JGak1nRXpVQUVSQS9BVElYRlNNVkppc0JCaFVRQVJjUUJRY21RaEFZSFMwekFUNHIvcnJmWVRGMUcyOUZSbWdCTHc3K3cyUE9NVU95QVlORUF1NEJiUUV1Snd4Z053OUdPc3YrcHYwRFJQN3N0aHM3QUFBQUFBSC8rZ0FBQTVnR1RBQWtBRjRBc2hZQUFDdXlBZ0lBSzdBR003RWpDZW15QlFJQUt3R3dKUyt3RzlheEZBL3BzQkF5dEE4UEFDQUVLN0liRHdvcnMwQWJHQWtyc1NZQks3RVBHeEVTc1FVV09Ua0FzU01XRVJLeEVoazVPYkFDRWJRREJBc1BJU1FYT1RBeEF6VTNGelkzRnlVWEZSUWpGU2NFQnhzQkZ3Y1ZGQWNtSnpVMlBRRTNKeE1DS3dFSEpnWXBwcVkzVkFGMUtUZzMvc2NURHdRTURFWkFCRGdNREFnZkpVWGVSUVhES1NnYURDc2RPQThwS0E4UEtSMytZdjJXVWthWFFpMGJIQ2xLTXpmNFJnRlVBZ0FPRWdBQUFBRUFNZi9zQXJvR1hBQVpBRllBc2hnQUFDdXhEUW5wc2dJQ0FDdXdFek1Cc0JvdnNBRFdzUXNQNmJBSE1ySUxBQW9yczBBTEJRa3JzQXNRc1JJQks3UVZFUUFiQkN1eEd3RXJzUklMRVJLeUF3a1lPVGs1c0JVUnNoQVJGams1T1FBd01STVNPd0VYRlFJZEFSY0hGUkk3QVRJVE53TTNNaFVEQWlFaU1TRS9LUnRRREF3dFRnN0hhZzBySzI0TWpmN2Z6d1BEQXBrZERQM211VklPRGtUOXVnTUhwUUgwTjZYK2lmdkpBQUFBQVFBdC8vd0MvQWE2QUJRQVZRQ3lFUUFBSzdJQkFnQXJzQW96QWJBVkw3QUExclFERVFBT0JDdXdBeEN4QndFcnNRNFI2YlFNRVFBYkJDdXhGZ0Vyc1FNQUVSS3dFem13QnhHeEVCRTVPYkFPRXJFS0R6azVBTEVCRVJFU3NBVTVNREVUTnpJVEZqTVNFVFVUTnhZVkZBY0NBd2NpSnlZdE4xS2NTaGFtQ2taVUt4bmRRMElTWVFZVU9Qc2xzd0pJQVVoN0FjZ3BIQnN2TWZ6ci9SY3B6L3dBQUFBQkFFai91Z1FDQnM4QUxRQ1BBTElxQUFBcnNnTUNBQ3V3SGpPeUV3RUFLN1FqR0NvVERTdXhJd3ZwQWJBdUw3QUExckVKRCttd0N6S3dDUkN4RVFFcnRCVVJBQmNFSzdBVkVMRWFBU3V4SVE3cHNTOEJLN0VKQUJFU3NRUXNPVG13RVJHMEJnb05KeWtrRnptd0ZSS3lEeFlsT1RrNXNCb1JzaGdkSXprNU9iQWhFckFlT1FDeEdDTVJFckFOT2JBVEViTUxDaVVuSkJjNU1ERVROUkk3QVJZWEFoVVJGd2NXTXpZVE5TYzJNeklYQnhJek1oTTFOQU0zRmhVVEFpTWlBd1lEQWdjaklpY2pTQUpGRFM4SU53NE9DaCtMc2hzakwxQVREeng1U1JjcE56Y2JNNDJrVmlXUW5Vd2RJd1lPQW51bUE0RVBLZjR5NVA1VXdDdVl5d0xUWWlsZ1lHRDhwZ0h4N01jQjAyQU9SUHlrL1Q4RElSZitKZjR5QnpnQUFBQUFBZi9wL3hRRERBYWtBQjRBS1FDeUhnQUFLN0lPQWdBckFiQWZMN0FDMXJFVEVlbXhJQUVyc1JNQ0VSS3lDQXdhT1RrNUFEQXhCd0FUTlFNM016SVRGeFE3QVJJM0ZoY0dBeFVTRndZckFTWURCZ01QQVJjQkxsYlBLUTR0ZVE0YkhhZHRMUXB1dzVKMkZCY01IOXNudG9sR3d3SEZBYkJHQW5zcC9qa09LUUtxWEE0cGx2MEVEdjdMdlRjRUFad2gvZmo2RFFBQUFBQUJBRFgvcWdMd0Jzc0FJQUJiQUxJZkFBQXJzUVFJNmJJWUFnQXJzQkF6dEFvV0h4QU5LN0VLQ3VrQnNDRXZzQTNXc1JRTzZiSVVEUW9yczBBVUVna3JzQjR5c1NJQks3RVVEUkVTc0E4NUFMRUtCQkVTc2dFREhEazVPYkVZRmhFU3NRY0dPVGt3TVRjMU16VVhJQk1qQXdZckFTSW5OUkkzRnhVR0VSWXpOaE16RndZREFpTVZJalVkZlFFM1dBekRseWtyUEFnSWdTbFJEaHI0b0RjNFJEOXI4TUJDRGc1VUJQait0TURBZlFJOFhBOHA0LzR2WU9jQ1BEaUIvUTM4d2c0QUFRQW5BQUFEY3didUFCMEFJd0N5SEFBQUs3SUxBZ0Fyc2dJQ0FDc0JzQjR2c1I4Qkt3Q3hDeHdSRXJBRU9UQXhOd0FUSndVbUp6VTBOelFsTXhjVkZoVVFBUlV6SlRJZEFRWWpKd1VpSndJTU9pbitiajBHM1FGTUtTZ0MvZUkzQWgxU0d6ZGovYnNuTndOekFzY09peHdiRGlrUEhHRXBEeDRmL2hMOEd5dVpZZ3czR29rQUFBRUFJZjhmQW04R0p3QVdBRG9Bc2hVQUFDdXlFUUFBSzdJRkFnQXJzUVlGRUNEQUw3RUpCdWtCc0JjdnNSZ0JLd0N4Q1JFUkVyQUFPYkFHRWJBS09iQUZFckFDT1RBeE56WVRORE0xQlJVR0l5VWlBeFk3QVRJM014VVVCeVFoTnhkU0FhNFBRLzdQT0NVaHNFUkJTaW5kL3FZSXFnVXZPQTVnSFNrYitvbW1VZ3lJSGtNQUFBQUIvLzRBSndKdEJZMEFEQUFXQUFHd0RTK3dBTmEwQmhFQUJ3UXJzUTRCS3dBd01RTTNNeklURWhNR0t3RWlBUUlDTnlzbFNyam1GUlFkTWY3TFRnVmlLLzYxL2UzK0x6Y0RQUUVMQUFBQUFBRUFGUDhDQWxnR1ZnQVpBRUFBc2cwQUFDdXlFd0FBSzdJRUFnQXJzUmdKNmJJQ0FnQXJBYkFhTDdBVjFyRUpEdW16R0FrVkNDdTBDQThBSUFRcnNSc0JLd0N4QkJnUkVyQUdPVEF4RXpVM0Z6TTNGd1lSQXhRWEJpTWtQUUUvQVRVV016VVNFeVFVT04xU2wwYUpJVzhYVFA2TURDdHhYaThwL25BR0VCc3JLdzQzZS8xbi9XQ0hmMFk5SXlrUERnNHJqQVJpQVRjcEFBQUFBQUVBZXdLZUF5OEZ2Z0FSQUNzQXNnNEJBQ3V4QXd6cHNnNERDaXV6UUE0QUNTdXpRQTRKQ1N1eUJnRUFLd0d3RWkreEV3RXJBREF4RXpVQU93RXlFeGNWQnlJMUppY2pCZ01IZXdFbE5SczV6emMzaTJzZkRsVEFPQUtlUXdMZC9nQkROeEh1OFFkVy9nSW5BQUVBR3dBSUJMUUFyZ0FPQUNnQXNBd3ZzUU1JNmJJRERBb3JzMEFEQWdrckFiQVBMN0VRQVNzQXNRTU1FUkt4QVFjNU9UQXhOelUzRnpNbEZoY1ZCeWNqQlNFaUd4ejQwUUpnT2hvY3BnLzkxLzdnYlQ4cEhSMUdFalFPS1E0M0FBRUFid1RQQW5zRnp3QUVBQmtBc0FRdkFiQUZMN0FBMXJRREVRQUlCQ3V4QmdFckFEQXhFemMyQlFkdkdFWUJybThGZ1U0eDJWZ0FBZ0JNLzJRQ2dRUkNBQlVBSUFCRkFMSVVBQUFyc1JnSzZiSURBUUFyc1I0STZiSUZBUUFydEE4S0ZBVU5LN0VQQStrQnNDRXZzQURXc1JZTzZiRWlBU3V4RmdBUkVyQVVPUUN4SGhRUkVyQVJPVEF4TnpVUU56STNNeGNIRWpzQkZSUUhJeUlESXdJakloTVVNeklUTlNZckFTSVJUT2tuU0NzcER5ZFdHemM0TnlrT1VLaGdZQ2xhV2dvZks0bUpsZ0o5VWxRZHpmMGhERXdYQVRIK0tRRWxtUUxPRDhMOXV3QUFBQUlBTGYvaEFvMEdkd0FXQUI0QWlBQ3lEZ0FBSzdJQ0FnQXJzZ2dCQUN1eEhRUHBzaFlCQUNzQnNCOHZzQlhXdEJjUkFERUVLN0lWRndvcnMwQVZFd2tyc3dNWEZRZ3J0QUFSQUI0RUs3QUFMN1FERVFBZUJDdXdGeEN4R3dFcnNRc1I2YkVnQVN1eEZRQVJFckFDT2JBREViQUVPYkFYRXJJRkJoQTVPVG13R3hHeERnazVPUUN4SFE0UkVyTUdCUlVZSkJjNU1ERVRORGNYQnhNek5qc0JGaFVDRHdFbU5TTWlKelUzRUJNWE5oTTNOQ01pTFVSRkRqY1BlRllycGw3dEVUY2JaZ2dhZncyQmFoMS9nd1l4SlNFcmUvMU9wbzZYL2pYbkRRMDNLd3h2QTdENzRReE1BVjV1N2dBQUFBRUFFdi9uQWtvRXRnQVZBRVVBc2hJQUFDdXhEQWpwc2dRQkFDc0JzQll2c0FEV3NRb082YkFLRUxFT0FTdTBFQThBSUFRcnNSY0JLN0VPQ2hFU3NnTUZFams1T1FDeEJBd1JFckVPRURrNU1ERVROUkEvQVJjVkJCRUhGUlFYTWpjekZ4UUhJaWNtRXRHS0tmN3JETTJsS3lrUDNlQlFLd0dXWUFHVDZFVU9HN3IrdW4yeTFUK0pLWll0M25BQUFBSUFPZi9WQW9VRjlnQVpBQ01BWVFDeUVBQUFLN0lYQUFBcnNBOHpzUndENmJJY0Z3b3JzMEFjQ0FrckFiQWtMN0FBMXJFYUVlbXdHaEN4QkFFcnNRc082Yk1jQkFZT0s3UUtFUUFjQkN1eEpRRXJzUVlhRVJLeEFoODVPYkVMQkJFU3NSSVZPVG13Q2hHd0VEa0FNREVUTkRjMlBRRUROamN5RndjU016STFCeVlqQXljakFpc0JJamNVRnpNeUV5Y2pCaFU1N01JY0doMU9FaHdoSFFFdE9RUU5EQTVVcGh1bWIwWU1VbkFNTjlFQlJQSG1MV3JCQVQ4K0JrUmkrcVVCSVJrQ1FRNzl1L3BySVFKaERuL2JBQUFBQWdBUy8rd0NTZ1NEQUJjQUlRQnRBTElVQUFBcnNRMEQ2YklFQVFBcnNTQUQ2YlFLR2hRRURTdXhDZ1BwQWJBaUw3QVcxclFMRVFBeEJDdXdDeEN4SFFFcnNRY082YkVqQVN1eEN4WVJFckVDR0RrNXNCMFJ0UWtFRFJRYklDUVhPUUN4Q2cwUkVySVFFUkk1T1Rtd0doR3dGam13SUJLd0FEa3dNUk0yRXpZekZoMEJFQVVqRlJRWE16STNGek1DSXlJRElqY1dPd0UyUFFFbUl5SVNPQ3RxWTkzKzYxNTdLMDZQREE5anNxSm1Gb1VNSDFTbUZXcW1BbWdyQVR5MFFad3Avc3QzSGZoaTNReit3UUkzWUVSTzhBNkpBQUFBQWYvRi8rY0RBZ1lDQUNnQVpBQ3lJZ0FBSzdBbkw3RUVBK213RmpLeUJDY0tLN05BQkFJSks3QVRMN0VMQStrQnNDa3ZzQWZXc0NNeXNSVU82YkFkTXJBVkVMRWxEK213SlMreEtnRXJzUlVsRVJLeElTSTVPUUN4QkNjUkVyRUFIVGs1c0JNUnRBa1FFUmthSkJjNU1ERUROanNCRnpNeU5UUTFFaUVXSFFFUEFSVW5JeUlERVRNMk54Y1ZCZ1VURlJRSEl5YzNBeWNqSWpzY0d4MXVEQnMxQVVMZERpa1BwZDRwRFpXY0RnNyt3ZzA0RENzZERSQWJxZ0xGVkIyaUZSZ0NOd2d2R3c0UERnNytiLzc2R0VnTUhUOVkva1Y5YUJVNGl3RzZLUUFDQUJuOGFnS1RCRm9BSGdBbkFHa0FzZ1VCQUN1d0R5K3hGUWpwc0JVUXNRMEc2YkFkTDdFaEEra0JzQ2d2c0FEV3NSOFI2YkFmRUxFWEFTdXdJekt4Q3c3cHNRb1A2YkVwQVN1eEZ4OFJFck1DRVEwYUpCYzVzQW9Sc0FNNUFMRWRGUkVTc1FzU09UbXhCU0VSRXJNS0dSb2tKQmM1TURFM0VBRTNORHNCRnhVR0VSTVFJeFFqSmowQk14WXpNaGtCSnlNQ0t3RW1OeFF6TWhNMUlnTUhHUUVFMFdBYUsySVJ3MGFtRzF3K2x3d2RhTWNRTHo4M2NhVHNWQXpsQWFBQlBsRkdLVVc1L3ZEODBmMlJHeU4xRGtVQnlBS2tZLzU5QnBFcEFwaDcvbUp2QUFBQkFBai95d0tnQm04QUlBQnNBTEljQUFBcnNnSUNBQ3V5REFFQUs3RVZDZW15RlF3S0s3TkFGUkFKS3dHd0lTK3dIOWF4RnhIcHNCY1FzUk1CSzdFT0R1bTBEeEVBTWdRcnNTSUJLN0VYSHhFU3N3TUtHeHdrRnptd0V4R3hEQms1T2JBT0VyQVFPUUN4RlJ3UkVyUUlDZzhKSHlRWE9UQXhFelkzTXhjVkJ4VVRGek1TTXpJVEZ3Y2lKelVRSXdZREZqTUdCeU1tTlRjQ0NCYzlLU2tiR3c0YlhMbUZGQnNwU0F4dnFpVUpGQjBhSzBRYk9nWU9QaU1wRDI1aC9Vd3BBVnI5QjVoR2pHQUNia0g5cXNNOUJpZEhSQVdSQUFBQ0FEWC85Z0VHQlFvQURBQVVBRUFBc2dzQUFDdXlBZ0VBSzdBUE03TVRBZzhJS3dHd0ZTK3dBTmF4Qmc3cHNBMGcxaEcwRVJFQUdRUXJzUllCSzdFUkJoRVN0QU1FQ0FvVEpCYzVBREF4RXhBN0FSY0dGUklYRlFjakloTTJOeklYRkFjaU5WUWJLemNHU3lncFFnb2JLVFV0WWlVQ2dRRWhPRGY0L3ZyNEhDc0V3RXdJTnlrM0FBQUFBQUwvWHZ3QUFUTUVwQUFUQUJzQVRRQ3lDZ0VBSzdJVkFRQXJzUmtMNmJBUkw3RUVDT2tCc0J3dnNBald0QXNSQUI0RUs3QUxFTEVHQ3l1eER3L3BzUjBCSzdFTENCRVNzd3dWRnhva0Z6a0FzUW9FRVJLeEFBczVPVEF4QXpNZkFUTXlFUUlETmpNWEJ4SWRBUkFoSmpVVE54WVhGUWNqSnFJYllnd2QzU2xpRkU0cERtRCt3NWpQTjFvSEtVWXAvVEhDRFFMUEFxZ0Jxa1FudC8wWjYwajlNVkNOQjRORUl5RXJKdzBBQUFBQUFRQUsvK0VDdmdYUkFDY0FmQUN5SUFBQUs3QVhNN0lLQVFBckFiQW9MN0FpMXJBbU1yRWJEdW13RHpLekJSc2lDQ3V4Snc3cHNDY3ZzUVVPNmJNZUp3QU9LN1FHRVFBZUJDdXdCREt3SWhDMEhSRUFIQVFyc1NrQks3RWlBQkVTc0NVNXNBWVJzUUlnT1Rtd0d4S3dCem13SFJHeEVCazVPUUN4Q2lBUkVyTUdGUmttSkJjNU1ERVRORGNXRndjVE16WVROek1YRlFBZEFSUUJNemNWQmdjbUFRY1ZGaGNHS3dFbk56VTBJemNEQ2tZOUNSMGRER0tZRGhzMy9zSUJuZzVVR2pwOC90QU9CaU1iSEJ0RkRoMFBLUVYvR1RrWkhwajl2RW9CS3c4NEhQNVdPZzZvL3U0Y056RVZHd0V4RGxKbkpGSkRZMjdxTndOYUFBQUFBQUVBUnYvbkFORUdXZ0FPQUZFQXNnNEFBQ3V5QndJQUt3R3dEeSt3Qk5hMENBOEFOZ1Fyc2dnRUNpdXpRQWdNQ1N1d0NCQ3dDeURXRWJFQ0QrbXdBaSt4Q3cvcHNnSUxDaXV6UUFJQUNTdXhFQUVyc1FzRUVSS3dEamtBTURFM05qMEJFell6Tnc4QkV3TVhGQWRHSEJVWUJ5OExCQXNOSFVnZlI5d2FCTVV0RFB6aC9Ybis2NllhT2dBQUFRQkNBQUFEV0FTV0FDd0F3Z0N5S1FBQUs3SUNBUUFyc0E0enNna0JBQ3V4SXd6cHNoY0JBQ3NCc0MwdnNDdldzU1VSNmJBbEVMTVpKU2NPSzdRcUVRQVpCQ3V3S2krMEp4RUFHUVFyc0FBZzFoRzBCQkVBTVFRcnNDVVFzU0FCSzdFYUQrbXlJQm9LSzdOQUlCNEpLN0FhRUxFVkFTdXhFUTdwc0JFUXRCUVJBREVFSzdBVUw3RXVBU3V4SnlvUkVySUNCUWM1T1RteEpTc1JFckFwT2JBZ0ViQUpPYkFhRXJFTEd6azVzQlFSc2c0TkZqazVPUUN4SXlrUkVrQUtCUWNMRVJJVUdnWWJLaVFYT1RBeEV6UTNGaFVIRlRNMk16SVhNajhCTWhNUkJ5SW5Fd0luSXdJUkJ5TWlKellSQWlzQkloRVZGd1lqSnpjMVFrYzRIUXh0T1VwUUhFUlNnVFVyT3hrZEgwRWJmeWMzR1JJM0VqSVFieEVmVURjYkE2eE9FZzVHVWh6Um11d3AvTGIrNnlzNEFTSUNheEwrcVAza0hVWmdBWU1CQnYyVGJsUlNSTFJGQUFBQkFDWC91Z0pPQkw0QUlBQ0RBTElkQUFBcnNCRXpzZ0lCQUN1eUNRRUFLN0VYQytrQnNDRXZzQ0RXc1JrUjZiQUJJTllSc1FRUjZiQVpFTFFmRVFBeUJDdXdIeSswR3hFQUhnUXJzQmtRc1JRQks3RU5EdW13RHpLeEVCSHBzQTR5c1NJQks3RVpIeEVTc3dJRkJ4MGtGem14RkNBUkVyQUpPYkFORWJBUk9RQ3hGeDBSRXJNRkJ3NEdKQmM1TURFVE5UY1dGUWNYTXpRM016SVRGUmNIRndjbU5SRVFKeU1HQXhFWEJpTWlKeE1sTnpjT0RodkRES1FlRHc4UEswUmlESlFoRHgwYlJROFBBOVZTTnhRVnp3N0xtLzJVK3BjNGZSb1NUZ0hKQWVNcFRQM3MvbjA0VWpnQmRBQUFBQUFDQUMvLzJRSUdCRGNBQ3dBVkFFUUFzZ29BQUN1eERnUHBzZ0lCQUNzQnNCWXZzQURXc1F3UDZiQU1FTEVSQVN1eEJnL3BzUmNCSzdFUkRCRVNzZ0lKQ0RrNU9RQ3hBZzRSRXJJQUJSUTVPVGt3TVJNUUlUSVRCeFVDSXdjakpoTVNPd0V5RXpVMEp3WXZBU09CTXc0anVnOE96MVFmWEE1MUkzdW1BZWNDVVA2T0VWTDlnd3d2QWlQK0hRSHh3N29UTVFBQUFnQWQvVE1CMXdPaUFCUUFIUUJtQUxJR0FRQXJzUnNENmJBUEx3R3dIaSt3QWRheEZSSHBzQW95c0JVUXNSRU82YkFSTDdBVE03SVZFUW9yczBBVkRRa3JzQlVRc1JnQks3RUlEdW14SHdFcnNSRUJFUkt4QkJJNU9iRVlGUkVTc1FZT09Ua0FzUnNQRVJLekJBb0RGU1FYT1RBeFB3RVJOeU1TTXpJVEZBRVZFQk1ISXlJMUp6YzFFek0yRVNZckFRWVJIUkFNREVpd2p5UCswU3NyREZRUEQxUU0wVGNyRFc0ZFZBRWlwZ0ZwL3NEZC9xZ1Evc2IrYXh1YWV3NE1BbFRIQVJDbVd2N1hBQUFBQWdBMS9UY0Nld1E3QUJjQUlnQmNBTElEQVFBcnNTQUg2YklESUFvcnMwQURCUWtyc0JZdnNSb0Q2UUd3SXkrd0FOYXhHQTdwc0JnUXNSRUJLN0VLRHVteEpBRXJzUkVZRVJLMUF3NEZEeFllSkJjNXNBb1JzZ2dIRERrNU9RQ3hJQm9SRXJFVUV6azVNREVUTlJBbE1qVXlGd2NTRXhBSElqVWpOaEVRQXlNQ0l5STNGQmN6TWhNM0ppTWlBelVCRlVWL0p3NUdEbFEzRFRnckcydVBwbU0zR210a0R3OHB6aWtCYlZRQlp2b2FVamY5ZmYyTC9xZ3JSa1lCckFGNEFSLytOK3hyRWdJcEtjLzl5d0FBQUFFQUh3QUVBaDhFU0FBWkFETUFzZ0lCQUN1eUNnRUFLN0VOQStrQnNCb3ZzQmZXc1JFUjZiUUZEd0FnQkN1d0ZES3hHd0Vyc1JFRkVSS3dCemtBTURFVE5qc0JGaDBCTXhJM014Y1ZCeWNDRVJVWEZDTVZKajBCQWg4Y0d3NDREb21MS1RnZFJOME5SRGMwQTF4VUZreVlBU3RuT0J3YkR2N2MvdnZkbVRnTUZSU1lBcGNBQUFBQi84UC8yUUhzQkg4QUZnQkhBTElWQUFBcnNRRUk2YklCRlFvcnMwQUJBQWtyc2dvQkFDc0JzQmN2c0FqV3NROFI2YklQQ0FvcnMwQVBEQWtyc1JnQks3RVBDQkVTc0FjNUFMRUtBUkVTc0JNNU1ERW5Gek0yUFFFMEF5YzBKVE1YRlFRZEFSUVRGd0loSWoybE9NTENLUUZNR2cvKytld01aUDdobDBnUEwzY1BJZ0VibXY2OEVCdTZ5UjJUL3ZZNC92b0FBZi9OLy93Qm1BWnpBQjRBWWdDeUZ3QUFLN0lKQWdBcnNnSUJBQ3V4SFFYcHNnNEJBQ3NCc0I4dnNCbldzUlVPNmJRVER3QTJCQ3V3RnpLd0V4Q3dDU0RXRWJFR0R1bXdCaSt4Q1E3cHNTQUJLN0VaQmhFU3NnVUhIVGs1T2JBSkViQUlPYkVWRXhFU3NBMDVBREF4QXo4Qk16WTFBejhDRnhVUU16Y1dGd1lYQnhNVkJnY3ZBUkUxRUNNSE13UVlHNE1kRHk4ZkJpbUhEZzBaRHFZZEJCbEJCQ2wvQkRNaEJoTkpBWjRNRVFKakR2N0RMUjBmRmdaUy9URTN5M3NFMXdGV21BRm1DZ0FCQUNQLzhBSWpBLzRBR0FCZ0FMSVhBQUFyc1FrRDZiSVJBUUFyQWJBWkw3QUExckVIRWVteUJ3QUtLN05BQndVSks3QUhFTEVNQVN1eEV3N3BzaE1NQ2l1elFCTVNDU3V4R2dFcnNRY0FFUkt3QkRtd0RCR3hEeGM1T2JBVEVyQVJPUUN4RVFrUkVyQURPVEF4RXpVME56TVhCeFVRRXpNMkV6VTBKelEzRndjVkZ3SWpJaU0zSFNrUGZSMWdHeHQ5R3hzTU43SzJBckpTYVJJYllJbis3ZjcySndIbGpHSTNXQmNkYml0di9SY0FBQUFCQUQzLzR3SXZCQ2tBRXdCbkFMSVJBQUFyc2dJQkFDdXdDek1Cc0JRdnNCUFd0QVFQQUNBRUs3SUVFd29yczBBRUF3a3JzaE1FQ2l1elFCTUFDU3V3QkJDeENRRXJ0QTBSQUJzRUs3RVZBU3V4QkJNUkVyQUNPYkFKRWJJR0R4RTVPVG13RFJLd0NEa0FzUUlSRVJLd0Jqa3dNUk0yTXhjSEVqTVNOU2MyTXhZWEJnTUdCeUlSUFJNL0tRd0dQclFPTXk4YUhTdlBOVGxTQTZ4U04yLzllUUlsbVc4ckJrQlUvTk51RVFHREFBRUFKd0FBQTNNRWlRQWxBSThBc2gwQUFDdXhFUXJwc0JFUXNBa2cxaEd4SXducHNnTUJBQ3V4RFJnek13R3dKaSt3QWRheEJ3N3BzZ2NCQ2l1elFBY0ZDU3V3QnhDeERBRXJ0QTRSQUI0RUs3QU9FTEVWQVN1MEdoRUFNZ1Fyc1NjQks3RUhBUkVTc0FRNXNBd1JzZ2tqSkRrNU9iQU9FcklMSHlBNU9UbXdGUkd4RVIwNU9iQWFFckFVT1FDeEF3a1JFcklVSHlBNU9Ua3dNUk0xRWpzQkZ3WVZFak15RXljM0Z4VVFGek15RXdNMU5ETVdIUUVDSXlJREl3SXJBUlVpSnc1RUVDY25HME5qYmc1U04yTU1XQ2NyVWlzanJuMDFHNEZRSFpVQ1JDa0JkaXQ3aS8zMEFzK21HaWxGL1pYVEFva0JGUTVVTlVqci9OOENLZjRBRGdBQUFmLzgvcVFDa3dVNUFCc0FOUUN5RkFBQUs3QWFNN0lHQVFBcnNBMHpBYkFjTDdBQTFyUU9FUUFIQkN1eEhRRXJBTEVHRkJFU3RRSUtDeEFXRnlRWE9UQXhBellUQWljMU56TXlFeGN6RWpNWEFnTVRCaXNCTkNjakFnOEJKZ1JLeW9rcEtTa3BSZzRwdEVaRDdTZTBFaGRGWVJ6Uk5RODMvdHRhQXJrQnhpc3JLZjZZS1FLWE4vNHYvc3YrTjBONjdQMkhMUXdNQUFBQkFDdjh6d0p2QS80QUpBQ0VBTElOQVFBcnNDTXZzUWtNNlFHd0pTK3dBTmF4Qnc3cHNnY0FDaXV6UUFjRENTdXdCeEN4SGdFcnNSVU82YkFSTXJJVkhnb3JzMEFWRHdrcnNCVVF0QXdSQURFRUs3QU1MN0VtQVN1eERBY1JFclVDR1JvY0lTTWtGem13SGhHd0h6bXdGUkt6RFE0VEZpUVhPUUN4Q1NNUkVyQWhPYkFORWJRQUFoUWVIeVFYT1RBeEV4QTNGeFVHSFFFVU93RUFFVGN6RndZZEFRTVhGUWNRS3dFbk5qVVNFU01HQXdZSElpdDdLMGc0RUFFRU55czRHeEFRRUY4M04xSXBEUlN1UEVGN0FkVUJTa2NPTjFhd1ZQZ0J1Z0VoVkRjNFlHTCttUTRPaWZ3T1JVREhBWHNDcmdmK1BqY1BBQUVBSmYvWkFza0UrZ0FmQURzQXNoWUFBQ3V5QkFFQUs3RWNDZW16SHhZRUNDc0JzQ0F2c0JyV3NRZ1I2YkVoQVN1eENCb1JFckFGT1FDeEh4WVJFcklLRHhnNU9Ua3dNUk0wTnpZM014WWRBUlFCRlJjek1pVXpGeFVISnlNRkpqVUFQUUVqSWdjakpjOWVjUTQzL3NNYUtUUUJOU2twUkE0cC9xYkRBV2tkSjk4cEJDc2hXbEFFRTJnZDcvMFlHaDJMS1JwSUVJc2hQd0xvMDR1TEFBQUJBQi8vSHdKekJ0Y0FMd0J2QUxJakFBQXJzUjBJNmJJZkFBQXJzZ1FDQUN1MEtCUWpCQTByc1NnSjZiSVVLQW9yczBBVUZ3a3JBYkF3TDdBQTFyRUtFZW15Q2dBS0s3TkFDZ1VKSzdFeEFTdXhDZ0FSRXJJcEtpczVPVGtBc1NnZkVSS3hKaWs1T2JBVUViSVpLaXM1T1Rtd0JCS3hHQzA1T1RBeEV4QUJOak1WQUFjR0hRRVVGemNXSFFFSEJoMEJNemN6RnhVR0VSWXpNamN6RndZSElpY1RKeU1ISnpVU05TSW5Id0dEYkVqK25DMDR0YlFwejI4UHpnOHB0RE10SVhnTksxK2JmUnRTREE2MU4reVFYQVBzQVY0QlNVUWQvdnEwVmxCZWl4c25ERVlNakh3NEREY3JLY3Irdml0dkhZa3B3Z0ZuREF3cFJRRVpKY0FBQVFCRy8rY0EwUWMvQUE0QU5nQ3lEZ0FBS3dHd0R5K3dBdGF4Q3cvcHNnc0NDaXV6UUFzTUNTdXlBZ3NLSzdOQUFnQUpLN0VRQVN1eEN3SVJFckFPT1FBd01UYzJQUUVUTmpNM0V3Y1RBeGNVQjBZY0Foc0dMd1FFRFEwZFNCOUgzQm9GcWk4Sy9xM2svTzcrNjZZYU9nQUFBQUFCQUJ2L2p3SXpCcndBTFFCVEFMSWdBQUFyc2dzQ0FDdXhDQXJwdEN3VUlBc05LN0VzQStrQnNDNHZzQVhXc1E4TzZiQWNNckV2QVN1eER3VVJFckFXT1FDeExDQVJFckVZTFRrNXNCUVJzZ0VBRmprNU9iQUlFckVERVRrNU1ERVROVFkxTmpjMU5DTW5OanNCRmgwQkFnTVZGak1mQVFZSEZUTXlGVE1DQnlNbk5TUTNOU01ISno4Qk5DTUhHK21lSTk0bUhobFMzVFhnQ1dZM0tReFVleXNNcU9jckp3RXREZ3pSTjVrcEtkQUN2aXVxUUxMc1IzczNVbUNKUnY3Wi91SWJLUTVFTlZZM09QNjEzaWtiL29VckcxS01OeHNQQUFBQUFRQ0RCVW9FTlFiVkFCUUFJQUN5QWdJQUs3QUlNN0lTQWdBckFiQVZMN0FBMXJFVUQrbXhGZ0VyQURBeEV6WTNGeFlmQVJZM0h3RUhCaThCSmk4QkpnOEJneWZSS2Fod0ZaZXZGQW9HdHNGdXV4Z05XRDBHQmMvckd4ZjNJUVFyc0FZTkdPbzRRZGtKQkJhVExRQUFBQUlBeWY5NEFYUUdEUUFJQUE4QUxRQUJzQkF2c1FrQks3RUtEdW16R0FrQURpdTBCQkVBR0FRcnNSRUJLN0VLQ1JFU3NnY0NEVGs1T1FBd01STVVGelkzTlNZakloTTNFU2NqQmhISlRsUUpHaWhRRFYwT0dUWUZyVEV3SURFdlFmbHJNZ1JkRVNMK093QUFBQUlBRXY5U0Frb0dLUUFoQUNzQWxRQ3lHd0FBSzdJWUFBQXJzUklINmJJSUFnQXJzZ3dCQUN1eERRZnBzZ1FCQUNzQnNDd3ZzQURXc1NJTzZiQWlFTEVFQVN1eUhCNGtNakl5c1FzUDZiRVBFVEl5dEJrUkFCOEVLN0FMRUxFVUFTdTBGZzhBSUFRcnNTMEJLN0VFSWhFU3NBTTVzUXNBRVJLd0d6bXdGQkd4RUJnNU9iQVdFckVORERrNUFMRU5FaEVTc3hRV0pDZ2tGem14Q0F3UkVyQUZPVEF4RXpVUVB3RVJOak0zRndjVk53Y0dCeE1ERnpZM014Y1VCeGNVQnljMk55WW5KamNVRnpZOUFRTUdEd0VTMFRRWUNDOExCTW9lWVVrS0RCSnhJaWtQd1ExRVNBUUNsVDRyWTU4SEFuMGJEQUdXWUFHVDZCb0JaUzBNUGVSU0VWQVBLLzI1L3V1UkZHOHBqUnRjR3prM1BEc1pySEFwdmtoMWRSb0NvSC93ZlFBQi85My85Z09vQmJ3QUhRQjRBTElWQUFBcnNoZ0FBQ3V3RGkreERBZnBzQXdRc1JBRDZiQVFFTEFkSU5ZUnNRRUQ2YkFHTHdHd0hpK3dHOWF3QWpLeEVCSHBzQWd5c2hBYkNpdXpRQkFPQ1N1eUd4QUtLN05BR3dBSks3RWZBU3V4RUJzUkVyQVNPUUN4RGhVUkVyUUFGaGNaR3lRWE9iRU1BUkVTc2dJS0RUazVPVEF4QXpVM0F3SUJGd0VuRWhNbE14Y1ZCZ2NDQnlVRkJ5UUhBRGMyRXdZSEk5RVlnZ04vQi8zOGhBSUpBUUlPS2V4V0hEb0JPZ0d3Sy81L0JQNHJJMHNYYVNzQ00wWVNBdW9CN2YyRGVBRVNQZjRGL3RJUktTa1FELzdCcnArQmJxZ24vdnl3d2dGQUVRb0FBQUFDQUhjQUl3TUlCUmNBSndBd0FDZ0FzZ2tCQUN1d0VqTUJzREV2c0N6V3NSY082YkV5QVN1eEZ5d1JFck1TRlJnY0pCYzVBREF4TnhZVEpqWTNKaWMxTnpNeUZ6WVhGaGNTTXhjR0J4WVFCeGNHS3dFMEp3WW5JeVluQmc4QkpoTUdGeFlUTlNZbkJuY2hiRFVJSVdJYktTc1lTa2lMSVIxV0xVTlFPVVk0Y1JJWFJqTkJidzQ4SzFvaERqZmZQWDJ3SGh4N1oxb2xBVWlGdklyK0dpc3AyV3NQQ0JzQkF6aVppcGYrMVlQMlJHdURTQWtNTWRzZkRBd0MwYnlrbkFGNVFjc1RPZ0FBQUFILzl2K2tBcUFGWWdBcUFOQUFzaDhBQUN1d0d5K3hHUWZwc0JrUXNDWWcxaEd4SVFqcHNCWXZzQlF6c1JFSTZRR3dLeSt3SDlhMEhoRUFIZ1Fyc0I0UXNCMGcxaEcwSVJFQUx3UXJzQ0V2c0NZenRCMFJBQzhFSzdFUUZqSXlzaDBoQ2l1elFCMGJDU3V5SVIwS0s3TkFJUUFKSzdOQUlTVUpLN0FkRUxRQ0VRQXdCQ3V3QWkrd0hoQ3hDd0VydEEwUkFESUVLN0FUTXJFc0FTdXhBaDhSRXJBR09iQUxFYk1EQ1E4b0pCYzVzQTBTc1JJWk9Ua0FzU1lmRVJLeEdpTTVPYkFaRWJFWEtqazVzQllTc1FBb09UbXdFUkd4QWdFNU9UQXhBelVsTndNMk14Y1dFeEkxTmhjQ0F3YzNNeGNWQmdjVk56TVhGUVlIQXdjMkV3WUhKelVsTmpjR0J3b0JSd1dhTDBJYUQwbDlNMHBCa0FLY0RpbHhaTGdQS1lGekVJd0pFSHRnTndFWUFnU1hjUUloUlJjbEFtcFdwb1grK2dFUjlTbE8vdmIrbWhzS0tTa0dDRTRYS3lrT0VmNDNHcjRCRHhVWUswTWpKeWtUR2dBQ0FGci81d0RsQno4QUJ3QVBBRXNBc2djQUFDdXlBd0VBSzdJSUFRQXJzQWd2QWJBUUw3QUMxckFKTXJFREQrbXdEREt5QXdJS0s3TkFBd1VKSzdJQ0F3b3JzMEFDQUFrcnNSRUJLN0VEQWhFU3NRY1BPVGtBTURFM05oRTNHd0VVQndNVE5qTTNFd2NEV2gxWUJoQkhMd29hQnk4RUJBc2ZSd002QXY1VS9rVWFPZ1FaQXdZdkN2NnQ1UDc0QUFBQ0FFTUFVZ0tGQlNzQUdnQWhBRGNBc0JRdnNSZ0k2YklZRkFvcnMwQVlGZ2tyc0FndkFiQWlMN0VqQVNzQXNSZ1VFUkt3R1Rtd0NCRzJCQTBQRVJvY0lDUVhPVEF4RWdJbEppY0NCUWNWSkFjVkZCY0FCU0luQkFJbElqVVhNd1FsSnhjM05pY2xCcXJOQVRjWVFDQUJ6QTcrN2lHMkFlNzlkeWtmQWRtYy90T1hwamNCZS82MmoyQ3dnMFArOCtrQmpRR3F1U0tpQVdmd09SdXVwaHFVb3Y2Rk9RcVgvdFV2Ync4Y3h1Z0pFeWRpNTdBQUFBQUFBZ0ZRQmNrREp3YUJBQVlBRFFBMEFMSUlBZ0Fyc0FFenNRVUU2UUd3RGkrd0FOYTBDaEVBQ1FRcnNROEJLN0VLQUJFU3NRTUhPVGtBc1FnRkVSS3dERGt3TVFFM014Y1VCeVlsTnpNWEZBY21BVkE3S1R4S1BBRWRQQ2s3U2pzR0tVNU9NeTBhVUU1T015MGJBQUFBQUFNQVJBQWRBNVVFNHdBSEFBNEFJZ0FUQUFHd0l5K3dEOWF4Rnc3cHNTUUJLd0F3TVJNU05oY0VBaVVrRXhJekJCSWxJaE0xRWdFSEFnOEJGUlFYTmpjekZ3WUhJaWNtUkgybGNRSW4wLzVHL3E1VU05RUJ5Q3YrU3JZTVNBRlFGK012RDg5dExTa09FcFRmVWlrQ29BSEFtQlY1KzFsYU9RSWwvZm9wQkNrdi9lTmdBZ3Y5NTFvQkp5ZDlzdGMrTDR3cm1samRjUUFBQWdBZEFQSUJvZ003QUJVQUlBQklBTEFVTDdFWUJ1bXdEeSt4Q2dYcHNCNHZzUU1GNmJJREhnb3JzMEFEQlFrckFiQWhMN0FBMXJRV0R3QTJCQ3V4SWdFcnNSWUFFUkt3RkRrQXNSNEtFUkt4RVJJNU9UQXhFelVRTnpJM014Y0hFanNCRlJRSEl5SW5Jd1lqSWpjVU16SVROU1lyQVNJUkhhQWJNaDBjQ2hzN0V5WW5KaHdKTjNSQ1FodytQZ2NWSGw0QmUwY0JLeVlvRG1EK3B3WWtDby9kaVVnQlVnZGIvdThBQUFJQWR3RWRCQkFFUmdBUUFDRUFGZ0N5QkFFQUs3RVZGek16QWJBaUw3RWpBU3NBTURFVE5EYzJKUllWRkFFSEJSVUhJaVVtSnlVME56WWxGaFVVQVFjRkZRY2lKU1luZDRsUUFUTTMvcG9PQVhRcEovN2NKNDRCUElsUUFUTTMvcG9NQVhJbkp2N2JKNUFDVGtNcmQrRU1LeGorNlViM0t5blBIQTltUmlsMjVBOHBHdjdwUS9vcEtjOGFEd0FBQUFFQVdBRVpBOUVDendBTEFCNEFzQW92c0FBenNRTUg2UUd3REMreERRRXJBTEVEQ2hFU3NBUTVNREVUTmpjRkJEYzJBeWNUSXdSWUNpY0JIUUZneXhZdFdCTUwvdndDYWtvUkRSZ3ZMZjRkQmdGQkxRQUFBQUFCQUdRQ3p3THdBNEVBQndBQUV6VWxNeGNWQkFka0FsUU5LLzZONFFMNFJVUXBLU2szQUFBQUF3QXJBQUFDK2dWekFBa0FLZ0EwQUpVQXNnZ0FBQ3V4REFmcHNoMEJBQ3V3S0MreEF3M3BBYkExTDdBQTFyUUtEd0EyQkN1d0NoQ3hHUUVyc1JRUDZiQXJNckFVRUxRYUR3QWdCQ3V3R2krd0ZCQ3hMZ0VydEI4UEFDQUVLN0FmRUxFbEFTdXhCUS9wc1RZQks3RVVHUkVTc1FNYk9UbXhMaG9SRXJZSENCRU1IU0VvSkJjNXNCOFJzZzRnSXprNU9RQ3hEQWdSRXJBSE9iQWRFYklqTERBNU9Ua3dNUk0xRWpNQUV4QUZCeUlERWpNeU55WXZBU01WRnhRckFTSW5FemN6TnhZVkJnY1NGellSQXdJaklnTTNGelk5QVNjaklnOEJLMkJ2QWZnSS91dUw0d1lwem4xS0wxQlVGZ2dwRlJJR0h4Z0d0RzhNdTN0R1ZDVWoyYlplM1E3QklRWldUQVlCeDZZREJnRTMvQmY5K2E0TUFneitSbUl6MnI0R2c5OG1BeGNXS1JwcjFYVCtWRENpQVZBQmNRRWEvT3l3RUp0NUp4MUV6d0FCQUdZRTdBSXpCVjRBQlFBWkFMQUVMd0d3Qmkrd0FkYTBBeEVBQ1FRcnNRY0JLd0F3TVJNM0JUY1hKbVlIQVpzcEFyb0ZBRjRRQm1naUFBQUNBQTBCRGdGT0FrQUFDd0FWQURvQXNBb3Z0QTRGQUVJRUt3R3dGaSt3QU5hMERBOEFJQVFyc0F3UXNSRUJLN1FHRHdBZ0JDdXhGd0Vyc1JFTUVSS3lBZ2dVT1RrNUFEQXhFelF6TWhjSEZRWWpCeU1tTnhZN0FUSTNOVFFuQmczSFdDSUpHSDhLQ28wNUZqNEtVQmhVY2dHZW9tVUZGcTRFRFphRWlEVXpCUTBBQUFBQkFGSUF5UU9UQklNQUtRQ2hBTElKQVFBcnNCa3ZzUmNINmJJWkZ3b3JzMEFaSGdrcnN5TVhHUWdyc1NFRDZiQXBMN0VEQStrQnNDb3ZzQVhXc1F3TzZiSUZEQW9yczBBRkFBa3JzQXdRc0JRZzFoR3hKZzdwc0NZdnNSUU82YklVSmdvcnMwQVVFUWtyc2lZVUNpdXpRQ1lqQ1N1eEt3RXJzU1lGRVJLeEpTZzVPYkFNRWJJSkpDYzVPVG13RkJLeEhoODVPUUN4S1NFUkVySVZIeVk1T1Rtd0F4R3lFQk1vT1RrNU1ERVROVFE3QVRjMUp6WTNGd2NWRkRNbEZ4VVVCUlVUSlRNWEZRWUhCaXNCSndZSEp6VWxKamMySXdWU3BsUkREQk14Tnd3cEFSUWIvc0l6QVIwT0tjeWVDQVlkQk05N053RkZIQWdLSmY3Z0F1VXBHdzZNVVVvbEc2VnZIUjByRENjZkR2NmJHeWtwRWhNSUFoMGNLVVVmU0c3TEhRQUFBUUFnQVlRQndRUnNBQlVBTGdDeUF3RUFLN0VSQitrQnNCWXZzQURXdEFzUkFBb0VLN0VYQVN1eEN3QVJFclVGQ2cwT0VCUWtGemtBTURFVFBnRTNGaFVDQnpZM014Y1VCU2MxRWljaUR3RWlJQjl2TDFNMFNXNTJDeC8rNTFUUlhqd01IeHdEZ1dTRkFoR0cvcW00Q0ZNVVRqc09CUUo0RHJZT0FBRUFNUUYxQWIwRVB3QW1BR01Bc2dJQkFDdXhJQWJwc0JVdnNRWUY2UUd3Snkrd0FOYXhJdzdwc0NNUXNSMEJLN0VFRCttd0JCQ3hFd0VydEFrUEFEWUVLN0VvQVN1eEl3QVJFclVMRGhFWEd5SWtGem14QkIwUkVyQUdPYkFURWJBVk9RQ3hJQVlSRXJFQUpUazVNREVUTmpNV0ZSUUhNeklWRkFVbU5TTTJOeGMyTlRRbklnOEJJeVluTmowQkp6VWlCeGNVQnlZeFJva3dRaTZoL3NndUNoSVVITzFEZVRFY0ZCSVRxZ3BERWdvNEhRTm8xd29tS3JSK25xQUVIaUFDQm9LTkdTVnZGUVFlMWx3Y0J3ZDlDQlFVQlFBQUFBRUFid1ZpQWRjR29BQUVBQ0lBc2dJQ0FDdTBCQVFBRFFRckFiQUZMN0FBMXJRREVRQU1CQ3V4QmdFckFEQXhFeVEzRndGdkFSNFhNLzdaQlo3NENqUCs5UUFBQVFCRS8vQURWQVJ6QUIwQWRBQ3lDZ0FBSzdBVE03SURBUUFyc2cwQkFDc0JzQjR2c0JiV3NSRU82YklXRVFvcnMwQVdBQWtyc0JZUXN4c1dGUTRydEJJUkFCc0VLN0FSRUxFTEFTdXhDQkhwc0FZeXNBZ1FzUTBQNmJBTkw3RWZBU3V4RWhVUkVySVFHQm81T1Rtd0N4R3dEem14Q0EwUkVyRUhDams1QURBeEV4SWhOek0yQndNVEZBY25OQk1HQndZREZ3Y2lKemMxRXpVakJpTWlSSXNCSTRrZDF4c1hEMFlwSVIwblB5TXBOemdwRHpFZGRKTENBcXdCckJzS00vMnkva1laT1RWSUE2TUVBbmY5UktZM1ZHQXBBV1libHdBQUFBRUFZQUhKQU9jQ1pnQUhBREFBc0FZdnNRSU02YkVDRE9rQnNBZ3ZzQURXdEFRUkFCOEVLN1FFRVFBZkJDdXhDUUVyQUxFQ0JoRVNzQVE1TURFVE5EYzJGd1luSm1BdFNCSVdOUzBDSVNNaURWWmhEUllBQUFBQkFPSDlNUUw4QUNzQUVBQWRBTEFQTDdFQkNPa0JzQkV2c0FEV3RBMFJBQWdFSzdFU0FTc0FNREVURnpNMlBRRTBBeWMzRlJRVEZ3SWhJdUdtTjhIQksyL3NEbVQrNFpqOW9BMHVlQTBrQVJ1V0VCMlYvdmc0L3ZnQUFBRUFPUUdRQVJBRTBRQVBBQ0lBc2dFQkFDc0JzQkF2c0EzV3NRa1I2YkVSQVN1eENRMFJFckVIQ3prNUFEQXhFemN6RndjVkZCTVhGUlFISWljM05Ea2FIaVlTY1JvNElSZ0xCTUlQSFNzclZ2MzBGZ2M5RWhVcmNRQUFBZ0FmQVdZQlBRT0FBQXNBRlFBNkFMQUtMN1FPQlFEQkJDc0JzQll2c0FEV3RBd1BBQ0FFSzdBTUVMRVJBU3UwQmc4QUlBUXJzUmNCSzdFUkRCRVNzZ0lJQ1RrNU9RQXdNUk1RTXpJWEJ4VUNJd2NqSmhNV093RXlOelUwSndZZnNFOGZDUlZ4Q1FsOU14STRDVWNWU21VQ1l3RWRzZ2dvL3M0R0Z3RUg2TzVlV2drWUFBQUFBQUlBVGdFOUJEY0U1UUFNQUJvQVB3Q3lBd0VBSzdBUU13R3dHeSt3RE5hMEJoRUFNZ1Fyc2d3R0NpdXpRQXdCQ1N1d0JoQ3hHZ0VydEJNUkFESUVLN0VjQVN1eEJnd1JFckFXT1FBd01STTFORGNYQUJVVUFTYzJBRFVETlRRM01nQVZGQUFISnpZQU5VNDNHUUlRL2h0U0VnR29XamNwQWdEK2UxNUtKd0dKQkcwM0pRWUUvcmg5US81NlJqTUJGMVFCVmpjakZQNm1mVVgrcENjdktRRTNWZ0FBQXdBOUFDd0VLUVg4QUE4QUhBQTdBSXdBc2lnQkFDdXlBd0VBS3dHd1BDK3dFTmF4R3hIcHNCc1FzQWtnMWhHMERSRUFIUVFyc0EwdnRBa1JBQjBFSzdBYkVMRTZBU3V4SXhIcHN4Y2pPZ2dyc1JNTzZiQVRMN0VYRHVtd0l4Q3hKZ0Vyc1N3TzZiRTlBU3V4R3hBUkVyRUhDems1c0JNUnNCazVzQmNTc1RzZE9UbXhJem9SRXJJVkh6azVPVG13SmhHekpDRTNPQ1FYT1FBd01STTNNeGNIRlJRVEZ4VVVCeUluTnpRVE5SSVRORGN6RlFJREloVUhBVFl6TWhjSEV4Y3pOeEF6TWhjSEVUTVdCeFVIRndZckFTWTFOd2NuRWowaUpURVlrQ0ZHS3g0T01jbXVReDJMd1IwbUFWNFdMQ1FnR2dzcVF5bFFId2thRG15SURpb2NHaHcyRThJMkRnVTlFaUl6TW1YOW1Ca0lTQlVaTW9UOTl6Z0JrUU5uWUNrYi9RTDk2bjBiQXkwb0tDLytaUmtaQWtrb252NmRFVTVZZnlZd0VDRHdEQmtCM3dBQUFBTUFQUUFPQkdNRjFRQVBBQndBTWdCTkFMQXVMN0VnQitrQnNETXZzQkRXc0EweXNSc1I2YlFKRVFBZEJDdXdHeEN4RXdFcnNSY082YkUwQVN1eEd4QVJFckVIQ3prNXNSTUpFUkt4R1IwNU9iQVhFYklyTERFNU9Ua0FNREVUTnpNWEJ4VVVFeGNWRkFjaUp6YzBFVFVTRXpRM014VUNBeUlWQndFK0FUY1dGUUlITmpjekZ4UUZKelVBSnlJUEFTSTlJaVV4R0pBaFJpc2VEc211UXgyTHdSMG1BUlVxbDBCeFIyU1hvUThyL29CeUFSMkJVaEFySmdVdkVpSXlNV1A5cFJrSVJoVVpNWUg5enpnQmtRTm5ZQ2tiL1FMOTZuMGJBaFJrZ3dJUWh2NnN0d2hURkUwN0RnVUNjdzYxRFFBQUFBQURBRFlBR0FSVEJkOEFKZ0F6QUZJQXJnQ3lBZ0VBSzdFZ0J1bXdGUyt4QmdYcEFiQlRMN0FuMXJFeUVlbXpCREluQ0N1eEhSSHBzQjB2c1FRUjZiSWRCQW9yczBBZEFBa3JzRElRc1JNQks3RUpEdW13Q1JDeFVRRXJzQ295c1RvTzZiRXREdW14TGc3cHNEb1FzVDBCSzdGREQrbXhWQUVyc1RJbkVSS3dGVG14Q1JNUkVyQXdPYkJSRWJBME9iQXRFcklzTmxBNU9UbXhQUzRSRXJRNE96eE9UeVFYT1FDeEJoVVJFckE0T2JBZ0ViVUFJaVUyUDBFa0Z6a3dNUk0yTXhZVkZBY3pNaFVVQlNZMUl6WTNGeVExTkNjaUR3RWpKaWMyUFFFbk5TSUhGeFFISmdFMUVoTTBOek1WQWdNaUZRY0JOak15RndjVEZ6TTNFRE15RndjUk14WUhGUWNYQmlzQkpqVTNCeWNTTm1LK1FsdEE0UDVPUUE0YUd5Y0JTVnlwUkNjYkdocnNEVjBhRGs0b0FVakpya01kaThFZEpnRWNGQ2toSFJnTEpqd25TUndJR0ExamZBNG5HUmdhTVJHeE1Rd0RZdFFMSlNteWZKeWZCQjhmQWdhQWl4a2xiUllFSHRSYUhBY0hmQWNVRlFYODJ6Z0JrUU5uWUNrYi9RTDk2bjBiQXZva0pDditoaGNYQWhrbGtmNjZFRWhRZFNNc0R4M2RDeFlCdVFBQ0FEd0FId0lGQnhNQUhBQW1BR0lBc2g4Q0FDdXhKUXJwQWJBbkw3QUExckVURWVtd0V4Q3hBd0Vyc0JZeXNRd082YkVZRWVtd0N6S3dHQkMwQmhFQUhBUXJzQVl2c1NnQks3RUdFeEVTc2hRZEpUazVPYkFERWJRRkVCOGdKQ1FYT2JBTUVyUUlDUmNpSXlRWE9RQXdNVGMwRXpjMUppYzJOek1XRndjUUZ4UUhBaDBCRnpJL0FSY0NLd0VpRXpRek5SWVhGUWNqSmp6bExRZ2xGRGNQSUIwUVhiZVlMeXMrTFQxdVpTQ0pxVm8vSFUwdFBQaHhBYzJlanNjU094d0pRbFgrNUdjNWN2N3ZWMlF0NWg0ci9uc0dyVGtPRkRNT1J4d0FBd0FVLzMwQzlnZTlBQklBRndBaEFFNEFzaElBQUN1d0NET3lCQUlBSzdFZ0JPbXlGZ0lBSzdBWEx3R3dJaSt3Qzlhd0d6S3hCZzdwdEFjUkFCNEVLN0VqQVN1eEJnc1JFcklJRngwNU9Ua0FzU0FTRVJLeUFBd1pPVGs1TURFM0VoTVNGeFliQVFjakp4RW5Jd1FIQWdjakV6YzJCUWNCRnlROUFUY25KaU1pRkVTYWFzR1ZCaXRGSFNrT0RmNjFIelViTjU0WVJnR3ViLzU1UkFFVURpSW5LMWdqQWc0Q2V3SU1GQVQ2cFA1RkRDa0NBTThwWS80SkJnZURUakhaV1B3WU5UMGgrclNMcGdBQUF3QVUvMzBDNHdlZ0FCSUFGd0FoQUU4QXNoSUFBQ3V3Q0RPeUJBSUFLN0VnQk9teUV3SUFLN01YSUFRSUt3R3dJaSt3Qzlhd0d6S3hCZzdwdEFjUkFCNEVLN0VqQVN1eEJnc1JFckVJSFRrNUFMRWdFaEVTc2dBTUdUazVPVEF4TnhJVEVoY1dHd0VISXljUkp5TUVCd0lISXhNa054Y0JBeGNrUFFFM0p5WWpJaFJFbW1yQmxRWXJSUjBwRGczK3RSODFHemVpQVI0WE0vN1pMMFFCRkE0aUp5dFlJd0lPQW5zQ0RCUUUrcVQrUlF3cEFnRFBLV1ArQ1FZR3N2Z0tNLzcxL0hNMVBTSDZ0SXVtQUFBQUFBTUFGUDk5QXdvSDJRQVNBQ0VBS3dCVkFMSVNBQUFyc0FnenNnUUNBQ3V4S2dUcHNoNENBQ3V4Rmd6cHN4TXFGZ2dyQWJBc0w3QUwxckFsTXJFR0R1bTBCeEVBSGdRcnNTMEJLN0VHQ3hFU3NnZ2JKems1T1FDeEtoSVJFcklBRENNNU9Ua3dNVGNTRXhJWEZoc0JCeU1uRVNjakJBY0NCeU1UTlJJN0FUSVRCaWNtSnlNR0R3RVRGeVE5QVRjbkppTWlGRVNhYXNHVkJpdEZIU2tPRGY2MUh6VWJONlBOTlJzNXhYY1NZeDRQVkdvNEJVUUJGQTRpSnl0WUl3SU9BbnNDREJRRStxVCtSUXdwQWdEUEtXUCtDUVlHYWtNQlFQNTlNNUY3QkZaZ0oveC9OVDBoK3JTTHBnQUFBd0FVLzMwRWlRZlRBQklBSndBeEFITUFzaElBQUN1d0NET3lCQUlBSzdFd0JPbXlHd0lBSzdJVEFnQXJzeWN3R3dnckFiQXlMN0FUMXJFbkQrbXdKeEN4Q3dFcnNDc3lzUVlPNmJRSEVRQWVCQ3V4TXdFcnNTY1RFUkt3S0Rtd0N4RzBEUlVXS1RBa0Z6bXdCaEt5Q0NFdE9UazVBTEV3RWhFU3NnQU1LVGs1T1RBeE54SVRFaGNXR3dFSEl5Y1JKeU1FQndJSEl4TTJOeGNXSHdFV054OEJCd1l2QVNZdkFTWVBBUU1YSkQwQk55Y21JeUlVUkpwcXdaVUdLMFVkS1E0Ti9yVWZOUnMzaXlmUkthaHdGWmV2RkFvR3RzRnV1eGdOV0QwR0kwUUJGQTRpSnl0WUl3SU9BbnNDREJRRStxVCtSUXdwQWdEUEtXUCtDUVlHNGVzYkYvY2hCQ3V3QmcwWTZqaEIyUWtFRnBNdC9CQTFQU0g2dEl1bUFBQUFCQUFVLzMwQzR3ZFNBQklBSEFBakFDb0FXQUN5RWdBQUs3QUlNN0lFQWdBcnNSc0U2YklkQWdBcnNpUUNBQ3V3SWk4QnNDc3ZzQXZXc0JZeXNRWU82YlFIRVFBZUJDdXdKekt4TEFFcnNRWUxFUkswQ0JnbEppa2tGemtBc1JzU0VSS3lBQXdVT1RrNU1ERTNFaE1TRnhZYkFRY2pKeEVuSXdRSEFnY2pFeGNrUFFFM0p5WWpJZ00zTXhjVUJ5WWxOek1YRkFjbUZFU2Fhc0dWQml0RkhTa09EZjYxSHpVYk43UkVBUlFPSWljcldJODdLVHhLUEFFZFBDazdTanNqQWc0Q2V3SU1GQVQ2cFA1RkRDa0NBTThwWS80SkJnTHBOVDBoK3JTTHBnRWRUazR6TFJwUVRrNHpMUnNBQUFBQUJBQVUvMzBDNHdnRUFCSUFIZ0FvQURNQWtRQ3lFZ0FBSzdBSU03SXNBZ0FydEIwTkFJMEVLN0lzQWdBcnRDY01BQmdFSzdJRUFnQXJBYkEwTDdBVDFyUXBEd0EyQkN1d0tSQ3hDd0Vyc0NJeXNRWU82YkFhTXJRSEVRQWVCQ3V3QmhDMExnOEFOZ1Fyc0M0dnNUVUJLN0VwRXhFU3NCODVzQXNSdHcwV0dCd2dKeXN4SkJjNXNDNFNzQ1E1c0FZUnNRZ0pPVGtBc1NjU0VSS3lBQXdnT1RrNU1ERTNFaE1TRnhZYkFRY2pKeEVuSXdRSEFnY2pFelUwTnpJMU1oY1VCeU1pQXhja1BRRTNKeVlqSWdNVUZ6TXlOelF2QVFZSEZFU2Fhc0dWQml0RkhTa09EZjYxSHpVYk42emFRV2xGMndyQkcwUUJGQTRpSnl0WVlIY1VuaHQxTFljYkl3SU9BbnNDREJRRStxVCtSUXdwQWdEUEtXUCtDUVlIS0JPNEh3YWcwU1A4WlRVOUlmcTBpNllCV29NbnZuY1ZDQXgvQUFBQUFBTUFGUDk5Qkw0RzFRQVNBQndBUFFDbkFMSThBQUFyc0JFenNUZ0Q2YklIQUFBcnNnUUNBQ3V4R3dUcHNpWUNBQ3V5TUFFQUt3R3dQaSt3Rjlhd0NqS3hJUS9wc0I0eXNpRVhDaXV6UUNFeUNTdXdGeEN4TmhIcHRBY1JBQjRFSzdBaEVMRWhDeXV4TEEvcHNpd2hDaXV6UUN3cENTdXhQd0Vyc1NFWEVSS3lDQjhrT1RrNXNEWVJzUVVHT1RteExBY1JFckV0TkRrNUFMRTRQQkVTc0FBNXNEQVJ0dzhUREIwZkZEazZKQmM1c0JzU3NCZzVNREUzRWhNU0Z4WWJBUWNqSnhFbkl3UUhBZ2NqRXhja1BRRTNKeVlqSWhzQkp6WTFBelFqTkNVV0hRRVVCUU1WRkRNbEZ4VVVCUU1WRkRNbEZ4WUZJaFJFbW1yQmxRWXJSUjBwRGczK3RSODFHemUwUkFFVURpSW5LMWk4UkNrM0RoMEJnMGIrd0FvbkFRZ00vc1UzYmdGekdCUCtONGNqQWc0Q2V3SU1GQVQ2cFA1RkRDa0NBTThwWS80SkJnTHBOVDBoK3JTTHB2c2RBbEpGYVQwQlhvcHVTQk1ZS1NzOC9oMUdIQndPRGpjNC9hQWJsNWRVRko0QUFnQWwvVEVDNFFiTkFCb0FLd0NNQUxJWUFBQXJzUklENmJJU0dBb3JzMEFTRkFrcnNpSUFBQ3V5QkFJQUs3RUpBK213S2kreEhBanBBYkFzTDdBQTFyRU9EdW15RGdBS0s3TkFEZ2NKSzdBT0VMRVVBU3UwRlE4QUlBUXJzUzBCSzdFT0FCRVNzUm9iT1Rtd0ZCRzFDUmdmSXljcUpCYzVzQlVTc1FRb09Ua0FzUmdjRVJLeEp5ZzVPYkFTRWJFakpEazVzQWtTc0JvNU1ERVRFQUUyTXhZZEFSUWpCZ01DRVJVU014Y3pOaE16RlFJaklnTVRGek0yUFFFMEF5YzNGUlFURndJaElpVUJSYlZ1VkgzclZwNGJwaXRTVDJVcFNMRHFqVEttTjhIQksyL3NEbVQrNFpnQnl3SldBYy9kSFJvZEczdis2djdHL24wTy9tSU9Jd0VwRC81VUFWdjhYZzB1ZUEwa0FSdVdFQjJWL3ZnNC92Z0FBQUFDQUNiLzNRS09DQUlBSUFBbEFGMEFzaDhBQUN1eEd3UHBzZ2tDQUN1eUpRSUFLN0lUQVFBcnNDVXZBYkFtTDdBRTFyRVFEK215RUFRS0s3TkFFQXdKSzdJRUVBb3JzMEFFQUFrcnNTY0JLN0VRQkJFU3NoY1lHVGs1T1FDeEV4c1JFck1DQUJ3ZEpCYzVNREUzRXljMk5RTTBJelFsRmgwQkZBVURGUlF6SlJjVkZBVURGUlF6SlJjV0JTSUROellGQnlaRUtUY09IUUdEUnY3QUNpY0JDQXoreFRkdUFYTVlFLzQzaHh3WVJnR3ViL0lDVWtWcFBRRmVpbTVJRXhncEt6eitIVVljSEE0T056ajlvQnVYbDFRVW5nZlhUakhaV0FBQUFnQW0vOTBDamdmaUFDQUFKUUJoQUxJZkFBQXJzUnNENmJJSkFnQXJzaUVDQUN1eUV3RUFLN01sRXdrSUt3R3dKaSt3Qk5heEVBL3BzaEFFQ2l1elFCQU1DU3V5QkJBS0s3TkFCQUFKSzdFbkFTdXhFQVFSRXJNWEdCa2xKQmM1QUxFVEd4RVNzd0lBSEIwa0Z6a3dNVGNUSnpZMUF6UWpOQ1VXSFFFVUJRTVZGRE1sRnhVVUJRTVZGRE1sRnhZRkloTWtOeGNCSmtRcE53NGRBWU5HL3NBS0p3RUlEUDdGTjI0QmN4Z1QvamVIRlFFZUZ6UCsyZklDVWtWcFBRRmVpbTVJRXhncEt6eitIVVljSEE0T056ajlvQnVYbDFRVW5nY0QrQW96L3ZVQUFBQUFBZ0FtLzkwQ2pnaGdBQ0FBTHdCcEFMSWZBQUFyc1JzRDZiSUpBZ0Fyc2lFQ0FDdXlKd0lBSzdJVEFRQXJzQ0V2c0N3dnNTUU02UUd3TUMrd0JOYXhFQS9wc2hBRUNpdXpRQkFNQ1N1eUJCQUtLN05BQkFBSks3RXhBU3V4RUFRUkVySVhHQms1T1RrQXNSTWJFUkt6QWdBY0hTUVhPVEF4TnhNbk5qVUROQ00wSlJZZEFSUUZBeFVVTXlVWEZSUUZBeFVVTXlVWEZnVWlBelVTT3dFeUV3WW5KaWNqQmc4QkprUXBOdzRkQVlORy9zQUtKd0VJRFA3Rk4yNEJjeGdUL2plSEJzMDFHem5GZHhKakhnOVVhamp5QWxKRmFUMEJYb3B1U0JNWUtTczgvaDFHSEJ3T0RqYzQvYUFibDVkVUZKNEhBRU1CUVA1OU01RjdCRlpnSndBQUFBQURBQ2IvM1FLT0I2d0FJQUFuQUM0QVpBQ3lId0FBSzdFYkErbXlDUUlBSzdJbUFnQXJzaTBDQUN1eUV3RUFLN0FtTHdHd0x5K3dCTmF4RUEvcHNoQUVDaXV6UUJBTUNTdXlCQkFLSzdOQUJBQUpLN0V3QVN1eEVBUVJFclFYR0JraUppUVhPUUN4RXhzUkVyTUNBQndkSkJjNU1ERTNFeWMyTlFNMEl6UWxGaDBCRkFVREZSUXpKUmNWRkFVREZSUXpKUmNXQlNJVE56TVhGQWNtSlRjekZ4UUhKaVpFS1RjT0hRR0RSdjdBQ2ljQkNBeit4VGR1QVhNWUUvNDNoeVU3S1R4S1BBRWRQQ2s3U2p2eUFsSkZhVDBCWG9wdVNCTVlLU3M4L2gxR0hCd09EamM0L2FBYmw1ZFVGSjRIZDA1T015MGFVRTVPTXkwYkFBQUNBQmovOEFJa0IyOEFCQUFTQURRQXNoRUFBQ3V3QkM4QnNCTXZzQVhXdEJBUkFCc0VLN0VVQVN1eEVBVVJFcklCQmc0NU9Ua0FzUVFSRVJLeENnNDVPVEF4RXpjMkJRY0JOaEk3QVRVMkNnRVJGeFVISWhnWVJnR3ViLzU2SFhVb0hVNDNjUnRFT3djaFRqSFpXUG5qSVFYTUR5MythdjFNL21WVUd6Y0FBQUlBTC8vd0Faa0hXQUFOQUJJQU53Q3lEQUFBSzdBU0x3R3dFeSt3QU5hd0RqSzBDeEVBR3dRcnNSUUJLN0VMQUJFU3NnRUpFams1T1FDeEVnd1JFckVBQ1RrNU1ERTNOaEk3QVRVMkNnRVJGeFVISWdNa054Y0JMeDExS0IxT04zRWJSRHNYQVI0WE0vN1pVaUVGekE4dC9tcjlUUDVsVkJzM0JtYjRDalArOVFBQUFBSUFFLy93QWk0SGxBQU9BQndBU2dDeUd3QUFLN0lMQWdBcnNRTU02YklHQWdBcnNoRUNBQ3V6QUJzRENDc0JzQjB2c0EvV3RCb1JBQnNFSzdFZUFTdXhHZzhSRXJFUUdEazVBTEVBR3hFU3NnY1BHRGs1T1RBeEV6VVNPd0V5RXdZbkppY2pCZzhCRXpZU093RTFOZ29CRVJjVkJ5SVR6VFViT2NWM0VtTWVEMVJxT0JBZGRTZ2RUamR4RzBRN0JoRkRBVUQrZlRPUmV3UldZQ2Y2UVNFRnpBOHQvbXI5VFA1bFZCczNBQUFBQXdBYS8vQUI4UWRPQUFZQUZBQWJBRGNBc2hNQUFDdXdCUyt3R2pNQnNCd3ZzQWZXdEJJUkFCc0VLN0VkQVN1eEVnY1JFclFCQlFNSUVDUVhPUUN4QlJNUkVyQU5PVEF4RXpjekZ4UUhKZ00yRWpzQk5UWUtBUkVYRlFjaUFUY3pGeFFISmhvN0tUeEtQQVVkZFNnZFRqZHhHMFE3QVFrOEtUdEtPd2IyVGs0ekxScjVvaUVGekE4dC9tcjlUUDVsVkJzM0J4Qk9Uak10R3dBQUF2KzAvN1lDL2dkZ0FCWUFKZ0RPQUxJUEFBQXJzZ2tDQUN1eEhnYnBzZ1FDQUN1eUl3RUFLN0VsQitteUFRRUFLN0lDQVFBcnNnc0JBQ3V5RlFFQUs3SVdBUUFyQWJBbkw3QWIxckVMRHVteEtBRXJzRFlhdXU1cnduWUFGU3NLc0JZdXNBSXVzQllRc1FFUCtiQUNFTEVWRC9tNlArSDhGUUFWS3dvT3NBSVFzQlBBc1NBVCtiQVh3TEFYRUxNaEZ5QVRLN01tRnlBVEs3SW1GeUFnaWlDS0l3WU9FUkk1c0NFNUFMUVRGeUFoSmk0dUxpNHVBVUFKQVFJVEZSWVhJQ0VtTGk0dUxpNHVMaTR1c0VBYUFRQ3hKUThSRXJFTkdEazVNREVETlJjMk56VTBNeFl6QkJFUUFRWWpJalVqRXhJVEp4TXpOaE0zTlJJbEloVURGek1YRlNkTTdnNEtiMkplQVJYOW9CVTlPQXhTS1Jtd3dnencyUjBFL3N0akhMb01LL29FWGtaRTArR1l0SW1hL3RIOXVmMTRpVVFCV2dGR0FYSXAvTCtQQW5mclVnRTZJTUwrZXpZb0tUa0FBdjlsLzlVRGN3Z2JBQlFBUWdDVkFMSTJBQUFyc2lBQ0FDdXdMRE95QUFJQUs3SUhBZ0Fyc2d3Q0FDdXdGQzhCc0VNdnNBRFdzUlFQNmJBVUVMRVlBU3V4RmgweU1yRThEK216SGhnVkRpdTBQeEVBSGdRcnNEd1FzU29CSzdRdUVRQXlCQ3V5TGlvS0s3TkFMak1KSzdGRUFTdXhQeFVSRXJVQ0F4Y2JJRDRrRnpteFBCZ1JFckJBT2JBcUViSU9LRGc1T1RrQXNTQTJFUkt5SlNZdk9UazVNREVETmpjWEZoOEJGamNmQVFjR0x3RW1Md0VtRHdFYkFTYzNFVFEzTlNjMU5qTXlFeFlURnpNMUF6Y25OamN5RlFjWEV3Y1hCZ2NqSWdNQUp5SURGd2NUQnlNaW15ZlJLYWh3RlpldkZBb0d0c0Z1dXhnTldEMEdoQjBPRGpjM0d6YzlybFNtYnd4TURRMExMVU1hQ0VVT0d4c2RLVE55L3E1QUpSSU9EaDBwRDBvSEZlc2JGL2NoQkN1d0JnMFk2amhCMlFrRUZwTXQrV0FCa1E1R0FrU2xWQnRHS1RmK1JxTDk0ZDJYQkJQQVJpa09pVlRoKzljM3BrQUdBYUFEcWh6K0s4SjkvbFEzQUFNQUt3QUFBdm9IRVFBT0FCb0FId0JyQUxJTkFBQXJzUkVINmJBV0w3RUREZW15QXhZS0s3TkFBd1VKSzdBZkx3R3dJQyt3QWRheEdnL3BzQm9Rc1JNQks3RUtEK214SVFFcnNSb0JFUkt4RHhnNU9iQVRFYmNJREEwUkF4WWJIaVFYT1FDeEVRMFJFckFNT2JBV0ViQUtPYkVmQXhFU3NBZzVNREVUTlJJek5EY3pNaGNFRVJBRkJ5SURFak1nRVRVQ0l5SURGeFVUTnpZRkJ5dGdiMzBPVENNQkJ2N3JpK01HS2M0QlBralp0bDRNRXhoR0FhNXZBY2VtQXdZcmJuM00vZjc5K2E0TUFneitSZ0tKTndKVS9Pd09Ed1NPVGpIWldBQURBQ3NBQUFMNkJ6TUFEZ0FhQUI4QWVBQ3lEUUFBSzdFUkIrbXlIUUlBSzdJR0FnQXJ0QU1XRFIwTks3RUREZW15QXhZS0s3TkFBd1VKS3dHd0lDK3dBZGF4R2cvcHNCb1FzUk1CSzdFS0QrbXhJUUVyc1JvQkVSS3hEeGc1T2JBVEViY0lEQTBSQXhZYkhpUVhPUUN4RVEwUkVyQU1PYkFXRWJBS09iRWRBeEVTc1FnZk9Ua3dNUk0xRWpNME56TXlGd1FSRUFVSElnTVNNeUFSTlFJaklnTVhGUk1rTnhjQksyQnZmUTVNSXdFRy91dUw0d1lwemdFK1NObTJYZ3dQQVI0WE0vN1pBY2VtQXdZcmJuM00vZjc5K2E0TUFneitSZ0tKTndKVS9Pd09Ed1A4K0Fvei92VUFBQU1BS3dBQUF2b0hMd0FPQUJvQUtRQ1NBTElOQUFBcnNSRUg2YkllQWdBcnNTWU02YkltSGdvcnMwQW1Hd2tyc2dZQ0FDdTBBeFlOSGcwcnNRTU42YklERmdvcnMwQURCUWtyQWJBcUw3QUIxckVhRCttd0doQ3hFd0Vyc1FvUDZiRXJBU3V4R2dFUkVyRVBHRGs1c0JNUlFBa0lEQTBSQXhZYkhDTWtGem13Q2hLd0lUa0FzUkVORVJLd0REbXdGaEd3Q2pteEpnTVJFck1JSENFaUpCYzVNREVUTlJJek5EY3pNaGNFRVJBRkJ5SURFak1nRVRVQ0l5SURGeFVUTlJJN0FUSVRCaWNtSnlNR0R3RXJZRzk5RGt3akFRYis2NHZqQmluT0FUNUkyYlplREJyTk5SczV4WGNTWXg0UFZHbzRBY2VtQXdZcmJuM00vZjc5K2E0TUFneitSZ0tKTndKVS9Pd09Ed04zUXdGQS9uMHprWHNFVm1BbkFBQUFBQU1BQVFBQUE3TUhpd0FVQUNNQUx3Q1VBTElpQUFBcnNTWUg2YklJQWdBcnNnQUNBQ3V5RGdJQUs3SWFBZ0FydEJncklnZ05LN0VZRGVteUdDc0tLN05BR0JvSks3TVVJZ2dJS3dHd01DK3dBTmF4RkEvcHN4WVVBQWdyc1M4UDZiQVVFTEVvQVN1eEh3L3BzVEVCSzdFdkZCRVNzU1F0T1Rtd0tCRkFDUUlERGgwaElpWVlLeVFYT1FDeEppSVJFckFoT2JBckViQWZPYkVVR0JFU3NRd2RPVGt3TVJNMk54Y1dId0VXTng4QkJ3WXZBU1l2QVNZUEFRTTFFak0wTnpNeUZ3UVJFQVVISWdNU015QVJOUUlqSWdNWEZRRW4wU21vY0JXWHJ4UUtCcmJCYnJzWURWZzlCaUpnYjMwT1RDTUJCdjdyaStNR0tjNEJQa2padGw0TUJvWHJHeGYzSVFRcnNBWU5HT280UWRrSkJCYVRMZnRLcGdNR0syNTl6UDMrL2ZtdURBSU0va1lDaVRjQ1ZQenNEZzhBQkFBckFBQUMrZ2RLQUE0QUdnQWhBQ2dBY1FDeURRQUFLN0VSQittd0ZpK3hBdzNwc2dNV0NpdXpRQU1GQ1N1d0lDK3dKek1Cc0NrdnNBSFdzUm9QNmJBYUVMRVRBU3V4Q2cvcHNTb0JLN0VhQVJFU3NROFlPVG13RXhGQUNnZ01EUkVERmhzZUlpVWtGemtBc1JFTkVSS3dERG13RmhHd0NqbXhJQU1SRXJBSU9UQXhFelVTTXpRM016SVhCQkVRQlFjaUF4SXpJQkUxQWlNaUF4Y1ZFemN6RnhRSEppVTNNeGNVQnlZcllHOTlEa3dqQVFiKzY0dmpCaW5PQVQ1STJiWmVEQ1E3S1R4S1BBRWRQQ2s3U2pzQng2WURCaXR1ZmN6OS92MzVyZ3dDRFA1R0FvazNBbFQ4N0E0UEJMMU9Uak10R2xCT1RqTXRHd0FBQVFBWEFHUUNXQVBSQUJjQUhnQ3lCZ0VBSzdBTE13R3dHQyt3QU5hMERCRUFDQVFyc1JrQkt3QXdNVGMyTndJbk5UY3pNaE1YRXhjR0J4TUdJd1lEQmc4QkpoZEpzSWtwS1NrcFJpbXNaSm8vcGhNWU5aQ21NdzQzbkZyNEFXUXJLeW4rK21NQlNGeXNyUDdYUmlNQkdlY3JEUTBBQUFBQUF3QXJBQUFDK2dZTUFBNEFHZ0FuQUhZQXNnMEFBQ3V3SnpPeEVRZnBzQll2c1FNTjZiSURGZ29yczBBREJRa3JBYkFvTDdBQjFyRWFEK213R2hDeEhnRXJzU0lPNmJBaUVMRVRBU3V4Q2cvcHNTa0JLN0VhQVJFU3NROFlPVG13SGhHM0NBd05FUllER3lRa0Z6a0FzUkVORVJLeURCd21PVGs1c0JZUnNnb2VKRGs1T1RBeEV6VVNNelEzTXpJWEJCRVFCUWNpQXhJeklCRTFBaU1pQXhjVkV6VVNFelEzTXhVQ0F5SVZCeXRnYjMwT1RDTUJCdjdyaStNR0tjNEJQa2padGw0TUtjbXVReDJMd1IwbUFjZW1Bd1lyYm4zTS9mNzkrYTRNQWd6K1JnS0pOd0pVL093T0QvM2ZPQUdSQTJkZ0tSdjlBdjNxZlJzQUFnQXgvK3dDdWdkMUFCa0FIZ0JvQUxJWUFBQXJzUTBKNmJJQ0FnQXJzQk16c2hvQ0FDdXdIaThCc0I4dnNBRFdzUXNQNmJBSE1ySUxBQW9yczBBTEJRa3JzQXNRc1JJQks3UVZFUUFiQkN1eElBRXJzUXNBRVJLeEdoczVPYkFTRWJNRENSZ2VKQmM1c0JVU3N4QVJGaDBrRnprQU1ERVRFanNCRnhVQ0hRRVhCeFVTT3dFeUV6Y0ROeklWQXdJaEloTTNOZ1VITVNFL0tSdFFEQXd0VGc3SGFnMHJLMjRNamY3Znp5WVlSZ0d1YndQREFwa2REUDNtdVZJT0RrVDl1Z01IcFFIME42WCtpZnZKQnp0T01kbFlBQUFDQURILzdBSzZCNUFBR1FBZUFHSUFzaGdBQUN1eERRbnBzZ0lDQUN1d0V6T3lHZ0lBSzdBZUx3R3dIeSt3QU5heEN3L3BzQWN5c2dzQUNpdXpRQXNGQ1N1d0N4Q3hFZ0VydEJVUkFCc0VLN0VnQVN1eEVnc1JFclFEQ1JnYUhpUVhPYkFWRWJRUUVSWWNIU1FYT1FBd01STVNPd0VYRlFJZEFSY0hGUkk3QVRJVE53TTNNaFVEQWlFaUV5UTNGd0V4SVQ4cEcxQU1EQzFPRHNkcURTc3JiZ3lOL3QvUDVBRWVGelArMlFQREFwa2REUDNtdVZJT0RrVDl1Z01IcFFIME42WCtpZnZKQnFMNENqUCs5UUFBQWdBeC8rd0N1Z2hPQUJrQUtBQjFBTElZQUFBcnNRMEo2YklDQWdBcnNCTXpzaG9DQUN1eUlBSUFLN0FhTDdBbEw3RWRET2tCc0NrdnNBRFdzUXNQNmJBSE1ySUxBQW9yczBBTEJRa3JzQXNRc1JJQks3UVZFUUFiQkN1eEtnRXJzUXNBRVJLeEdoczVPYkFTRWJRRENSZ2lLQ1FYT2JBVkVyTVFFUllnSkJjNUFEQXhFeEk3QVJjVkFoMEJGd2NWRWpzQk1oTTNBemN5RlFNQ0lTSVROUkk3QVRJVEJpY21KeU1HRHdFeElUOHBHMUFNREMxT0RzZHFEU3NyYmd5Ti90L1BUODAxR3puRmR4SmpIZzlVYWpnRHd3S1pIUXo5NXJsU0RnNUUvYm9EQjZVQjlEZWwvb243eVFiZlF3RkEvbjB6a1hzRVZtQW5BQUFBQXdBeC8rd0N1Z2RVQUJrQUlBQW5BR29Bc2hnQUFDdXhEUW5wc2dJQ0FDdXdFek95R2dJQUs3SWhBZ0Fyc0I4dkFiQW9MN0FBMXJFTEQrbXdCekt5Q3dBS0s3TkFDd1VKSzdBTEVMRVNBU3UwRlJFQUd3UXJzU2tCSzdFU0N4RVN0Z01KR0JvZElTSWtGem13RlJHMUVCRVdJeVFtSkJjNUFEQXhFeEk3QVJjVkFoMEJGd2NWRWpzQk1oTTNBemN5RlFNQ0lTSVROek1YRkFjbUpUY3pGeFFISmpFaFB5a2JVQXdNTFU0T3gyb05LeXR1REkzKzM4OThPeWs4U2p3QkhUd3BPMG83QThNQ21SME0vZWE1VWc0T1JQMjZBd2VsQWZRM3BmNkorOGtIRUU1T015MGFVRTVPTXkwYkFBQUFBZ0ExLzZvQzhBZnFBQ0FBSlFCbUFMSWZBQUFyc1FRSTZiSVlBZ0Fyc0JBenNpRUNBQ3UwQ2hZZkVBMHJzUW9LNmJNbEdCQUlLd0d3Smkrd0RkYXhGQTdwc2hRTkNpdXpRQlFTQ1N1d0hqS3hKd0Vyc1JRTkVSS3dEemtBc1FvRUVSS3lBUU1jT1RrNXNSZ1dFUkt4QndZNU9UQXhOelV6TlJjZ0V5TURCaXNCSWljMUVqY1hGUVlSRmpNMkV6TVhCZ01DSXhVaUV5UTNGd0UxSFgwQk4xZ013NWNwS3p3SUNJRXBVUTRhK0tBM09FUS9hL0RBL0FFZUZ6UCsyVUlPRGxRRStQNjB3TUI5QWp4Y0R5bmovaTlnNXdJOE9JSDlEZnpDRGdjKytBb3ovdlVBQWdBbC84a0NCd1pjQUJFQUdBQlRBTElBQUFBcnNnVUNBQ3V5Q3dFQUs3RVhDT2tCc0JrdnNBUFdzQUF5dEFnUkFESUVLN0FHTXJFUkR1bXhHZ0Vyc1JFREVSS3hBUVU1T2JBSUViSUhFQmc1T1RrQXNSY0FFUkt5RHhBVE9UazVNREVYRXhBbk5EY1hCeEV6TmpzQkZnSUdKd01URWhzQk5DTUdKU3NwUTBZT0RubFdLOERHNWlzSUlVcXFRWDNSTndKVUE2NUpKU01yZS82NXBadjlGbEE2L2xBQ1lQNzRBWElCTU91c0FBQUIvOS8rU0FMZEJ1TUFJd0JlQUxJRkFnQXJzaHNDQUN1eUN3RUFLN0VXQStteUdRRUFLd0d3SkMrd0F0YTBJQThBSUFRcnNDQVFzUnNCSzdFSEVlbXhKUUVyc1NBQ0VSS3dJVG13R3hHMUNna1NGaGtSSkJjNXNBY1NzUlFWT1RrQXNRVUxFUkt3SHprd01RTTJFemMyTnpJWEZBTVZOeklYQWdjR0p6Y0VFeElqQmdjbkFCRW1KeUlIQXdJREJpRkVVcDkvYlhjaHozdG9NUlRraGFRQ0FUQm1HMitOVWhzQkl4c2NqS1VORGtRci9raStCd1ozVUJDeWNQNWlEdy9kL2QvVGJVcVl6d0p3QVV3ek5aTUJPQUVhUUFUUC9sVCtadncrbEFBQUFBTUFDUDlrQW9FRnp3QUVBQm9BSlFCUEFMSVpBQUFyc1IwSzZiSUlBUUFyc1NNSTZiSUtBUUFyc2dNQkFDdTBGQThaQ2cwcnNSUUQ2YkFFTHdHd0ppK3dCZGF4R3c3cHNTY0JLN0ViQlJFU3NCazVBTEVqRHhFU3NSWVhPVGt3TVJNM05nVUhBVFVRTnpJM014Y0hFanNCRlJRSEl5SURJd0lqSWhNVU16SVROU1lyQVNJUkNCaEdBYTV2L3FmcEowZ3JLUThuVmhzM09EY3BEbENvWUdBcFdsb0tIeXVKQllGT01kbFkrN3FXQW4xU1ZCM04vU0VNVEJjQk1mNHBBU1daQXM0UHd2MjdBQUFBQUFNQVRQOWtBb0VHb0FBVkFDQUFKUUJNQUxJVUFBQXJzUmdLNmJJakFnQXJzZ01CQUN1eEhnanBzZ1VCQUN1MER3b1VCUTByc1E4RDZRR3dKaSt3QU5heEZnN3BzU2NCSzdFV0FCRVNzQlE1QUxFZUNoRVNzUkVTT1Rrd01UYzFFRGN5TnpNWEJ4STdBUlVVQnlNaUF5TUNJeUlURkRNeUV6VW1Ld0VpRVJNa054Y0JUT2tuU0NzcER5ZFdHemM0TnlrT1VLaGdZQ2xhV2dvZks0azZBUjRYTS83WmlaWUNmVkpVSGMzOUlReE1Gd0V4L2lrQkpaa0N6Zy9DL2JzRVZQZ0tNLzcxQUFBQUF3Qk0vMlFDbndYZ0FCVUFKQUF2QUZzQXNoUUFBQ3V4SndycHNnTUJBQ3V4TFFqcHNnVUJBQ3V5SVFFQUs3RVpET214RHhRUUlNQXZzUW9ENmJNV0xSa0lLd0d3TUMrd0FOYXhKUTdwc1RFQks3RWxBQkVTc3hRV0Z5UWtGemtBc1MwS0VSS3hFUkk1T1RBeE56VVFOekkzTXhjSEVqc0JGUlFISXlJREl3SWpJaE0xRWpzQk1oTUdKeVluSXdZUEFSTVVNeklUTlNZckFTSVJUT2tuU0NzcER5ZFdHemM0TnlrT1VLaGdPTTAxR3puRmR4SmpIZzlVYWpnY0tWcGFDaDhyaVltV0FuMVNWQjNOL1NFTVRCY0JNZjRwQlBsREFVRCtmVE9SZXdSV1lDZjhMSmtDemcvQy9ic0FBQUFBQS8rSS8yUURPZ2JWQUJRQUtnQTFBR2dBc2lrQUFDdXhMUXJwc2dJQ0FDdXdDRE95RWdJQUs3SVlBUUFyc1RNSTZiSWFBUUFyc2d3QkFDdTBKQjhwR2cwcnNTUUQ2UUd3Tmkrd0FOYXhGQS9wc0JRUXNSVUJLN0VyRHVteE53RXJzU3NWRVJLeUF3SXBPVGs1QUxFekh4RVNzU1luT1Rrd01RTTJOeGNXSHdFV054OEJCd1l2QVNZdkFTWVBBUk0xRURjeU56TVhCeEk3QVJVVUJ5TWlBeU1DSXlJVEZETXlFelVtS3dFaUVYZ24wU21vY0JXWHJ4UUtCcmJCYnJzWURWZzlCbmpwSjBncktROG5WaHMzT0RjcERsQ29ZR0FwV2xvS0h5dUpCYy9yR3hmM0lRUXJzQVlOR09vNFFka0pCQmFUTGZyQ2xnSjlVbFFkemYwaERFd1hBVEgrS1FFbG1RTE9EOEw5dXdBRUFFei9aQUtCQldzQUZRQWNBQ2NBTGdCWUFMSVVBQUFyc1I4SzZiSURBUUFyc1NVSTZiSUZBUUFyc2hZQkFDdXlLQUVBSzdRUENoUUZEU3V4RHdQcHNCc3ZBYkF2TDdBQTFyRWREdW14TUFFcnNSMEFFUkt5RkJZWE9UazVBTEVsQ2hFU3NSRVNPVGt3TVRjMUVEY3lOek1YQnhJN0FSVVVCeU1pQXlNQ0l5SVROek1YRkFjbUV4UXpNaE0xSmlzQkloRVROek1YRkFjbVRPa25TQ3NwRHlkV0d6YzROeWtPVUtoZ0hqc3BQRW84S0NsYVdnb2ZLNG4xUENrN1NqdUpsZ0o5VWxRZHpmMGhERXdYQVRIK0tRV3ZUazR6TFJyN3ZKa0N6Zy9DL2JzRDAwNU9NeTBiQUFBQUFBUUFUUDlrQW9FRmVnQVZBQ0VBTEFBM0FJOEFzaFFBQUN1eEx3cnBzaVVCQUN1eE5RUHBzZ01CQUN1MElBMEE3QVFyc2dNZ0NpdXpRQU1GQ1N1MER3b1VCUTByc1E4RDZRR3dPQyt3QU5heExRN3BzQ0l5c0MwUXRCWVBBRFlFSzdBV0w3QXRFTEVuQVN1MEhROEFOZ1Fyc1RrQks3RXRGaEVTc0JRNXNDY1JRQW9HQXhFSUdSc2ZKQ294SkJjNXNCMFNzQWM1QUxFMUNoRVNzUkVTT1Rrd01UYzFFRGN5TnpNWEJ4STdBUlVVQnlNaUF5TUNJeUlUTlRRM01qVXlGeFFISXlJM0ZCY3pNamMwTHdFR0J4TVVNeklUTlNZckFTSVJUT2tuU0NzcER5ZFdHemM0TnlrT1VLaGdHOXBCYVVYYkNzRWZkeFNlRzNVdGh4c0RLVnBhQ2g4cmlZbVdBbjFTVkIzTi9TRU1UQmNCTWY0cEJTWVR1QjhHb05Fang0TW52bmNWQ0F4Lys3K1pBczRQd3YyN0FBQUFCQUJNLzJRRCtBU0xBQlVBSUFBNEFFSUFyUUN5RkFBQUs3RVlDdW15TlFBQUs3RXVBK213RGlEV0ViRUtBK215QXdFQUs3RWVDT215QlFFQUs3SWxBUUFyc1VFRDZiUTdLeFFsRFN1eE93UHBBYkJETDdBQTFyRVdEdW13RmhDeEdnRXJ0RGtSQUJZRUs3QTVFTEUrQVN1eEtBN3BzVVFCSzdFV0FCRVNzQlE1c0JvUnNBTTVzRGtTdHdVSURoSUhJU00zSkJjNXNENFJ0UXNsS2lzdU5TUVhPUUN4S3dvUkVyUVJFakV5TXlRWE9iQTdFYkEzT2JBZUVyQWhPVEF4TnpVUU56STNNeGNIRWpzQkZSUUhJeUlESXdJakloTVVNeklUTlNZckFTSVJBVFlUTmpNV0hRRVFCU01WRkJjek1qY1hNd0lqSWdNaU54WTdBVFk5QVNZaklrenBKMGdyS1E4blZoczNPRGNwRGxDb1lHQXBXbG9LSHl1SkFSUTRLMnBqM2Y3clhuc3JUbzhNRDJPeW9tWVdoUXdmVktZVmFxYUpsZ0o5VWxRZHpmMGhERXdYQVRIK0tRRWxtUUxPRDhMOXV3RW1Ld0U4dEVHY0tmN0xkeDM0WXQwTS9zRUNOMkJFVHZBT2lRQUNBQkw5TVFKVEJMWUFGUUFtQUhJQXNoSUFBQ3V4REFqcHNoMEFBQ3V5QkFFQUs3QWxMN0VYQ09rQnNDY3ZzQURXc1FvTzZiQUtFTEVPQVN1MEVBOEFJQVFyc1NnQks3RUtBQkVTc0JZNXNBNFJ0d01GRWhvZUh5QWxKQmM1c0JBU3NDSTVBTEVTRnhFU3NTSWpPVG13REJHeEhoODVPYkFFRXJFT0VEazVNREVUTlJBL0FSY1ZCQkVIRlJRWE1qY3pGeFFISWljbUV4Y3pOajBCTkFNbk54VVVFeGNDSVNJUzBZb3AvdXNNemFVcktRL2Q0RkFySnFZM3djRXJiK3dPWlA3aG1BR1dZQUdUNkVVT0c3cit1bjJ5MVQrSktaWXQzbkQ4YXcwdWVBMGtBUnVXRUIyVi92ZzQvdmdBQUFBRC8rMy83QUpLQmM4QUJBQWNBQ1lBY0FDeUdRQUFLN0VTQStteUNRRUFLN0VsQStteUF3RUFLN1FQSHhrSkRTdXhEd1Bwc0FRdkFiQW5MN0FiMXJRUUVRQXhCQ3V3RUJDeElnRXJzUXdPNmJFb0FTdXhFQnNSRXJFSEhUazVzQ0lSdGdRT0NSSVpJQ1VrRnptd0RCS3dBemtBc1E4U0VSS3lGUllYT1RrNU1ERUROellGQndFMkV6WXpGaDBCRUFVakZSUVhNekkzRnpNQ0l5SURJamNXT3dFMlBRRW1JeUlUR0VZQnJtLytpRGdyYW1QZC91dGVleXRPand3UFk3S2laaGFGREI5VXBoVnFwZ1dCVGpIWldQMlpLd0U4dEVHY0tmN0xkeDM0WXQwTS9zRUNOMkJFVHZBT2lRQUFBQUFEQUJMLzdBSktCcUFBRndBaEFDWUFkZ0N5RkFBQUs3RU5BK215SkFJQUs3SUVBUUFyc1NBRDZiUUtHaFFFRFN1eENnUHBBYkFuTDdBVzFyUUxFUUF4QkN1d0N4Q3hIUUVyc1FjTzZiRW9BU3V4Q3hZUkVyRUNHRGs1c0IwUnR3a0VEUlFiSUNJbUpCYzVzQWNTc0NRNUFMRUtEUkVTc2hBUkVqazVPYkVrQkJFU3NDWTVNREVUTmhNMk14WWRBUkFGSXhVVUZ6TXlOeGN6QWlNaUF5STNGanNCTmowQkppTWlFeVEzRndFU09DdHFZOTMrNjE1N0swNlBEQTlqc3FKbUZvVU1IMVNtRldxbUx3RWVGelArMlFKb0t3RTh0RUdjS2Y3TGR4MzRZdDBNL3NFQ04yQkVUdkFPaVFHSytBb3ovdlVBQXdBUy8rd0NkZ1hBQUJjQUpnQXdBSWdBc2hRQUFDdXhEUVBwc2dRQkFDdXhMd1Bwc2lNQkFDdXhHd3pwdEFvcEZCc05LN0VLQStteEdDOFFJTUF2QWJBeEw3QVcxclFMRVFBeEJDdXdDeEN4TEFFcnNRY082YkV5QVN1eEN4WVJFclFDR0JrbUp5UVhPYkFzRWJZSkJBMFVJeW92SkJjNXNBY1NzQ0E1QUxFS0RSRVNzaEFSRWprNU9iQXBFYkFXT2JBdkVyQUFPVEF4RXpZVE5qTVdIUUVRQlNNVkZCY3pNamNYTXdJaklnTWlFelVTT3dFeUV3WW5KaWNqQmc4QkV4WTdBVFk5QVNZakloSTRLMnBqM2Y3clhuc3JUbzhNRDJPeW9tWVdSTTAxR3puRmR4SmpIZzlVYWpnMURCOVVwaFZxcGdKb0t3RTh0RUdjS2Y3TGR4MzRZdDBNL3NFQ053SWFRd0ZBL24wemtYc0VWbUFuL2taRVR2QU9pUUFBQkFBUy8rd0NTZ1dTQUJjQUhnQW9BQzhBZ0FDeUZBQUFLN0VOQStteUJBRUFLN0VuQStteUdBRUFLN0l1QVFBcnRBb2hGQVFOSzdFS0ErbXdIUzhCc0RBdnNCYld0QXNSQURFRUs3QUxFTEVrQVN1eEJ3N3BzVEVCSzdFTEZoRVN0QUlZR2gwZkpCYzVzQ1FSUUFrSkJBMFVHeUluS1Nva0Z6bXdCeEt5S3l3dU9UazVBTEVLRFJFU3NoQVJFams1T1RBeEV6WVROak1XSFFFUUJTTVZGQmN6TWpjWE13SWpJZ01pRXpjekZ4UUhKaE1XT3dFMlBRRW1JeUlUTnpNWEZBY21FamdyYW1QZC91dGVleXRPand3UFk3S2laaFltT3lrOFNqeEZEQjlVcGhWcXB0ZzhLVHRLT3dKb0t3RTh0RUdjS2Y3TGR4MzRZdDBNL3NFQ053TVhUazR6TFJyOWowUk84QTZKQVRCT1RqTXRHd0FBQUFQL1R2LzJBZEVGM3dBSUFCVUFJZ0F1QUxJVkFBQXJzQ0F6c2d3QkFDdXdHRE95QXdFQUt3R3dJeSt3Q3Rhd0ZqS3hIQTdwc0JBeXNTUUJLd0F3TVFNM05nRWZBUVlBQnhJREVEc0JGd1lWRWhjVkJ5TURFRHNCRndZVkVoY1ZCeU1pc2hZdkFjbFVJV24rYXgyZ0lWUWJLemNHU3lncFkxUWJLemNHU3lncFFnWFBFQ0greXhrdk93RVVEdnFvQW9zQklUZzMrUDc2K0J3ckFvc0JJVGczK1A3NitCd3JBQUwvUGYvMkFlRUY4QUFJQUJVQUlnQ3lGUUFBSzdJTUFRQXJzZ0FCQUNzQnNCWXZzQXJXc1JBTzZiRVhBU3NBTURFRFB3RUFId0VISmdRU0F4QTdBUmNHRlJJWEZRY2p3eUZZQWVJeEdHd2gvbGFzSVZRYkt6Y0dTeWdwQkw0cEZ3RU1HaEZ3RFBMN2JRS0xBU0U0Ti9qKyt2Z2NLd0FBQUFML3NQLzJBZDhHU2dBUEFCd0FPUUN5R3dBQUs3SURBZ0Fyc1F3TTZiSU1Bd29yczBBTUJ3a3JzaElCQUN1eUFRRUFLN0FBTHdHd0hTK3dFTmF4Rmc3cHNSNEJLd0F3TVFNMUVqc0JNaE1YSWljbUp5TUdEd0VURURzQkZ3WVZFaGNWQnlNaVVNY3pHem5QRW9zU2F4OE9WR0E0ZDFRYkt6Y0dTeWdwUWdSSVJ3RzcvZjR4ay9RR1dOa3IvamtCSVRnMytQNzYrQndyQUFBQUFBUC9vdi8yQVhzRkFBQUdBQk1BR2dBd0FMSVNBQUFyc2hVQkFDdXhBUWt6TTdNRkVoVUlLd0d3R3krd0I5YXhEUTdwc1J3Qks3RU5CeEVTc0FNNUFEQXhBemN6RnhRSEpoTVFPd0VYQmhVU0Z4VUhJeUlUTnpNWEZBY21YanNyUEVvOGQxUWJLemNHU3lncFFvTTdMamxLT3dTb1RrNHpMUnIrSHdFaE9EZjQvdnI0SENzRXZFNU9NeTBiQUFBQUFBSUFYUC91QWo4RlNnQVdBQ0VBSmdDd0h5K3hBd1BwQWJBaUw3QUExckVYRHVteEl3RXJzUmNBRVJLeUZnTU1PVGs1QURBeEV6VTBOeUFURWdFSEp6Y0dKellmQVRZM0Z3Y0FBUVFURWhjek1qY0NLd0VHRlZ4TUFSSXQ0UDdyUFZBMUc4SVpKclVyVFZaZ0FiZitNLzYrTVMxTUxTTUtMMllSTFFHeXRrWWgvbUFCaHdFUHRTUGZDazV6RVVWRmtpblQvaVg5ZTU0Q1Z2NlpFdDBCVUFoR0FBQUFBdjluLzdvREdRYlZBQlFBTlFDM0FMSXlBQUFyc0NZenNnSUNBQ3V3Q0RPeUVnSUFLN0lYQVFBcnNoNEJBQ3V4TEF2cHNnd0JBQ3NCc0RZdnNBRFdzUlFQNmJBVUVMRTFBU3V4TGhIcHNCWWcxaEd4R1JIcHNDNFF0RFFSQURJRUs3QTBMN1F3RVFBZUJDdXdMaEN4S1FFcnNTSU82YkFrTXJFbEVlbXdJekt4TndFcnNSa1dFUkswQXdJYUd6SWtGem14TGpRUkVyRVhIRGs1c1NrMUVSS3hEaDQ1T2JBaUViQW1PUUN4TERJUkVyTWFIQ01iSkJjNXNRSWVFUkt4QnhRNU9UQXhBelkzRnhZZkFSWTNId0VIQmk4QkppOEJKZzhCRXpVM0ZoVUhGek0wTnpNeUV4VVhCeGNISmpVUkVDY2pCZ01SRndZaklpY1RtU2ZSS2Fod0ZaZXZGQW9HdHNGdXV4Z05XRDBHY2pjM0RnNGJ3d3lrSGc4UER5dEVZZ3lVSVE4ZEcwVVBEd1hQNnhzWDl5RUVLN0FHRFJqcU9FSFpDUVFXa3kzK0RsSTNGQlhQRHN1Yi9aVDZsemg5R2hKT0Fja0I0eWxNL2V6K2ZUaFNPQUYwQUFBRC83Ny8yUUlHQmM4QUJBQVFBQm9BVXdDeUR3QUFLN0VUQStteUJ3RUFLN0lEQVFBcnNBUXZBYkFiTDdBRjFyRVJEK213RVJDeEZnRXJzUXNQNmJFY0FTdXhGaEVSRXJNRUJ3NE5KQmM1c0FzUnNBTTVBTEVIRXhFU3NnVUtHVGs1T1RBeEF6YzJCUWNCRUNFeUV3Y1ZBaU1ISXlZVEVqc0JNaE0xTkNjR1FoaEdBYTV2L3RRQkk0RXpEaU82RHc3UFZCOWNEblVqZTZZRmdVNHgyVmo5R0FKUS9vNFJVdjJEREM4Q0kvNGRBZkhEdWhNeEFBQUFBd0F2LzlrQ0JnYWdBQXNBRlFBYUFGY0FzZ29BQUN1eERnUHBzaGdDQUN1eUFnRUFLd0d3R3krd0FOYXhEQS9wc0F3UXNSRUJLN0VHRCtteEhBRXJzUkVNRVJLMEFna0lGaG9rRnptd0JoR3dHRGtBc1FJT0VSS3lBQVVVT1RrNXNCZ1JzQm81TURFVEVDRXlFd2NWQWlNSEl5WVRFanNCTWhNMU5DY0dFeVEzRndFdkFTT0JNdzRqdWc4T3oxUWZYQTUxSTN1bUdRRWVGelArMlFIbkFsRCtqaEZTL1lNTUx3SWovaDBCOGNPNkV6RUNCdmdLTS83MUFBQURBQy8vMlFKUEJjZ0FDd0FhQUNRQVpBQ3lDZ0FBSzdFZEErbXlBZ0VBSzdJWEFRQXJzUThNNmJFTUFoQWd3QzhCc0NVdnNBRFdzQXd5c1JzUDZiQWJFTEVnQVN1eEJnL3BzU1lCSzdFYkFCRVNzQm81c0NBUnN3SUpGd2drRnptd0JoS3dGRGtBc1FJZEVSS3lBQVVqT1RrNU1ERVRFQ0V5RXdjVkFpTUhJeVlUTlJJN0FUSVRCaWNtSnlNR0R3RVRFanNCTWhNMU5DY0dMd0VqZ1RNT0k3b1BEczhGelRVYk9jVjNFbU1lRDFScU9FTWZYQTUxSTN1bUFlY0NVUDZPRVZMOWd3d3ZCRDFEQVVEK2ZUT1Jld1JXWUNmOTV2NGRBZkhEdWhNeEFBUC93Ly9aQTNVR0FRQVVBQ0FBS2dCa0FMSWZBQUFyc1NNRDZiSVhBUUFyc2dBQkFDdXlCd0VBSzdJTEFRQXJzQlF2QWJBckw3QUExckVVRCttd0ZCQ3hGUUVyc1NFUDZiQWhFTEVtQVN1eEd3L3BzU3dCSzdFbUlSRVN0UUlPRndNZUhTUVhPUUN4RnlNUkVySVZHaWs1T1Rrd01RTTJOeGNXSHdFV054OEJCd1l2QVNZdkFTWVBBUk1RSVRJVEJ4VUNJd2NqSmhNU093RXlFelUwSndZOUo5RXBxSEFWbDY4VUNnYTJ3VzY3R0ExWVBRWWdBU09CTXc0anVnOE96MVFmWEE1MUkzdW1CUHZyR3hmM0lRUXJzQVlOR09vNFFka0pCQmFUTGZ6MEFsRCtqaEZTL1lNTUx3SWovaDBCOGNPNkV6RUFBQUFBQkFBdi85a0NGZ1U4QUFzQUVnQWNBQ01BYUFDeUNnQUFLN0VWQStteURRRUFLN0FDTTdJZEFRQXJzeEVDRFFnckFiQWtMN0FBMXJFVEQrbXdFeEN4R0FFcnNRWVA2YkVsQVN1eEV3QVJFckVNRFRrNXNCZ1J0Z0lKRGdnUkR4MGtGem13QmhLeUhoOGlPVGs1QUxFUkZSRVNzZ0FGR3prNU9UQXhFeEFoTWhNSEZRSWpCeU1tRXpjekZ4UUhKaE1TT3dFeUV6VTBKd1lUTnpNWEZBY21Md0VqZ1RNT0k3b1BEczhRT3lrOFNqd3FIMXdPZFNON3B2TThLVHRLT3dIbkFsRCtqaEZTL1lNTUx3VGNUazR6TFJyOWpmNGRBZkhEdWhNeEFWWk9Uak10R3dBQUF3QXlBUGNCL3dNbEFBVUFEZ0FXQUVNQXNBMHZzUWdMNlFHd0Z5K3dCdGEwQ3hFQUdnUXJzQXNRc0JRZzFoRzBEeEVBSHdRcnNBOHZ0QlFSQUI4RUs3RVlBU3V4Q3c4UkVyTU1DQkVWSkJjNUFEQXhFemNGTnhjbUp6WTNGaDBCQnlNaUV6UTNGaDBCQnlZeUJBR2NLUVM4aFFSYlFDWVBQd3REUVVGREFmbGdFQVpxSTh3ckpoSk5FQ2YrazA4VEVSZ3NPQk1BQUFBREFCYi9QZ0lHQlFVQURBQVlBQ0lBZ2dDeUN3QUFLN0lXQUFBcnNBZ3pzUnNENmJJV0FBQXJzUnNENmJJRUFRQXJzQTh6QWJBakw3QU4xckVaRCttd0NqS3dHUkN4REJIcHNBd3ZzQmtRc1I0Qks3RVREK213QlRLd0V4Q3hBZzdwc0FJdnNTUUJLN0VaRFJFU3NBczVzQUlSdEFnUEZSWWhKQmM1c1JNZUVSS3dCRGtBc1FRYkVSS3lEUkloT1RrNU1ERVhFaE0wTnpNVkFnTWlGUWNuRXhBaE1oTUhGUUlqQnlNbUV4STdBVElUTlRRbkJoYkpya01kaThFZEprZ1pBU09CTXc0anVnOE96MVFmWEE1MUkzdW1mQUdSQTJkZ0tSdjlBdjNxZlJzT0Fwc0NVUDZPRVZMOWd3d3ZBaVArSFFIeHc3b1RNUUFBQUFBQy84ei84QUlqQmM4QUJBQWRBR3dBc2h3QUFDdXhEZ1Bwc2hZQkFDdXlBd0VBSzdBRUx3R3dIaSt3QmRheERCSHBzZ3dGQ2l1elFBd0tDU3V3REJDeEVRRXJzUmdPNmJJWUVRb3JzMEFZRndrcnNSOEJLN0VNQlJFU3NBazVzQkVSc2dRVUhEazVPYkFZRXJFREZqazVBTEVXRGhFU3NBZzVNREVETnpZRkJ3RTFORGN6RndjVkVCTXpOaE0xTkNjME54Y0hGUmNDSXlJMEdFWUJybS8rdWpjZEtROTlIV0FiRzMwYkd3dzNzcllGZ1U0eDJWajk0MUpwRWh0Z2lmN3QvdlluQWVXTVlqZFlGeDF1SzIvOUZ3QUFBQUlBSS8vd0FpTUdvQUFZQUIwQWNBQ3lGd0FBSzdFSkErbXlHd0lBSzdJUkFRQXJBYkFlTDdBQTFyRUhFZW15QndBS0s3TkFCd1VKSzdBSEVMRU1BU3V4RXc3cHNoTU1DaXV6UUJNU0NTdXhId0Vyc1FjQUVSS3dCRG13REJHekR4Y1pIU1FYT2JBVEVyRVJHems1QUxFUkNSRVNzQU01c0JzUnNCMDVNREVUTlRRM014Y0hGUkFUTXpZVE5UUW5ORGNYQnhVWEFpTWlFeVEzRndFak54MHBEMzBkWUJzYmZSc2JERGV5dGpVQkhoY3ovdGtDc2xKcEVodGdpZjd0L3ZZbkFlV01ZamRZRngxdUsyLzlGd1d1K0Fvei92VUFBQUlBRC8vd0Fpb0YzQUFPQUNjQWNnQ3lKZ0FBSzdFWUErbXlJQUVBSzdJTEFRQXJzUU1NNmJNQUlBTUlLd0d3S0Mrd0Q5YXhGaEhwc2hZUENpdXpRQllVQ1N1d0ZoQ3hHd0Vyc1NJTzZiSWlHd29yczBBaUlRa3JzU2tCSzdFV0R4RVNzQk01c0JzUnN3Z0xIaVlrRnptd0loS3dJRGtBc1NBWUVSS3dFamt3TVJNMUVqc0JNaE1HSnlZbkl3WVBBUk0xTkRjekZ3Y1ZFQk16TmhNMU5DYzBOeGNIRlJjQ0l5SVB6VFViT2NWM0VtTWVEMVJxT0FnM0hTa1BmUjFnR3h0OUd4c01ON0syQkZsREFVRCtmVE9SZXdSV1lDZitXVkpwRWh0Z2lmN3QvdlluQWVXTVlqZFlGeDF1SzIvOUZ3QUFBQUFEQUNQLzhBSWpCUlVBR0FBZkFDWUFlUUN5RndBQUs3RUpBK215R2dFQUs3RVJJVE16c3g0UkdnZ3JBYkFuTDdBQTFyRUhFZW15QndBS0s3TkFCd1VKSzdBSEVMRU1BU3V4RXc3cHNoTU1DaXV6UUJNU0NTdXhLQUVyc1FjQUVSS3lCQmthT1RrNXNBd1J0UThYR3h3ZUlDUVhPYkFURXJNUklTSWxKQmM1QUxFZUNSRVNzQU01TURFVE5UUTNNeGNIRlJBVE16WVROVFFuTkRjWEJ4VVhBaU1pQXpjekZ4UUhKaVUzTXhjVUJ5WWpOeDBwRDMwZFlCc2JmUnNiRERleXRpbzdLVHhLUEFFZFBDazdTanNDc2xKcEVodGdpZjd0L3ZZbkFlV01ZamRZRngxdUsyLzlGd1ROVGs0ekxScFFUazR6TFJzQUFBSUFLL3pQQW04RlJ3QWtBQ2tBa1FDeURRRUFLN0lsQVFBcnNDTXZzUWtNNmJBcEx3R3dLaSt3QU5heEJ3N3BzZ2NBQ2l1elFBY0RDU3V3QnhDeEhnRXJzUlVPNmJBUk1ySVZIZ29yczBBVkR3a3JzQlVRdEF3UkFERUVLN0FNTDdFckFTdXhEQWNSRWtBSkFoa2FIQ0VqSlNjcEpCYzVzQjRSc0I4NXNCVVN0QTBPRXhZb0pCYzVBTEVKSXhFU3NDRTVzQTBSdEFBQ0ZCNGZKQmM1TURFVEVEY1hGUVlkQVJRN0FRQVJOek1YQmgwQkF4Y1ZCeEFyQVNjMk5SSVJJd1lEQmdjaUV5UTNGd0VyZXl0SU9CQUJCRGNyT0JzUUVCQmZOemRTS1EwVXJqeEJlM1VCSGhjei90a0IxUUZLUnc0M1ZyQlUrQUc2QVNGVU56aGdZdjZaRGc2Si9BNUZRTWNCZXdLdUIvNCtOdzhFRVBnS00vNzFBQUFBQWdBUS91RUIwUVNOQUJBQUdRQnZBTElPQUFBcnNnVUJBQ3V4RndQcHNnRUJBQ3NCc0JvdnNCRFdzUkVPNmJBSk1yQUFJTllSc1FFTzZiQVJFTEVVQVN1eEJ4SHBzUnNCSzdFUUFCRVNzQTg1c0FFUnNBTTVzQkVTc0EwNXNCUVJzd1VNRWhja0Z6bXdCeEt3RXprQXNSY09FUkt6QXdrQ0VTUVhPVEF4RXpjQ0p6WXpNaE1VQlJVUU53Y2pJamNUTXpZREVpY2pCaEVRWHhFRVNvR1BIZjdYQkNzTVZCWmxETWtMQWxFTmJnUjNGdjQ4R01IK1h0MzJFUDdHR3gyTUFVbG5BUVlCQkF4YS90Y0FBd0FyL004Q2ZnVThBQ1FBS3dBeUFKWUFzZzBCQUN1d0pqT3lMQUVBSzdBakw3RUpET213S2k4QnNETXZzQURXc1FjTzZiSUhBQW9yczBBSEF3a3JzQWNRc1I0Qks3RVZEdW13RVRLeUZSNEtLN05BRlE4Sks3QVZFTFFNRVFBeEJDdXdEQyt4TkFFcnNRd0hFUkszQWhrYUhDRWpKU2drRnptd0hoR3hIeXc1T2JBVkVyWU5EaE1XTFM0eEpCYzVBTEVKSXhFU3NDRTVzQTBSdEFBQ0ZCNGZKQmM1TURFVEVEY1hGUVlkQVJRN0FRQVJOek1YQmgwQkF4Y1ZCeEFyQVNjMk5SSVJJd1lEQmdjaUV6Y3pGeFFISmlVM014Y1VCeVlyZXl0SU9CQUJCRGNyT0JzUUVCQmZOemRTS1EwVXJqeEJlM3c3S1R4S1BBRWRQQ2s3U2pzQjFRRktSdzQzVnJCVStBRzZBU0ZVTnpoZ1l2NlpEZzZKL0E1RlFNY0Jld0t1Qi80K053OEVyMDVPTXkwYVVFNU9NeTBiQUFBQUF3QXIvNUFFOXdhQUFBNEFHZ0E3QU00QXNqb0FBQ3V4TmdQcHNnMEFBQ3V4RVFmcHNpUUNBQ3V5QmdJQUs3RURKQkFnd0MreEZnM3BzZ01XQ2l1elFBTUZDU3NCc0R3dnNBSFdzUm9QNmJBYUVMRVRBU3V3SFRLeE5BL3BzQW95c2pRVENpdXpRRFF3Q1N1eUV6UUtLN05BRXhzSks3TWZOQk1JSzdFcUQrbXlLaDhLSzdOQUtpY0pLN0U5QVN1eEdnRVJFckVQR0RrNXNCTVJ0UWdNRFJFREZpUVhPYkFmRXJFY0lqazVzU28wRVJLeEt6STVPUUN4RVRZUkVyRU1PRGs1c0JZUnRnb2JIUzB1TWpja0Z6bXhKQU1SRXJJSUlpazVPVGt3TVJNMUVqTTBOek15RndRUkVBVUhJZ01TTXlBUk5RSWpJZ01YRlFFVEp6WTFBelFqTkNVV0hRRVVCUU1WRkRNbEZ4VVVCUU1WRkRNbEZ4WUZJaXRnYjMwT1RDTUJCdjdyaStNR0tjNEJQa2padGw0TUFoSkVLVGNPSFFHRFJ2N0FDaWNCQ0F6K3hUZHVBWE1ZRS80M2h3SEhwZ01HSzI1OXpQMysvZm11REFJTS9rWUNpVGNDVlB6c0RnLytjQUpTUldrOUFWNktia2dUR0NrclBQNGRSaHdjRGc0M09QMmdHNWVYVkJTZUFBQUFBQVFBTC8vWkEvZ0VjZ0FMQUJVQUxRQTNBS3dBc2dvQUFDdXdLak94RGdQcHNDTXlzZ0lCQUN1eUdnRUFLN0UyQSttMElEQUtHZzByc1NBRDZRR3dPQyt3QU5heERBL3BzQXdRc1JFQks3UXVFUUFaQkN1d0xoQ3dJU0RXRWJRc0VRQXhCQ3V3TEMrMElSRUFNUVFyc0M0UXNUTUJLN0VkRHVteE9RRXJzUkVNRVJLeUFna0lPVGs1c0M0UnRBVUdCQllZSkJjNXNUTWhFUksxSHhvaktqRTJKQmM1QUxFZ0RoRVNzaVluS0RrNU9iRTJDaEVTc2dRQUZEazVPVEF4RXhBaE1oTUhGUUlqQnlNbUV4STdBVElUTlRRbkJnRTJFell6RmgwQkVBVWpGUlFYTXpJM0Z6TUNJeUlESWpjV093RTJQUUVtSXlJdkFTT0JNdzRqdWc4T3oxUWZYQTUxSTN1bUFUMDRLMnBqM2Y3clhuc3JUbzhNRDJPeW9tWVdoUXdmVktZVmFxWUI1d0pRL280UlV2MkREQzhDSS80ZEFmSER1aE14L3I4ckFUeTBRWndwL3N0M0hmaGkzUXord1FJM1lFUk84QTZKQUFBQUFBTUFOZitxQXZBSDFRQWdBQ2NBTGdCb0FMSWZBQUFyc1FRSTZiSVlBZ0Fyc0JBenNpWUNBQ3V5TFFJQUs3UUtGaDhRRFN1eENncnBzQ1l2QWJBdkw3QU4xckVVRHVteUZBMEtLN05BRkJJSks3QWVNckV3QVN1eEZBMFJFckFQT1FDeENnUVJFcklCQXh3NU9UbXhHQllSRXJFSEJqazVNREUzTlRNMUZ5QVRJd01HS3dFaUp6VVNOeGNWQmhFV016WVRNeGNHQXdJakZTSVROek1YRkFjbUpUY3pGeFFISmpVZGZRRTNXQXpEbHlrclBBZ0lnU2xSRGhyNG9EYzRSRDlyOE1DMU95azhTandCSFR3cE8wbzdRZzRPVkFUNC9yVEF3SDBDUEZ3UEtlUCtMMkRuQWp3NGdmME4vTUlPQjlOT1RqTXRHbEJPVGpNdEd3QUFBQUFCQUljRlNnS2lCczBBRGdBcUFMSURBZ0Fyc1FzTTZiSUxBd29yczBBTEFBa3JBYkFQTDdBQTFyUUdFUUFJQkN1eEVBRXJBREF4RXpVU093RXlFd1luSmljakJnOEJoODAxR3puRmR4SmpIZzlVYWpnRlNrTUJRUDU5TTVGN0JGWmdKd0FBQVFDREJVb0VOUWJWQUJRQUlBQ3lBZ0lBSzdBSU03SVNBZ0FyQWJBVkw3QUExckVVRCtteEZnRXJBREF4RXpZM0Z4WWZBUlkzSHdFSEJpOEJKaThCSmc4Qmd5ZlJLYWh3RlpldkZBb0d0c0Z1dXhnTldEMEdCYy9yR3hmM0lRUXJzQVlOR09vNFFka0pCQmFUTFFBQUFBRUFaQUxQQXZBRGdRQUhBQUFUTlNVekZ4VUVCMlFDVkEwci9vM2hBdmhGUkNrcEtUY0FBQUFCQUdRQ3p3THdBNEVBQndBQUV6VWxNeGNWQkFka0FsUU5LLzZONFFMNFJVUXBLU2szQUFBQUFRQmtBczhDOEFPQkFBY0FBQk0xSlRNWEZRUUhaQUpVRFN2K2plRUMrRVZFS1NrcE53QUFBQUVBWUFMSkFpMERQUUFGQUJZQUFiQUdMN0FCMXJRREVRQUpCQ3V4QndFckFEQXhFemNGTnhjbVlBUUJuQ2tFdkFMZFlCQUdhaU1BQVFCYUFxWURhZ01VQUFjQUtBQ3dCeSt4QVFQcHNRRUQ2YkFCRUxFRkIra0JzQWd2c1FrQkt3Q3hBUVVSRXJFQUJqazVNREVUTlFVekZ4VWtCMW9DMlF3ci9mVE5BczlGQWlrb0NDTUFBQUFCQUVvRW1BRDJCbUFBQ1FBcUFMSUVBZ0FydEFrRUFBa0VLd0d3Q2krd0F0YTBCaEVBSGdRcnNRc0JLN0VHQWhFU3NBazVBREF4RXpRM0VqTVdGUUlISTBvZ01pVTFaUndMQk1NNU5RRXZHamorcUI0QUFBQUFBUUJLQkpnQTlnWmdBQWtBS2dDeUJBSUFLN1FKQkFBSkJDc0JzQW92c0FMV3RBWVJBQjRFSzdFTEFTdXhCZ0lSRXJBSk9RQXdNUk0wTnhJekZoVUNCeU5LSURJbE5XVWNDd1RET1RVQkx4bzQvcWdlQUFBQUFBRUFiZjlvQVJrQk1RQUpBQ29Bc2drQUFDdTBCQVFBQ1FRckFiQUtMN0FDMXJRR0VRQWVCQ3V4Q3dFcnNRWUNFUkt3Q1RrQU1ERVhORGNTTXhZVkFnY2piU0F4SlRabEhBdHRPalVCTHhvNC9xZ2ZBQUlBZ3dTb0Fmb0dxQUFKQUJNQVF3Q3lBd0lBSzdRU0JBQUlCQ3V5QVFJQUs3QU1NN01JRWdNSUt3R3dGQyt3QU5hMEJSRUFIZ1Fyc0FVUXNRb0JLN0VRRCtteEZRRXJBTEVJRWhFU3NCQTVNREVUTlRZek1oY0NLd0VpTnhJekZoVUdEd0VqSW9NSUkwb1VKeHdiSzlFYlZEZElEQTROTndZcksxSTMvcGxFQVFnVUY1UGlEZ0FDQUlNRXFBSDZCcWdBQ1FBVEFFTUFzZ01DQUN1MEVnUUFDQVFyc2dFQ0FDdXdERE96Q0JJRENDc0JzQlF2c0FEV3RBVVJBQjRFSzdBRkVMRUtBU3V4RUEvcHNSVUJLd0N4Q0JJUkVyQVFPVEF4RXpVMk16SVhBaXNCSWpjU014WVZCZzhCSXlLRENDTktGQ2NjR3l2UkcxUTNTQXdPRFRjR0t5dFNOLzZaUkFFSUZCZVQ0ZzRBQWdDRC8zY0IrQUYzQUFrQUV3QThBTElTQUFBcnRBTUVBQWdFSzdJSUFBQXJBYkFVTDdBQTFyUUZFUUFlQkN1d0JSQ3hDZ0Vyc1JBUDZiRVZBU3NBc1FNSUVSS3hEQTQ1T1RBeE56VTJNeklYQWlzQklqY1NNeFlWQmc4Qkl5S0RCaU5NRkNrY0d5blBHMVEzUmc0TUR6ZjZLVlE0L3BoR0FRWVZGSlRoRGdBQkFITUJ0Z0ZvQXJnQUJ3QTJBTEFHTDdRQ0JBQVFCQ3UwQWdRQUVBUXJBYkFJTDdBQTFyUUVFUUFSQkN1MEJCRUFFUVFyc1FrQkt3Q3hBZ1lSRXJBRU9UQXhFelEzTmhjR0p5WnpVb0VpSzF4VUFrbzNOeGVRblJRbEFBTUF0Z0FBQlc4QXJnQUdBQTBBRkFBdUFMSUZBQUFyc1F3VE16TzBBZ3dBR0FRcnNRa1FNaklCc0JVdnNSWUJLd0N4QWdVUkVySUJDQTg1T1Rrd01UOEJNeGNVQnlZbE56TVhGQWNtSlRjekZ4UUhKclk4S3psS09RSHdPUzA3U1Q0Qjhqc3JPa281WUU1T015MGJSVTVPTXkwYlJVNU9NeTBiQUFBQkFIY0JIUUs2QkJRQUVBQWxBTElFQVFBckFiQVJMN0FBMXJRS0VRQUlCQ3V4RWdFcnNRb0FFUkt4QmdrNU9RQXdNUk0wTnpZbEZoVVVBUWNGRlFjaUpTWW5kNGxRQVRNMy9wb09BWFFwSi83Y0o0NENUa01yZCtFTUt4ais2VWIzS3luUEhBOEFBQUVBVGdHREFxNEUyd0FTQUM0QUFiQVRMN0FOMXJRS0VRQVdCQ3V3Q2hDeEVnRXJ0QWdSQURJRUs3RVVBU3V4Q2cwUkVyRUdFRGs1QURBeEV6VTBOelV5RndRVkZBVVVCeWMxTkRjMk5VNDNLY0VCUC83QllXQzB6d1J0TnlVR0RNMkxmVVA2SHljYk55OHpsbFFBQUFBREFEbi81d1FaQnpzQUJ3QVBBQ2NBUWdDeUZBSUFLN0VaQStteUF3RUFLN0VGQittd0RTK3hDd2ZwQWJBb0w3QVExckVlRHVteEtRRXJzUjRRRVJLd0p6a0FzUXNORVJLd0NUbXdCUkd3Qnprd01STTFKVE1YRlFRUEFUVWxNeGNWQkFjWEVBRWtNeFlkQVJRakJBTUNFUlVTTXhjbE5oWUZJZ001QWxJUEtmNk4zeUVDVWc0cC9vM2Zad0ZhQVJCdlVuMytzRmFtR0tncEFTOU9TUDV6Nm9zRHZrUkdLU2tyT0xwR1JTc3BLVGZsQWxZQ2g1TWFIUnNjZC83cC9sVCtmUTcrWWc0bEk1SWxBVnNBQUFBQUFmLysvNzRHY1FiRkFGQUFzd0N5TWdBQUs3QkNNN0lMQWdBcnNoVUNBQ3V5QWdFQUs3QUdNN0ZQQ2VteUJRRUFLN0lyQVFBcnNqa0JBQ3NCc0ZFdnNFZldzVUFQNmJKSFFBb3JzMEJIUkFrcnNFQVFzVFFCSzdBMk1yRXZEK213THhDeElBRXJzUnNPNmJGU0FTdXhRRWNSRXJJRk8wSTVPVG13TkJHMUJna3lNd2MxSkJjNXNDOFNzU3N0T1Rtd0lCR3hFQms1T2JBYkVyQWVPUUN4VHpJUkVrQUtFUjBmSmljcEVEWStTaVFYT2JFTEJSRVNzZ2NqSkRrNU9UQXhBelUzRnpZM0Z5VW1KelkzTXhZVEZoTXpFelVuTkRNMUZoVVRGUlFISXljM05SQURJd0lEQnlJREFpY0dJeGNWRUNzQkp4TWpOelVRSndRSEV4RVhCeFVVQnlZbk5UWTlBVGNuTndJckFRY21BaW1tcGpkU0FTY0lFUmtmS0VaZ1JsSXB0QTVGVkdFcEhTa09WQTVTWUZST0VwZ3JCZ1lNVWlrT053NE9DdjdMRXc4TURFWkFCRGdNREF3ZkpVZmRSQVRCS0NrYURDc2RLNFlrUUFRRS9tYUQvcXdEVENsVU53OGhRdnBqWVVjTEc4OHJBbFlCMGY3OC9YUW9BV1lCelNVQ3pmcjhtVVlDTncyMEFUVzRLQjMrWXY2WVVrYVhRaTBiSENsS016ZjRSbElDQUE0U0FBRUFBQUFBQlRjRk53QURBQ2NBc2dBQUFDdXlBUUVBS3dHd0JDK3dBTmEwQXhFQUJ3UXJ0QU1SQUFjRUs3RUZBU3NBTURFeEVTRVJCVGNGTi9ySkFBQUQvOFgvNXdNU0JnSUFKZ0F6QURzQXF3Q3lNZ0FBSzdBZk03STJBUUFyc0NrenNnY0JBQ3UwQkNVZk5nMHJzUVFENmJBVU1ySUVKUW9yczBBRUFna3Jzem9mTmdncnNCRXZzUWtENlFHd1BDK3dCOWF3SVRLeEV3N3BzQnN5c0JNUXNTTVA2YkFqTDdBVEVMRW5BU3V4TFE3cHNEUWcxaEcwT0JFQUdRUXJzVDBCSzdFMEJ4RVNzUmdrT1RteE9DMFJFcllMRUNvckx6RTZKQmM1QUxFRUpSRVNzUUFiT1RteE5qSVJFckVYSVRrNXNCRVJzUTRQT1Rrd01RTTJPd0VYTXpJbkVpRVdIUUVQQVJVbkl5SURFVE0yTnhjVkJnVVRGUlFISXljM0F5Y2pJZ1VRT3dFWEJoVVNGeFVISXlJVE5qY3lGeFFISWpzY0d4MXVEQjhFTlFGQzNRNHBENlhlS1EyVm5BNE8vc0lOT0F3ckhRMFFHNm9DV0ZRYkt6Y0dTeWdwUWdvYktUVXRZaVVDeFZRZHp3STNDQzhiRGc4T0R2NXYvdm9ZU0F3ZFAxaitSWDFvRlRpTEFib3BEQUVoT0RmNC92cjRIQ3NFd0V3SU55azNBQUFBQUFML3hmL25Bd0lHV2dBbUFEVUF4QUN5SUFBQUs3QTFNN0l1QWdBcnRDVUVJQzROSzdBVU03RWxBK215QkNVS0s3TkFCQUlKSzdFSkxoQWd3Qyt4RVFQcEFiQTJMN0FIMXJBaE1yRVREdW13R3pLd0V4Q3hJdy9wc0NNdnNCTVFzU2tCSzdFeUQrbXdNREt5S1RJS0s3TkFLU2NKSzdBeUVMQU9JTllSdENzUEFEWUVLN0FyTDdRT0R3QTJCQ3V4TGpFeU1ySU9Ld29yczBBT013a3JzVGNCSzdFckJ4RVNzUmdrT1Rtd01oR3hFRFU1T1FDeEpTQVJFckFuT2JBRUViRUFHems1c0JFU3RBY09EeGNZSkJjNU1ERUROanNCRnpNeUp4SWhGaDBCRHdFVkp5TWlBeEV6TmpjWEZRWUZFeFVVQnlNbk53TW5JeUlCTmowQkV6WXpOdzhCRXdNWEZBYzdIQnNkYmd3ZkJEVUJRdDBPS1ErbDNpa05sWndPRHY3Q0RUZ01LeDBORUJ1cUFta2NGUmdITHdzRUN3MGRTQUxGVkIzUEFqY0lMeHNPRHc0Ty9tLysraGhJREIwL1dQNUZmV2dWT0lzQnVpbjlra2ZjR2dURkxRejg0ZjE1L3V1bUdqb0FBQUFBQVFBQUFBRUFnMDkyWG05ZkR6ejFBQjhJQUFBQUFBRFRoWFVQQUFBQUFOT0ZkUS8vUGZ3QUJuRUlZQUFBQUFnQUFnQUFBQUFBQUFBQkFBQUliZnZZQUFBSVlQODkvb3NHY1FBQkFBQUFBQUFBQUFBQUFBQUFBQUFBNXdMc0FFUUFBQUFBQXFvQUFBUVpBQUFDREFDV0FwNEFnd1VsQUM4RGhRQjVBdkFBaVFRbEFJRUJaZ0JLQW5VQUxRSTVBRW9EZndCRUJBZ0FVZ0lNQUlzRE93QmtBZ3dBdGdMSkFIa0NzZ0FuQWNNQVB3S0xBQ01DeFFBM0FsSUFOd0o1QUQ0Q2VRQkVBdVVBRndKdEFFUUN5UUFoQWd3QWlRSU1BREVETlFCM0JFNEF2QVJPQUU0Q25BQ3lCQ1VBTFFNVUFCUUMzd0FNQXRzQUpRTGJBQWdDM3dBckFpVUFDQU1RQUNNREF2LzJBVkFBTHdKUUFCMEN1QUFmQXNjQVJnUFhBQzhEdGdBMUF5a0FLd0p6QURzRG1nQW5BclFBRkFNcEFFSUN5Ly82QXVNQU1RTHBBQzBFUHdCSUF3Ny82UUwyQURVRG1nQW5Bb2NBSVFKOS8vNENZQUFVQTNVQWV3VGRBQnNDeFFCdkFyd0FUQUtvQUMwQ2h3QVNBb3NBT1FLSEFCSUNEUC9GQXJnQUdRTFBBQWdCSFFBMUFhTC9YZ0xiQUFvQklRQkdBNGtBUWdKOUFDVUNLUUF2QWowQUhRS3VBRFVDUkFBZkFoVC93d0dKLzgwQ1JBQWpBaDhBUFFPOEFDY0Nsdi84QXE0QUt3TUNBQ1VDZHdBZkFla0FSZ0ozQUJzRTR3Q0RCQmtBQUFJTUFNa0Nod0FTQkVqLzNRUExBSGNDdy8vMkFUVUFXZ01DQUVNR0pRRlFBL29BUkFHb0FCMEVXZ0IzQkRjQVdBTTdBR1FES1FBckFtb0FaZ0ZjQUEwRUNBQlNBZjRBSUFIcEFERUNyZ0J2QTdZQVJBRmlBR0FFVWdEaEFUMEFPUUZjQUI4RVRnQk9CUUFBUFFTMEFEMEZZQUEyQWdBQVBBTVVBQlFERkFBVUF4UUFGQU1VQUJRREZBQVVBeFFBRkFVZEFCUUMyd0FsQXRzQUpnTGJBQ1lDMndBbUF0c0FKZ0ZRQUJnQlVBQXZBVkFBRXdGUUFCb0MyLyswQTdiL1pRTXBBQ3NES1FBckF5a0FLd01wQUFFREtRQXJBcE1BRndNcEFDc0M0d0F4QXVNQU1RTGpBREVDNHdBeEF2WUFOUUpPQUNVQzl2L2ZBcndBQ0FLOEFFd0N2QUJNQXJ6L2lBSzhBRXdDdkFCTUJEOEFUQUtIQUJJQ2gvL3RBb2NBRWdLSEFCSUNod0FTQVIzL1RnRWQvejBCSGYrd0FSMy9vZ0xkQUZ3Q2ZmOW5BaW4vdmdJcEFDOENLUUF2QWluL3d3SXBBQzhDREFBeUFpa0FGZ0pFLzh3Q1JBQWpBa1FBRHdKRUFDTUNyZ0FyQWU0QUVBS3VBQ3NGUkFBckJFZ0FMd0wyQURVRDFRQ0hCT01BZ3dRd0FBQUlZQUFBQkRBQUFBaGdBQUFDeWdBQUFoZ0FBQUZsQUFBQlpRQUFBUXdBQUFHc0FBQUFkd0FBQXpzQVpBTTdBR1FET3dCa0Ftb0FZQU03QUZvQlpnQktBV1lBU2dGbUFHMENuZ0NEQXA0QWd3S2VBSU1CbmdCekJpVUF0Z0dzQUFBRE5RQjNCRTRBVGdJWUFBQUVid0E1QnFULy9nVTNBQUFESy8vRkF5Ly94UUFBQUN3QUxBQXNBQ3dBYUFDc0FhQUNXZ0s2QTFJRGZnTzBBK0FFZUFUT0JQUUZHZ1ZBQlc0RnNBWG9CalFHcWdjRUIyZ0h6QWc4Q0pBSkZnbFlDWkFKeEFvR0NqNEtzZ3MrQzVnTUtneU1ET1lOUkEzT0RoNE9lZzYyRHZBUFRBK1dFQkFRbkJENkVXQVI0QkpxRXRRVFFCT1lFK29VZkJUSUZTb1ZiaFd5RmRvV0tCWmVGbzRXcWhjQUYzZ1h3QmdxR0pZWkJobDRHZVFhS2hxQ0d3SWJTQnZ1SEdZY3NCMFdIWDRkd2g0TUhuQWV5aDhpSDZRZjhDQnNJTHdoUENGMkllUWlIQ0ljSWxJaTVDTmNJOEFrY0NTNEpSUWxUQ1dZSmU0bU5pWmlKblluRmljMEozWW9DQ2hHS0xJbzFDbENLVzRwbkNuS0tnNHFZQ3NFSzM0c1VDeStMU1F0akM0Q0xwSXZDaStvTUdBdzdqRmNNYzR5VURMT013NHpVRE9vTS9ZMG5qVlVOY0kyT0RiSU4ySTM0RGdjT0pvNUJEbHNPZW82WWpyVU95dzduRHdDUEdZODNqMW1QZHcrZGo4dVA2WkFIa0NZUVNoQnRFSUlRa1JDa2tMYVF5eEQza1E2UkpoRkNFV0VSZlpHUWtiQVJ5cEhsa2dRU0l4SkdrbUFTaHhLNUV1U1RCSk1SRXg4VEh4TWZFeDhUSHhNZkV4OFRIeE1mRXg4VEh4TWZFeVFUS1JNdUV6VVRQeE5LRTFVVFg1TndrNEdUa1pPZEU2eVRySk81azhlVHg1UGhsQmFVSHBSTEZIa0FBRUFBQURuQUZNQUJBQUFBQUFBQWdBQkFBSUFGZ0FBQVFBQkRBQUFBQUFBQUFBU0FONEFBd0FCQkFrQUFBQjRBQUFBQXdBQkJBa0FBUUFpQUhnQUF3QUJCQWtBQWdBT0FKb0FBd0FCQkFrQUF3QThBS2dBQXdBQkJBa0FCQUF5QU9RQUF3QUJCQWtBQlFBa0FSWUFBd0FCQkFrQUJnQWNBVG9BQXdBQkJBa0FCd0JxQVZZQUF3QUJCQWtBQ0FBZ0FjQUFBd0FCQkFrQUNRQWdBZUFBQXdBQkJBa0FDZ0I0QWdBQUF3QUJCQWtBQ3dBMEFuZ0FBd0FCQkFrQURBQTBBcXdBQXdBQkJBa0FEUUdhQXVBQUF3QUJCQWtBRGdBMEJIb0FBd0FCQkFrQUVnQWlCSzRBQXdBQkJBa0F5QUFXQk5BQUF3QUJCQWtBeVFBd0JPWUFRd0J2QUhBQWVRQnlBR2tBWndCb0FIUUFJQUFvQUdNQUtRQWdBRElBTUFBd0FEWUFJQUJpQUhrQUlBQkxBR2tBYlFCaUFHVUFjZ0JzQUhrQUlBQkhBR1VBY3dCM0FHVUFhUUJ1QUM0QUlBQkJBR3dBYkFBZ0FISUFhUUJuQUdnQWRBQnpBQ0FBY2dCbEFITUFaUUJ5QUhZQVpRQmtBQzRBVEFCdkFIWUFaUUJrQUNBQVlnQjVBQ0FBZEFCb0FHVUFJQUJMQUdrQWJnQm5BRklBWlFCbkFIVUFiQUJoQUhJQVRBQnZBSFlBWlFCa0FDQUFZZ0I1QUNBQWRBQm9BR1VBSUFCTEFHa0FiZ0JuQURvQVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXdBREFBVEFCdkFIWUFaUUJrQUNBQVlnQjVBQ0FBZEFCb0FHVUFJQUJMQUdrQWJnQm5BQ0FBVWdCbEFHY0FkUUJzQUdFQWNnQldBR1VBY2dCekFHa0Fid0J1QUNBQU1RQXVBREFBTUFBeUFDQUFNZ0F3QURBQU5nQk1BRzhBZGdCbEFHUUFZZ0I1QUhRQWFBQmxBRXNBYVFCdUFHY0FUQUJ2QUhZQVpRQmtBQ0FBWWdCNUFDQUFkQUJvQUdVQUlBQkxBR2tBYmdCbkFDQUFhUUJ6QUNBQVlRQWdBSFFBY2dCaEFHUUFaUUJ0QUdFQWNnQnJBQ0FBYndCbUFDQUFTd0JwQUcwQVlnQmxBSElBYkFCNUFDQUFSd0JsQUhNQWR3QmxBR2tBYmdBdUFFc0FhUUJ0QUdJQVpRQnlBR3dBZVFBZ0FFY0FaUUJ6QUhjQVpRQnBBRzRBU3dCcEFHMEFZZ0JsQUhJQWJBQjVBQ0FBUndCbEFITUFkd0JsQUdrQWJnQkRBRzhBY0FCNUFISUFhUUJuQUdnQWRBQWdBQ2dBWXdBcEFDQUFNZ0F3QURBQU5nQWdBR0lBZVFBZ0FFc0FhUUJ0QUdJQVpRQnlBR3dBZVFBZ0FFY0FaUUJ6QUhjQVpRQnBBRzRBTGdBZ0FFRUFiQUJzQUNBQWNnQnBBR2NBYUFCMEFITUFJQUJ5QUdVQWN3QmxBSElBZGdCbEFHUUFMZ0JvQUhRQWRBQndBRG9BTHdBdkFHc0FhUUJ0QUdJQVpRQnlBR3dBZVFCbkFHVUFjd0IzQUdVQWFRQnVBQzRBWXdCdkFHMEFhQUIwQUhRQWNBQTZBQzhBTHdCckFHa0FiUUJpQUdVQWNnQnNBSGtBWndCbEFITUFkd0JsQUdrQWJnQXVBR01BYndCdEFFTUFid0J3QUhrQWNnQnBBR2NBYUFCMEFDQUFLQUJqQUNrQUlBQXlBREFBTVFBd0FDd0FJQUJMQUdrQWJRQmlBR1VBY2dCc0FIa0FJQUJIQUdVQWN3QjNBR1VBYVFCdUFDQUFLQUJyQUdrQWJRQmlBR1VBY2dCc0FIa0Fad0JsQUhNQWR3QmxBR2tBYmdBdUFHTUFid0J0QUNrQURRQlVBR2dBYVFCekFDQUFSZ0J2QUc0QWRBQWdBRk1BYndCbUFIUUFkd0JoQUhJQVpRQWdBR2tBY3dBZ0FHd0FhUUJqQUdVQWJnQnpBR1VBWkFBZ0FIVUFiZ0JrQUdVQWNnQWdBSFFBYUFCbEFDQUFVd0JKQUV3QUlBQlBBSEFBWlFCdUFDQUFSZ0J2QUc0QWRBQWdBRXdBYVFCakFHVUFiZ0J6QUdVQUxBQWdBRllBWlFCeUFITUFhUUJ2QUc0QUlBQXhBQzRBTVFBdUFDQUFJQUJVQUdnQWFRQnpBQ0FBYkFCcEFHTUFaUUJ1QUhNQVpRQWdBR2tBY3dBZ0FHRUFkZ0JoQUdrQWJBQmhBR0lBYkFCbEFDQUFkd0JwQUhRQWFBQWdBR0VBSUFCR0FFRUFVUUFnQUdFQWRBQTZBQ0FBSUFCb0FIUUFkQUJ3QURvQUx3QXZBSE1BWXdCeUFHa0FjQUIwQUhNQUxnQnpBR2tBYkFBdUFHOEFjZ0JuQUM4QVR3QkdBRXdBYUFCMEFIUUFjQUE2QUM4QUx3QnpBR01BY2dCcEFIQUFkQUJ6QUM0QWN3QnBBR3dBTGdCdkFISUFad0F2QUU4QVJnQk1BRXdBYndCMkFHVUFaQUFnQUdJQWVRQWdBSFFBYUFCbEFDQUFTd0JwQUc0QVp3QlhBR1VBWWdCbUFHOEFiZ0IwQUNBQU1RQXVBREFBVkFCMUFHVUFJQUJLQUhVQWJnQWdBREVBTkFBZ0FEQUFOQUE2QURRQU53QTZBREVBTVFBZ0FESUFNQUF4QURZQUFnQUFBQUFBQVA4aEFKb0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQURuQUFBQkFnRURBQU1BQkFBRkFBWUFCd0FJQUFrQUNnQUxBQXdBRFFBT0FBOEFFQUFSQUJJQUV3QVVBQlVBRmdBWEFCZ0FHUUFhQUJzQUhBQWRBQjRBSHdBZ0FDRUFJZ0FqQUNRQUpRQW1BQ2NBS0FBcEFDb0FLd0FzQUMwQUxnQXZBREFBTVFBeUFETUFOQUExQURZQU53QTRBRGtBT2dBN0FEd0FQUUErQUQ4QVFBQkJBRUlBUXdCRUFFVUFSZ0JIQUVnQVNRQktBRXNBVEFCTkFFNEFUd0JRQUZFQVVnQlRBRlFBVlFCV0FGY0FXQUJaQUZvQVd3QmNBRjBBWGdCZkFHQUFZUUVFQUtNQWhBQ0ZBTDBBbGdEb0FJWUFqZ0NMQUowQXFRQ2tBUVVBaWdEYUFJTUFrd0VHQVFjQWpRQ0lBTU1BM2dFSUFKNEFxZ0QxQVBRQTlnQ2lBSzBBeVFESEFLNEFZZ0JqQUpBQVpBRExBR1VBeUFES0FNOEF6QUROQU00QTZRQm1BTk1BMEFEUkFLOEFad0R3QUpFQTFnRFVBTlVBYUFEckFPMEFpUUJxQUdrQWF3QnRBR3dBYmdDZ0FHOEFjUUJ3QUhJQWN3QjFBSFFBZGdCM0FPb0FlQUI2QUhrQWV3QjlBSHdBdUFDaEFIOEFmZ0NBQUlFQTdBRHVBTG9Bc0FDeEFMc0EyQURaQVFrQkNnRUxBUXdCRFFFT0FROEJFQUVSQVJJQkV3RVVBUlVCRmdDeUFMTUF0Z0MzQU1RQXRBQzFBTVVBaHdDckFSY0F2Z0MvQVJnQkdRQ01BUm9CR3dFY0JtZHNlWEJvTVFkMWJta3dNREJFQjNWdWFUQXdRVEFIZFc1cE1EQkJSQWQxYm1rd01FSXlCM1Z1YVRBd1FqTUhkVzVwTURCQ09RZDFibWt5TURBd0IzVnVhVEl3TURFSGRXNXBNakF3TWdkMWJta3lNREF6QjNWdWFUSXdNRFFIZFc1cE1qQXdOUWQxYm1reU1EQTJCM1Z1YVRJd01EY0hkVzVwTWpBd09BZDFibWt5TURBNUIzVnVhVEl3TUVFSGRXNXBNakF4TUFkMWJta3lNREV4Q21acFozVnlaV1JoYzJnSGRXNXBNakF5UmdkMWJta3lNRFZHQkVWMWNtOEhkVzVwTWpWR1F3ZDFibWxHUWpBeEIzVnVhVVpDTURJQXVBSC9oYkFCalFCTHNBaFFXTEVCQVk1WnNVWUdLMWdoc0JCWlM3QVVVbGdoc0lCWkhiQUdLMXhZQUxBRElFV3dBeXRFc0FRZ1JiSURGUUlyc0FNclJMQUZJRVd5QkJVQ0s3QURLMFN3QmlCRnNnVThBaXV3QXl0RXNBY2dSYklHTVFJcnNBTXJSTEFJSUVXeUJ5c0NLN0FESzBTd0NTQkZzZ2doQWl1d0F5dEVzQW9nUmJJSkhnSXJzQU1yUkxBTElFV3lDaHdDSzdBREswU3dEQ0JGc2dzYkFpdXdBeXRFc0EwZ1JiSU1Hd0lyc0FNclJBR3dEaUJGc0FNclJMQVBJRVd5RGtzQ0s3RURSbllyUkxBUUlFVzZBQTUvL3dBQ0s3RURSbllyUkxBUklFV3lFRjBDSzdFRFJuWXJSRm13RkNzQUFBQUJWMS9FandBQVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdHlsZXMvZm9udHMvTG92ZWRieXRoZUtpbmcuZW90XG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgUm91dGVyLCBTd2l0Y2gsIFJvdXRlIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcblxuaW1wb3J0IGNyZWF0ZUJyb3dzZXJIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlQnJvd3Nlckhpc3RvcnknXG5jb25zdCBjdXN0b21IaXN0b3J5ID0gY3JlYXRlQnJvd3Nlckhpc3RvcnkoKTtcblxuaW1wb3J0IGNvbnN0YW50cyBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgY29uZmlnIGZyb20gJy4vY29uZmlnLmpzb24nO1xuaW1wb3J0IGNvbnRlbnQgZnJvbSAnLi9jb250ZW50Lmpzb24nO1xuXG5pbXBvcnQgSG9tZSBmcm9tICcuL2V4cGVyaWVuY2VzL0hvbWUnO1xuXG5yZXF1aXJlKCcuLi9zdHlsZXMvbWFpbi5sZXNzJyk7XG5cbmNvbnN0IGFwcCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHAnKTtcblJlYWN0RE9NLnJlbmRlcihcbiAgPFJvdXRlciBoaXN0b3J5PXtjdXN0b21IaXN0b3J5fT5cbiAgICA8U3dpdGNoPlxuICAgICAgPFJvdXRlIGV4YWN0IHBhdGg9XCIvXCIgcmVuZGVyPXsoKSA9PiAoPEhvbWUgY29uZmlnPXtjb25maWd9IGNvbnN0YW50cz17Y29uc3RhbnRzfSBjb250ZW50PXtjb250ZW50fSAvPil9PjwvUm91dGU+XG4gICAgICA8Um91dGUgcGF0aD1cIi9nYWxsZXJ5LzpnYWxsZXJ5SWRcIiByZW5kZXI9eygpID0+ICg8SG9tZSBjb25maWc9e2NvbmZpZ30gY29uc3RhbnRzPXtjb25zdGFudHN9IGNvbnRlbnQ9e2NvbnRlbnR9IHBhZ2U9XCJnYWxsZXJ5XCIvPil9PjwvUm91dGU+XG4gICAgICA8Um91dGUgcGF0aD1cIi9zdHJ1Y3R1cmVcIiByZW5kZXI9eygpID0+ICg8SG9tZSBjb25maWc9e2NvbmZpZ30gY29uc3RhbnRzPXtjb25zdGFudHN9IGNvbnRlbnQ9e2NvbnRlbnR9IHBhZ2U9XCJzdHJ1Y3R1cmVcIi8+KX0+PC9Sb3V0ZT5cbiAgICAgIDxSb3V0ZSByZW5kZXI9eygpID0+ICg8SG9tZSBjb25maWc9e2NvbmZpZ30gY29uc3RhbnRzPXtjb25zdGFudHN9IGNvbnRlbnQ9e2NvbnRlbnR9IC8+KX0+PC9Sb3V0ZT5cbiAgICA8L1N3aXRjaD5cbiAgPC9Sb3V0ZXI+LFxuYXBwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvaW5kZXguanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXI7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogdHJhdmVyc2FsLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xuICogQHBhcmFtIHshZnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIHRyYXZlcnNhbCB3aXRoLlxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRm9yRWFjaEJvb2tLZWVwaW5nKGZvckVhY2hGdW5jdGlvbiwgZm9yRWFjaENvbnRleHQpIHtcbiAgdGhpcy5mdW5jID0gZm9yRWFjaEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Gb3JFYWNoQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdCxcbiAgICAgIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeCxcbiAgICAgIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIE1hcEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWFjdENoaWxkcmVuID0ge1xuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWw6IG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwsXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogU3RhdGljIHBvb2xlcnMuIFNldmVyYWwgY3VzdG9tIHZlcnNpb25zIGZvciBlYWNoIHBvdGVudGlhbCBudW1iZXIgb2ZcbiAqIGFyZ3VtZW50cy4gQSBjb21wbGV0ZWx5IGdlbmVyaWMgcG9vbGVyIGlzIGVhc3kgdG8gaW1wbGVtZW50LCBidXQgd291bGRcbiAqIHJlcXVpcmUgYWNjZXNzaW5nIHRoZSBgYXJndW1lbnRzYCBvYmplY3QuIEluIGVhY2ggb2YgdGhlc2UsIGB0aGlzYCByZWZlcnMgdG9cbiAqIHRoZSBDbGFzcyBpdHNlbGYsIG5vdCBhbiBpbnN0YW5jZS4gSWYgYW55IG90aGVycyBhcmUgbmVlZGVkLCBzaW1wbHkgYWRkIHRoZW1cbiAqIGhlcmUsIG9yIGluIHRoZWlyIG93biBmaWxlcy5cbiAqL1xudmFyIG9uZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGNvcHlGaWVsZHNGcm9tKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGNvcHlGaWVsZHNGcm9tKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhjb3B5RmllbGRzRnJvbSk7XG4gIH1cbn07XG5cbnZhciB0d29Bcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIpO1xuICB9XG59O1xuXG52YXIgdGhyZWVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMpO1xuICB9XG59O1xuXG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0KSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMiwgYTMsIGE0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICAvLyBDYXN0aW5nIGFzIGFueSBzbyB0aGF0IGZsb3cgaWdub3JlcyB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGFuZCB0cnVzdHNcbiAgLy8gaXQgdG8gbWF0Y2ggdGhlIHR5cGUgd2UgZGVjbGFyZWRcbiAgdmFyIE5ld0tsYXNzID0gQ29weUNvbnN0cnVjdG9yO1xuICBOZXdLbGFzcy5pbnN0YW5jZVBvb2wgPSBbXTtcbiAgTmV3S2xhc3MuZ2V0UG9vbGVkID0gcG9vbGVyIHx8IERFRkFVTFRfUE9PTEVSO1xuICBpZiAoIU5ld0tsYXNzLnBvb2xTaXplKSB7XG4gICAgTmV3S2xhc3MucG9vbFNpemUgPSBERUZBVUxUX1BPT0xfU0laRTtcbiAgfVxuICBOZXdLbGFzcy5yZWxlYXNlID0gc3RhbmRhcmRSZWxlYXNlcjtcbiAgcmV0dXJuIE5ld0tsYXNzO1xufTtcblxudmFyIFBvb2xlZENsYXNzID0ge1xuICBhZGRQb29saW5nVG86IGFkZFBvb2xpbmdUbyxcbiAgb25lQXJndW1lbnRQb29sZXI6IG9uZUFyZ3VtZW50UG9vbGVyLFxuICB0d29Bcmd1bWVudFBvb2xlcjogdHdvQXJndW1lbnRQb29sZXIsXG4gIHRocmVlQXJndW1lbnRQb29sZXI6IHRocmVlQXJndW1lbnRQb29sZXIsXG4gIGZvdXJBcmd1bWVudFBvb2xlcjogZm91ckFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRTeW1ib2wnKTtcblxudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBUaGlzIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQgc2luY2UgdGhpcyBmaWxlIGlzIHNoYXJlZCBiZXR3ZWVuXG4gKiBpc29tb3JwaGljIGFuZCByZW5kZXJlcnMuIFdlIGNvdWxkIGV4dHJhY3QgdGhpcyB0byBhXG4gKlxuICovXG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIEtleUVzY2FwZVV0aWxzLmVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgLy8gVGhlIGZvbGxvd2luZyBpcyBpbmxpbmVkIGZyb20gUmVhY3RFbGVtZW50LiBUaGlzIG1lYW5zIHdlIGNhbiBvcHRpbWl6ZVxuICAvLyBzb21lIGNoZWNrcy4gUmVhY3QgRmliZXIgYWxzbyBpbmxpbmVzIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgcHVycG9zZXMuXG4gIHR5cGUgPT09ICdvYmplY3QnICYmIGNoaWxkcmVuLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBjaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpaSA9IDA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBjaGlsZCA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0gPSAnJztcbiAgICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgICBpZiAobWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtKSA6IHZvaWQgMDtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjaGlsZCA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIEtleUVzY2FwZVV0aWxzLmVzY2FwZShlbnRyeVswXSkgKyBTVUJTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIDApO1xuICAgICAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQgb3Igd3JhcCB0aGUgb2JqZWN0IHVzaW5nIGNyZWF0ZUZyYWdtZW50KG9iamVjdCkgZnJvbSB0aGUgJyArICdSZWFjdCBhZGQtb25zLic7XG4gICAgICAgIGlmIChjaGlsZHJlbi5faXNSZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9IFwiIEl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCBcIiArICd2ZXJzaW9uIG9mIFJlYWN0LiBNYWtlIHN1cmUgdG8gdXNlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtICs9ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9IFN0cmluZyhjaGlsZHJlbik7XG4gICAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKSA6IF9wcm9kSW52YXJpYW50KCczMScsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWJ0cmVlQ291bnQ7XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCwgYnV0XG4gKiBtaWdodCBhbHNvIGJlIHNwZWNpZmllZCB0aHJvdWdoIGF0dHJpYnV0ZXM6XG4gKlxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmNoaWxkcmVuLCAuLi4pYFxuICogLSBgdHJhdmVyc2VBbGxDaGlsZHJlbih0aGlzLnByb3BzLmxlZnRQYW5lbENoaWxkcmVuLCAuLi4pYFxuICpcbiAqIFRoZSBgdHJhdmVyc2VDb250ZXh0YCBpcyBhbiBvcHRpb25hbCBhcmd1bWVudCB0aGF0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZVxuICogZW50aXJlIHRyYXZlcnNhbC4gSXQgY2FuIGJlIHVzZWQgdG8gc3RvcmUgYWNjdW11bGF0aW9ucyBvciBhbnl0aGluZyBlbHNlIHRoYXRcbiAqIHRoZSBjYWxsYmFjayBtaWdodCBmaW5kIHJlbGV2YW50LlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgb2JqZWN0LlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIFRvIGludm9rZSB1cG9uIHRyYXZlcnNpbmcgZWFjaCBjaGlsZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IGZvciB0cmF2ZXJzYWwuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCAnJywgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhdmVyc2VBbGxDaGlsZHJlbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVW5lc2NhcGUgYW5kIHVud3JhcCBrZXkgZm9yIGh1bWFuLXJlYWRhYmxlIGRpc3BsYXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIHVuZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgdW5lc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gdW5lc2NhcGUoa2V5KSB7XG4gIHZhciB1bmVzY2FwZVJlZ2V4ID0gLyg9MHw9MikvZztcbiAgdmFyIHVuZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPTAnOiAnPScsXG4gICAgJz0yJzogJzonXG4gIH07XG4gIHZhciBrZXlTdWJzdHJpbmcgPSBrZXlbMF0gPT09ICcuJyAmJiBrZXlbMV0gPT09ICckJyA/IGtleS5zdWJzdHJpbmcoMikgOiBrZXkuc3Vic3RyaW5nKDEpO1xuXG4gIHJldHVybiAoJycgKyBrZXlTdWJzdHJpbmcpLnJlcGxhY2UodW5lc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIHVuZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xufVxuXG52YXIgS2V5RXNjYXBlVXRpbHMgPSB7XG4gIGVzY2FwZTogZXNjYXBlLFxuICB1bmVzY2FwZTogdW5lc2NhcGVcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5RXNjYXBlVXRpbHM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9LZXlFc2NhcGVVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIGZhY3RvcnkgdGhhdCBjcmVhdGVzIEhUTUwgdGFnIGVsZW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgY3JlYXRlRE9NRmFjdG9yeSA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXBwaW5nIGZyb20gc3VwcG9ydGVkIEhUTUwgdGFncyB0byBgUmVhY3RET01Db21wb25lbnRgIGNsYXNzZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSB7XG4gIGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2EnKSxcbiAgYWJicjogY3JlYXRlRE9NRmFjdG9yeSgnYWJicicpLFxuICBhZGRyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdhZGRyZXNzJyksXG4gIGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ2FyZWEnKSxcbiAgYXJ0aWNsZTogY3JlYXRlRE9NRmFjdG9yeSgnYXJ0aWNsZScpLFxuICBhc2lkZTogY3JlYXRlRE9NRmFjdG9yeSgnYXNpZGUnKSxcbiAgYXVkaW86IGNyZWF0ZURPTUZhY3RvcnkoJ2F1ZGlvJyksXG4gIGI6IGNyZWF0ZURPTUZhY3RvcnkoJ2InKSxcbiAgYmFzZTogY3JlYXRlRE9NRmFjdG9yeSgnYmFzZScpLFxuICBiZGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JkaScpLFxuICBiZG86IGNyZWF0ZURPTUZhY3RvcnkoJ2JkbycpLFxuICBiaWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2JpZycpLFxuICBibG9ja3F1b3RlOiBjcmVhdGVET01GYWN0b3J5KCdibG9ja3F1b3RlJyksXG4gIGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ2JvZHknKSxcbiAgYnI6IGNyZWF0ZURPTUZhY3RvcnkoJ2JyJyksXG4gIGJ1dHRvbjogY3JlYXRlRE9NRmFjdG9yeSgnYnV0dG9uJyksXG4gIGNhbnZhczogY3JlYXRlRE9NRmFjdG9yeSgnY2FudmFzJyksXG4gIGNhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2NhcHRpb24nKSxcbiAgY2l0ZTogY3JlYXRlRE9NRmFjdG9yeSgnY2l0ZScpLFxuICBjb2RlOiBjcmVhdGVET01GYWN0b3J5KCdjb2RlJyksXG4gIGNvbDogY3JlYXRlRE9NRmFjdG9yeSgnY29sJyksXG4gIGNvbGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdjb2xncm91cCcpLFxuICBkYXRhOiBjcmVhdGVET01GYWN0b3J5KCdkYXRhJyksXG4gIGRhdGFsaXN0OiBjcmVhdGVET01GYWN0b3J5KCdkYXRhbGlzdCcpLFxuICBkZDogY3JlYXRlRE9NRmFjdG9yeSgnZGQnKSxcbiAgZGVsOiBjcmVhdGVET01GYWN0b3J5KCdkZWwnKSxcbiAgZGV0YWlsczogY3JlYXRlRE9NRmFjdG9yeSgnZGV0YWlscycpLFxuICBkZm46IGNyZWF0ZURPTUZhY3RvcnkoJ2RmbicpLFxuICBkaWFsb2c6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpYWxvZycpLFxuICBkaXY6IGNyZWF0ZURPTUZhY3RvcnkoJ2RpdicpLFxuICBkbDogY3JlYXRlRE9NRmFjdG9yeSgnZGwnKSxcbiAgZHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2R0JyksXG4gIGVtOiBjcmVhdGVET01GYWN0b3J5KCdlbScpLFxuICBlbWJlZDogY3JlYXRlRE9NRmFjdG9yeSgnZW1iZWQnKSxcbiAgZmllbGRzZXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZWxkc2V0JyksXG4gIGZpZ2NhcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ2NhcHRpb24nKSxcbiAgZmlndXJlOiBjcmVhdGVET01GYWN0b3J5KCdmaWd1cmUnKSxcbiAgZm9vdGVyOiBjcmVhdGVET01GYWN0b3J5KCdmb290ZXInKSxcbiAgZm9ybTogY3JlYXRlRE9NRmFjdG9yeSgnZm9ybScpLFxuICBoMTogY3JlYXRlRE9NRmFjdG9yeSgnaDEnKSxcbiAgaDI6IGNyZWF0ZURPTUZhY3RvcnkoJ2gyJyksXG4gIGgzOiBjcmVhdGVET01GYWN0b3J5KCdoMycpLFxuICBoNDogY3JlYXRlRE9NRmFjdG9yeSgnaDQnKSxcbiAgaDU6IGNyZWF0ZURPTUZhY3RvcnkoJ2g1JyksXG4gIGg2OiBjcmVhdGVET01GYWN0b3J5KCdoNicpLFxuICBoZWFkOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkJyksXG4gIGhlYWRlcjogY3JlYXRlRE9NRmFjdG9yeSgnaGVhZGVyJyksXG4gIGhncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnaGdyb3VwJyksXG4gIGhyOiBjcmVhdGVET01GYWN0b3J5KCdocicpLFxuICBodG1sOiBjcmVhdGVET01GYWN0b3J5KCdodG1sJyksXG4gIGk6IGNyZWF0ZURPTUZhY3RvcnkoJ2knKSxcbiAgaWZyYW1lOiBjcmVhdGVET01GYWN0b3J5KCdpZnJhbWUnKSxcbiAgaW1nOiBjcmVhdGVET01GYWN0b3J5KCdpbWcnKSxcbiAgaW5wdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2lucHV0JyksXG4gIGluczogY3JlYXRlRE9NRmFjdG9yeSgnaW5zJyksXG4gIGtiZDogY3JlYXRlRE9NRmFjdG9yeSgna2JkJyksXG4gIGtleWdlbjogY3JlYXRlRE9NRmFjdG9yeSgna2V5Z2VuJyksXG4gIGxhYmVsOiBjcmVhdGVET01GYWN0b3J5KCdsYWJlbCcpLFxuICBsZWdlbmQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xlZ2VuZCcpLFxuICBsaTogY3JlYXRlRE9NRmFjdG9yeSgnbGknKSxcbiAgbGluazogY3JlYXRlRE9NRmFjdG9yeSgnbGluaycpLFxuICBtYWluOiBjcmVhdGVET01GYWN0b3J5KCdtYWluJyksXG4gIG1hcDogY3JlYXRlRE9NRmFjdG9yeSgnbWFwJyksXG4gIG1hcms6IGNyZWF0ZURPTUZhY3RvcnkoJ21hcmsnKSxcbiAgbWVudTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudScpLFxuICBtZW51aXRlbTogY3JlYXRlRE9NRmFjdG9yeSgnbWVudWl0ZW0nKSxcbiAgbWV0YTogY3JlYXRlRE9NRmFjdG9yeSgnbWV0YScpLFxuICBtZXRlcjogY3JlYXRlRE9NRmFjdG9yeSgnbWV0ZXInKSxcbiAgbmF2OiBjcmVhdGVET01GYWN0b3J5KCduYXYnKSxcbiAgbm9zY3JpcHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ25vc2NyaXB0JyksXG4gIG9iamVjdDogY3JlYXRlRE9NRmFjdG9yeSgnb2JqZWN0JyksXG4gIG9sOiBjcmVhdGVET01GYWN0b3J5KCdvbCcpLFxuICBvcHRncm91cDogY3JlYXRlRE9NRmFjdG9yeSgnb3B0Z3JvdXAnKSxcbiAgb3B0aW9uOiBjcmVhdGVET01GYWN0b3J5KCdvcHRpb24nKSxcbiAgb3V0cHV0OiBjcmVhdGVET01GYWN0b3J5KCdvdXRwdXQnKSxcbiAgcDogY3JlYXRlRE9NRmFjdG9yeSgncCcpLFxuICBwYXJhbTogY3JlYXRlRE9NRmFjdG9yeSgncGFyYW0nKSxcbiAgcGljdHVyZTogY3JlYXRlRE9NRmFjdG9yeSgncGljdHVyZScpLFxuICBwcmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3ByZScpLFxuICBwcm9ncmVzczogY3JlYXRlRE9NRmFjdG9yeSgncHJvZ3Jlc3MnKSxcbiAgcTogY3JlYXRlRE9NRmFjdG9yeSgncScpLFxuICBycDogY3JlYXRlRE9NRmFjdG9yeSgncnAnKSxcbiAgcnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3J0JyksXG4gIHJ1Ynk6IGNyZWF0ZURPTUZhY3RvcnkoJ3J1YnknKSxcbiAgczogY3JlYXRlRE9NRmFjdG9yeSgncycpLFxuICBzYW1wOiBjcmVhdGVET01GYWN0b3J5KCdzYW1wJyksXG4gIHNjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnc2NyaXB0JyksXG4gIHNlY3Rpb246IGNyZWF0ZURPTUZhY3RvcnkoJ3NlY3Rpb24nKSxcbiAgc2VsZWN0OiBjcmVhdGVET01GYWN0b3J5KCdzZWxlY3QnKSxcbiAgc21hbGw6IGNyZWF0ZURPTUZhY3RvcnkoJ3NtYWxsJyksXG4gIHNvdXJjZTogY3JlYXRlRE9NRmFjdG9yeSgnc291cmNlJyksXG4gIHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3NwYW4nKSxcbiAgc3Ryb25nOiBjcmVhdGVET01GYWN0b3J5KCdzdHJvbmcnKSxcbiAgc3R5bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0eWxlJyksXG4gIHN1YjogY3JlYXRlRE9NRmFjdG9yeSgnc3ViJyksXG4gIHN1bW1hcnk6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1bW1hcnknKSxcbiAgc3VwOiBjcmVhdGVET01GYWN0b3J5KCdzdXAnKSxcbiAgdGFibGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RhYmxlJyksXG4gIHRib2R5OiBjcmVhdGVET01GYWN0b3J5KCd0Ym9keScpLFxuICB0ZDogY3JlYXRlRE9NRmFjdG9yeSgndGQnKSxcbiAgdGV4dGFyZWE6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHRhcmVhJyksXG4gIHRmb290OiBjcmVhdGVET01GYWN0b3J5KCd0Zm9vdCcpLFxuICB0aDogY3JlYXRlRE9NRmFjdG9yeSgndGgnKSxcbiAgdGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RoZWFkJyksXG4gIHRpbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpbWUnKSxcbiAgdGl0bGU6IGNyZWF0ZURPTUZhY3RvcnkoJ3RpdGxlJyksXG4gIHRyOiBjcmVhdGVET01GYWN0b3J5KCd0cicpLFxuICB0cmFjazogY3JlYXRlRE9NRmFjdG9yeSgndHJhY2snKSxcbiAgdTogY3JlYXRlRE9NRmFjdG9yeSgndScpLFxuICB1bDogY3JlYXRlRE9NRmFjdG9yeSgndWwnKSxcbiAgJ3Zhcic6IGNyZWF0ZURPTUZhY3RvcnkoJ3ZhcicpLFxuICB2aWRlbzogY3JlYXRlRE9NRmFjdG9yeSgndmlkZW8nKSxcbiAgd2JyOiBjcmVhdGVET01GYWN0b3J5KCd3YnInKSxcblxuICAvLyBTVkdcbiAgY2lyY2xlOiBjcmVhdGVET01GYWN0b3J5KCdjaXJjbGUnKSxcbiAgY2xpcFBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ2NsaXBQYXRoJyksXG4gIGRlZnM6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlZnMnKSxcbiAgZWxsaXBzZTogY3JlYXRlRE9NRmFjdG9yeSgnZWxsaXBzZScpLFxuICBnOiBjcmVhdGVET01GYWN0b3J5KCdnJyksXG4gIGltYWdlOiBjcmVhdGVET01GYWN0b3J5KCdpbWFnZScpLFxuICBsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdsaW5lJyksXG4gIGxpbmVhckdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdsaW5lYXJHcmFkaWVudCcpLFxuICBtYXNrOiBjcmVhdGVET01GYWN0b3J5KCdtYXNrJyksXG4gIHBhdGg6IGNyZWF0ZURPTUZhY3RvcnkoJ3BhdGgnKSxcbiAgcGF0dGVybjogY3JlYXRlRE9NRmFjdG9yeSgncGF0dGVybicpLFxuICBwb2x5Z29uOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5Z29uJyksXG4gIHBvbHlsaW5lOiBjcmVhdGVET01GYWN0b3J5KCdwb2x5bGluZScpLFxuICByYWRpYWxHcmFkaWVudDogY3JlYXRlRE9NRmFjdG9yeSgncmFkaWFsR3JhZGllbnQnKSxcbiAgcmVjdDogY3JlYXRlRE9NRmFjdG9yeSgncmVjdCcpLFxuICBzdG9wOiBjcmVhdGVET01GYWN0b3J5KCdzdG9wJyksXG4gIHN2ZzogY3JlYXRlRE9NRmFjdG9yeSgnc3ZnJyksXG4gIHRleHQ6IGNyZWF0ZURPTUZhY3RvcnkoJ3RleHQnKSxcbiAgdHNwYW46IGNyZWF0ZURPTUZhY3RvcnkoJ3RzcGFuJylcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GYWN0b3JpZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdERPTUZhY3Rvcmllcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/b2JqZWN0fSBlbGVtZW50IFRoZSBSZWFjdCBlbGVtZW50IHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0gez9udW1iZXJ9IGRlYnVnSUQgVGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGlzIGJlaW5nIHR5cGUtY2hlY2tlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCwgZGVidWdJRCkge1xuICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICB2YXIgZXJyb3I7XG4gICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgISh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzg0JywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpIDogdm9pZCAwO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGNvbXBvbmVudFN0YWNrSW5mbyA9ICcnO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFSZWFjdENvbXBvbmVudFRyZWVIb29rKSB7XG4gICAgICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWJ1Z0lEICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIGNvbXBvbmVudFN0YWNrSW5mbykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tSZWFjdFR5cGVTcGVjO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvY2hlY2tSZWFjdFR5cGVTcGVjLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50JyksXG4gICAgaXNWYWxpZEVsZW1lbnQgPSBfcmVxdWlyZS5pc1ZhbGlkRWxlbWVudDtcblxudmFyIGZhY3RvcnkgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2ZhY3RvcnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGlzVmFsaWRFbGVtZW50KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAnUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gJzE1LjYuMSc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL1JlYWN0QmFzZUNsYXNzZXMnKSxcbiAgICBDb21wb25lbnQgPSBfcmVxdWlyZS5Db21wb25lbnQ7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpLFxuICAgIGlzVmFsaWRFbGVtZW50ID0gX3JlcXVpcmUyLmlzVmFsaWRFbGVtZW50O1xuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG52YXIgZmFjdG9yeSA9IHJlcXVpcmUoJ2NyZWF0ZS1yZWFjdC1jbGFzcy9mYWN0b3J5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShDb21wb25lbnQsIGlzVmFsaWRFbGVtZW50LCBSZWFjdE5vb3BVcGRhdGVRdWV1ZSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jcmVhdGVDbGFzcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG59XG5cbnZhciBNSVhJTlNfS0VZID0gJ21peGlucyc7XG5cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBhbGxvdyB0aGUgY3JlYXRpb24gb2YgYW5vbnltb3VzIGZ1bmN0aW9ucyB3aGljaCBkbyBub3Rcbi8vIGhhdmUgLm5hbWUgc2V0IHRvIHRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSBiZWluZyBhc3NpZ25lZCB0by5cbmZ1bmN0aW9uIGlkZW50aXR5KGZuKSB7XG4gIHJldHVybiBmbjtcbn1cblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7XG4gICAgcHJvcDogJ3Byb3AnLFxuICAgIGNvbnRleHQ6ICdjb250ZXh0JyxcbiAgICBjaGlsZENvbnRleHQ6ICdjaGlsZCBjb250ZXh0J1xuICB9O1xufSBlbHNlIHtcbiAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSB7fTtcbn1cblxuZnVuY3Rpb24gZmFjdG9yeShSZWFjdENvbXBvbmVudCwgaXNWYWxpZEVsZW1lbnQsIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlKSB7XG4gIC8qKlxuICAgKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICAgKi9cblxuICB2YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuICAvKipcbiAgICogQ29tcG9zaXRlIGNvbXBvbmVudHMgYXJlIGhpZ2hlci1sZXZlbCBjb21wb25lbnRzIHRoYXQgY29tcG9zZSBvdGhlciBjb21wb3NpdGVcbiAgICogb3IgaG9zdCBjb21wb25lbnRzLlxuICAgKlxuICAgKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gICAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAgICogc3BlY2lmaWNhdGlvbiBpcyB0aGF0IHlvdSBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuXG4gICAqXG4gICAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gICAqICAgICB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAgICogc3BlY2lhbCBtZWFuaW5nIChlLmcuIGByZW5kZXJgKS4gU2VlIGBSZWFjdENsYXNzSW50ZXJmYWNlYCBmb3JcbiAgICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gICAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAgICpcbiAgICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7YXJyYXl9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgbWl4aW5zOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB0aGF0IHNob3VsZCBiZSBkZWZpbmVkIG9uXG4gICAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgICAqXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBzdGF0aWNzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgcHJvcFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29udGV4dFR5cGVzOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY2hpbGRDb250ZXh0VHlwZXM6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBWYWx1ZXMgaW4gdGhlIG1hcHBpbmcgd2lsbCBiZSBzZXQgb25cbiAgICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJlZm9yZSBgZ2V0SW5pdGlhbFN0YXRlYCBhbmQgdGhlcmVmb3JlIGNhbm5vdCByZWx5XG4gICAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFByb3BzOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgICAqIGFzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGB0aGlzLnN0YXRlYC5cbiAgICAgKlxuICAgICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgcmV0dXJuIHtcbiAgICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgZ2V0SW5pdGlhbFN0YXRlOiAnREVGSU5FX01BTllfTUVSR0VEJyxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBnZXRDaGlsZENvbnRleHQ6ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuXG4gICAgLyoqXG4gICAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgICAqXG4gICAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICAgKiAgICAgcmV0dXJuIDxkaXY+SGVsbG8sIHtuYW1lfSE8L2Rpdj47XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH1cbiAgICAgKiBAcmVxdWlyZWRcbiAgICAgKi9cbiAgICByZW5kZXI6ICdERUZJTkVfT05DRScsXG5cbiAgICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGx5IGNyZWF0ZWQgYW5kIGFib3V0IHRvIGJlIG1vdW50ZWQuXG4gICAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICAgKlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIGNvbXBvbmVudFdpbGxNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBIb3dldmVyLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgRE9NIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICAgKiBiZWVuIG1vdW50ZWQgKGluaXRpYWxpemVkIGFuZCByZW5kZXJlZCkgZm9yIHRoZSBmaXJzdCB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudDogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVhY3QgdG8gYSBwcm9wIHRyYW5zaXRpb24gYnkgdXBkYXRpbmcgdGhlXG4gICAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgICAqXG4gICAgICogICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gICAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAgICogICAgIH0pO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogTk9URTogVGhlcmUgaXMgbm8gZXF1aXZhbGVudCBgY29tcG9uZW50V2lsbFJlY2VpdmVTdGF0ZWAuIEFuIGluY29taW5nIHByb3BcbiAgICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogJ0RFRklORV9NQU5ZJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hpbGUgZGVjaWRpbmcgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZlxuICAgICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gYHJldHVybiBmYWxzZWAgd2hlbiB5b3UncmUgY2VydGFpbiB0aGF0IHRoZVxuICAgICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICAgKiB1cGRhdGUuXG4gICAgICpcbiAgICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgICAqICAgICAgICFlcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpIHx8XG4gICAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAqICAgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgICAqIEBvcHRpb25hbFxuICAgICAqL1xuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogJ0RFRklORV9PTkNFJyxcblxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIHVwZGF0ZSBkdWUgdG8gYSB0cmFuc2l0aW9uIGZyb21cbiAgICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgICAqXG4gICAgICogTk9URTogWW91ICoqY2Fubm90KiogdXNlIGB0aGlzLnNldFN0YXRlKClgIGluIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAb3B0aW9uYWxcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAgICogYmVlbiB1cGRhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByZXZQcm9wc1xuICAgICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkVXBkYXRlOiAnREVGSU5FX01BTlknLFxuXG4gICAgLyoqXG4gICAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICAgKiBpdHMgRE9NIHJlcHJlc2VudGF0aW9uIGRlc3Ryb3llZC5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgICAqXG4gICAgICogQG9wdGlvbmFsXG4gICAgICovXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQ6ICdERUZJTkVfTUFOWScsXG5cbiAgICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50J3MgY3VycmVudGx5IG1vdW50ZWQgRE9NIHJlcHJlc2VudGF0aW9uLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAgICogQGludGVybmFsXG4gICAgICogQG92ZXJyaWRhYmxlXG4gICAgICovXG4gICAgdXBkYXRlQ29tcG9uZW50OiAnT1ZFUlJJREVfQkFTRSdcbiAgfTtcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBBbHRob3VnaCB0aGVzZSBhcmUgZGVjbGFyZWQgbGlrZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGluIHRoZSBzcGVjaWZpY2F0aW9uXG4gICAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAgICogYW5kIGFyZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkIG9mIHRoZSBwcm90b3R5cGUuIERlc3BpdGVcbiAgICogYmVpbmcgc3RhdGljLCB0aGV5IG11c3QgYmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBcInN0YXRpY3NcIiBrZXkgdW5kZXJcbiAgICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICAgKi9cbiAgdmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgICBkaXNwbGF5TmFtZTogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICAgIH0sXG4gICAgbWl4aW5zOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgICBpZiAobWl4aW5zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWl4aW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsICdjaGlsZENvbnRleHQnKTtcbiAgICAgIH1cbiAgICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gX2Fzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzLFxuICAgICAgICBjaGlsZENvbnRleHRUeXBlc1xuICAgICAgKTtcbiAgICB9LFxuICAgIGNvbnRleHRUeXBlczogZnVuY3Rpb24oQ29uc3RydWN0b3IsIGNvbnRleHRUeXBlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBjb250ZXh0VHlwZXMsICdjb250ZXh0Jyk7XG4gICAgICB9XG4gICAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBfYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAgQ29uc3RydWN0b3IuY29udGV4dFR5cGVzLFxuICAgICAgICBjb250ZXh0VHlwZXNcbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oXG4gICAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLFxuICAgICAgICAgIGdldERlZmF1bHRQcm9wc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gZ2V0RGVmYXVsdFByb3BzO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcFR5cGVzOiBmdW5jdGlvbihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHByb3BUeXBlcywgJ3Byb3AnKTtcbiAgICAgIH1cbiAgICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IF9hc3NpZ24oe30sIENvbnN0cnVjdG9yLnByb3BUeXBlcywgcHJvcFR5cGVzKTtcbiAgICB9LFxuICAgIHN0YXRpY3M6IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gICAgfSxcbiAgICBhdXRvYmluZDogZnVuY3Rpb24oKSB7fVxuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0eXBlRGVmKSB7XG4gICAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIF9pbnZhcmlhbnQgc28gY29tcG9uZW50c1xuICAgICAgICAvLyBkb24ndCBzaG93IHVwIGluIHByb2QgYnV0IG9ubHkgaW4gX19ERVZfX1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICB0eXBlb2YgdHlwZURlZltwcm9wTmFtZV0gPT09ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICtcbiAgICAgICAgICAgICAgJ1JlYWN0LlByb3BUeXBlcy4nLFxuICAgICAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q2xhc3MnLFxuICAgICAgICAgICAgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLFxuICAgICAgICAgICAgcHJvcE5hbWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RPdmVycmlkZShpc0FscmVhZHlEZWZpbmVkLCBuYW1lKSB7XG4gICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpXG4gICAgICA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV1cbiAgICAgIDogbnVsbDtcblxuICAgIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gICAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgX2ludmFyaWFudChcbiAgICAgICAgc3BlY1BvbGljeSA9PT0gJ09WRVJSSURFX0JBU0UnLFxuICAgICAgICAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlICcgK1xuICAgICAgICAgICdgJXNgIGZyb20geW91ciBjbGFzcyBzcGVjaWZpY2F0aW9uLiBFbnN1cmUgdGhhdCB5b3VyIG1ldGhvZCBuYW1lcyAnICtcbiAgICAgICAgICAnZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsXG4gICAgICAgIG5hbWVcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRGlzYWxsb3cgZGVmaW5pbmcgbWV0aG9kcyBtb3JlIHRoYW4gb25jZSB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICAgIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICBzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTlknIHx8IHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWV9NRVJHRUQnLFxuICAgICAgICAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSAnICtcbiAgICAgICAgICAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlICcgK1xuICAgICAgICAgICd0byBhIG1peGluLicsXG4gICAgICAgIG5hbWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICAgKiBzcGVjaWZpY2F0aW9uIGtleXMgd2hlbiBidWlsZGluZyBSZWFjdCBjbGFzc2VzLlxuICAgKi9cbiAgZnVuY3Rpb24gbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpIHtcbiAgICBpZiAoIXNwZWMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciB0eXBlb2ZTcGVjID0gdHlwZW9mIHNwZWM7XG4gICAgICAgIHZhciBpc01peGluVmFsaWQgPSB0eXBlb2ZTcGVjID09PSAnb2JqZWN0JyAmJiBzcGVjICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgIGlzTWl4aW5WYWxpZCxcbiAgICAgICAgICAgIFwiJXM6IFlvdSdyZSBhdHRlbXB0aW5nIHRvIGluY2x1ZGUgYSBtaXhpbiB0aGF0IGlzIGVpdGhlciBudWxsIFwiICtcbiAgICAgICAgICAgICAgJ29yIG5vdCBhbiBvYmplY3QuIENoZWNrIHRoZSBtaXhpbnMgaW5jbHVkZWQgYnkgdGhlIGNvbXBvbmVudCwgJyArXG4gICAgICAgICAgICAgICdhcyB3ZWxsIGFzIGFueSBtaXhpbnMgdGhleSBpbmNsdWRlIHRoZW1zZWx2ZXMuICcgK1xuICAgICAgICAgICAgICAnRXhwZWN0ZWQgb2JqZWN0IGJ1dCBnb3QgJXMuJyxcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENsYXNzJyxcbiAgICAgICAgICAgIHNwZWMgPT09IG51bGwgPyBudWxsIDogdHlwZW9mU3BlY1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9pbnZhcmlhbnQoXG4gICAgICB0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJyxcbiAgICAgIFwiUmVhY3RDbGFzczogWW91J3JlIGF0dGVtcHRpbmcgdG8gXCIgK1xuICAgICAgICAndXNlIGEgY29tcG9uZW50IGNsYXNzIG9yIGZ1bmN0aW9uIGFzIGEgbWl4aW4uIEluc3RlYWQsIGp1c3QgdXNlIGEgJyArXG4gICAgICAgICdyZWd1bGFyIG9iamVjdC4nXG4gICAgKTtcbiAgICBfaW52YXJpYW50KFxuICAgICAgIWlzVmFsaWRFbGVtZW50KHNwZWMpLFxuICAgICAgXCJSZWFjdENsYXNzOiBZb3UncmUgYXR0ZW1wdGluZyB0byBcIiArXG4gICAgICAgICd1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nXG4gICAgKTtcblxuICAgIHZhciBwcm90byA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICB2YXIgYXV0b0JpbmRQYWlycyA9IHByb3RvLl9fcmVhY3RBdXRvQmluZFBhaXJzO1xuXG4gICAgLy8gQnkgaGFuZGxpbmcgbWl4aW5zIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcywgd2UgZW5zdXJlIHRoZSBzYW1lXG4gICAgLy8gY2hhaW5pbmcgb3JkZXIgaXMgYXBwbGllZCB0byBtZXRob2RzIHdpdGggREVGSU5FX01BTlkgcG9saWN5LCB3aGV0aGVyXG4gICAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXG4gICAgaWYgKHNwZWMuaGFzT3duUHJvcGVydHkoTUlYSU5TX0tFWSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZUy5taXhpbnMoQ29uc3RydWN0b3IsIHNwZWMubWl4aW5zKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIHNwZWMpIHtcbiAgICAgIGlmICghc3BlYy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09IE1JWElOU19LRVkpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcbiAgICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpO1xuXG4gICAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgICAvLyAxLiBFeHBlY3RlZCBSZWFjdENsYXNzIG1ldGhvZHMgKGluIHRoZSBcImludGVyZmFjZVwiKS5cbiAgICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgICB2YXIgaXNSZWFjdENsYXNzTWV0aG9kID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbic7XG4gICAgICAgIHZhciBzaG91bGRBdXRvQmluZCA9XG4gICAgICAgICAgaXNGdW5jdGlvbiAmJlxuICAgICAgICAgICFpc1JlYWN0Q2xhc3NNZXRob2QgJiZcbiAgICAgICAgICAhaXNBbHJlYWR5RGVmaW5lZCAmJlxuICAgICAgICAgIHNwZWMuYXV0b2JpbmQgIT09IGZhbHNlO1xuXG4gICAgICAgIGlmIChzaG91bGRBdXRvQmluZCkge1xuICAgICAgICAgIGF1dG9CaW5kUGFpcnMucHVzaChuYW1lLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlW25hbWVdO1xuXG4gICAgICAgICAgICAvLyBUaGVzZSBjYXNlcyBzaG91bGQgYWxyZWFkeSBiZSBjYXVnaHQgYnkgdmFsaWRhdGVNZXRob2RPdmVycmlkZS5cbiAgICAgICAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICAgICAgIGlzUmVhY3RDbGFzc01ldGhvZCAmJlxuICAgICAgICAgICAgICAgIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJyB8fFxuICAgICAgICAgICAgICAgICAgc3BlY1BvbGljeSA9PT0gJ0RFRklORV9NQU5ZJyksXG4gICAgICAgICAgICAgICdSZWFjdENsYXNzOiBVbmV4cGVjdGVkIHNwZWMgcG9saWN5ICVzIGZvciBrZXkgJXMgJyArXG4gICAgICAgICAgICAgICAgJ3doZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLFxuICAgICAgICAgICAgICBzcGVjUG9saWN5LFxuICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBGb3IgbWV0aG9kcyB3aGljaCBhcmUgZGVmaW5lZCBtb3JlIHRoYW4gb25jZSwgY2FsbCB0aGUgZXhpc3RpbmdcbiAgICAgICAgICAgIC8vIG1ldGhvZHMgYmVmb3JlIGNhbGxpbmcgdGhlIG5ldyBwcm9wZXJ0eSwgbWVyZ2luZyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSAnREVGSU5FX01BTllfTUVSR0VEJykge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXSA9IGNyZWF0ZU1lcmdlZFJlc3VsdEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09ICdERUZJTkVfTUFOWScpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXG4gICAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJyAmJiBzcGVjLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKSB7XG4gICAgaWYgKCFzdGF0aWNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuICAgICAgdmFyIHByb3BlcnR5ID0gc3RhdGljc1tuYW1lXTtcbiAgICAgIGlmICghc3RhdGljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzUmVzZXJ2ZWQgPSBuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUztcbiAgICAgIF9pbnZhcmlhbnQoXG4gICAgICAgICFpc1Jlc2VydmVkLFxuICAgICAgICAnUmVhY3RDbGFzczogWW91IGFyZSBhdHRlbXB0aW5nIHRvIGRlZmluZSBhIHJlc2VydmVkICcgK1xuICAgICAgICAgICdwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgJyArXG4gICAgICAgICAgJ2FzIGFuIGluc3RhbmNlIHByb3BlcnR5IGluc3RlYWQ7IGl0IHdpbGwgc3RpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgJyArXG4gICAgICAgICAgJ2NvbnN0cnVjdG9yLicsXG4gICAgICAgIG5hbWVcbiAgICAgICk7XG5cbiAgICAgIHZhciBpc0luaGVyaXRlZCA9IG5hbWUgaW4gQ29uc3RydWN0b3I7XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICAhaXNJbmhlcml0ZWQsXG4gICAgICAgICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgK1xuICAgICAgICAgICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSAnICtcbiAgICAgICAgICAnZHVlIHRvIGEgbWl4aW4uJyxcbiAgICAgICAgbmFtZVxuICAgICAgKTtcbiAgICAgIENvbnN0cnVjdG9yW25hbWVdID0gcHJvcGVydHk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9uZSBUaGUgZmlyc3Qgb2JqZWN0LCB3aGljaCBpcyBtdXRhdGVkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gICAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgICBfaW52YXJpYW50KFxuICAgICAgb25lICYmIHR3byAmJiB0eXBlb2Ygb25lID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdHdvID09PSAnb2JqZWN0JyxcbiAgICAgICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nXG4gICAgKTtcblxuICAgIGZvciAodmFyIGtleSBpbiB0d28pIHtcbiAgICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBfaW52YXJpYW50KFxuICAgICAgICAgIG9uZVtrZXldID09PSB1bmRlZmluZWQsXG4gICAgICAgICAgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogJyArXG4gICAgICAgICAgICAnVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgJyArXG4gICAgICAgICAgICAnbWF5IGJlIGR1ZSB0byBhIG1peGluOyBpbiBwYXJ0aWN1bGFyLCB0aGlzIG1heSBiZSBjYXVzZWQgYnkgdHdvICcgK1xuICAgICAgICAgICAgJ2dldEluaXRpYWxTdGF0ZSgpIG9yIGdldERlZmF1bHRQcm9wcygpIG1ldGhvZHMgcmV0dXJuaW5nIG9iamVjdHMgJyArXG4gICAgICAgICAgICAnd2l0aCBjbGFzaGluZyBrZXlzLicsXG4gICAgICAgICAga2V5XG4gICAgICAgICk7XG4gICAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvbmU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRSZXN1bHQoKSB7XG4gICAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmIChhID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICAgIHZhciBjID0ge307XG4gICAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGEpO1xuICAgICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICAgIHJldHVybiBjO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBpZ25vcmVzIHRoZWlyIHJldHVybiB2YWxlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgICAgb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBib3VuZCBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgICB2YXIgYm91bmRNZXRob2QgPSBtZXRob2QuYmluZChjb21wb25lbnQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgICAgdmFyIF9iaW5kID0gYm91bmRNZXRob2QuYmluZDtcbiAgICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbihuZXdUaGlzKSB7XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSxcbiAgICAgICAgICAgIF9rZXkgPSAxO1xuICAgICAgICAgIF9rZXkgPCBfbGVuO1xuICAgICAgICAgIF9rZXkrK1xuICAgICAgICApIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZXIgaXMgdHJ5aW5nIHRvIGJpbmQoKSBhbiBhdXRvYm91bmQgbWV0aG9kOyB3ZSBlZmZlY3RpdmVseSB3aWxsXG4gICAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuICAgICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgICBpZiAobmV3VGhpcyAhPT0gY29tcG9uZW50ICYmIG5ld1RoaXMgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdiaW5kKCk6IFJlYWN0IGNvbXBvbmVudCBtZXRob2RzIG1heSBvbmx5IGJlIGJvdW5kIHRvIHRoZSAnICtcbiAgICAgICAgICAgICAgICAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJXMnLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArXG4gICAgICAgICAgICAgICAgJ1JlYWN0IGRvZXMgdGhpcyBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaW4gYSBoaWdoLXBlcmZvcm1hbmNlICcgK1xuICAgICAgICAgICAgICAgICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAlcycsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kTWV0aG9kID0gbWV0aG9kO1xuICAgICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJvdW5kTWV0aG9kO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRBdXRvQmluZE1ldGhvZHMoY29tcG9uZW50KSB7XG4gICAgdmFyIHBhaXJzID0gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciBhdXRvQmluZEtleSA9IHBhaXJzW2ldO1xuICAgICAgdmFyIG1ldGhvZCA9IHBhaXJzW2kgKyAxXTtcbiAgICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBJc01vdW50ZWRQcmVNaXhpbiA9IHtcbiAgICBjb21wb25lbnREaWRNb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9faXNNb3VudGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIElzTW91bnRlZFBvc3RNaXhpbiA9IHtcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9faXNNb3VudGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgbW9yZSB0byB0aGUgUmVhY3RDbGFzcyBiYXNlIGNsYXNzLiBUaGVzZSBhcmUgYWxsIGxlZ2FjeSBmZWF0dXJlcyBhbmRcbiAgICogdGhlcmVmb3JlIG5vdCBhbHJlYWR5IHBhcnQgb2YgdGhlIG1vZGVybiBSZWFjdENvbXBvbmVudC5cbiAgICovXG4gIHZhciBSZWFjdENsYXNzTWl4aW4gPSB7XG4gICAgLyoqXG4gICAgICogVE9ETzogVGhpcyB3aWxsIGJlIGRlcHJlY2F0ZWQgYmVjYXVzZSBzdGF0ZSBzaG91bGQgYWx3YXlzIGtlZXAgYSBjb25zaXN0ZW50XG4gICAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgICAqL1xuICAgIHJlcGxhY2VTdGF0ZTogZnVuY3Rpb24obmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZSh0aGlzLCBuZXdTdGF0ZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIGlzTW91bnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIHRoaXMuX19kaWRXYXJuSXNNb3VudGVkLFxuICAgICAgICAgICclczogaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCAnICtcbiAgICAgICAgICAgICdzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluIGNvbXBvbmVudFdpbGxVbm1vdW50IHRvICcgK1xuICAgICAgICAgICAgJ3ByZXZlbnQgbWVtb3J5IGxlYWtzLicsXG4gICAgICAgICAgKHRoaXMuY29uc3RydWN0b3IgJiYgdGhpcy5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSkgfHxcbiAgICAgICAgICAgIHRoaXMubmFtZSB8fFxuICAgICAgICAgICAgJ0NvbXBvbmVudCdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fX2RpZFdhcm5Jc01vdW50ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhdGhpcy5fX2lzTW91bnRlZDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIFJlYWN0Q2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbigpIHt9O1xuICBfYXNzaWduKFxuICAgIFJlYWN0Q2xhc3NDb21wb25lbnQucHJvdG90eXBlLFxuICAgIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSxcbiAgICBSZWFjdENsYXNzTWl4aW5cbiAgKTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvbXBvc2l0ZSBjb21wb25lbnQgY2xhc3MgZ2l2ZW4gYSBjbGFzcyBzcGVjaWZpY2F0aW9uLlxuICAgKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlY2xhc3NcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDbGFzcyhzcGVjKSB7XG4gICAgLy8gVG8ga2VlcCBvdXIgd2FybmluZ3MgbW9yZSB1bmRlcnN0YW5kYWJsZSwgd2UnbGwgdXNlIGEgbGl0dGxlIGhhY2sgaGVyZSB0b1xuICAgIC8vIGVuc3VyZSB0aGF0IENvbnN0cnVjdG9yLm5hbWUgIT09ICdDb25zdHJ1Y3RvcicuIFRoaXMgbWFrZXMgc3VyZSB3ZSBkb24ndFxuICAgIC8vIHVubmVjZXNzYXJpbHkgaWRlbnRpZnkgYSBjbGFzcyB3aXRob3V0IGRpc3BsYXlOYW1lIGFzICdDb25zdHJ1Y3RvcicuXG4gICAgdmFyIENvbnN0cnVjdG9yID0gaWRlbnRpdHkoZnVuY3Rpb24ocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgZ2V0cyBvdmVycmlkZGVuIGJ5IG1vY2tzLiBUaGUgYXJndW1lbnQgaXMgdXNlZFxuICAgICAgLy8gYnkgbW9ja3MgdG8gYXNzZXJ0IG9uIHdoYXQgZ2V0cyBtb3VudGVkLlxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIHRoaXMgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcixcbiAgICAgICAgICAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArXG4gICAgICAgICAgICAnSlNYIGluc3RlYWQuIFNlZTogaHR0cHM6Ly9mYi5tZS9yZWFjdC1sZWdhY3lmYWN0b3J5J1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBXaXJlIHVwIGF1dG8tYmluZGluZ1xuICAgICAgaWYgKHRoaXMuX19yZWFjdEF1dG9CaW5kUGFpcnMubGVuZ3RoKSB7XG4gICAgICAgIGJpbmRBdXRvQmluZE1ldGhvZHModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICAgIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gICAgICAvLyBSZWFjdENsYXNzZXMgZG9lc24ndCBoYXZlIGNvbnN0cnVjdG9ycy4gSW5zdGVhZCwgdGhleSB1c2UgdGhlXG4gICAgICAvLyBnZXRJbml0aWFsU3RhdGUgYW5kIGNvbXBvbmVudFdpbGxNb3VudCBtZXRob2RzIGZvciBpbml0aWFsaXphdGlvbi5cblxuICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlID8gdGhpcy5nZXRJbml0aWFsU3RhdGUoKSA6IG51bGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBXZSBhbGxvdyBhdXRvLW1vY2tzIHRvIHByb2NlZWQgYXMgaWYgdGhleSdyZSByZXR1cm5pbmcgbnVsbC5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgdGhpcy5nZXRJbml0aWFsU3RhdGUuX2lzTW9ja0Z1bmN0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgYmFkIHByYWN0aWNlLiBDb25zaWRlciB3YXJuaW5nIGhlcmUgYW5kXG4gICAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgICBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBfaW52YXJpYW50KFxuICAgICAgICB0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpLFxuICAgICAgICAnJXMuZ2V0SW5pdGlhbFN0YXRlKCk6IG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsJyxcbiAgICAgICAgQ29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50J1xuICAgICAgKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICB9KTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fX3JlYWN0QXV0b0JpbmRQYWlycyA9IFtdO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgSXNNb3VudGVkUHJlTWl4aW4pO1xuICAgIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKTtcbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgSXNNb3VudGVkUG9zdE1peGluKTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIGRlZmF1bHRQcm9wcyBwcm9wZXJ0eSBhZnRlciBhbGwgbWl4aW5zIGhhdmUgYmVlbiBtZXJnZWQuXG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZGVmYXVsdFByb3BzID0gQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0YWcgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdXNlIG9mIHRoZXNlIG1ldGhvZCBuYW1lcyBpcyBvayxcbiAgICAgIC8vIHNpbmNlIGl0J3MgdXNlZCB3aXRoIGNyZWF0ZUNsYXNzLiBJZiBpdCdzIG5vdCwgdGhlbiBpdCdzIGxpa2VseSBhXG4gICAgICAvLyBtaXN0YWtlIHNvIHdlJ2xsIHdhcm4geW91IHRvIHVzZSB0aGUgc3RhdGljIHByb3BlcnR5LCBwcm9wZXJ0eVxuICAgICAgLy8gaW5pdGlhbGl6ZXIgb3IgY29uc3RydWN0b3IgcmVzcGVjdGl2ZWx5LlxuICAgICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfaW52YXJpYW50KFxuICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLnJlbmRlcixcbiAgICAgICdjcmVhdGVDbGFzcyguLi4pOiBDbGFzcyBzcGVjaWZpY2F0aW9uIG11c3QgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLidcbiAgICApO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5pbmcoXG4gICAgICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29tcG9uZW50U2hvdWxkVXBkYXRlLFxuICAgICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICtcbiAgICAgICAgICAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArXG4gICAgICAgICAgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICtcbiAgICAgICAgICAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJyxcbiAgICAgICAgc3BlYy5kaXNwbGF5TmFtZSB8fCAnQSBjb21wb25lbnQnXG4gICAgICApO1xuICAgICAgd2FybmluZyhcbiAgICAgICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLFxuICAgICAgICAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICtcbiAgICAgICAgICAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsXG4gICAgICAgIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBSZWR1Y2UgdGltZSBzcGVudCBkb2luZyBsb29rdXBzIGJ5IHNldHRpbmcgdGhlc2Ugb24gdGhlIHByb3RvdHlwZS5cbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIFJlYWN0Q2xhc3NJbnRlcmZhY2UpIHtcbiAgICAgIGlmICghQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUNsYXNzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3Rvcnk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY3JlYXRlLXJlYWN0LWNsYXNzL2ZhY3RvcnkuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2NyZWF0ZS1yZWFjdC1jbGFzcy9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MycpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9saWIvb25seUNoaWxkLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL1JlYWN0RE9NJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qIGdsb2JhbHMgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERlZmF1bHRJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEluamVjdGlvbicpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlcicpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xudmFyIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyID0gcmVxdWlyZSgnLi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cblJlYWN0RGVmYXVsdEluamVjdGlvbi5pbmplY3QoKTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBmaW5kRE9NTm9kZTogZmluZERPTU5vZGUsXG4gIHJlbmRlcjogUmVhY3RNb3VudC5yZW5kZXIsXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzLFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbiAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbn07XG5cbi8vIEluamVjdCB0aGUgcnVudGltZSBpbnRvIGEgZGV2dG9vbHMgZ2xvYmFsIGhvb2sgcmVnYXJkbGVzcyBvZiBicm93c2VyLlxuLy8gQWxsb3dzIGZvciBkZWJ1Z2dpbmcgd2hlbiB0aGUgaG9vayBpcyBpbmplY3RlZCBvbiB0aGUgcGFnZS5cbmlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uaW5qZWN0KHtcbiAgICBDb21wb25lbnRUcmVlOiB7XG4gICAgICBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogUmVhY3RET01Db21wb25lbnRUcmVlLmdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICAgICAgZ2V0Tm9kZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgLy8gaW5zdCBpcyBhbiBpbnRlcm5hbCBpbnN0YW5jZSAoYnV0IGNvdWxkIGJlIGEgY29tcG9zaXRlKVxuICAgICAgICBpZiAoaW5zdC5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgICAgICBpbnN0ID0gZ2V0SG9zdENvbXBvbmVudEZyb21Db21wb3NpdGUoaW5zdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgICByZXR1cm4gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlclxuICB9KTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGRldnRvb2xzIGlzIG5vdCBpbnN0YWxsZWRcbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgICAvLyBGaXJlZm94IGRvZXMgbm90IGhhdmUgdGhlIGlzc3VlIHdpdGggZGV2dG9vbHMgbG9hZGVkIG92ZXIgZmlsZTovL1xuICAgICAgICB2YXIgc2hvd0ZpbGVVcmxNZXNzYWdlID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSA9PT0gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArIChzaG93RmlsZVVybE1lc3NhZ2UgPyAnYW5kIHVzZSBhbiBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBhIGZpbGU6IFVSTCkgJyA6ICcnKSArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRlc3RGdW5jID0gZnVuY3Rpb24gdGVzdEZuKCkge307XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoKHRlc3RGdW5jLm5hbWUgfHwgdGVzdEZ1bmMudG9TdHJpbmcoKSkuaW5kZXhPZigndGVzdEZuJykgIT09IC0xLCBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIGEgbWluaWZpZWQgY29weSBvZiB0aGUgZGV2ZWxvcG1lbnQgYnVpbGQgXCIgKyAnb2YgUmVhY3QuIFdoZW4gZGVwbG95aW5nIFJlYWN0IGFwcHMgdG8gcHJvZHVjdGlvbiwgbWFrZSBzdXJlIHRvIHVzZSAnICsgJ3RoZSBwcm9kdWN0aW9uIGJ1aWxkIHdoaWNoIHNraXBzIGRldmVsb3BtZW50IHdhcm5pbmdzIGFuZCBpcyBmYXN0ZXIuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtbWluaWZpY2F0aW9uIGZvciBtb3JlIGRldGFpbHMuJykgOiB2b2lkIDA7XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBJRTgsIGNoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgaW4gY29tcGF0aWJpbGl0eSBtb2RlIGFuZCBwcm92aWRlXG4gICAgLy8gaW5mb3JtYXRpb24gb24gcHJldmVudGluZyBjb21wYXRpYmlsaXR5IG1vZGVcbiAgICB2YXIgaWVDb21wYXRpYmlsaXR5TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA4O1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWllQ29tcGF0aWJpbGl0eU1vZGUsICdJbnRlcm5ldCBFeHBsb3JlciBpcyBydW5uaW5nIGluIGNvbXBhdGliaWxpdHkgbW9kZTsgcGxlYXNlIGFkZCB0aGUgJyArICdmb2xsb3dpbmcgdGFnIHRvIHlvdXIgSFRNTCB0byBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmc6ICcgKyAnPG1ldGEgaHR0cC1lcXVpdj1cIlgtVUEtQ29tcGF0aWJsZVwiIGNvbnRlbnQ9XCJJRT1lZGdlXCIgLz4nKSA6IHZvaWQgMDtcblxuICAgIHZhciBleHBlY3RlZEZlYXR1cmVzID0gW1xuICAgIC8vIHNoaW1zXG4gICAgQXJyYXkuaXNBcnJheSwgQXJyYXkucHJvdG90eXBlLmV2ZXJ5LCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCwgQXJyYXkucHJvdG90eXBlLmluZGV4T2YsIEFycmF5LnByb3RvdHlwZS5tYXAsIERhdGUubm93LCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCwgT2JqZWN0LmtleXMsIFN0cmluZy5wcm90b3R5cGUudHJpbV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZXhwZWN0ZWRGZWF0dXJlc1tpXSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09uZSBvciBtb3JlIEVTNSBzaGltcyBleHBlY3RlZCBieSBSZWFjdCBhcmUgbm90IGF2YWlsYWJsZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctcG9seWZpbGxzJykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG4gIHZhciBSZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaycpO1xuICB2YXIgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTU51bGxJbnB1dFZhbHVlUHJvcEhvb2snKTtcbiAgdmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rID0gcmVxdWlyZSgnLi9SZWFjdERPTUludmFsaWRBUklBSG9vaycpO1xuXG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayk7XG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vayk7XG4gIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5hZGRIb29rKFJlYWN0RE9NSW52YWxpZEFSSUFIb29rKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBUklBRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0FSSUFET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQ2hhbmdlRXZlbnRQbHVnaW4nKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vSFRNTERPTVByb3BlcnR5Q29uZmlnJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdERPTUVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RET01UcmVlVHJhdmVyc2FsID0gcmVxdWlyZSgnLi9SZWFjdERPTVRyZWVUcmF2ZXJzYWwnKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRMaXN0ZW5lcicpO1xudmFyIFJlYWN0SW5qZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluamVjdGlvbicpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2VsZWN0RXZlbnRQbHVnaW4nKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5VdGlscy5pbmplY3RDb21wb25lbnRUcmVlKFJlYWN0RE9NQ29tcG9uZW50VHJlZSk7XG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50UGx1Z2luVXRpbHMuaW5qZWN0VHJlZVRyYXZlcnNhbChSZWFjdERPTVRyZWVUcmF2ZXJzYWwpO1xuXG4gIC8qKlxuICAgKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAgICogdGhlbSkuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICAgIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gICAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICAgIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbiAgfSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uSG9zdENvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkhvc3RDb21wb25lbnQuaW5qZWN0VGV4dENvbXBvbmVudENsYXNzKFJlYWN0RE9NVGV4dENvbXBvbmVudCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoQVJJQURPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50RmFjdG9yeShmdW5jdGlvbiAoaW5zdGFudGlhdGUpIHtcbiAgICByZXR1cm4gbmV3IFJlYWN0RE9NRW1wdHlDb21wb25lbnQoaW5zdGFudGlhdGUpO1xuICB9KTtcblxuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICBSZWFjdEluamVjdGlvbi5VcGRhdGVzLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluamVjdDogaW5qZWN0XG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RGVmYXVsdEluamVjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBBUklBRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICAvLyBHbG9iYWwgU3RhdGVzIGFuZCBQcm9wZXJ0aWVzXG4gICAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAgICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgICAnYXJpYS1sYWJlbCc6IDAsXG4gICAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAgICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgICAnYXJpYS1sZXZlbCc6IDAsXG4gICAgJ2FyaWEtbW9kYWwnOiAwLFxuICAgICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAgICdhcmlhLXByZXNzZWQnOiAwLFxuICAgICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAgICdhcmlhLXNvcnQnOiAwLFxuICAgICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAgICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gICAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAgICdhcmlhLWF0b21pYyc6IDAsXG4gICAgJ2FyaWEtYnVzeSc6IDAsXG4gICAgJ2FyaWEtbGl2ZSc6IDAsXG4gICAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAgIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAgICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAgICdhcmlhLWdyYWJiZWQnOiAwLFxuICAgIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAgICdhcmlhLWNvbGluZGV4JzogMCxcbiAgICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgICAnYXJpYS1jb250cm9scyc6IDAsXG4gICAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAgICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgICAnYXJpYS1vd25zJzogMCxcbiAgICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAgICdhcmlhLXJvd2luZGV4JzogMCxcbiAgICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgICAnYXJpYS1zZXRzaXplJzogMFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge30sXG4gIERPTVByb3BlcnR5TmFtZXM6IHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFSSUFET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9BUklBRE9NUHJvcGVydHlDb25maWcuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSA9IHJlcXVpcmUoJy4vRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlJyk7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ29tcG9zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0lucHV0RXZlbnQnKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5UHJlc3MnLCAndG9wVGV4dElucHV0JywgJ3RvcFBhc3RlJ11cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25VcGRhdGUnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblVwZGF0ZSc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIGZhbGxiYWNrIG9iamVjdCwgaWYgYW55LlxudmFyIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghY3VycmVudENvbXBvc2l0aW9uICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBjdXJyZW50Q29tcG9zaXRpb24gPSBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuZ2V0UG9vbGVkKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlICd0b3BUZXh0SW5wdXQnOlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDb21wb3NpdGlvbkVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBjdXJyZW50Q29tcG9zaXRpb24uZ2V0RGF0YSgpO1xuICAgICAgRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLnJlbGVhc2UoY3VycmVudENvbXBvc2l0aW9uKTtcbiAgICAgIGN1cnJlbnRDb21wb3NpdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAobmF0aXZlRXZlbnQud2hpY2ggJiYgIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciA9IHJlcXVpcmUoJy4vZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcicpO1xuXG4vKipcbiAqIFRoaXMgaGVscGVyIGNsYXNzIHN0b3JlcyBpbmZvcm1hdGlvbiBhYm91dCB0ZXh0IGNvbnRlbnQgb2YgYSB0YXJnZXQgbm9kZSxcbiAqIGFsbG93aW5nIGNvbXBhcmlzb24gb2YgY29udGVudCBiZWZvcmUgYW5kIGFmdGVyIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogSWRlbnRpZnkgdGhlIG5vZGUgd2hlcmUgc2VsZWN0aW9uIGN1cnJlbnRseSBiZWdpbnMsIHRoZW4gb2JzZXJ2ZVxuICogYm90aCBpdHMgdGV4dCBjb250ZW50IGFuZCBpdHMgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgRE9NLiBTaW5jZSB0aGVcbiAqIGJyb3dzZXIgbWF5IG5hdGl2ZWx5IHJlcGxhY2UgdGhlIHRhcmdldCBub2RlIGR1cmluZyBjb21wb3NpdGlvbiwgd2UgY2FuXG4gKiB1c2UgaXRzIHBvc2l0aW9uIHRvIGZpbmQgaXRzIHJlcGxhY2VtZW50LlxuICpcbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHJvb3RcbiAqL1xuZnVuY3Rpb24gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlKHJvb3QpIHtcbiAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gIHRoaXMuX3N0YXJ0VGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICB0aGlzLl9mYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5fYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0lucHV0RXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljSW5wdXRFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGlucHV0VmFsdWVUcmFja2luZyA9IHJlcXVpcmUoJy4vaW5wdXRWYWx1ZVRyYWNraW5nJyk7XG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGlzVGV4dElucHV0RWxlbWVudCA9IHJlcXVpcmUoJy4vaXNUZXh0SW5wdXRFbGVtZW50Jyk7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ2hhbmdlJywgJ3RvcENsaWNrJywgJ3RvcEZvY3VzJywgJ3RvcElucHV0JywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuY2hhbmdlLCBpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KTtcbiAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDgpO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCkge1xuICB2YXIgdXBkYXRlZCA9IGlucHV0VmFsdWVUcmFja2luZy51cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgdmFyIHNpbXVsYXRlZCA9IG5hdGl2ZUV2ZW50LnNpbXVsYXRlZCA9PT0gdHJ1ZSAmJiBDaGFuZ2VFdmVudFBsdWdpbi5fYWxsb3dTaW11bGF0ZWRQYXNzVGhyb3VnaDtcblxuICBpZiAodXBkYXRlZCB8fCBzaW11bGF0ZWQpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEZvY3VzJykge1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgIHN0b3BXYXRjaGluZ0ZvckNoYW5nZUV2ZW50SUU4KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cblxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU4LCB3ZSBjYW4gY2FwdHVyZSBhbG1vc3QgYWxsIC52YWx1ZSBjaGFuZ2VzIGJ5IGFkZGluZyBhXG4gICAgLy8gcHJvcGVydHljaGFuZ2UgaGFuZGxlciBhbmQgbG9va2luZyBmb3IgZXZlbnRzIHdpdGggcHJvcGVydHlOYW1lXG4gICAgLy8gZXF1YWwgdG8gJ3ZhbHVlJ1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BTZWxlY3Rpb25DaGFuZ2UnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDbGljaycpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihpbnN0LCBub2RlKSB7XG4gIC8vIFRPRE86IEluIElFLCBpbnN0IGlzIG9jY2FzaW9uYWxseSBudWxsLiBXaHk/XG4gIGlmIChpbnN0ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGaWJlciBhbmQgUmVhY3RET00ga2VlcCB3cmFwcGVyIHN0YXRlIGluIHNlcGFyYXRlIHBsYWNlc1xuICB2YXIgc3RhdGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUgfHwgbm9kZS5fd3JhcHBlclN0YXRlO1xuXG4gIGlmICghc3RhdGUgfHwgIXN0YXRlLmNvbnRyb2xsZWQgfHwgbm9kZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGNvbnRyb2xsZWQsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9uIGJsdXJcbiAgdmFyIHZhbHVlID0gJycgKyBub2RlLnZhbHVlO1xuICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgIT09IHZhbHVlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBfYWxsb3dTaW11bGF0ZWRQYXNzVGhyb3VnaDogdHJ1ZSxcbiAgX2lzSW5wdXRFdmVudFN1cHBvcnRlZDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoZG9lc0NoYW5nZUV2ZW50QnViYmxlKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SW5zdCk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBibHVycmluZywgc2V0IHRoZSB2YWx1ZSBhdHRyaWJ1dGUgZm9yIG51bWJlciBpbnB1dHNcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICAgIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0SW5zdCwgdGFyZ2V0Tm9kZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5nZUV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RPd25lcicpO1xuXG52YXIgUmVhY3RSZWYgPSB7fTtcblxuZnVuY3Rpb24gYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIuYWRkQ29tcG9uZW50QXNSZWZUbyhjb21wb25lbnQsIHJlZiwgb3duZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaFJlZihyZWYsIGNvbXBvbmVudCwgb3duZXIpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZWYobnVsbCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTGVnYWN5IHJlZlxuICAgIFJlYWN0T3duZXIucmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuUmVhY3RSZWYuYXR0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBhdHRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5SZWFjdFJlZi5zaG91bGRVcGRhdGVSZWZzID0gZnVuY3Rpb24gKHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkge1xuICAvLyBJZiBlaXRoZXIgdGhlIG93bmVyIG9yIGEgYHJlZmAgaGFzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0aGUgbmV3ZXN0IG93bmVyXG4gIC8vIGhhcyBzdG9yZWQgYSByZWZlcmVuY2UgdG8gYHRoaXNgLCBhbmQgdGhlIHByZXZpb3VzIG93bmVyIChpZiBkaWZmZXJlbnQpXG4gIC8vIGhhcyBmb3Jnb3R0ZW4gdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AuIFdlIHVzZSB0aGUgZWxlbWVudCBpbnN0ZWFkXG4gIC8vIG9mIHRoZSBwdWJsaWMgdGhpcy5wcm9wcyBiZWNhdXNlIHRoZSBwb3N0IHByb2Nlc3NpbmcgY2Fubm90IGRldGVybWluZVxuICAvLyBhIHJlZi4gVGhlIHJlZiBjb25jZXB0dWFsbHkgbGl2ZXMgb24gdGhlIGVsZW1lbnQuXG5cbiAgLy8gVE9ETzogU2hvdWxkIHRoaXMgZXZlbiBiZSBwb3NzaWJsZT8gVGhlIG93bmVyIGNhbm5vdCBjaGFuZ2UgYmVjYXVzZVxuICAvLyBpdCdzIGZvcmJpZGRlbiBieSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudC4gVGhlIHJlZiBjYW4gY2hhbmdlXG4gIC8vIGlmIHlvdSBzd2FwIHRoZSBrZXlzIG9mIGJ1dCBub3QgdGhlIHJlZnMuIFJlY29uc2lkZXIgd2hlcmUgdGhpcyBjaGVja1xuICAvLyBpcyBtYWRlLiBJdCBwcm9iYWJseSBiZWxvbmdzIHdoZXJlIHRoZSBrZXkgY2hlY2tpbmcgYW5kXG4gIC8vIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgaXMgZG9uZS5cblxuICB2YXIgcHJldlJlZiA9IG51bGw7XG4gIHZhciBwcmV2T3duZXIgPSBudWxsO1xuICBpZiAocHJldkVsZW1lbnQgIT09IG51bGwgJiYgdHlwZW9mIHByZXZFbGVtZW50ID09PSAnb2JqZWN0Jykge1xuICAgIHByZXZSZWYgPSBwcmV2RWxlbWVudC5yZWY7XG4gICAgcHJldk93bmVyID0gcHJldkVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgdmFyIG5leHRSZWYgPSBudWxsO1xuICB2YXIgbmV4dE93bmVyID0gbnVsbDtcbiAgaWYgKG5leHRFbGVtZW50ICE9PSBudWxsICYmIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICBuZXh0UmVmID0gbmV4dEVsZW1lbnQucmVmO1xuICAgIG5leHRPd25lciA9IG5leHRFbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHJldHVybiBwcmV2UmVmICE9PSBuZXh0UmVmIHx8XG4gIC8vIElmIG93bmVyIGNoYW5nZXMgYnV0IHdlIGhhdmUgYW4gdW5jaGFuZ2VkIGZ1bmN0aW9uIHJlZiwgZG9uJ3QgdXBkYXRlIHJlZnNcbiAgdHlwZW9mIG5leHRSZWYgPT09ICdzdHJpbmcnICYmIG5leHRPd25lciAhPT0gcHJldk93bmVyO1xufTtcblxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAocmVmICE9IG51bGwpIHtcbiAgICBkZXRhY2hSZWYocmVmLCBpbnN0YW5jZSwgZWxlbWVudC5fb3duZXIpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVmO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0UmVmLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBvd25lci5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkT3duZXIob2JqZWN0KSB7XG4gIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjb21wb25lbnQgYnkgcmVmIHRvIGFuIG93bmVyIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byByZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBieSB3aGljaCB0byByZWZlciB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge1JlYWN0T3duZXJ9IG93bmVyIENvbXBvbmVudCBvbiB3aGljaCB0byByZWNvcmQgdGhlIHJlZi5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYWRkQ29tcG9uZW50QXNSZWZUbzogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFpc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0IGJlIGFkZGluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTE5JykgOiB2b2lkIDA7XG4gICAgb3duZXIuYXR0YWNoUmVmKHJlZiwgY29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNvbXBvbmVudCBieSByZWYgZnJvbSBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gZGVyZWZlcmVuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSBvZiB0aGUgcmVmIHRvIHJlbW92ZS5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdGhlIHJlZiBpcyByZWNvcmRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tOiBmdW5jdGlvbiAoY29tcG9uZW50LCByZWYsIG93bmVyKSB7XG4gICAgIWlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCBiZSByZW1vdmluZyBhIHJlZiB0byBhIGNvbXBvbmVudCB0aGF0IHdhcyBub3QgY3JlYXRlZCBpbnNpZGUgYSBjb21wb25lbnRcXCdzIGByZW5kZXJgIG1ldGhvZCwgb3IgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZCAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBfcHJvZEludmFyaWFudCgnMTIwJykgOiB2b2lkIDA7XG4gICAgdmFyIG93bmVyUHVibGljSW5zdGFuY2UgPSBvd25lci5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAncyBvd25lciBpcyBzdGlsbCBhbGl2ZSBhbmQgdGhhdCBgY29tcG9uZW50YCBpcyBzdGlsbCB0aGUgY3VycmVudCByZWZcbiAgICAvLyBiZWNhdXNlIHdlIGRvIG5vdCB3YW50IHRvIGRldGFjaCB0aGUgcmVmIGlmIGFub3RoZXIgY29tcG9uZW50IHN0b2xlIGl0LlxuICAgIGlmIChvd25lclB1YmxpY0luc3RhbmNlICYmIG93bmVyUHVibGljSW5zdGFuY2UucmVmc1tyZWZdID09PSBjb21wb25lbnQuZ2V0UHVibGljSW5zdGFuY2UoKSkge1xuICAgICAgb3duZXIuZGV0YWNoUmVmKHJlZik7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0T3duZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RPd25lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2sgPSByZXF1aXJlKCcuL1JlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2snKTtcbnZhciBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayA9IHJlcXVpcmUoJy4vUmVhY3RIb3N0T3BlcmF0aW9uSGlzdG9yeUhvb2snKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGhvb2tzID0gW107XG52YXIgZGlkSG9va1Rocm93Rm9yRXZlbnQgPSB7fTtcblxuZnVuY3Rpb24gY2FsbEhvb2soZXZlbnQsIGZuLCBjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG4gIHRyeSB7XG4gICAgZm4uY2FsbChjb250ZXh0LCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZEhvb2tUaHJvd0ZvckV2ZW50W2V2ZW50XSwgJ0V4Y2VwdGlvbiB0aHJvd24gYnkgaG9vayB3aGlsZSBoYW5kbGluZyAlczogJXMnLCBldmVudCwgZSArICdcXG4nICsgZS5zdGFjaykgOiB2b2lkIDA7XG4gICAgZGlkSG9va1Rocm93Rm9yRXZlbnRbZXZlbnRdID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXZlbnQoZXZlbnQsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBob29rID0gaG9va3NbaV07XG4gICAgdmFyIGZuID0gaG9va1tldmVudF07XG4gICAgaWYgKGZuKSB7XG4gICAgICBjYWxsSG9vayhldmVudCwgZm4sIGhvb2ssIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgaXNQcm9maWxpbmcgPSBmYWxzZTtcbnZhciBmbHVzaEhpc3RvcnkgPSBbXTtcbnZhciBsaWZlQ3ljbGVUaW1lclN0YWNrID0gW107XG52YXIgY3VycmVudEZsdXNoTmVzdGluZyA9IDA7XG52YXIgY3VycmVudEZsdXNoTWVhc3VyZW1lbnRzID0gW107XG52YXIgY3VycmVudEZsdXNoU3RhcnRUaW1lID0gMDtcbnZhciBjdXJyZW50VGltZXJEZWJ1Z0lEID0gbnVsbDtcbnZhciBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xudmFyIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb24gPSAwO1xudmFyIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xuXG52YXIgbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KCkge1xuICBSZWFjdENvbXBvbmVudFRyZWVIb29rLnB1cmdlVW5tb3VudGVkQ29tcG9uZW50cygpO1xuICBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5jbGVhckhpc3RvcnkoKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJlZVNuYXBzaG90KHJlZ2lzdGVyZWRJRHMpIHtcbiAgcmV0dXJuIHJlZ2lzdGVyZWRJRHMucmVkdWNlKGZ1bmN0aW9uICh0cmVlLCBpZCkge1xuICAgIHZhciBvd25lcklEID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKGlkKTtcbiAgICB2YXIgcGFyZW50SUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFBhcmVudElEKGlkKTtcbiAgICB0cmVlW2lkXSA9IHtcbiAgICAgIGRpc3BsYXlOYW1lOiBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldERpc3BsYXlOYW1lKGlkKSxcbiAgICAgIHRleHQ6IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0VGV4dChpZCksXG4gICAgICB1cGRhdGVDb3VudDogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRVcGRhdGVDb3VudChpZCksXG4gICAgICBjaGlsZElEczogUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDaGlsZElEcyhpZCksXG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUgb3duZXJzIGJ1dCB0aGlzIGlzIGNsb3NlIGVub3VnaC5cbiAgICAgIG93bmVySUQ6IG93bmVySUQgfHwgcGFyZW50SUQgJiYgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRPd25lcklEKHBhcmVudElEKSB8fCAwLFxuICAgICAgcGFyZW50SUQ6IHBhcmVudElEXG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiByZXNldE1lYXN1cmVtZW50cygpIHtcbiAgdmFyIHByZXZpb3VzU3RhcnRUaW1lID0gY3VycmVudEZsdXNoU3RhcnRUaW1lO1xuICB2YXIgcHJldmlvdXNNZWFzdXJlbWVudHMgPSBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHM7XG4gIHZhciBwcmV2aW91c09wZXJhdGlvbnMgPSBSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vay5nZXRIaXN0b3J5KCk7XG5cbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICBjdXJyZW50Rmx1c2hTdGFydFRpbWUgPSAwO1xuICAgIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xuICAgIGNsZWFySGlzdG9yeSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcmV2aW91c01lYXN1cmVtZW50cy5sZW5ndGggfHwgcHJldmlvdXNPcGVyYXRpb25zLmxlbmd0aCkge1xuICAgIHZhciByZWdpc3RlcmVkSURzID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRSZWdpc3RlcmVkSURzKCk7XG4gICAgZmx1c2hIaXN0b3J5LnB1c2goe1xuICAgICAgZHVyYXRpb246IHBlcmZvcm1hbmNlTm93KCkgLSBwcmV2aW91c1N0YXJ0VGltZSxcbiAgICAgIG1lYXN1cmVtZW50czogcHJldmlvdXNNZWFzdXJlbWVudHMgfHwgW10sXG4gICAgICBvcGVyYXRpb25zOiBwcmV2aW91c09wZXJhdGlvbnMgfHwgW10sXG4gICAgICB0cmVlU25hcHNob3Q6IGdldFRyZWVTbmFwc2hvdChyZWdpc3RlcmVkSURzKVxuICAgIH0pO1xuICB9XG5cbiAgY2xlYXJIaXN0b3J5KCk7XG4gIGN1cnJlbnRGbHVzaFN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGN1cnJlbnRGbHVzaE1lYXN1cmVtZW50cyA9IFtdO1xufVxuXG5mdW5jdGlvbiBjaGVja0RlYnVnSUQoZGVidWdJRCkge1xuICB2YXIgYWxsb3dSb290ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICBpZiAoYWxsb3dSb290ICYmIGRlYnVnSUQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFkZWJ1Z0lEKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERlYnVnVG9vbDogZGVidWdJRCBtYXkgbm90IGJlIGVtcHR5LicpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChjdXJyZW50Rmx1c2hOZXN0aW5nID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChjdXJyZW50VGltZXJUeXBlICYmICFsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVGhlcmUgaXMgYW4gaW50ZXJuYWwgZXJyb3IgaW4gdGhlIFJlYWN0IHBlcmZvcm1hbmNlIG1lYXN1cmVtZW50IGNvZGUuICcgKyAnRGlkIG5vdCBleHBlY3QgJXMgdGltZXIgdG8gc3RhcnQgd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuJywgdGltZXJUeXBlLCBjdXJyZW50VGltZXJUeXBlIHx8ICdubycsIGRlYnVnSUQgPT09IGN1cnJlbnRUaW1lckRlYnVnSUQgPyAndGhlIHNhbWUnIDogJ2Fub3RoZXInKSA6IHZvaWQgMDtcbiAgICBsaWZlQ3ljbGVUaW1lckhhc1dhcm5lZCA9IHRydWU7XG4gIH1cbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBkZWJ1Z0lEO1xuICBjdXJyZW50VGltZXJUeXBlID0gdGltZXJUeXBlO1xufVxuXG5mdW5jdGlvbiBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgaWYgKGN1cnJlbnRGbHVzaE5lc3RpbmcgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRUaW1lclR5cGUgIT09IHRpbWVyVHlwZSAmJiAhbGlmZUN5Y2xlVGltZXJIYXNXYXJuZWQpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RoZXJlIGlzIGFuIGludGVybmFsIGVycm9yIGluIHRoZSBSZWFjdCBwZXJmb3JtYW5jZSBtZWFzdXJlbWVudCBjb2RlLiAnICsgJ1dlIGRpZCBub3QgZXhwZWN0ICVzIHRpbWVyIHRvIHN0b3Agd2hpbGUgJXMgdGltZXIgaXMgc3RpbGwgaW4gJyArICdwcm9ncmVzcyBmb3IgJXMgaW5zdGFuY2UuIFBsZWFzZSByZXBvcnQgdGhpcyBhcyBhIGJ1ZyBpbiBSZWFjdC4nLCB0aW1lclR5cGUsIGN1cnJlbnRUaW1lclR5cGUgfHwgJ25vJywgZGVidWdJRCA9PT0gY3VycmVudFRpbWVyRGVidWdJRCA/ICd0aGUgc2FtZScgOiAnYW5vdGhlcicpIDogdm9pZCAwO1xuICAgIGxpZmVDeWNsZVRpbWVySGFzV2FybmVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICBjdXJyZW50Rmx1c2hNZWFzdXJlbWVudHMucHVzaCh7XG4gICAgICB0aW1lclR5cGU6IHRpbWVyVHlwZSxcbiAgICAgIGluc3RhbmNlSUQ6IGRlYnVnSUQsXG4gICAgICBkdXJhdGlvbjogcGVyZm9ybWFuY2VOb3coKSAtIGN1cnJlbnRUaW1lclN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lck5lc3RlZEZsdXNoRHVyYXRpb25cbiAgICB9KTtcbiAgfVxuICBjdXJyZW50VGltZXJTdGFydFRpbWUgPSAwO1xuICBjdXJyZW50VGltZXJOZXN0ZWRGbHVzaER1cmF0aW9uID0gMDtcbiAgY3VycmVudFRpbWVyRGVidWdJRCA9IG51bGw7XG4gIGN1cnJlbnRUaW1lclR5cGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXVzZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lciA9IHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lclN0YXJ0VGltZSxcbiAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZTogcGVyZm9ybWFuY2VOb3coKSxcbiAgICBkZWJ1Z0lEOiBjdXJyZW50VGltZXJEZWJ1Z0lELFxuICAgIHRpbWVyVHlwZTogY3VycmVudFRpbWVyVHlwZVxuICB9O1xuICBsaWZlQ3ljbGVUaW1lclN0YWNrLnB1c2goY3VycmVudFRpbWVyKTtcbiAgY3VycmVudFRpbWVyU3RhcnRUaW1lID0gMDtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiA9IDA7XG4gIGN1cnJlbnRUaW1lckRlYnVnSUQgPSBudWxsO1xuICBjdXJyZW50VGltZXJUeXBlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzdW1lQ3VycmVudExpZmVDeWNsZVRpbWVyKCkge1xuICB2YXIgX2xpZmVDeWNsZVRpbWVyU3RhY2skID0gbGlmZUN5Y2xlVGltZXJTdGFjay5wb3AoKSxcbiAgICAgIHN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5zdGFydFRpbWUsXG4gICAgICBuZXN0ZWRGbHVzaFN0YXJ0VGltZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC5uZXN0ZWRGbHVzaFN0YXJ0VGltZSxcbiAgICAgIGRlYnVnSUQgPSBfbGlmZUN5Y2xlVGltZXJTdGFjayQuZGVidWdJRCxcbiAgICAgIHRpbWVyVHlwZSA9IF9saWZlQ3ljbGVUaW1lclN0YWNrJC50aW1lclR5cGU7XG5cbiAgdmFyIG5lc3RlZEZsdXNoRHVyYXRpb24gPSBwZXJmb3JtYW5jZU5vdygpIC0gbmVzdGVkRmx1c2hTdGFydFRpbWU7XG4gIGN1cnJlbnRUaW1lclN0YXJ0VGltZSA9IHN0YXJ0VGltZTtcbiAgY3VycmVudFRpbWVyTmVzdGVkRmx1c2hEdXJhdGlvbiArPSBuZXN0ZWRGbHVzaER1cmF0aW9uO1xuICBjdXJyZW50VGltZXJEZWJ1Z0lEID0gZGVidWdJRDtcbiAgY3VycmVudFRpbWVyVHlwZSA9IHRpbWVyVHlwZTtcbn1cblxudmFyIGxhc3RNYXJrVGltZVN0YW1wID0gMDtcbnZhciBjYW5Vc2VQZXJmb3JtYW5jZU1lYXN1cmUgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5tZWFzdXJlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBzaG91bGRNYXJrKGRlYnVnSUQpIHtcbiAgaWYgKCFpc1Byb2ZpbGluZyB8fCAhY2FuVXNlUGVyZm9ybWFuY2VNZWFzdXJlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGRlYnVnSUQpO1xuICBpZiAoZWxlbWVudCA9PSBudWxsIHx8IHR5cGVvZiBlbGVtZW50ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaXNIb3N0RWxlbWVudCA9IHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnO1xuICBpZiAoaXNIb3N0RWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbWFya0JlZ2luKGRlYnVnSUQsIG1hcmtUeXBlKSB7XG4gIGlmICghc2hvdWxkTWFyayhkZWJ1Z0lEKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBtYXJrTmFtZSA9IGRlYnVnSUQgKyAnOjonICsgbWFya1R5cGU7XG4gIGxhc3RNYXJrVGltZVN0YW1wID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgcGVyZm9ybWFuY2UubWFyayhtYXJrTmFtZSk7XG59XG5cbmZ1bmN0aW9uIG1hcmtFbmQoZGVidWdJRCwgbWFya1R5cGUpIHtcbiAgaWYgKCFzaG91bGRNYXJrKGRlYnVnSUQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG1hcmtOYW1lID0gZGVidWdJRCArICc6OicgKyBtYXJrVHlwZTtcbiAgdmFyIGRpc3BsYXlOYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShkZWJ1Z0lEKSB8fCAnVW5rbm93bic7XG5cbiAgLy8gQ2hyb21lIGhhcyBhbiBpc3N1ZSBvZiBkcm9wcGluZyBtYXJrZXJzIHJlY29yZGVkIHRvbyBmYXN0OlxuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02NDA2NTJcbiAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgd2Ugd2lsbCBub3QgcmVwb3J0IHZlcnkgc21hbGwgbWVhc3VyZW1lbnRzLlxuICAvLyBJIGRldGVybWluZWQgdGhlIG1hZ2ljIG51bWJlciBieSB0d2Vha2luZyBpdCBiYWNrIGFuZCBmb3J0aC5cbiAgLy8gMC4wNW1zIHdhcyBlbm91Z2ggdG8gcHJldmVudCB0aGUgaXNzdWUsIGJ1dCBJIHNldCBpdCB0byAwLjFtcyB0byBiZSBzYWZlLlxuICAvLyBXaGVuIHRoZSBidWcgaXMgZml4ZWQsIHdlIGNhbiBgbWVhc3VyZSgpYCB1bmNvbmRpdGlvbmFsbHkgaWYgd2Ugd2FudCB0by5cbiAgdmFyIHRpbWVTdGFtcCA9IHBlcmZvcm1hbmNlTm93KCk7XG4gIGlmICh0aW1lU3RhbXAgLSBsYXN0TWFya1RpbWVTdGFtcCA+IDAuMSkge1xuICAgIHZhciBtZWFzdXJlbWVudE5hbWUgPSBkaXNwbGF5TmFtZSArICcgWycgKyBtYXJrVHlwZSArICddJztcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKG1lYXN1cmVtZW50TmFtZSwgbWFya05hbWUpO1xuICB9XG5cbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhtYXJrTmFtZSk7XG4gIGlmIChtZWFzdXJlbWVudE5hbWUpIHtcbiAgICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmVtZW50TmFtZSk7XG4gIH1cbn1cblxudmFyIFJlYWN0RGVidWdUb29sID0ge1xuICBhZGRIb29rOiBmdW5jdGlvbiAoaG9vaykge1xuICAgIGhvb2tzLnB1c2goaG9vayk7XG4gIH0sXG4gIHJlbW92ZUhvb2s6IGZ1bmN0aW9uIChob29rKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhvb2tzW2ldID09PSBob29rKSB7XG4gICAgICAgIGhvb2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaXNQcm9maWxpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNQcm9maWxpbmc7XG4gIH0sXG4gIGJlZ2luUHJvZmlsaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaXNQcm9maWxpbmcgPSB0cnVlO1xuICAgIGZsdXNoSGlzdG9yeS5sZW5ndGggPSAwO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayk7XG4gIH0sXG4gIGVuZFByb2ZpbGluZzogZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNQcm9maWxpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpc1Byb2ZpbGluZyA9IGZhbHNlO1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgUmVhY3REZWJ1Z1Rvb2wucmVtb3ZlSG9vayhSZWFjdEhvc3RPcGVyYXRpb25IaXN0b3J5SG9vayk7XG4gIH0sXG4gIGdldEZsdXNoSGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbHVzaEhpc3Rvcnk7XG4gIH0sXG4gIG9uQmVnaW5GbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRGbHVzaE5lc3RpbmcrKztcbiAgICByZXNldE1lYXN1cmVtZW50cygpO1xuICAgIHBhdXNlQ3VycmVudExpZmVDeWNsZVRpbWVyKCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luRmx1c2gnKTtcbiAgfSxcbiAgb25FbmRGbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgY3VycmVudEZsdXNoTmVzdGluZy0tO1xuICAgIHJlc3VtZUN1cnJlbnRMaWZlQ3ljbGVUaW1lcigpO1xuICAgIGVtaXRFdmVudCgnb25FbmRGbHVzaCcpO1xuICB9LFxuICBvbkJlZ2luTGlmZUN5Y2xlVGltZXI6IGZ1bmN0aW9uIChkZWJ1Z0lELCB0aW1lclR5cGUpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvbkJlZ2luTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIGJlZ2luTGlmZUN5Y2xlVGltZXIoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgfSxcbiAgb25FbmRMaWZlQ3ljbGVUaW1lcjogZnVuY3Rpb24gKGRlYnVnSUQsIHRpbWVyVHlwZSkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbmRMaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgdGltZXJUeXBlKTtcbiAgICBlbWl0RXZlbnQoJ29uRW5kTGlmZUN5Y2xlVGltZXInLCBkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB9LFxuICBvbkJlZ2luUHJvY2Vzc2luZ0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQnKTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgZW1pdEV2ZW50KCdvbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQnKTtcbiAgfSxcbiAgb25Ib3N0T3BlcmF0aW9uOiBmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKG9wZXJhdGlvbi5pbnN0YW5jZUlEKTtcbiAgICBlbWl0RXZlbnQoJ29uSG9zdE9wZXJhdGlvbicsIG9wZXJhdGlvbik7XG4gIH0sXG4gIG9uU2V0U3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0RXZlbnQoJ29uU2V0U3RhdGUnKTtcbiAgfSxcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpIHtcbiAgICBjaGVja0RlYnVnSUQoZGVidWdJRCk7XG4gICAgY2hpbGREZWJ1Z0lEcy5mb3JFYWNoKGNoZWNrRGVidWdJRCk7XG4gICAgZW1pdEV2ZW50KCdvblNldENoaWxkcmVuJywgZGVidWdJRCwgY2hpbGREZWJ1Z0lEcyk7XG4gIH0sXG4gIG9uQmVmb3JlTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIGNoZWNrRGVidWdJRChwYXJlbnREZWJ1Z0lELCB0cnVlKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlTW91bnRDb21wb25lbnQnLCBkZWJ1Z0lELCBlbGVtZW50LCBwYXJlbnREZWJ1Z0lEKTtcbiAgICBtYXJrQmVnaW4oZGVidWdJRCwgJ21vdW50Jyk7XG4gIH0sXG4gIG9uTW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgJ21vdW50Jyk7XG4gICAgZW1pdEV2ZW50KCdvbk1vdW50Q29tcG9uZW50JywgZGVidWdJRCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVXBkYXRlQ29tcG9uZW50JywgZGVidWdJRCwgZWxlbWVudCk7XG4gICAgbWFya0JlZ2luKGRlYnVnSUQsICd1cGRhdGUnKTtcbiAgfSxcbiAgb25VcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgJ3VwZGF0ZScpO1xuICAgIGVtaXRFdmVudCgnb25VcGRhdGVDb21wb25lbnQnLCBkZWJ1Z0lEKTtcbiAgfSxcbiAgb25CZWZvcmVVbm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCkge1xuICAgIGNoZWNrRGVidWdJRChkZWJ1Z0lEKTtcbiAgICBlbWl0RXZlbnQoJ29uQmVmb3JlVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICAgIG1hcmtCZWdpbihkZWJ1Z0lELCAndW5tb3VudCcpO1xuICB9LFxuICBvblVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lEKSB7XG4gICAgY2hlY2tEZWJ1Z0lEKGRlYnVnSUQpO1xuICAgIG1hcmtFbmQoZGVidWdJRCwgJ3VubW91bnQnKTtcbiAgICBlbWl0RXZlbnQoJ29uVW5tb3VudENvbXBvbmVudCcsIGRlYnVnSUQpO1xuICB9LFxuICBvblRlc3RFdmVudDogZnVuY3Rpb24gKCkge1xuICAgIGVtaXRFdmVudCgnb25UZXN0RXZlbnQnKTtcbiAgfVxufTtcblxuLy8gVE9ETyByZW1vdmUgdGhlc2Ugd2hlbiBSTi93d3cgZ2V0cyB1cGRhdGVkXG5SZWFjdERlYnVnVG9vbC5hZGREZXZ0b29sID0gUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vaztcblJlYWN0RGVidWdUb29sLnJlbW92ZURldnRvb2wgPSBSZWFjdERlYnVnVG9vbC5yZW1vdmVIb29rO1xuXG5SZWFjdERlYnVnVG9vbC5hZGRIb29rKFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2spO1xuUmVhY3REZWJ1Z1Rvb2wuYWRkSG9vayhSZWFjdENvbXBvbmVudFRyZWVIb29rKTtcbnZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG5pZiAoL1s/Jl1yZWFjdF9wZXJmXFxiLy50ZXN0KHVybCkpIHtcbiAgUmVhY3REZWJ1Z1Rvb2wuYmVnaW5Qcm9maWxpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlYnVnVG9vbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERlYnVnVG9vbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5JbnZhbGlkU2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIXByb2Nlc3NpbmdDaGlsZENvbnRleHQsICdzZXRTdGF0ZSguLi4pOiBDYW5ub3QgY2FsbCBzZXRTdGF0ZSgpIGluc2lkZSBnZXRDaGlsZENvbnRleHQoKScpIDogdm9pZCAwO1xuICB9O1xufVxuXG52YXIgUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vayA9IHtcbiAgb25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9jZXNzaW5nQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgfSxcbiAgb25FbmRQcm9jZXNzaW5nQ2hpbGRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzc2luZ0NoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB9LFxuICBvblNldFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgd2FybkludmFsaWRTZXRTdGF0ZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW52YWxpZFNldFN0YXRlV2FybmluZ0hvb2s7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RJbnZhbGlkU2V0U3RhdGVXYXJuaW5nSG9vay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhpc3RvcnkgPSBbXTtcblxudmFyIFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rID0ge1xuICBvbkhvc3RPcGVyYXRpb246IGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICBoaXN0b3J5LnB1c2gob3BlcmF0aW9uKTtcbiAgfSxcbiAgY2xlYXJIaXN0b3J5OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLl9wcmV2ZW50Q2xlYXJpbmcpIHtcbiAgICAgIC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHRlc3RzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhpc3RvcnkgPSBbXTtcbiAgfSxcbiAgZ2V0SGlzdG9yeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoaXN0b3J5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SG9zdE9wZXJhdGlvbkhpc3RvcnlIb29rLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgcGVyZm9ybWFuY2UgPSByZXF1aXJlKCcuL3BlcmZvcm1hbmNlJyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdztcblxuLyoqXG4gKiBEZXRlY3QgaWYgd2UgY2FuIHVzZSBgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpYCBhbmQgZ3JhY2VmdWxseSBmYWxsYmFjayB0b1xuICogYERhdGUubm93KClgIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG5lZWQgdG8gc3VwcG9ydCBGaXJlZm94IDwgMTUgZm9yIG5vd1xuICogYmVjYXVzZSBvZiBGYWNlYm9vaydzIHRlc3RpbmcgaW5mcmFzdHJ1Y3R1cmUuXG4gKi9cbmlmIChwZXJmb3JtYW5jZS5ub3cpIHtcbiAgcGVyZm9ybWFuY2VOb3cgPSBmdW5jdGlvbiBwZXJmb3JtYW5jZU5vdygpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICBwZXJmb3JtYW5jZU5vdyA9IGZ1bmN0aW9uIHBlcmZvcm1hbmNlTm93KCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlTm93O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgcGVyZm9ybWFuY2U7XG5cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcGVyZm9ybWFuY2UgPSB3aW5kb3cucGVyZm9ybWFuY2UgfHwgd2luZG93Lm1zUGVyZm9ybWFuY2UgfHwgd2luZG93LndlYmtpdFBlcmZvcm1hbmNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlIHx8IHt9O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cblxudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50UHJvcGFnYXRvcnMgPSByZXF1aXJlKCcuL0V2ZW50UHJvcGFnYXRvcnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUVudGVyJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlTGVhdmUnLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9XG59O1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodG8pO1xuXG4gICAgdmFyIGxlYXZlID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0VudGVyTGVhdmVFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcblxudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFO1xudmFyIEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgaXNDdXN0b21BdHRyaWJ1dGU6IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKG5ldyBSZWdFeHAoJ14oZGF0YXxhcmlhKS1bJyArIERPTVByb3BlcnR5LkFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJykpLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogMCxcbiAgICBhY2NlcHRDaGFyc2V0OiAwLFxuICAgIGFjY2Vzc0tleTogMCxcbiAgICBhY3Rpb246IDAsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogMCxcbiAgICBhbHQ6IDAsXG4gICAgLy8gc3BlY2lmaWVzIHRhcmdldCBjb250ZXh0IGZvciBsaW5rcyB3aXRoIGBwcmVsb2FkYCB0eXBlXG4gICAgYXM6IDAsXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9Db21wbGV0ZTogMCxcbiAgICAvLyBhdXRvRm9jdXMgaXMgcG9seWZpbGxlZC9ub3JtYWxpemVkIGJ5IEF1dG9Gb2N1c1V0aWxzXG4gICAgLy8gYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2VsbFBhZGRpbmc6IDAsXG4gICAgY2VsbFNwYWNpbmc6IDAsXG4gICAgY2hhclNldDogMCxcbiAgICBjaGFsbGVuZ2U6IDAsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjaXRlOiAwLFxuICAgIGNsYXNzSUQ6IDAsXG4gICAgY2xhc3NOYW1lOiAwLFxuICAgIGNvbHM6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IDAsXG4gICAgY29udGVudDogMCxcbiAgICBjb250ZW50RWRpdGFibGU6IDAsXG4gICAgY29udGV4dE1lbnU6IDAsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvb3JkczogMCxcbiAgICBjcm9zc09yaWdpbjogMCxcbiAgICBkYXRhOiAwLCAvLyBGb3IgYDxvYmplY3QgLz5gIGFjdHMgYXMgYHNyY2AuXG4gICAgZGF0ZVRpbWU6IDAsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiAwLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IDAsXG4gICAgZW5jVHlwZTogMCxcbiAgICBmb3JtOiAwLFxuICAgIGZvcm1BY3Rpb246IDAsXG4gICAgZm9ybUVuY1R5cGU6IDAsXG4gICAgZm9ybU1ldGhvZDogMCxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybVRhcmdldDogMCxcbiAgICBmcmFtZUJvcmRlcjogMCxcbiAgICBoZWFkZXJzOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBoaWRkZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZ2g6IDAsXG4gICAgaHJlZjogMCxcbiAgICBocmVmTGFuZzogMCxcbiAgICBodG1sRm9yOiAwLFxuICAgIGh0dHBFcXVpdjogMCxcbiAgICBpY29uOiAwLFxuICAgIGlkOiAwLFxuICAgIGlucHV0TW9kZTogMCxcbiAgICBpbnRlZ3JpdHk6IDAsXG4gICAgaXM6IDAsXG4gICAga2V5UGFyYW1zOiAwLFxuICAgIGtleVR5cGU6IDAsXG4gICAga2luZDogMCxcbiAgICBsYWJlbDogMCxcbiAgICBsYW5nOiAwLFxuICAgIGxpc3Q6IDAsXG4gICAgbG9vcDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiAwLFxuICAgIG1hbmlmZXN0OiAwLFxuICAgIG1hcmdpbkhlaWdodDogMCxcbiAgICBtYXJnaW5XaWR0aDogMCxcbiAgICBtYXg6IDAsXG4gICAgbWF4TGVuZ3RoOiAwLFxuICAgIG1lZGlhOiAwLFxuICAgIG1lZGlhR3JvdXA6IDAsXG4gICAgbWV0aG9kOiAwLFxuICAgIG1pbjogMCxcbiAgICBtaW5MZW5ndGg6IDAsXG4gICAgLy8gQ2F1dGlvbjsgYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbiAgICAvLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLlxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5hbWU6IDAsXG4gICAgbm9uY2U6IDAsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogMCxcbiAgICBwYXR0ZXJuOiAwLFxuICAgIHBsYWNlaG9sZGVyOiAwLFxuICAgIHBsYXlzSW5saW5lOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBwb3N0ZXI6IDAsXG4gICAgcHJlbG9hZDogMCxcbiAgICBwcm9maWxlOiAwLFxuICAgIHJhZGlvR3JvdXA6IDAsXG4gICAgcmVhZE9ubHk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlZmVycmVyUG9saWN5OiAwLFxuICAgIHJlbDogMCxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvbGU6IDAsXG4gICAgcm93czogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgcm93U3BhbjogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgc2FuZGJveDogMCxcbiAgICBzY29wZTogMCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogMCxcbiAgICBzZWFtbGVzczogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IDAsXG4gICAgc2l6ZTogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IDAsXG4gICAgc3BhbjogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc3BlbGxDaGVjazogMCxcbiAgICBzcmM6IDAsXG4gICAgc3JjRG9jOiAwLFxuICAgIHNyY0xhbmc6IDAsXG4gICAgc3JjU2V0OiAwLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGVwOiAwLFxuICAgIHN0eWxlOiAwLFxuICAgIHN1bW1hcnk6IDAsXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgdGFyZ2V0OiAwLFxuICAgIHRpdGxlOiAwLFxuICAgIC8vIFNldHRpbmcgLnR5cGUgdGhyb3dzIG9uIG5vbi08aW5wdXQ+IHRhZ3NcbiAgICB0eXBlOiAwLFxuICAgIHVzZU1hcDogMCxcbiAgICB2YWx1ZTogMCxcbiAgICB3aWR0aDogMCxcbiAgICB3bW9kZTogMCxcbiAgICB3cmFwOiAwLFxuXG4gICAgLyoqXG4gICAgICogUkRGYSBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgYWJvdXQ6IDAsXG4gICAgZGF0YXR5cGU6IDAsXG4gICAgaW5saXN0OiAwLFxuICAgIHByZWZpeDogMCxcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogMCxcbiAgICByZXNvdXJjZTogMCxcbiAgICAndHlwZW9mJzogMCxcbiAgICB2b2NhYjogMCxcblxuICAgIC8qKlxuICAgICAqIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzXG4gICAgICovXG4gICAgLy8gYXV0b0NhcGl0YWxpemUgYW5kIGF1dG9Db3JyZWN0IGFyZSBzdXBwb3J0ZWQgaW4gTW9iaWxlIFNhZmFyaSBmb3JcbiAgICAvLyBrZXlib2FyZCBoaW50cy5cbiAgICBhdXRvQ2FwaXRhbGl6ZTogMCxcbiAgICBhdXRvQ29ycmVjdDogMCxcbiAgICAvLyBhdXRvU2F2ZSBhbGxvd3MgV2ViS2l0L0JsaW5rIHRvIHBlcnNpc3QgdmFsdWVzIG9mIGlucHV0IGZpZWxkcyBvbiBwYWdlIHJlbG9hZHNcbiAgICBhdXRvU2F2ZTogMCxcbiAgICAvLyBjb2xvciBpcyBmb3IgU2FmYXJpIG1hc2staWNvbiBsaW5rXG4gICAgY29sb3I6IDAsXG4gICAgLy8gaXRlbVByb3AsIGl0ZW1TY29wZSwgaXRlbVR5cGUgYXJlIGZvclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVByb3A6IDAsXG4gICAgaXRlbVNjb3BlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBpdGVtVHlwZTogMCxcbiAgICAvLyBpdGVtSUQgYW5kIGl0ZW1SZWYgYXJlIGZvciBNaWNyb2RhdGEgc3VwcG9ydCBhcyB3ZWxsIGJ1dFxuICAgIC8vIG9ubHkgc3BlY2lmaWVkIGluIHRoZSBXSEFUV0cgc3BlYyBkb2N1bWVudC4gU2VlXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvbWljcm9kYXRhLmh0bWwjbWljcm9kYXRhLWRvbS1hcGlcbiAgICBpdGVtSUQ6IDAsXG4gICAgaXRlbVJlZjogMCxcbiAgICAvLyByZXN1bHRzIHNob3cgbG9va2luZyBnbGFzcyBpY29uIGFuZCByZWNlbnQgc2VhcmNoZXMgb24gaW5wdXRcbiAgICAvLyBzZWFyY2ggZmllbGRzIGluIFdlYktpdC9CbGlua1xuICAgIHJlc3VsdHM6IDAsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIGFuIGlmcmFtZVxuICAgIC8vIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSBvbiBJRTwxMFxuICAgIHNlY3VyaXR5OiAwLFxuICAgIC8vIElFLW9ubHkgYXR0cmlidXRlIHRoYXQgY29udHJvbHMgZm9jdXMgYmVoYXZpb3JcbiAgICB1bnNlbGVjdGFibGU6IDBcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhY2NlcHRDaGFyc2V0OiAnYWNjZXB0LWNoYXJzZXQnLFxuICAgIGNsYXNzTmFtZTogJ2NsYXNzJyxcbiAgICBodG1sRm9yOiAnZm9yJyxcbiAgICBodHRwRXF1aXY6ICdodHRwLWVxdWl2J1xuICB9LFxuICBET01Qcm9wZXJ0eU5hbWVzOiB7fSxcbiAgRE9NTXV0YXRpb25NZXRob2RzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXIgaW5wdXRzIGdldCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gc29tZSBlZGdlIGNhc2VzIGluXG4gICAgICAvLyBDaHJvbWUuIExldCBldmVyeXRoaW5nIGVsc2UgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgYXMgbm9ybWFsLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzI2lzc3VlY29tbWVudC0yMzYwNzQzMjZcbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2YWx1ZScpID09PSBmYWxzZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWxpZGl0eSAmJiAhbm9kZS52YWxpZGl0eS5iYWRJbnB1dCAmJiBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgICAgICAvLyBEb24ndCBhc3NpZ24gYW4gYXR0cmlidXRlIGlmIHZhbGlkYXRpb24gcmVwb3J0cyBiYWRcbiAgICAgICAgLy8gaW5wdXQuIENocm9tZSB3aWxsIGNsZWFyIHRoZSB2YWx1ZS4gQWRkaXRpb25hbGx5LCBkb24ndFxuICAgICAgICAvLyBvcGVyYXRlIG9uIGlucHV0cyB0aGF0IGhhdmUgZm9jdXMsIG90aGVyd2lzZSBDaHJvbWUgbWlnaHRcbiAgICAgICAgLy8gc3RyaXAgb2ZmIHRyYWlsaW5nIGRlY2ltYWwgcGxhY2VzIGFuZCBjYXVzZSB0aGUgdXNlcidzXG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvbiB0byBqdW1wIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGlucHV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBSZWFjdERPTUlucHV0LCB3ZSBoYXZlIGFuIG9uQmx1ciBldmVudCB0aGF0IHdpbGwgdHJpZ2dlclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFnYWluIHdoZW4gZm9jdXMgaXMgbG9zdC5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhUTUxET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgcmVjb25jaWxlciB0aGF0IHJlcXVpcmVzIGtub3dsZWRnZSBvZlxuICogdGhlIGJyb3dzZXIgY29udGV4dC4gVE9ETzogVGhlc2UgY2FsbGVycyBzaG91bGQgYmUgcmVmYWN0b3JlZCB0byBhdm9pZCB0aGVcbiAqIG5lZWQgZm9yIHRoaXMgaW5qZWN0aW9uLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XG4gIHByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyxcblxuICByZXBsYWNlTm9kZVdpdGhNYXJrdXA6IERPTUNoaWxkcmVuT3BlcmF0aW9ucy5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgPSByZXF1aXJlKCdmYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgRGFuZ2VyID0ge1xuICAvKipcbiAgICogUmVwbGFjZXMgYSBub2RlIHdpdGggYSBzdHJpbmcgb2YgbWFya3VwIGF0IGl0cyBjdXJyZW50IHBvc2l0aW9uIHdpdGhpbiBpdHNcbiAgICogcGFyZW50LiBUaGUgbWFya3VwIG11c3QgcmVuZGVyIGludG8gYSBzaW5nbGUgcm9vdCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG9sZENoaWxkIENoaWxkIG5vZGUgdG8gcmVwbGFjZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgdG8gcmVuZGVyIGluIHBsYWNlIG9mIHRoZSBjaGlsZCBub2RlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkQ2hpbGQsIG1hcmt1cCkge1xuICAgICFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlbmRlciBtYXJrdXAgaW4gYSB3b3JrZXIgdGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSBiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLicpIDogX3Byb2RJbnZhcmlhbnQoJzU2JykgOiB2b2lkIDA7XG4gICAgIW1hcmt1cCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBNaXNzaW5nIG1hcmt1cC4nKSA6IF9wcm9kSW52YXJpYW50KCc1NycpIDogdm9pZCAwO1xuICAgICEob2xkQ2hpbGQubm9kZU5hbWUgIT09ICdIVE1MJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogQ2Fubm90IHJlcGxhY2UgbWFya3VwIG9mIHRoZSA8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlIGFuZC9vciBzbG93LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgdG8gdGhlIHJvb3QgeW91IG11c3QgdXNlIHNlcnZlciByZW5kZXJpbmcuIFNlZSBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0cmluZygpLicpIDogX3Byb2RJbnZhcmlhbnQoJzU4JykgOiB2b2lkIDA7XG5cbiAgICBpZiAodHlwZW9mIG1hcmt1cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBuZXdDaGlsZCA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGVtcHR5RnVuY3Rpb24pWzBdO1xuICAgICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgRE9NTGF6eVRyZWUucmVwbGFjZUNoaWxkV2l0aFRyZWUob2xkQ2hpbGQsIG1hcmt1cCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9EYW5nZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sKi9cblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCcuL2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJy4vZ2V0TWFya3VwV3JhcCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XG5cbiAgdmFyIHdyYXAgPSBub2RlTmFtZSAmJiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKTtcbiAgaWYgKHdyYXApIHtcbiAgICBub2RlLmlubmVySFRNTCA9IHdyYXBbMV0gKyBtYXJrdXAgKyB3cmFwWzJdO1xuXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XG4gICAgd2hpbGUgKHdyYXBEZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbWFya3VwO1xuICB9XG5cbiAgdmFyIHNjcmlwdHMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgIWhhbmRsZVNjcmlwdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAoLi4uKTogVW5leHBlY3RlZCA8c2NyaXB0PiBlbGVtZW50IHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBjcmVhdGVBcnJheUZyb21NaXhlZChzY3JpcHRzKS5mb3JFYWNoKGhhbmRsZVNjcmlwdCk7XG4gIH1cblxuICB2YXIgbm9kZXMgPSBBcnJheS5mcm9tKG5vZGUuY2hpbGROb2Rlcyk7XG4gIHdoaWxlIChub2RlLmxhc3RDaGlsZCkge1xuICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5sYXN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2Rlcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVOb2Rlc0Zyb21NYXJrdXA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gYXJyYXlzLlxuICpcbiAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGNhbGxlciBrbm93cyB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgdHlwZS4gRm9yIGxlc3NcbiAqIHdlbGwgZGVmaW5lZCBpbnB1dHMgdXNlIGNyZWF0ZUFycmF5RnJvbU1peGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufGZpbGVsaXN0fSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICAvLyBTb21lIGJyb3dzZXJzIGJ1aWx0aW4gb2JqZWN0cyBjYW4gcmVwb3J0IHR5cGVvZiAnZnVuY3Rpb24nIChlLmcuIE5vZGVMaXN0XG4gIC8vIGluIG9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkpLlxuICAhKCFBcnJheS5pc0FycmF5KG9iaikgJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBBcnJheS1saWtlIG9iamVjdCBleHBlY3RlZCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAhKHR5cGVvZiBsZW5ndGggPT09ICdudW1iZXInKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3QgbmVlZHMgYSBsZW5ndGggcHJvcGVydHknKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgIShsZW5ndGggPT09IDAgfHwgbGVuZ3RoIC0gMSBpbiBvYmopID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBzaG91bGQgaGF2ZSBrZXlzIGZvciBpbmRpY2VzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICEodHlwZW9mIG9iai5jYWxsZWUgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RvQXJyYXk6IE9iamVjdCBjYW5cXCd0IGJlIGBhcmd1bWVudHNgLiBVc2UgcmVzdCBwYXJhbXMgJyArICcoZnVuY3Rpb24oLi4uYXJncykge30pIG9yIEFycmF5LmZyb20oKSBpbnN0ZWFkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAvLyBPbGQgSUUgZG9lc24ndCBnaXZlIGNvbGxlY3Rpb25zIGFjY2VzcyB0byBoYXNPd25Qcm9wZXJ0eS4gQXNzdW1lIGlucHV0c1xuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcbiAgLy8gZmFsbGJhY2suXG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIGtleSBieSBrZXkuIFRoaXMgYXNzdW1lcyBhbGwga2V5cyBoYXZlIGEgdmFsdWUsXG4gIC8vIHNvIHdpbGwgbm90IHByZXNlcnZlIHNwYXJzZWx5IHBvcHVsYXRlZCBpbnB1dHMuXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKSB7XG4gICAgcmV0W2lpXSA9IG9ialtpaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGEgaGV1cmlzdGljIHRlc3QgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBcImFycmF5LWxpa2VcIi5cbiAqXG4gKiAgIEEgbW9uayBhc2tlZCBKb3NodSwgYSBaZW4gbWFzdGVyLCBcIkhhcyBhIGRvZyBCdWRkaGEgbmF0dXJlP1wiXG4gKiAgIEpvc2h1IHJlcGxpZWQ6IFwiTXUuXCJcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgaXRzIGFyZ3VtZW50IGhhcyBcImFycmF5IG5hdHVyZVwiOiBpdCByZXR1cm5zXG4gKiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhbiBhY3R1YWwgYXJyYXksIGFuIGBhcmd1bWVudHMnIG9iamVjdCwgb3IgYW5cbiAqIEhUTUxDb2xsZWN0aW9uIChlLmcuIG5vZGUuY2hpbGROb2RlcyBvciBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCkpLlxuICpcbiAqIEl0IHdpbGwgcmV0dXJuIGZhbHNlIGZvciBvdGhlciBhcnJheS1saWtlIG9iamVjdHMgbGlrZSBGaWxlbGlzdC5cbiAqXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaGFzQXJyYXlOYXR1cmUob2JqKSB7XG4gIHJldHVybiAoXG4gICAgLy8gbm90IG51bGwvZmFsc2VcbiAgICAhIW9iaiAmJiAoXG4gICAgLy8gYXJyYXlzIGFyZSBvYmplY3RzLCBOb2RlTGlzdHMgYXJlIGZ1bmN0aW9ucyBpbiBTYWZhcmlcbiAgICB0eXBlb2Ygb2JqID09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAvLyBxdWFja3MgbGlrZSBhbiBhcnJheVxuICAgICdsZW5ndGgnIGluIG9iaiAmJlxuICAgIC8vIG5vdCB3aW5kb3dcbiAgICAhKCdzZXRJbnRlcnZhbCcgaW4gb2JqKSAmJlxuICAgIC8vIG5vIERPTSBub2RlIHNob3VsZCBiZSBjb25zaWRlcmVkIGFuIGFycmF5LWxpa2VcbiAgICAvLyBhICdzZWxlY3QnIGVsZW1lbnQgaGFzICdsZW5ndGgnIGFuZCAnaXRlbScgcHJvcGVydGllcyBvbiBJRThcbiAgICB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9ICdudW1iZXInICYmIChcbiAgICAvLyBhIHJlYWwgYXJyYXlcbiAgICBBcnJheS5pc0FycmF5KG9iaikgfHxcbiAgICAvLyBhcmd1bWVudHNcbiAgICAnY2FsbGVlJyBpbiBvYmogfHxcbiAgICAvLyBIVE1MQ29sbGVjdGlvbi9Ob2RlTGlzdFxuICAgICdpdGVtJyBpbiBvYmopXG4gICk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgdGhlIGFyZ3VtZW50IGlzIGFuIGFycmF5IGJ5IHdyYXBwaW5nIGl0IGluIGFuIGFycmF5IGlmIGl0IGlzIG5vdC5cbiAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBhbHJlYWR5IGFuIGFycmF5LlxuICpcbiAqIFRoaXMgaXMgbW9zdGx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5OlxuICpcbiAqICAgdmFyIGNyZWF0ZUFycmF5RnJvbU1peGVkID0gcmVxdWlyZSgnY3JlYXRlQXJyYXlGcm9tTWl4ZWQnKTtcbiAqXG4gKiAgIGZ1bmN0aW9uIHRha2VzT25lT3JNb3JlVGhpbmdzKHRoaW5ncykge1xuICogICAgIHRoaW5ncyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkKHRoaW5ncyk7XG4gKiAgICAgLi4uXG4gKiAgIH1cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJlYXQgYHRoaW5ncycgYXMgYW4gYXJyYXksIGJ1dCBhY2NlcHQgc2NhbGFycyBpbiB0aGUgQVBJLlxuICpcbiAqIElmIHlvdSBuZWVkIHRvIGNvbnZlcnQgYW4gYXJyYXktbGlrZSBvYmplY3QsIGxpa2UgYGFyZ3VtZW50c2AsIGludG8gYW4gYXJyYXlcbiAqIHVzZSB0b0FycmF5IGluc3RlYWQuXG4gKlxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiBjcmVhdGVBcnJheUZyb21NaXhlZChvYmopIHtcbiAgaWYgKCFoYXNBcnJheU5hdHVyZShvYmopKSB7XG4gICAgcmV0dXJuIFtvYmpdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmouc2xpY2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdG9BcnJheShvYmopO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQXJyYXlGcm9tTWl4ZWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NyZWF0ZUFycmF5RnJvbU1peGVkLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sICovXG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gZGV0ZWN0IHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogU29tZSBicm93c2VycyBjYW5ub3QgdXNlIGBpbm5lckhUTUxgIHRvIHJlbmRlciBjZXJ0YWluIGVsZW1lbnRzIHN0YW5kYWxvbmUsXG4gKiBzbyB3ZSB3cmFwIHRoZW0sIHJlbmRlciB0aGUgd3JhcHBlZCBub2RlcywgdGhlbiBleHRyYWN0IHRoZSBkZXNpcmVkIG5vZGUuXG4gKlxuICogSW4gSUU4LCBjZXJ0YWluIGVsZW1lbnRzIGNhbm5vdCByZW5kZXIgYWxvbmUsIHNvIHdyYXAgYWxsIGVsZW1lbnRzICgnKicpLlxuICovXG5cbnZhciBzaG91bGRXcmFwID0ge307XG5cbnZhciBzZWxlY3RXcmFwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwidHJ1ZVwiPicsICc8L3NlbGVjdD4nXTtcbnZhciB0YWJsZVdyYXAgPSBbMSwgJzx0YWJsZT4nLCAnPC90YWJsZT4nXTtcbnZhciB0cldyYXAgPSBbMywgJzx0YWJsZT48dGJvZHk+PHRyPicsICc8L3RyPjwvdGJvZHk+PC90YWJsZT4nXTtcblxudmFyIHN2Z1dyYXAgPSBbMSwgJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPicsICc8L3N2Zz4nXTtcblxudmFyIG1hcmt1cFdyYXAgPSB7XG4gICcqJzogWzEsICc/PGRpdj4nLCAnPC9kaXY+J10sXG5cbiAgJ2FyZWEnOiBbMSwgJzxtYXA+JywgJzwvbWFwPiddLFxuICAnY29sJzogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gICdsZWdlbmQnOiBbMSwgJzxmaWVsZHNldD4nLCAnPC9maWVsZHNldD4nXSxcbiAgJ3BhcmFtJzogWzEsICc8b2JqZWN0PicsICc8L29iamVjdD4nXSxcbiAgJ3RyJzogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG5cbiAgJ29wdGdyb3VwJzogc2VsZWN0V3JhcCxcbiAgJ29wdGlvbic6IHNlbGVjdFdyYXAsXG5cbiAgJ2NhcHRpb24nOiB0YWJsZVdyYXAsXG4gICdjb2xncm91cCc6IHRhYmxlV3JhcCxcbiAgJ3Rib2R5JzogdGFibGVXcmFwLFxuICAndGZvb3QnOiB0YWJsZVdyYXAsXG4gICd0aGVhZCc6IHRhYmxlV3JhcCxcblxuICAndGQnOiB0cldyYXAsXG4gICd0aCc6IHRyV3JhcFxufTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgU1ZHIGVsZW1lbnRzIHNpbmNlIHdlIGtub3cgdGhleSdsbCBhbHdheXMgbmVlZCB0byBiZSB3cmFwcGVkXG4vLyBjb25zaXN0ZW50bHkuIElmIHRoZXkgYXJlIGNyZWF0ZWQgaW5zaWRlIGEgPGRpdj4gdGhleSB3aWxsIGJlIGluaXRpYWxpemVkIGluXG4vLyB0aGUgd3JvbmcgbmFtZXNwYWNlIChhbmQgd2lsbCBub3QgZGlzcGxheSkuXG52YXIgc3ZnRWxlbWVudHMgPSBbJ2NpcmNsZScsICdjbGlwUGF0aCcsICdkZWZzJywgJ2VsbGlwc2UnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3RleHQnLCAndHNwYW4nXTtcbnN2Z0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gIG1hcmt1cFdyYXBbbm9kZU5hbWVdID0gc3ZnV3JhcDtcbiAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSB0cnVlO1xufSk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGBub2RlTmFtZWAuXG4gKlxuICogTk9URTogVGhpcyBsYXppbHkgZGV0ZWN0cyB3aGljaCB3cmFwcyBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgY3VycmVudCBicm93c2VyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBMb3dlcmNhc2UgYG5vZGVOYW1lYC5cbiAqIEByZXR1cm4gez9hcnJheX0gTWFya3VwIHdyYXAgY29uZmlndXJhdGlvbiwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkge1xuICAhISFkdW1teU5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWFya3VwIHdyYXBwaW5nIG5vZGUgbm90IGluaXRpYWxpemVkJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBpZiAoIW1hcmt1cFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgbm9kZU5hbWUgPSAnKic7XG4gIH1cbiAgaWYgKCFzaG91bGRXcmFwLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyonKSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzxsaW5rIC8+JztcbiAgICB9IGVsc2Uge1xuICAgICAgZHVtbXlOb2RlLmlubmVySFRNTCA9ICc8JyArIG5vZGVOYW1lICsgJz48LycgKyBub2RlTmFtZSArICc+JztcbiAgICB9XG4gICAgc2hvdWxkV3JhcFtub2RlTmFtZV0gPSAhZHVtbXlOb2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIHNob3VsZFdyYXBbbm9kZU5hbWVdID8gbWFya3VwV3JhcFtub2RlTmFtZV0gOiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE1hcmt1cFdyYXA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldE1hcmt1cFdyYXAuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgdXNlZCB0byBwcm9jZXNzIHVwZGF0ZXMgdG8gRE9NIG5vZGVzLlxuICovXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5PG9iamVjdD59IHVwZGF0ZXMgTGlzdCBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzOiBmdW5jdGlvbiAocGFyZW50SW5zdCwgdXBkYXRlcykge1xuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UocGFyZW50SW5zdCk7XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnByb2Nlc3NVcGRhdGVzKG5vZGUsIHVwZGF0ZXMpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSURPcGVyYXRpb25zO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NSURPcGVyYXRpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbi8qIGdsb2JhbCBoYXNPd25Qcm9wZXJ0eTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBET01OYW1lc3BhY2VzID0gcmVxdWlyZSgnLi9ET01OYW1lc3BhY2VzJyk7XG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudEZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudEZsYWdzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdERPTUlucHV0ID0gcmVxdWlyZSgnLi9SZWFjdERPTUlucHV0Jyk7XG52YXIgUmVhY3RET01PcHRpb24gPSByZXF1aXJlKCcuL1JlYWN0RE9NT3B0aW9uJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHJlcXVpcmUoJy4vUmVhY3RET01UZXh0YXJlYScpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHJlcXVpcmUoJy4vUmVhY3RNdWx0aUNoaWxkJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbicpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIgPSByZXF1aXJlKCcuL2VzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlcicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGlzRXZlbnRTdXBwb3J0ZWQgPSByZXF1aXJlKCcuL2lzRXZlbnRTdXBwb3J0ZWQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBpbnB1dFZhbHVlVHJhY2tpbmcgPSByZXF1aXJlKCcuL2lucHV0VmFsdWVUcmFja2luZycpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIEZsYWdzID0gUmVhY3RET01Db21wb25lbnRGbGFncztcbnZhciBkZWxldGVMaXN0ZW5lciA9IEV2ZW50UGx1Z2luSHViLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGdldE5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZTtcbnZhciBsaXN0ZW5UbyA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5saXN0ZW5UbztcbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM7XG5cbi8vIEZvciBxdWlja2x5IG1hdGNoaW5nIGNoaWxkcmVuIHR5cGUsIHRvIHRlc3QgaWYgY2FuIGJlIHRyZWF0ZWQgYXMgY29udGVudC5cbnZhciBDT05URU5UX1RZUEVTID0geyBzdHJpbmc6IHRydWUsIG51bWJlcjogdHJ1ZSB9O1xuXG52YXIgU1RZTEUgPSAnc3R5bGUnO1xudmFyIEhUTUwgPSAnX19odG1sJztcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAgY2hpbGRyZW46IG51bGwsXG4gIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MOiBudWxsLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IG51bGxcbn07XG5cbi8vIE5vZGUgdHlwZSBmb3IgZG9jdW1lbnQgZnJhZ21lbnRzIChOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpLlxudmFyIERPQ19GUkFHTUVOVF9UWVBFID0gMTE7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgdmFyIG93bmVyID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyIHx8IG51bGw7XG4gICAgaWYgKG93bmVyKSB7XG4gICAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnIFRoaXMgRE9NIG5vZGUgd2FzIHJlbmRlcmVkIGJ5IGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZSB1bmRlZmluZWQgYW5kIHRoYXRcbiAgLy8gaW5mIGFuZCBuYW4gZG9uJ3QgYmVjb21lIG51bGxcbiAgcmV0dXJuIFN0cmluZyhvYmopO1xufVxuXG52YXIgc3R5bGVNdXRhdGlvbldhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHN0eWxlMSwgc3R5bGUyLCBjb21wb25lbnQpIHtcbiAgaWYgKHN0eWxlMSA9PSBudWxsIHx8IHN0eWxlMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzaGFsbG93RXF1YWwoc3R5bGUxLCBzdHlsZTIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuX3RhZztcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gIHZhciBvd25lck5hbWU7XG4gIGlmIChvd25lcikge1xuICAgIG93bmVyTmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgfVxuXG4gIHZhciBoYXNoID0gb3duZXJOYW1lICsgJ3wnICsgY29tcG9uZW50TmFtZTtcblxuICBpZiAoc3R5bGVNdXRhdGlvbldhcm5pbmcuaGFzT3duUHJvcGVydHkoaGFzaCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzdHlsZU11dGF0aW9uV2FybmluZ1toYXNoXSA9IHRydWU7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgJXNgIHdhcyBwYXNzZWQgYSBzdHlsZSBvYmplY3QgdGhhdCBoYXMgcHJldmlvdXNseSBiZWVuIG11dGF0ZWQuICcgKyAnTXV0YXRpbmcgYHN0eWxlYCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciBjbG9uaW5nIGl0IGJlZm9yZWhhbmQuIENoZWNrICcgKyAndGhlIGByZW5kZXJgICVzLiBQcmV2aW91cyBzdHlsZTogJXMuIE11dGF0ZWQgc3R5bGU6ICVzLicsIGNvbXBvbmVudE5hbWUsIG93bmVyID8gJ29mIGAnICsgb3duZXJOYW1lICsgJ2AnIDogJ3VzaW5nIDwnICsgY29tcG9uZW50TmFtZSArICc+JywgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUxKSwgZnJpZW5kbHlTdHJpbmdpZnkoc3R5bGUyKSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBwcm9wc1xuICovXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKGNvbXBvbmVudCwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgY29tcG9uZW50Ll90YWcsIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyID8gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAnICsgY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nIDogJycpIDogX3Byb2RJbnZhcmlhbnQoJzEzNycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiBfcHJvZEludmFyaWFudCgnNjAnKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogX3Byb2RJbnZhcmlhbnQoJzYxJykgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpIDogdm9pZCAwO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLm9uRm9jdXNJbiA9PSBudWxsICYmIHByb3BzLm9uRm9jdXNPdXQgPT0gbnVsbCwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJykgOiB2b2lkIDA7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiBfcHJvZEludmFyaWFudCgnNjInLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oY29tcG9uZW50KSkgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVQdXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHRyYW5zYWN0aW9uIGluc3RhbmNlb2YgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIElFOCBoYXMgbm8gQVBJIGZvciBldmVudCBjYXB0dXJpbmcgYW5kIHRoZSBgb25TY3JvbGxgIGV2ZW50IGRvZXNuJ3RcbiAgICAvLyBidWJibGUuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocmVnaXN0cmF0aW9uTmFtZSAhPT0gJ29uU2Nyb2xsJyB8fCBpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSwgXCJUaGlzIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBgb25TY3JvbGxgIGV2ZW50XCIpIDogdm9pZCAwO1xuICB9XG4gIHZhciBjb250YWluZXJJbmZvID0gaW5zdC5faG9zdENvbnRhaW5lckluZm87XG4gIHZhciBpc0RvY3VtZW50RnJhZ21lbnQgPSBjb250YWluZXJJbmZvLl9ub2RlICYmIGNvbnRhaW5lckluZm8uX25vZGUubm9kZVR5cGUgPT09IERPQ19GUkFHTUVOVF9UWVBFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudEZyYWdtZW50ID8gY29udGFpbmVySW5mby5fbm9kZSA6IGNvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUocHV0TGlzdGVuZXIsIHtcbiAgICBpbnN0OiBpbnN0LFxuICAgIHJlZ2lzdHJhdGlvbk5hbWU6IHJlZ2lzdHJhdGlvbk5hbWUsXG4gICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwdXRMaXN0ZW5lcigpIHtcbiAgdmFyIGxpc3RlbmVyVG9QdXQgPSB0aGlzO1xuICBFdmVudFBsdWdpbkh1Yi5wdXRMaXN0ZW5lcihsaXN0ZW5lclRvUHV0Lmluc3QsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbmZ1bmN0aW9uIGlucHV0UG9zdE1vdW50KCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIFJlYWN0RE9NSW5wdXQucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxuZnVuY3Rpb24gdGV4dGFyZWFQb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01UZXh0YXJlYS5wb3N0TW91bnRXcmFwcGVyKGluc3QpO1xufVxuXG5mdW5jdGlvbiBvcHRpb25Qb3N0TW91bnQoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgUmVhY3RET01PcHRpb24ucG9zdE1vdW50V3JhcHBlcihpbnN0KTtcbn1cblxudmFyIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2ID0gZW1wdHlGdW5jdGlvbjtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICB2YXIgaGFzRXhpc3RpbmdDb250ZW50ID0gdGhpcy5fY29udGVudERlYnVnSUQgIT0gbnVsbDtcbiAgICB2YXIgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgLy8gVGhpcyBJRCByZXByZXNlbnRzIHRoZSBpbmxpbmVkIGNoaWxkIHRoYXQgaGFzIG5vIGJhY2tpbmcgaW5zdGFuY2U6XG4gICAgdmFyIGNvbnRlbnREZWJ1Z0lEID0gLWRlYnVnSUQ7XG5cbiAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XG4gICAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblVubW91bnRDb21wb25lbnQodGhpcy5fY29udGVudERlYnVnSUQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCBTdHJpbmcoY29udGVudCksIHRoaXMsIHRoaXMuX2FuY2VzdG9ySW5mbyk7XG4gICAgdGhpcy5fY29udGVudERlYnVnSUQgPSBjb250ZW50RGVidWdJRDtcbiAgICBpZiAoaGFzRXhpc3RpbmdDb250ZW50KSB7XG4gICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWZvcmVVcGRhdGVDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uVXBkYXRlQ29tcG9uZW50KGNvbnRlbnREZWJ1Z0lEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVmb3JlTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQsIGNvbnRlbnQsIGRlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uTW91bnRDb21wb25lbnQoY29udGVudERlYnVnSUQpO1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4oZGVidWdJRCwgW2NvbnRlbnREZWJ1Z0lEXSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhY2tJbnB1dFZhbHVlKCkge1xuICBpbnB1dFZhbHVlVHJhY2tpbmcudHJhY2sodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnRzTG9jYWwoKSB7XG4gIHZhciBpbnN0ID0gdGhpcztcbiAgLy8gSWYgYSBjb21wb25lbnQgcmVuZGVycyB0byBudWxsIG9yIGlmIGFub3RoZXIgY29tcG9uZW50IGZhdGFscyBhbmQgY2F1c2VzXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgdHJlZSB0byBiZSBjb3JydXB0ZWQsIGBub2RlYCBoZXJlIGNhbiBiZSBudWxsLlxuICAhaW5zdC5fcm9vdE5vZGVJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNdXN0IGJlIG1vdW50ZWQgdG8gdHJhcCBldmVudHMnKSA6IF9wcm9kSW52YXJpYW50KCc2MycpIDogdm9pZCAwO1xuICB2YXIgbm9kZSA9IGdldE5vZGUoaW5zdCk7XG4gICFub2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3RyYXBCdWJibGVkRXZlbnQoLi4uKTogUmVxdWlyZXMgbm9kZSB0byBiZSByZW5kZXJlZC4nKSA6IF9wcm9kSW52YXJpYW50KCc2NCcpIDogdm9pZCAwO1xuXG4gIHN3aXRjaCAoaW5zdC5fdGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLmxpc3RlbmVycyA9IFtSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbXTtcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMucHVzaChSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5saXN0ZW5lcnMgPSBbUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG4gIC8vIE5PVEU6IG1lbnVpdGVtJ3MgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgdGhhdCBjYXVzZXMgcHJvYmxlbXMuXG59O1xuXG52YXIgbmV3bGluZUVhdGluZ1RhZ3MgPSB7XG4gIGxpc3Rpbmc6IHRydWUsXG4gIHByZTogdHJ1ZSxcbiAgdGV4dGFyZWE6IHRydWVcbn07XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3MgY2Fubm90IGhhdmUgY2hpbGRyZW4uIFRoaXMgaGFzIHRoZSBzYW1lIHB1cnBvc2UgYXNcbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbGlkYXRlZFRhZ0NhY2hlLCB0YWcpKSB7XG4gICAgIVZBTElEX1RBR19SRUdFWC50ZXN0KHRhZykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0YWc6ICVzJywgdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NScsIHRhZykgOiB2b2lkIDA7XG4gICAgdmFsaWRhdGVkVGFnQ2FjaGVbdGFnXSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgcmV0dXJuIHRhZ05hbWUuaW5kZXhPZignLScpID49IDAgfHwgcHJvcHMuaXMgIT0gbnVsbDtcbn1cblxudmFyIGdsb2JhbElkQ291bnRlciA9IDE7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZWFjdCBjbGFzcyB0aGF0IGlzIGlkZW1wb3RlbnQgYW5kIGNhcGFibGUgb2YgY29udGFpbmluZyBvdGhlclxuICogUmVhY3QgY29tcG9uZW50cy4gSXQgYWNjZXB0cyBldmVudCBsaXN0ZW5lcnMgYW5kIERPTSBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiB2YWxpZCBhY2NvcmRpbmcgdG8gYERPTVByb3BlcnR5YC5cbiAqXG4gKiAgLSBFdmVudCBsaXN0ZW5lcnM6IGBvbkNsaWNrYCwgYG9uTW91c2VEb3duYCwgZXRjLlxuICogIC0gRE9NIHByb3BlcnRpZXM6IGBjbGFzc05hbWVgLCBgbmFtZWAsIGB0aXRsZWAsIGV0Yy5cbiAqXG4gKiBUaGUgYHN0eWxlYCBwcm9wZXJ0eSBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZnJvbSB0aGUgRE9NIEFQSS4gSXQgYWNjZXB0cyBhblxuICogb2JqZWN0IG1hcHBpbmcgb2Ygc3R5bGUgcHJvcGVydGllcyB0byB2YWx1ZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yIFJlYWN0RE9NQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdE11bHRpQ2hpbGRcbiAqL1xuZnVuY3Rpb24gUmVhY3RET01Db21wb25lbnQoZWxlbWVudCkge1xuICB2YXIgdGFnID0gZWxlbWVudC50eXBlO1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3RhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgdGhpcy5faG9zdE5vZGUgPSBudWxsO1xuICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgdGhpcy5fcm9vdE5vZGVJRCA9IDA7XG4gIHRoaXMuX2RvbUlEID0gMDtcbiAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9mbGFncyA9IDA7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdGhpcy5fYW5jZXN0b3JJbmZvID0gbnVsbDtcbiAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICB9XG59XG5cblJlYWN0RE9NQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ1JlYWN0RE9NQ29tcG9uZW50JztcblxuUmVhY3RET01Db21wb25lbnQuTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P1JlYWN0RE9NQ29tcG9uZW50fSB0aGUgcGFyZW50IGNvbXBvbmVudCBpbnN0YW5jZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IGluZm8gYWJvdXQgdGhlIGhvc3QgY29udGFpbmVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCBjb250ZXh0KSB7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IGdsb2JhbElkQ291bnRlcisrO1xuICAgIHRoaXMuX2RvbUlEID0gaG9zdENvbnRhaW5lckluZm8uX2lkQ291bnRlcisrO1xuICAgIHRoaXMuX2hvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gaG9zdENvbnRhaW5lckluZm87XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnbGluayc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgY2FzZSAnc291cmNlJzpcbiAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgdGhpcy5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgICAgIGxpc3RlbmVyczogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZSh0cmFja0lucHV0VmFsdWUsIHRoaXMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYXBCdWJibGVkRXZlbnRzTG9jYWwsIHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIFJlYWN0RE9NT3B0aW9uLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01PcHRpb24uZ2V0SG9zdFByb3BzKHRoaXMsIHByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBSZWFjdERPTVNlbGVjdC5tb3VudFdyYXBwZXIodGhpcywgcHJvcHMsIGhvc3RQYXJlbnQpO1xuICAgICAgICBwcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldEhvc3RQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgaG9zdFBhcmVudCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXRIb3N0UHJvcHModGhpcywgcHJvcHMpO1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHRyYWNrSW5wdXRWYWx1ZSwgdGhpcyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGFzc2VydFZhbGlkUHJvcHModGhpcywgcHJvcHMpO1xuXG4gICAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICAgIC8vIHRhZ3MgZ2V0IG5vIG5hbWVzcGFjZS5cbiAgICB2YXIgbmFtZXNwYWNlVVJJO1xuICAgIHZhciBwYXJlbnRUYWc7XG4gICAgaWYgKGhvc3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdFBhcmVudC5fbmFtZXNwYWNlVVJJO1xuICAgICAgcGFyZW50VGFnID0gaG9zdFBhcmVudC5fdGFnO1xuICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RhZykge1xuICAgICAgbmFtZXNwYWNlVVJJID0gaG9zdENvbnRhaW5lckluZm8uX25hbWVzcGFjZVVSSTtcbiAgICAgIHBhcmVudFRhZyA9IGhvc3RDb250YWluZXJJbmZvLl90YWc7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT0gbnVsbCB8fCBuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuc3ZnICYmIHBhcmVudFRhZyA9PT0gJ2ZvcmVpZ25vYmplY3QnKSB7XG4gICAgICBuYW1lc3BhY2VVUkkgPSBET01OYW1lc3BhY2VzLmh0bWw7XG4gICAgfVxuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IERPTU5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgbmFtZXNwYWNlVVJJID0gRE9NTmFtZXNwYWNlcy5zdmc7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RhZyA9PT0gJ21hdGgnKSB7XG4gICAgICAgIG5hbWVzcGFjZVVSSSA9IERPTU5hbWVzcGFjZXMubWF0aG1sO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9uYW1lc3BhY2VVUkkgPSBuYW1lc3BhY2VVUkk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHBhcmVudEluZm87XG4gICAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICAgIHBhcmVudEluZm8gPSBob3N0UGFyZW50Ll9hbmNlc3RvckluZm87XG4gICAgICB9IGVsc2UgaWYgKGhvc3RDb250YWluZXJJbmZvLl90YWcpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RDb250YWluZXJJbmZvLl9hbmNlc3RvckluZm87XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50SW5mbykge1xuICAgICAgICAvLyBwYXJlbnRJbmZvIHNob3VsZCBhbHdheXMgYmUgcHJlc2VudCBleGNlcHQgZm9yIHRoZSB0b3AtbGV2ZWxcbiAgICAgICAgLy8gY29tcG9uZW50IHdoZW4gc2VydmVyIHJlbmRlcmluZ1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCBudWxsLCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FuY2VzdG9ySW5mbyA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEluZm8sIHRoaXMuX3RhZywgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIG1vdW50SW1hZ2U7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnVzZUNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gaG9zdENvbnRhaW5lckluZm8uX293bmVyRG9jdW1lbnQ7XG4gICAgICB2YXIgZWw7XG4gICAgICBpZiAobmFtZXNwYWNlVVJJID09PSBET01OYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhZyA9PT0gJ3NjcmlwdCcpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgICAgICB2YXIgZGl2ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgICAgICAgZGl2LmlubmVySFRNTCA9ICc8JyArIHR5cGUgKyAnPjwvJyArIHR5cGUgKyAnPic7XG4gICAgICAgICAgZWwgPSBkaXYucmVtb3ZlQ2hpbGQoZGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLmlzKSB7XG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSwgcHJvcHMuaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFNlcGFyYXRlIGVsc2UgYnJhbmNoIGluc3RlYWQgb2YgdXNpbmcgYHByb3BzLmlzIHx8IHVuZGVmaW5lZGAgYWJvdmUgYmVjdWFzZSBvZiBhIEZpcmVmb3ggYnVnLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgICAgICAvLyBhbmQgZGlzY3Vzc2lvbiBpbiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjc2MjQwXG4gICAgICAgICAgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgZWwpO1xuICAgICAgdGhpcy5fZmxhZ3MgfD0gRmxhZ3MuaGFzQ2FjaGVkQ2hpbGROb2RlcztcbiAgICAgIGlmICghdGhpcy5faG9zdFBhcmVudCkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9yUm9vdChlbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKG51bGwsIHByb3BzLCB0cmFuc2FjdGlvbik7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShlbCk7XG4gICAgICB0aGlzLl9jcmVhdGVJbml0aWFsQ2hpbGRyZW4odHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0LCBsYXp5VHJlZSk7XG4gICAgICBtb3VudEltYWdlID0gbGF6eVRyZWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0YWdPcGVuID0gdGhpcy5fY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyh0cmFuc2FjdGlvbiwgcHJvcHMpO1xuICAgICAgdmFyIHRhZ0NvbnRlbnQgPSB0aGlzLl9jcmVhdGVDb250ZW50TWFya3VwKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCk7XG4gICAgICBpZiAoIXRhZ0NvbnRlbnQgJiYgb21pdHRlZENsb3NlVGFnc1t0aGlzLl90YWddKSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJy8+JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vdW50SW1hZ2UgPSB0YWdPcGVuICsgJz4nICsgdGFnQ29udGVudCArICc8LycgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlICsgJz4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5wdXRQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodGV4dGFyZWFQb3N0TW91bnQsIHRoaXMpO1xuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKG9wdGlvblBvc3RNb3VudCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBtb3VudEltYWdlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIG9wZW4gdGFnIGFuZCBhbGwgYXR0cmlidXRlcy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaGFzIHNpZGUgZWZmZWN0cyBiZWNhdXNlIGV2ZW50cyBnZXQgcmVnaXN0ZXJlZC5cbiAgICpcbiAgICogSXRlcmF0aW5nIG92ZXIgb2JqZWN0IHByb3BlcnRpZXMgaXMgZmFzdGVyIHRoYW4gaXRlcmF0aW5nIG92ZXIgYXJyYXlzLlxuICAgKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL29iai12cy1hcnItaXRlcmF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgb2Ygb3BlbmluZyB0YWcuXG4gICAqL1xuICBfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVyczogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcykge1xuICAgIHZhciByZXQgPSAnPCcgKyB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wS2V5XTtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgZW5xdWV1ZVB1dExpc3RlbmVyKHRoaXMsIHByb3BLZXksIHByb3BWYWx1ZSwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgICBpZiAocHJvcFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAvLyBTZWUgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gc3R5bGUgYmxvY2tcbiAgICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNTdHlsZSA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3BWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gX2Fzc2lnbih7fSwgcHJvcHMuc3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcm9wVmFsdWUgPSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuY3JlYXRlTWFya3VwRm9yU3R5bGVzKHByb3BWYWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcmt1cCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl90YWcgIT0gbnVsbCAmJiBpc0N1c3RvbUNvbXBvbmVudCh0aGlzLl90YWcsIHByb3BzKSkge1xuICAgICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9ob3N0UGFyZW50KSB7XG4gICAgICByZXQgKz0gJyAnICsgRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclJvb3QoKTtcbiAgICB9XG4gICAgcmV0ICs9ICcgJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRCh0aGlzLl9kb21JRCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIGNvbnRlbnRUb1VzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgIHJldHVybiAnXFxuJyArIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgbGF6eVRyZWUpIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIERPTUxhenlUcmVlLnF1ZXVlSFRNTChsYXp5VHJlZSwgaW5uZXJIVE1MLl9faHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0ZXh0IGlzIGFsbG93ZWQgYXMgYSBjaGlsZCBvZiB0aGlzIG5vZGVcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBBdm9pZCBzZXR0aW5nIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIHRleHQgYXJlYSB3aWxsIGNhdXNlIHRoZSBwbGFjZWhvbGRlciB0byBub3RcbiAgICAgICAgLy8gc2hvdyB3aXRoaW4gdGhlIHRleHRhcmVhIHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIGlmIChjb250ZW50VG9Vc2UgIT09ICcnKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgY29udGVudFRvVXNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgRE9NTGF6eVRyZWUucXVldWVUZXh0KGxhenlUcmVlLCBjb250ZW50VG9Vc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkcmVuVG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbW91bnRJbWFnZXMgPSB0aGlzLm1vdW50Q2hpbGRyZW4oY2hpbGRyZW5Ub1VzZSwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vdW50SW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgbW91bnRJbWFnZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNlaXZlcyBhIG5leHQgZWxlbWVudCBhbmQgdXBkYXRlcyB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBET00gY29tcG9uZW50IGFmdGVyIGl0IGhhcyBhbHJlYWR5IGJlZW4gYWxsb2NhdGVkIGFuZFxuICAgKiBhdHRhY2hlZCB0byB0aGUgRE9NLiBSZWNvbmNpbGVzIHRoZSByb290IERPTSBub2RlLCB0aGVuIHJlY3Vyc2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBwcmV2RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnRcbiAgICogQGludGVybmFsXG4gICAqIEBvdmVycmlkYWJsZVxuICAgKi9cbiAgdXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgY29udGV4dCkge1xuICAgIHZhciBsYXN0UHJvcHMgPSBwcmV2RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NT3B0aW9uLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXRIb3N0UHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXRIb3N0UHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01TZWxlY3QuZ2V0SG9zdFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldEhvc3RQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBhc3NlcnRWYWxpZFByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgdGhpcy5fdXBkYXRlRE9NUHJvcGVydGllcyhsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuX3VwZGF0ZURPTUNoaWxkcmVuKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG5cbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgICAvLyBoYXBwZW4gYWZ0ZXIgYF91cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyLCB0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZVxuICAgKi9cbiAgX3VwZGF0ZURPTVByb3BlcnRpZXM6IGZ1bmN0aW9uIChsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24pIHtcbiAgICB2YXIgcHJvcEtleTtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIHZhciBzdHlsZVVwZGF0ZXM7XG4gICAgZm9yIChwcm9wS2V5IGluIGxhc3RQcm9wcykge1xuICAgICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIHZhciBsYXN0U3R5bGUgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weTtcbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChsYXN0UHJvcHNbcHJvcEtleV0pIHtcbiAgICAgICAgICAvLyBPbmx5IGNhbGwgZGVsZXRlTGlzdGVuZXIgaWYgdGhlcmUgd2FzIGEgbGlzdGVuZXIgcHJldmlvdXNseSBvclxuICAgICAgICAgIC8vIGVsc2Ugd2lsbERlbGV0ZUxpc3RlbmVyIGdldHMgY2FsbGVkIHdoZW4gdGhlcmUgd2Fzbid0IGFjdHVhbGx5IGFcbiAgICAgICAgICAvLyBsaXN0ZW5lciAoZS5nLiwgb25DbGljaz17bnVsbH0pXG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBsYXN0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllc1twcm9wS2V5XSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShwcm9wS2V5KSkge1xuICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShnZXROb2RlKHRoaXMpLCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgICAgdmFyIGxhc3RQcm9wID0gcHJvcEtleSA9PT0gU1RZTEUgPyB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA6IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlKHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5LCB0aGlzLl9wcmV2aW91c1N0eWxlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBuZXh0UHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbmV4dFByb3AgPSB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IF9hc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcywgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZ2V0Tm9kZSh0aGlzKSwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBnZXROb2RlKHRoaXMpO1xuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JTdHlsZXMoZ2V0Tm9kZSh0aGlzKSwgc3R5bGVVcGRhdGVzLCB0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlY29uY2lsZXMgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHZhcmlvdXMgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0aGVcbiAgICogY2hpbGRyZW4gY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGxhc3RQcm9wc1xuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIF91cGRhdGVET01DaGlsZHJlbjogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBsYXN0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIGxhc3RQcm9wcy5jaGlsZHJlbl0gPyBsYXN0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgIHZhciBuZXh0Q29udGVudCA9IENPTlRFTlRfVFlQRVNbdHlwZW9mIG5leHRQcm9wcy5jaGlsZHJlbl0gPyBuZXh0UHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuXG4gICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIGxhc3RQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG4gICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICYmIG5leHRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWw7XG5cbiAgICAvLyBOb3RlIHRoZSB1c2Ugb2YgYCE9YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICAgIHZhciBsYXN0Q2hpbGRyZW4gPSBsYXN0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IGxhc3RQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENvbnRlbnQgIT0gbnVsbCA/IG51bGwgOiBuZXh0UHJvcHMuY2hpbGRyZW47XG5cbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBjaGlsZHJlbiB0byBjb250ZW50L2h0bWwgb3IgdmljZSB2ZXJzYSwgcmVtb3ZlXG4gICAgLy8gdGhlIG9sZCBjb250ZW50XG4gICAgdmFyIGxhc3RIYXNDb250ZW50T3JIdG1sID0gbGFzdENvbnRlbnQgIT0gbnVsbCB8fCBsYXN0SHRtbCAhPSBudWxsO1xuICAgIHZhciBuZXh0SGFzQ29udGVudE9ySHRtbCA9IG5leHRDb250ZW50ICE9IG51bGwgfHwgbmV4dEh0bWwgIT0gbnVsbDtcbiAgICBpZiAobGFzdENoaWxkcmVuICE9IG51bGwgJiYgbmV4dENoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obnVsbCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAobGFzdEhhc0NvbnRlbnRPckh0bWwgJiYgIW5leHRIYXNDb250ZW50T3JIdG1sKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKHRoaXMuX2RlYnVnSUQsIFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmV4dENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGxhc3RDb250ZW50ICE9PSBuZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHRDb250ZW50KCcnICsgbmV4dENvbnRlbnQpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbmV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uU2V0Q2hpbGRyZW4odGhpcy5fZGVidWdJRCwgW10pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldEFuZFZhbGlkYXRlQ29udGVudENoaWxkRGV2LmNhbGwodGhpcywgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldE5vZGUodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFsbCBldmVudCByZWdpc3RyYXRpb25zIGZvciB0aGlzIGluc3RhbmNlLiBEb2VzIG5vdCByZW1vdmUgZnJvbVxuICAgKiB0aGUgRE9NLiBUaGF0IG11c3QgYmUgZG9uZSBieSB0aGUgcGFyZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChzYWZlbHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3RhZykge1xuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIGlucHV0VmFsdWVUcmFja2luZy5zdG9wVHJhY2tpbmcodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgaW1wb3NzaWJsZSB0byB1bm1vdW50IHNvbWUgdG9wLWxldmVsIGNvbXBvbmVudHMgKGVnIDxodG1sPiwgPGhlYWQ+LCBhbmQgPGJvZHk+KSByZWxpYWJseSBhbmQgZWZmaWNpZW50bHkuIFRvIGZpeCB0aGlzLCBoYXZlIGEgc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgZWxlbWVudHMuJywgdGhpcy5fdGFnKSA6IF9wcm9kSW52YXJpYW50KCc2NicsIHRoaXMuX3RhZykgOiB2b2lkIDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMudW5tb3VudENoaWxkcmVuKHNhZmVseSk7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICAgIEV2ZW50UGx1Z2luSHViLmRlbGV0ZUFsbExpc3RlbmVycyh0aGlzKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gMDtcbiAgICB0aGlzLl9kb21JRCA9IDA7XG4gICAgdGhpcy5fd3JhcHBlclN0YXRlID0gbnVsbDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBzZXRBbmRWYWxpZGF0ZUNvbnRlbnRDaGlsZERldi5jYWxsKHRoaXMsIG51bGwpO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXROb2RlKHRoaXMpO1xuICB9XG59O1xuXG5fYXNzaWduKFJlYWN0RE9NQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RET01Db21wb25lbnQuTWl4aW4sIFJlYWN0TXVsdGlDaGlsZC5NaXhpbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01Db21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcblxudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSB7XG4gIGZvY3VzRE9NQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgZm9jdXNOb2RlKFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vQ1NTUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSA9IHJlcXVpcmUoJy4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZScpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IGZhbHNlO1xudmFyIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdjc3NGbG9hdCc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciB0ZW1wU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgdHJ5IHtcbiAgICAvLyBJRTggdGhyb3dzIFwiSW52YWxpZCBhcmd1bWVudC5cIiBpZiByZXNldHRpbmcgc2hvcnRoYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgdGVtcFN0eWxlLmZvbnQgPSAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gdHJ1ZTtcbiAgfVxuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIGNhbWVsaXplU3R5bGVOYW1lKG5hbWUpLCBjaGVja1JlbmRlck1lc3NhZ2Uob3duZXIpKSA6IHZvaWQgMDtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JXMnLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgb3duZXIpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiVzIFwiICsgJ1RyeSBcIiVzOiAlc1wiIGluc3RlYWQuJywgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSwgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIG93bmVyKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgY2hlY2tSZW5kZXJNZXNzYWdlKG93bmVyKSkgOiB2b2lkIDA7XG4gIH07XG5cbiAgdmFyIGNoZWNrUmVuZGVyTWVzc2FnZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgIGlmIChvd25lcikge1xuICAgICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuICB2YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGNvbXBvbmVudCkge1xuICAgIHZhciBvd25lcjtcbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgIH1cbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSwgb3duZXIpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lLCBvd25lcik7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSwgb3duZXIpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cbnZhciBDU1NQcm9wZXJ0eU9wZXJhdGlvbnMgPSB7XG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JTdHlsZXM6IGZ1bmN0aW9uIChzdHlsZXMsIGNvbXBvbmVudCkge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgd2FyblZhbGlkU3R5bGUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpICsgJzonO1xuICAgICAgICBzZXJpYWxpemVkICs9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZVZhbHVlLCBjb21wb25lbnQsIGlzQ3VzdG9tUHJvcGVydHkpICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBmb3IgbXVsdGlwbGUgc3R5bGVzIG9uIGEgbm9kZS4gIElmIGEgdmFsdWUgaXMgc3BlY2lmaWVkIGFzXG4gICAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICAgKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG4gIHNldFZhbHVlRm9yU3R5bGVzOiBmdW5jdGlvbiAobm9kZSwgc3R5bGVzLCBjb21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uSG9zdE9wZXJhdGlvbih7XG4gICAgICAgIGluc3RhbmNlSUQ6IGNvbXBvbmVudC5fZGVidWdJRCxcbiAgICAgICAgdHlwZTogJ3VwZGF0ZSBzdHlsZXMnLFxuICAgICAgICBwYXlsb2FkOiBzdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBjb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGVWYWx1ZSA9IGRhbmdlcm91c1N0eWxlVmFsdWUoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSwgY29tcG9uZW50LCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcgfHwgc3R5bGVOYW1lID09PSAnY3NzRmxvYXQnKSB7XG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlRmxvYXRBY2Nlc3NvcjtcbiAgICAgIH1cbiAgICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0eWxlVmFsdWUpIHtcbiAgICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwYW5zaW9uID0gaGFzU2hvcnRoYW5kUHJvcGVydHlCdWcgJiYgQ1NTUHJvcGVydHkuc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zW3N0eWxlTmFtZV07XG4gICAgICAgIGlmIChleHBhbnNpb24pIHtcbiAgICAgICAgICAvLyBTaG9ydGhhbmQgcHJvcGVydHkgdGhhdCBJRTggd29uJ3QgbGlrZSB1bnNldHRpbmcsIHNvIHVuc2V0IGVhY2hcbiAgICAgICAgICAvLyBjb21wb25lbnQgdG8gcGxhY2F0ZSBpdFxuICAgICAgICAgIGZvciAodmFyIGluZGl2aWR1YWxTdHlsZU5hbWUgaW4gZXhwYW5zaW9uKSB7XG4gICAgICAgICAgICBzdHlsZVtpbmRpdmlkdWFsU3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhbWVsaXplID0gcmVxdWlyZSgnLi9jYW1lbGl6ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tb3otdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJNb3pUcmFuc2l0aW9uXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1zLXRyYW5zaXRpb24nKVxuICogICA8IFwibXNUcmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gKiAoaHR0cDovL3d3dy5hbmRpc21pdGguY29tL2Jsb2cvMjAxMi8wMi9tb2Rlcm5penItcHJlZml4ZWQvKSwgYW4gYC1tc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGNhbWVsaXplKHN0cmluZy5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENTU1Byb3BlcnR5ID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eScpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcbnZhciBzdHlsZVdhcm5pbmdzID0ge307XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIGludG8gdGhlIHByb3BlciBjc3Mgd3JpdGFibGUgdmFsdWUuIFRoZSBzdHlsZSBuYW1lIGBuYW1lYFxuICogc2hvdWxkIGJlIGxvZ2ljYWwgKG5vIGh5cGhlbnMpLCBhcyBzcGVjaWZpZWRcbiAqIGluIGBDU1NQcm9wZXJ0eS5pc1VuaXRsZXNzTnVtYmVyYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgcHJvcGVydHkgbmFtZSBzdWNoIGFzIGB0b3BNYXJnaW5gLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBDU1MgcHJvcGVydHkgdmFsdWUgc3VjaCBhcyBgMTBweGAuXG4gKiBAcGFyYW0ge1JlYWN0RE9NQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgY29tcG9uZW50LCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgaXNOb25OdW1lcmljID0gaXNOYU4odmFsdWUpO1xuICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSB8fCBpc05vbk51bWVyaWMgfHwgdmFsdWUgPT09IDAgfHwgaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSB7XG4gICAgcmV0dXJuICcnICsgdmFsdWU7IC8vIGNhc3QgdG8gc3RyaW5nXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBBbGxvdyAnMCcgdG8gcGFzcyB0aHJvdWdoIHdpdGhvdXQgd2FybmluZy4gMCBpcyBhbHJlYWR5IHNwZWNpYWwgYW5kXG4gICAgICAvLyBkb2Vzbid0IHJlcXVpcmUgdW5pdHMsIHNvIHdlIGRvbid0IG5lZWQgdG8gd2FybiBhYm91dCBpdC5cbiAgICAgIGlmIChjb21wb25lbnQgJiYgdmFsdWUgIT09ICcwJykge1xuICAgICAgICB2YXIgb3duZXIgPSBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gb3duZXIuZ2V0TmFtZSgpIDogbnVsbDtcbiAgICAgICAgaWYgKG93bmVyTmFtZSAmJiAhc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdKSB7XG4gICAgICAgICAgc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgdmFyIHdhcm5pbmdzID0gc3R5bGVXYXJuaW5nc1tvd25lck5hbWVdO1xuICAgICAgICAgIHdhcm5lZCA9IHdhcm5pbmdzW25hbWVdO1xuICAgICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nc1tuYW1lXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdhIGAlc2AgdGFnIChvd25lcjogYCVzYCkgd2FzIHBhc3NlZCBhIG51bWVyaWMgc3RyaW5nIHZhbHVlICcgKyAnZm9yIENTUyBwcm9wZXJ0eSBgJXNgICh2YWx1ZTogYCVzYCkgd2hpY2ggd2lsbCBiZSB0cmVhdGVkICcgKyAnYXMgYSB1bml0bGVzcyBudW1iZXIgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSZWFjdC4nLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50LnR5cGUsIG93bmVyTmFtZSB8fCAndW5rbm93bicsIG5hbWUsIHZhbHVlKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdmFsdWUgKyAncHgnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRhbmdlcm91c1N0eWxlVmFsdWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvZGFuZ2Vyb3VzU3R5bGVWYWx1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNZW1vaXplcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIG9uZSBzdHJpbmcgYXJndW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpIHtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodmFsdWUpICsgJ1wiJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcbiAgLyoqXG4gICAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gICAqIG9wcG9ydHVuaXR5IHRvIGNyZWF0ZSBgUmVhY3RFdmVudGBzIHRvIGJlIGRpc3BhdGNoZWQuXG4gICAqL1xuICBoYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cyA9IEV2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9nZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBkaWRXYXJuVmFsdWVMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWRMaW5rID0gZmFsc2U7XG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMi9XRC1odG1sNS0yMDEyMTAyNS90aGUtaW5wdXQtZWxlbWVudC5odG1sXG4gKi9cbnZhciBSZWFjdERPTUlucHV0ID0ge1xuICBnZXRIb3N0UHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBjaGVja2VkID0gTGlua2VkVmFsdWVVdGlscy5nZXRDaGVja2VkKHByb3BzKTtcblxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnR5cGUgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzIChzZXR0aW5nIC52YWx1ZVxuICAgICAgLy8gYmVmb3JlIC50eXBlIG1lYW5zIC52YWx1ZSBpcyBsb3N0IGluIElFMTEgYW5kIGJlbG93KVxuICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAuc3RlcCBiZWZvcmUgLnZhbHVlIChzZXR0aW5nIC52YWx1ZSBiZWZvcmUgLnN0ZXBcbiAgICAgIC8vIG1lYW5zIC52YWx1ZSBpcyByb3VuZGVkIG9uIG1vdW50LCBiYXNlZCB1cG9uIHN0ZXAgcHJlY2lzaW9uKVxuICAgICAgc3RlcDogdW5kZWZpbmVkLFxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNldCAubWluICYgLm1heCBiZWZvcmUgLnZhbHVlICh0byBlbnN1cmUgcHJvcGVyIG9yZGVyXG4gICAgICAvLyBpbiBjb3JuZXIgY2FzZXMgc3VjaCBhcyBtaW4gb3IgbWF4IGRlcml2aW5nIGZyb20gdmFsdWUsIGUuZy4gSXNzdWUgIzcxNzApXG4gICAgICBtaW46IHVuZGVmaW5lZCxcbiAgICAgIG1heDogdW5kZWZpbmVkXG4gICAgfSwgcHJvcHMsIHtcbiAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZCxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcblxuICAgICAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICBpZiAocHJvcHMudmFsdWVMaW5rICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZUxpbmspIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdgdmFsdWVMaW5rYCBwcm9wIG9uIGBpbnB1dGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbHVlTGluayA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMuY2hlY2tlZExpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWRMaW5rKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYGNoZWNrZWRMaW5rYCBwcm9wIG9uIGBpbnB1dGAgaXMgZGVwcmVjYXRlZDsgc2V0IGB2YWx1ZWAgYW5kIGBvbkNoYW5nZWAgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkNoZWNrZWRMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSkgOiB2b2lkIDA7XG4gICAgICAgIGRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICAgIGluaXRpYWxWYWx1ZTogcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlLFxuICAgICAgbGlzdGVuZXJzOiBudWxsLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KSxcbiAgICAgIGNvbnRyb2xsZWQ6IGlzQ29udHJvbGxlZChwcm9wcylcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZVdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgdmFyIHByb3BzID0gaW5zdC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuICAgICAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICBpZiAoIWluc3QuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmIGNvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIG93bmVyICYmIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoaW5zdC5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgb3duZXIgJiYgb3duZXIuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTaG91bGRuJ3QgdGhpcyBiZSBnZXRDaGVja2VkKHByb3BzKT9cbiAgICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gICAgaWYgKGNoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLnNldFZhbHVlRm9yUHJvcGVydHkoUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCksICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSAnMCc7XG4gICAgICAgIC8vIE5vdGU6IElFOSByZXBvcnRzIGEgbnVtYmVyIGlucHV0cyBhcyAndGV4dCcsIHNvIGNoZWNrIHByb3BzIGluc3RlYWQuXG4gICAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIFNpbXVsYXRlIGBpbnB1dC52YWx1ZUFzTnVtYmVyYC4gSUU5IGRvZXMgbm90IHN1cHBvcnQgaXRcbiAgICAgICAgdmFyIHZhbHVlQXNOdW1iZXIgPSBwYXJzZUZsb2F0KG5vZGUudmFsdWUsIDEwKSB8fCAwO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHZhbHVlICE9IHZhbHVlQXNOdW1iZXIgfHxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHZhbHVlID09IHZhbHVlQXNOdW1iZXIgJiYgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgIT09ICcnICsgdmFsdWUpIHtcbiAgICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgICBub2RlLnZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgICAgLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuICAgICAgICAvLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuICAgICAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuICAgICAgICBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBwb3N0TW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAgIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG5cbiAgICAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWUuIFdlIHdvbid0IGRvIGFueXRoaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb25cbiAgICAvLyBzdWJtaXQgb3IgcmVzZXQgaW5wdXRzIGFzIHRob3NlIHZhbHVlcyAmIGRlZmF1bHRWYWx1ZXMgYXJlIGxpbmtlZC4gVGhleVxuICAgIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAgIC8vIHJlbW92ZXMgYnJvd3Nlci1kZWZhdWx0IHZhbHVlcyAoZWcgXCJTdWJtaXQgUXVlcnlcIikgd2hlbiBubyB2YWx1ZSBpc1xuICAgIC8vIHByb3ZpZGVkLlxuXG4gICAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgICBjYXNlICdzdWJtaXQnOlxuICAgICAgY2FzZSAncmVzZXQnOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxuICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgY2FzZSAndGltZSc6XG4gICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgLy8gVGhpcyBmaXhlcyB0aGUgbm8tc2hvdyBpc3N1ZSBvbiBpT1MgU2FmYXJpIGFuZCBBbmRyb2lkIENocm9tZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJztcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGUuZGVmYXVsdFZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG5vZGUudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuICAgIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gICAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAgIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4gICAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICAgIG5vZGUubmFtZSA9ICcnO1xuICAgIH1cbiAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIGlmIChuYW1lICE9PSAnJykge1xuICAgICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG5cbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcblxuICAvLyBIZXJlIHdlIHVzZSBhc2FwIHRvIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaFxuICAvLyBpcyBpbXBvcnRhbnQgd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcblxuICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxuICAgIC8vIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZy5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cbiAgICAgIHZhciBvdGhlckluc3RhbmNlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldEluc3RhbmNlRnJvbU5vZGUob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlckluc3RhbmNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSBzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogX3Byb2RJbnZhcmlhbnQoJzkwJykgOiB2b2lkIDA7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCBvdGhlckluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01JbnB1dDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTUlucHV0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RET01TZWxlY3QgPSByZXF1aXJlKCcuL1JlYWN0RE9NU2VsZWN0Jyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGRpZFdhcm5JbnZhbGlkT3B0aW9uQ2hpbGRyZW4gPSBmYWxzZTtcblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnRlbnQgKz0gY2hpbGQ7XG4gICAgfSBlbHNlIGlmICghZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbikge1xuICAgICAgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IHRydWU7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ09ubHkgc3RyaW5ncyBhbmQgbnVtYmVycyBhcmUgc3VwcG9ydGVkIGFzIDxvcHRpb24+IGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cbnZhciBSZWFjdERPTU9wdGlvbiA9IHtcbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGhvc3RQYXJlbnQpIHtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgd2hldGhlciB0aGlzIG9wdGlvbiBpcyAnc2VsZWN0ZWQnXG4gICAgdmFyIHNlbGVjdFZhbHVlID0gbnVsbDtcbiAgICBpZiAoaG9zdFBhcmVudCAhPSBudWxsKSB7XG4gICAgICB2YXIgc2VsZWN0UGFyZW50ID0gaG9zdFBhcmVudDtcblxuICAgICAgaWYgKHNlbGVjdFBhcmVudC5fdGFnID09PSAnb3B0Z3JvdXAnKSB7XG4gICAgICAgIHNlbGVjdFBhcmVudCA9IHNlbGVjdFBhcmVudC5faG9zdFBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdFBhcmVudCAhPSBudWxsICYmIHNlbGVjdFBhcmVudC5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICBzZWxlY3RWYWx1ZSA9IFJlYWN0RE9NU2VsZWN0LmdldFNlbGVjdFZhbHVlQ29udGV4dChzZWxlY3RQYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBudWxsIChlLmcuLCBubyBzcGVjaWZpZWQgdmFsdWUgb3IgYWZ0ZXIgaW5pdGlhbCBtb3VudClcbiAgICAvLyBvciBtaXNzaW5nIChlLmcuLCBmb3IgPGRhdGFsaXN0PiksIHdlIGRvbid0IGNoYW5nZSBwcm9wcy5zZWxlY3RlZFxuICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgaWYgKHNlbGVjdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgKyAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgLy8gbXVsdGlwbGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2ldID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgcG9zdE1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHByb3BzLnZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBob3N0UHJvcHMuc2VsZWN0ZWQgPSBpbnN0Ll93cmFwcGVyU3RhdGUuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgIGhvc3RQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvc3RQcm9wcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTU9wdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTGluayA9IGZhbHNlO1xudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZvcmNlVXBkYXRlSWZNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCkge1xuICAgIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gICAgUmVhY3RET01UZXh0YXJlYS51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG52YXIgUmVhY3RET01UZXh0YXJlYSA9IHtcbiAgZ2V0SG9zdFByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogX3Byb2RJbnZhcmlhbnQoJzkxJykgOiB2b2lkIDA7XG5cbiAgICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAgIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAgIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gICAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK0JlbiBzZWVtZWQgdG8gbGlrZSB0aGlzIHNvbHV0aW9uLlxuICAgIC8vIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkIHRvIGJlIGEgc3RyaW5nLlxuICAgIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY2hpbGRyZW46ICcnICsgaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBob3N0UHJvcHM7XG4gIH0sXG5cbiAgbW91bnRXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgTGlua2VkVmFsdWVVdGlscy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICAgIGlmIChwcm9wcy52YWx1ZUxpbmsgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlTGluaykge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2B2YWx1ZUxpbmtgIHByb3Agb24gYHRleHRhcmVhYCBpcyBkZXByZWNhdGVkOyBzZXQgYHZhbHVlYCBhbmQgYG9uQ2hhbmdlYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuVmFsdWVMaW5rID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBpbml0aWFsVmFsdWUgPSB2YWx1ZTtcblxuICAgIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogX3Byb2RJbnZhcmlhbnQoJzkyJykgOiB2b2lkIDA7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IF9wcm9kSW52YXJpYW50KCc5MycpIDogdm9pZCAwO1xuICAgICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWUsXG4gICAgICBsaXN0ZW5lcnM6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIHBvc3RNb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAgIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgIHZhciBub2RlID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gICAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAgIC8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4gICAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuICAgIGlmICh0ZXh0Q29udGVudCA9PT0gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgdmFyIHJldHVyblZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5leGVjdXRlT25DaGFuZ2UocHJvcHMsIGV2ZW50KTtcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0YXJlYTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVRleHRhcmVhLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSByZXF1aXJlKCcuL1JlYWN0Q2hpbGRSZWNvbmNpbGVyJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1hcmt1cCB0byBiZSByZW5kZXJlZCBhbmQgaW5zZXJ0ZWQgYXQgYSBzdXBwbGllZCBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXguXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlSW5zZXJ0TWFya3VwKG1hcmt1cCwgYWZ0ZXJOb2RlLCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnSU5TRVJUX01BUktVUCcsXG4gICAgY29udGVudDogbWFya3VwLFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0b0luZGV4OiB0b0luZGV4LFxuICAgIGFmdGVyTm9kZTogYWZ0ZXJOb2RlXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIG1vdmluZyBhbiBleGlzdGluZyBlbGVtZW50IHRvIGFub3RoZXIgaW5kZXguXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBTb3VyY2UgaW5kZXggb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VNb3ZlKGNoaWxkLCBhZnRlck5vZGUsIHRvSW5kZXgpIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdNT1ZFX0VYSVNUSU5HJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShjaGlsZCksXG4gICAgdG9JbmRleDogdG9JbmRleCxcbiAgICBhZnRlck5vZGU6IGFmdGVyTm9kZVxuICB9O1xufVxuXG4vKipcbiAqIE1ha2UgYW4gdXBkYXRlIGZvciByZW1vdmluZyBhbiBlbGVtZW50IGF0IGFuIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggSW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVJlbW92ZShjaGlsZCwgbm9kZSkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1JFTU9WRV9OT0RFJyxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogY2hpbGQuX21vdW50SW5kZXgsXG4gICAgZnJvbU5vZGU6IG5vZGUsXG4gICAgdG9JbmRleDogbnVsbCxcbiAgICBhZnRlck5vZGU6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBNYWtlIGFuIHVwZGF0ZSBmb3Igc2V0dGluZyB0aGUgbWFya3VwIG9mIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0aGF0IHJlbmRlcnMgaW50byBhbiBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVNldE1hcmt1cChtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICByZXR1cm4ge1xuICAgIHR5cGU6ICdTRVRfTUFSS1VQJyxcbiAgICBjb250ZW50OiBtYXJrdXAsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogTWFrZSBhbiB1cGRhdGUgZm9yIHNldHRpbmcgdGhlIHRleHQgY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dENvbnRlbnQgVGV4dCBjb250ZW50IHRvIHNldC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VUZXh0Q29udGVudCh0ZXh0Q29udGVudCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHJldHVybiB7XG4gICAgdHlwZTogJ1RFWFRfQ09OVEVOVCcsXG4gICAgY29udGVudDogdGV4dENvbnRlbnQsXG4gICAgZnJvbUluZGV4OiBudWxsLFxuICAgIGZyb21Ob2RlOiBudWxsLFxuICAgIHRvSW5kZXg6IG51bGwsXG4gICAgYWZ0ZXJOb2RlOiBudWxsXG4gIH07XG59XG5cbi8qKlxuICogUHVzaCBhbiB1cGRhdGUsIGlmIGFueSwgb250byB0aGUgcXVldWUuIENyZWF0ZXMgYSBuZXcgcXVldWUgaWYgbm9uZSBpc1xuICogcGFzc2VkIGFuZCBhbHdheXMgcmV0dXJucyB0aGUgcXVldWUuIE11dGF0aXZlLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgaWYgKHVwZGF0ZSkge1xuICAgIHF1ZXVlID0gcXVldWUgfHwgW107XG4gICAgcXVldWUucHVzaCh1cGRhdGUpO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuLyoqXG4gKiBQcm9jZXNzZXMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKGluc3QsIHVwZGF0ZVF1ZXVlKSB7XG4gIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyhpbnN0LCB1cGRhdGVRdWV1ZSk7XG59XG5cbnZhciBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbiA9IGVtcHR5RnVuY3Rpb247XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgZ2V0RGVidWdJRCA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgaWYgKCFpbnN0Ll9kZWJ1Z0lEKSB7XG4gICAgICAvLyBDaGVjayBmb3IgQVJULWxpa2UgaW5zdGFuY2VzLiBUT0RPOiBUaGlzIGlzIHNpbGx5L2dyb3NzLlxuICAgICAgdmFyIGludGVybmFsO1xuICAgICAgaWYgKGludGVybmFsID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdCkpIHtcbiAgICAgICAgaW5zdCA9IGludGVybmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdC5fZGVidWdJRDtcbiAgfTtcbiAgc2V0Q2hpbGRyZW5Gb3JJbnN0cnVtZW50YXRpb24gPSBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICB2YXIgZGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgLy8gVE9ETzogUmVhY3QgTmF0aXZlIGVtcHR5IGNvbXBvbmVudHMgYXJlIGFsc28gbXVsdGljaGlsZC5cbiAgICAvLyBUaGlzIG1lYW5zIHRoZXkgc3RpbGwgZ2V0IGludG8gdGhpcyBtZXRob2QgYnV0IGRvbid0IGhhdmUgX2RlYnVnSUQuXG4gICAgaWYgKGRlYnVnSUQgIT09IDApIHtcbiAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkcmVuID8gT2JqZWN0LmtleXMoY2hpbGRyZW4pLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltrZXldLl9kZWJ1Z0lEO1xuICAgICAgfSkgOiBbXSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlYWN0TXVsdGlDaGlsZCBhcmUgY2FwYWJsZSBvZiByZWNvbmNpbGluZyBtdWx0aXBsZSBjaGlsZHJlbi5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNdWx0aUNoaWxkXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0TXVsdGlDaGlsZCA9IHtcbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG4gICAgX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgc2VsZkRlYnVnSUQgPSBnZXREZWJ1Z0lEKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci5pbnN0YW50aWF0ZUNoaWxkcmVuKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIF9yZWNvbmNpbGVyVXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIG5leHRDaGlsZHJlbjtcbiAgICAgIHZhciBzZWxmRGVidWdJRCA9IDA7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICAgICAgcmV0dXJuIG5leHRDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCBzZWxmRGVidWdJRCk7XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgbW91bnRJbWFnZXMsIHJlbW92ZWROb2RlcywgdHJhbnNhY3Rpb24sIHRoaXMsIHRoaXMuX2hvc3RDb250YWluZXJJbmZvLCBjb250ZXh0LCBzZWxmRGVidWdJRCk7XG4gICAgICByZXR1cm4gbmV4dENoaWxkcmVuO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltuYW1lXTtcbiAgICAgICAgICB2YXIgc2VsZkRlYnVnSUQgPSAwO1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBzZWxmRGVidWdJRCA9IGdldERlYnVnSUQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgdGhpcywgdGhpcy5faG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgbW91bnRJbWFnZXMucHVzaChtb3VudEltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBzZXRDaGlsZHJlbkZvckluc3RydW1lbnRhdGlvbi5jYWxsKHRoaXMsIGNoaWxkcmVuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vdW50SW1hZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dENvbnRlbnQgU3RyaW5nIG9mIGNvbnRlbnQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlVGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChuZXh0Q29udGVudCkge1xuICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAvLyBSZW1vdmUgYW55IHJlbmRlcmVkIGNoaWxkcmVuLlxuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbiwgZmFsc2UpO1xuICAgICAgZm9yICh2YXIgbmFtZSBpbiBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd1cGRhdGVUZXh0Q29udGVudCBjYWxsZWQgb24gbm9uLWVtcHR5IGNvbXBvbmVudC4nKSA6IF9wcm9kSW52YXJpYW50KCcxMTgnKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IG5ldyB0ZXh0IGNvbnRlbnQuXG4gICAgICB2YXIgdXBkYXRlcyA9IFttYWtlVGV4dENvbnRlbnQobmV4dENvbnRlbnQpXTtcbiAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgYW55IHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBtYXJrdXAgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5leHRNYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVNYXJrdXA6IGZ1bmN0aW9uIChuZXh0TWFya3VwKSB7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBmYWxzZSk7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3VwZGF0ZVRleHRDb250ZW50IGNhbGxlZCBvbiBub24tZW1wdHkgY29tcG9uZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzExOCcpIDogdm9pZCAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgdXBkYXRlcyA9IFttYWtlU2V0TWFya3VwKG5leHRNYXJrdXApXTtcbiAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBuZXcgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAobmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAvLyBIb29rIHVzZWQgYnkgUmVhY3QgQVJUXG4gICAgICB0aGlzLl91cGRhdGVDaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgdmFyIHJlbW92ZWROb2RlcyA9IHt9O1xuICAgICAgdmFyIG1vdW50SW1hZ2VzID0gW107XG4gICAgICB2YXIgbmV4dENoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuKHByZXZDaGlsZHJlbiwgbmV4dE5lc3RlZENoaWxkcmVuRWxlbWVudHMsIG1vdW50SW1hZ2VzLCByZW1vdmVkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHVwZGF0ZXMgPSBudWxsO1xuICAgICAgdmFyIG5hbWU7XG4gICAgICAvLyBgbmV4dEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBjaGlsZCBpbiBgbmV4dENoaWxkcmVuYCwgYnV0XG4gICAgICAvLyBgbGFzdEluZGV4YCB3aWxsIGJlIHRoZSBsYXN0IGluZGV4IHZpc2l0ZWQgaW4gYHByZXZDaGlsZHJlbmAuXG4gICAgICB2YXIgbmV4dEluZGV4ID0gMDtcbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgLy8gYG5leHRNb3VudEluZGV4YCB3aWxsIGluY3JlbWVudCBmb3IgZWFjaCBuZXdseSBtb3VudGVkIGNoaWxkLlxuICAgICAgdmFyIG5leHRNb3VudEluZGV4ID0gMDtcbiAgICAgIHZhciBsYXN0UGxhY2VkTm9kZSA9IG51bGw7XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIGlmIChwcmV2Q2hpbGQgPT09IG5leHRDaGlsZCkge1xuICAgICAgICAgIHVwZGF0ZXMgPSBlbnF1ZXVlKHVwZGF0ZXMsIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgbGFzdEluZGV4KSk7XG4gICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIHByZXZDaGlsZC5fbW91bnRJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYGxhc3RJbmRleGAgYmVmb3JlIGBfbW91bnRJbmRleGAgZ2V0cyB1bnNldCBieSB1bm1vdW50aW5nLlxuICAgICAgICAgICAgbGFzdEluZGV4ID0gTWF0aC5tYXgocHJldkNoaWxkLl9tb3VudEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgICAgLy8gVGhlIGByZW1vdmVkTm9kZXNgIGxvb3AgYmVsb3cgd2lsbCBhY3R1YWxseSByZW1vdmUgdGhlIGNoaWxkLlxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgICB1cGRhdGVzID0gZW5xdWV1ZSh1cGRhdGVzLCB0aGlzLl9tb3VudENoaWxkQXRJbmRleChuZXh0Q2hpbGQsIG1vdW50SW1hZ2VzW25leHRNb3VudEluZGV4XSwgbGFzdFBsYWNlZE5vZGUsIG5leHRJbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpKTtcbiAgICAgICAgICBuZXh0TW91bnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgICBsYXN0UGxhY2VkTm9kZSA9IFJlYWN0UmVjb25jaWxlci5nZXRIb3N0Tm9kZShuZXh0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgICAgZm9yIChuYW1lIGluIHJlbW92ZWROb2Rlcykge1xuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdXBkYXRlcyA9IGVucXVldWUodXBkYXRlcywgdGhpcy5fdW5tb3VudENoaWxkKHByZXZDaGlsZHJlbltuYW1lXSwgcmVtb3ZlZE5vZGVzW25hbWVdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cGRhdGVzKSB7XG4gICAgICAgIHByb2Nlc3NRdWV1ZSh0aGlzLCB1cGRhdGVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBuZXh0Q2hpbGRyZW47XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHNldENoaWxkcmVuRm9ySW5zdHJ1bWVudGF0aW9uLmNhbGwodGhpcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5tb3VudHMgYWxsIHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIHNob3VsZCBiZSB1c2VkIHRvIGNsZWFuIHVwIGNoaWxkcmVuXG4gICAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuIEl0IGRvZXMgbm90IGFjdHVhbGx5IHBlcmZvcm0gYW55XG4gICAgICogYmFja2VuZCBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdW5tb3VudENoaWxkcmVuOiBmdW5jdGlvbiAoc2FmZWx5KSB7XG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICBSZWFjdENoaWxkUmVjb25jaWxlci51bm1vdW50Q2hpbGRyZW4ocmVuZGVyZWRDaGlsZHJlbiwgc2FmZWx5KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhIGNoaWxkIGNvbXBvbmVudCB0byB0aGUgc3VwcGxpZWQgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleCBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbGFzdEluZGV4IExhc3QgaW5kZXggdmlzaXRlZCBvZiB0aGUgc2libGluZ3Mgb2YgYGNoaWxkYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIGFmdGVyTm9kZSwgdG9JbmRleCwgbGFzdEluZGV4KSB7XG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgYGNoaWxkYCBpcyBsZXNzIHRoYW4gYGxhc3RJbmRleGAsIHRoZW4gaXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIG1vdmVkLiBPdGhlcndpc2UsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgaXQgYmVjYXVzZSBhIGNoaWxkIHdpbGwgYmVcbiAgICAgIC8vIGluc2VydGVkIG9yIG1vdmVkIGJlZm9yZSBgY2hpbGRgLlxuICAgICAgaWYgKGNoaWxkLl9tb3VudEluZGV4IDwgbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybiBtYWtlTW92ZShjaGlsZCwgYWZ0ZXJOb2RlLCB0b0luZGV4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vdW50SW1hZ2UgTWFya3VwIHRvIGluc2VydC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgYWZ0ZXJOb2RlLCBtb3VudEltYWdlKSB7XG4gICAgICByZXR1cm4gbWFrZUluc2VydE1hcmt1cChtb3VudEltYWdlLCBhZnRlck5vZGUsIGNoaWxkLl9tb3VudEluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENoaWxkIHRvIHJlbW92ZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbm9kZSkge1xuICAgICAgcmV0dXJuIG1ha2VSZW1vdmUoY2hpbGQsIG5vZGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb3VudHMgYSBjaGlsZCB3aXRoIHRoZSBzdXBwbGllZCBuYW1lLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIG1vdW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGNoaWxkLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9tb3VudENoaWxkQXRJbmRleDogZnVuY3Rpb24gKGNoaWxkLCBtb3VudEltYWdlLCBhZnRlck5vZGUsIGluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgY2hpbGQuX21vdW50SW5kZXggPSBpbmRleDtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNoaWxkKGNoaWxkLCBhZnRlck5vZGUsIG1vdW50SW1hZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhIHJlbmRlcmVkIGNoaWxkLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBpcyBwYXJ0IG9mIGB1cGRhdGVDaGlsZHJlbmAgYW5kIGlzIGhlcmUgZm9yIHJlYWRhYmlsaXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gY2hpbGQgQ29tcG9uZW50IHRvIHVubW91bnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdW5tb3VudENoaWxkOiBmdW5jdGlvbiAoY2hpbGQsIG5vZGUpIHtcbiAgICAgIHZhciB1cGRhdGUgPSB0aGlzLnJlbW92ZUNoaWxkKGNoaWxkLCBub2RlKTtcbiAgICAgIGNoaWxkLl9tb3VudEluZGV4ID0gbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUNoaWxkKGNoaWxkSW5zdGFuY2VzLCBjaGlsZCwgbmFtZSwgc2VsZkRlYnVnSUQpIHtcbiAgLy8gV2UgZm91bmQgYSBjb21wb25lbnQgaW5zdGFuY2UuXG4gIHZhciBrZXlVbmlxdWUgPSBjaGlsZEluc3RhbmNlc1tuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG4gICAgfVxuICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLiVzJywgS2V5RXNjYXBlVXRpbHMudW5lc2NhcGUobmFtZSksIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoc2VsZkRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKGNoaWxkICE9IG51bGwgJiYga2V5VW5pcXVlKSB7XG4gICAgY2hpbGRJbnN0YW5jZXNbbmFtZV0gPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGNoaWxkLCB0cnVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlYWN0Q2hpbGRSZWNvbmNpbGVyIHByb3ZpZGVzIGhlbHBlcnMgZm9yIGluaXRpYWxpemluZyBvciB1cGRhdGluZyBhIHNldCBvZlxuICogY2hpbGRyZW4uIEl0cyBvdXRwdXQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgaXQgb250byBSZWFjdE11bHRpQ2hpbGQgd2hpY2hcbiAqIGRvZXMgZGlmZmVkIHJlb3JkZXJpbmcgYW5kIGluc2VydGlvbi5cbiAqL1xudmFyIFJlYWN0Q2hpbGRSZWNvbmNpbGVyID0ge1xuICAvKipcbiAgICogR2VuZXJhdGVzIGEgXCJtb3VudCBpbWFnZVwiIGZvciBlYWNoIG9mIHRoZSBzdXBwbGllZCBjaGlsZHJlbi4gSW4gdGhlIGNhc2VcbiAgICogb2YgYFJlYWN0RE9NQ29tcG9uZW50YCwgYSBtb3VudCBpbWFnZSBpcyBhIHN0cmluZyBvZiBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmVzdGVkQ2hpbGROb2RlcyBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICogQHJldHVybiB7P29iamVjdH0gQSBzZXQgb2YgY2hpbGQgaW5zdGFuY2VzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZE5vZGVzLCB0cmFuc2FjdGlvbiwgY29udGV4dCwgc2VsZkRlYnVnSUQpIC8vIDAgaW4gcHJvZHVjdGlvbiBhbmQgZm9yIHJvb3RzXG4gIHtcbiAgICBpZiAobmVzdGVkQ2hpbGROb2RlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGNoaWxkSW5zdGFuY2VzID0ge307XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBmdW5jdGlvbiAoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0cywgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgIH0sIGNoaWxkSW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhdmVyc2VBbGxDaGlsZHJlbihuZXN0ZWRDaGlsZE5vZGVzLCBpbnN0YW50aWF0ZUNoaWxkLCBjaGlsZEluc3RhbmNlcyk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZEluc3RhbmNlcztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gYW5kIHJldHVybnMgYSBuZXcgc2V0IG9mIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q2hpbGRyZW4gRmxhdCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBuZXcgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBtb3VudEltYWdlcywgcmVtb3ZlZE5vZGVzLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKSAvLyAwIGluIHByb2R1Y3Rpb24gYW5kIGZvciByb290c1xuICB7XG4gICAgLy8gV2UgY3VycmVudGx5IGRvbid0IGhhdmUgYSB3YXkgdG8gdHJhY2sgbW92ZXMgaGVyZSBidXQgaWYgd2UgdXNlIGl0ZXJhdG9yc1xuICAgIC8vIGluc3RlYWQgb2YgZm9yLi5pbiB3ZSBjYW4gemlwIHRoZSBpdGVyYXRvcnMgYW5kIGNoZWNrIGlmIGFuIGl0ZW0gaGFzXG4gICAgLy8gbW92ZWQuXG4gICAgLy8gVE9ETzogSWYgbm90aGluZyBoYXMgY2hhbmdlZCwgcmV0dXJuIHRoZSBwcmV2Q2hpbGRyZW4gb2JqZWN0IHNvIHRoYXQgd2VcbiAgICAvLyBjYW4gcXVpY2tseSBiYWlsb3V0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWQuXG4gICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgcHJldkNoaWxkO1xuICAgIGZvciAobmFtZSBpbiBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuICYmIHByZXZDaGlsZHJlbltuYW1lXTtcbiAgICAgIHZhciBwcmV2RWxlbWVudCA9IHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIG5leHRFbGVtZW50ID0gbmV4dENoaWxkcmVuW25hbWVdO1xuICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsICYmIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNoaWxkLCBuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBwcmV2Q2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldkNoaWxkKSB7XG4gICAgICAgICAgcmVtb3ZlZE5vZGVzW25hbWVdID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDaGlsZCk7XG4gICAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGNoaWxkIG11c3QgYmUgaW5zdGFudGlhdGVkIGJlZm9yZSBpdCdzIG1vdW50ZWQuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRJbnN0YW5jZSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dEVsZW1lbnQsIHRydWUpO1xuICAgICAgICBuZXh0Q2hpbGRyZW5bbmFtZV0gPSBuZXh0Q2hpbGRJbnN0YW5jZTtcbiAgICAgICAgLy8gQ3JlYXRpbmcgbW91bnQgaW1hZ2Ugbm93IGVuc3VyZXMgcmVmcyBhcmUgcmVzb2x2ZWQgaW4gcmlnaHQgb3JkZXJcbiAgICAgICAgLy8gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTAxIGZvciBleHBsYW5hdGlvbikuXG4gICAgICAgIHZhciBuZXh0Q2hpbGRNb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KG5leHRDaGlsZEluc3RhbmNlLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQsIHNlbGZEZWJ1Z0lEKTtcbiAgICAgICAgbW91bnRJbWFnZXMucHVzaChuZXh0Q2hpbGRNb3VudEltYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5tb3VudCBjaGlsZHJlbiB0aGF0IGFyZSBubyBsb25nZXIgcHJlc2VudC5cbiAgICBmb3IgKG5hbWUgaW4gcHJldkNoaWxkcmVuKSB7XG4gICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgcHJldkNoaWxkID0gcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgICByZW1vdmVkTm9kZXNbbmFtZV0gPSBSZWFjdFJlY29uY2lsZXIuZ2V0SG9zdE5vZGUocHJldkNoaWxkKTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNoaWxkLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICogd2hlbiB0aGlzIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcmVuZGVyZWRDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q2hpbGRyZW46IGZ1bmN0aW9uIChyZW5kZXJlZENoaWxkcmVuLCBzYWZlbHkpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocmVuZGVyZWRDaGlsZCwgc2FmZWx5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpLFxuICAgIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdCcpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RXJyb3JVdGlscyA9IHJlcXVpcmUoJy4vUmVhY3RFcnJvclV0aWxzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0Tm9kZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE5vZGVUeXBlcycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBjaGVja1JlYWN0VHlwZVNwZWMgPSByZXF1aXJlKCcuL2NoZWNrUmVhY3RUeXBlU3BlYycpO1xufVxuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBDb21wb3NpdGVUeXBlcyA9IHtcbiAgSW1wdXJlQ2xhc3M6IDAsXG4gIFB1cmVDbGFzczogMSxcbiAgU3RhdGVsZXNzRnVuY3Rpb25hbDogMlxufTtcblxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cblN0YXRlbGVzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gIHZhciBlbGVtZW50ID0gQ29tcG9uZW50KHRoaXMucHJvcHMsIHRoaXMuY29udGV4dCwgdGhpcy51cGRhdGVyKTtcbiAgd2FybklmSW52YWxpZEVsZW1lbnQoQ29tcG9uZW50LCBlbGVtZW50KTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG5mdW5jdGlvbiB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpLCAnJXMoLi4uKTogQSB2YWxpZCBSZWFjdCBlbGVtZW50IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgJyArICdyZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCAnJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbmFsIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgcmV0dXJuICEhKENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNQdXJlQ29tcG9uZW50KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KTtcbn1cblxuLy8gU2VwYXJhdGVkIGludG8gYSBmdW5jdGlvbiB0byBjb250YWluIGRlb3B0aW1pemF0aW9ucyBjYXVzZWQgYnkgdHJ5L2ZpbmFsbHkuXG5mdW5jdGlvbiBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmbiwgZGVidWdJRCwgdGltZXJUeXBlKSB7XG4gIGlmIChkZWJ1Z0lEID09PSAwKSB7XG4gICAgLy8gVG9wLWxldmVsIHdyYXBwZXJzIChzZWUgUmVhY3RNb3VudCkgYW5kIGVtcHR5IGNvbXBvbmVudHMgKHNlZVxuICAgIC8vIFJlYWN0RE9NRW1wdHlDb21wb25lbnQpIGFyZSBpbnZpc2libGUgdG8gaG9va3MgYW5kIGRldnRvb2xzLlxuICAgIC8vIEJvdGggYXJlIGltcGxlbWVudGF0aW9uIGRldGFpbHMgdGhhdCBzaG91bGQgZ28gYXdheSBpbiB0aGUgZnV0dXJlLlxuICAgIHJldHVybiBmbigpO1xuICB9XG5cbiAgUmVhY3RJbnN0cnVtZW50YXRpb24uZGVidWdUb29sLm9uQmVnaW5MaWZlQ3ljbGVUaW1lcihkZWJ1Z0lELCB0aW1lclR5cGUpO1xuICB0cnkge1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZExpZmVDeWNsZVRpbWVyKGRlYnVnSUQsIHRpbWVyVHlwZSk7XG4gIH1cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcbiAgLyoqXG4gICAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBjb21wb3NpdGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX2NvbXBvc2l0ZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9tb3VudE9yZGVyID0gMDtcbiAgICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuXG4gICAgLy8gU2VlIFJlYWN0VXBkYXRlcyBhbmQgUmVhY3RVcGRhdGVRdWV1ZS5cbiAgICB0aGlzLl9wZW5kaW5nQ2FsbGJhY2tzID0gbnVsbDtcblxuICAgIC8vIENvbXBvbmVudFdpbGxVbm1vdW50IHNoYWxsIG9ubHkgYmUgY2FsbGVkIG9uY2VcbiAgICB0aGlzLl9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IGZhbHNlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY29tcG9uZW50LCByZW5kZXJzIG1hcmt1cCwgYW5kIHJlZ2lzdGVycyBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IGhvc3RQYXJlbnRcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBob3N0Q29udGFpbmVySW5mb1xuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P3N0cmluZ30gUmVuZGVyZWQgbWFya3VwIHRvIGJlIGluc2VydGVkIGludG8gdGhlIERPTS5cbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IG5leHRNb3VudElEKys7XG4gICAgdGhpcy5faG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgdGhpcy5faG9zdENvbnRhaW5lckluZm8gPSBob3N0Q29udGFpbmVySW5mbztcblxuICAgIHZhciBwdWJsaWNQcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHRyYW5zYWN0aW9uLmdldFVwZGF0ZVF1ZXVlKCk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBwdWJsaWMgY2xhc3NcbiAgICB2YXIgZG9Db25zdHJ1Y3QgPSBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KTtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgLy8gU3VwcG9ydCBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICBpZiAoIWRvQ29uc3RydWN0ICYmIChpbnN0ID09IG51bGwgfHwgaW5zdC5yZW5kZXIgPT0gbnVsbCkpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XG4gICAgICB3YXJuSWZJbnZhbGlkRWxlbWVudChDb21wb25lbnQsIHJlbmRlcmVkRWxlbWVudCk7XG4gICAgICAhKGluc3QgPT09IG51bGwgfHwgaW5zdCA9PT0gZmFsc2UgfHwgUmVhY3QuaXNWYWxpZEVsZW1lbnQoaW5zdCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzKC4uLik6IEEgdmFsaWQgUmVhY3QgZWxlbWVudCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gWW91IG1heSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZCwgYW4gYXJyYXkgb3Igc29tZSBvdGhlciBpbnZhbGlkIG9iamVjdC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNScsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpbnN0ID0gbmV3IFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpO1xuICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1B1cmVDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgICB0aGlzLl9jb21wb3NpdGVUeXBlID0gQ29tcG9zaXRlVHlwZXMuUHVyZUNsYXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlVHlwZSA9IENvbXBvc2l0ZVR5cGVzLkltcHVyZUNsYXNzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgbGF0ZXIgaW4gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCwgYnV0IGFkZCBhbiBlYXJseVxuICAgICAgLy8gd2FybmluZyBub3cgdG8gaGVscCBkZWJ1Z2dpbmdcbiAgICAgIGlmIChpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb3BzTXV0YXRlZCA9IGluc3QucHJvcHMgIT09IHB1YmxpY1Byb3BzO1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGluc3QucHJvcHMgPT09IHVuZGVmaW5lZCB8fCAhcHJvcHNNdXRhdGVkLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIC8vIFRoZXNlIHNob3VsZCBiZSBzZXQgdXAgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAvLyBzaW1wbGVyIGNsYXNzIGFic3RyYWN0aW9ucywgd2Ugc2V0IHRoZW0gdXAgYWZ0ZXIgdGhlIGZhY3QuXG4gICAgaW5zdC5wcm9wcyA9IHB1YmxpY1Byb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdC51cGRhdGVyID0gdXBkYXRlUXVldWU7XG5cbiAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3Q7XG5cbiAgICAvLyBTdG9yZSBhIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSBiYWNrIHRvIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICAgIFJlYWN0SW5zdGFuY2VNYXAuc2V0KGluc3QsIHRoaXMpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFNpbmNlIHBsYWluIEpTIGNsYXNzZXMgYXJlIGRlZmluZWQgd2l0aG91dCBhbnkgc3BlY2lhbCBpbml0aWFsaXphdGlvblxuICAgICAgLy8gbG9naWMsIHdlIGNhbiBub3QgY2F0Y2ggY29tbW9uIGVycm9ycyBlYXJseS4gVGhlcmVmb3JlLCB3ZSBoYXZlIHRvXG4gICAgICAvLyBjYXRjaCB0aGVtIGhlcmUsIGF0IGluaXRpYWxpemF0aW9uIHRpbWUsIGluc3RlYWQuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdC5nZXRJbml0aWFsU3RhdGUuaXNSZWFjdENsYXNzQXBwcm92ZWQgfHwgaW5zdC5zdGF0ZSwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldERlZmF1bHRQcm9wcyB8fCBpbnN0LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogX3Byb2RJbnZhcmlhbnQoJzEwNicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuICAgIHRoaXMuX3BlbmRpbmdSZXBsYWNlU3RhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICAgIHZhciBtYXJrdXA7XG4gICAgaWYgKGluc3QudW5zdGFibGVfaGFuZGxlRXJyb3IpIHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudFdpdGhFcnJvckhhbmRsaW5nKHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya3VwID0gdGhpcy5wZXJmb3JtSW5pdGlhbE1vdW50KHJlbmRlcmVkRWxlbWVudCwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnREaWRNb3VudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9LCBfdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZE1vdW50LCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIF9jb25zdHJ1Y3RDb21wb25lbnQ6IGZ1bmN0aW9uIChkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnN0cnVjdENvbXBvbmVudFdpdGhvdXRPd25lcihkb0NvbnN0cnVjdCwgcHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyKGRvQ29uc3RydWN0LCBwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgIH1cbiAgfSxcblxuICBfY29uc3RydWN0Q29tcG9uZW50V2l0aG91dE93bmVyOiBmdW5jdGlvbiAoZG9Db25zdHJ1Y3QsIHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgaWYgKGRvQ29uc3RydWN0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICByZXR1cm4gbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCB1cGRhdGVRdWV1ZSk7XG4gICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjdG9yJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoaXMgY2FuIHN0aWxsIGJlIGFuIGluc3RhbmNlIGluIGNhc2Ugb2YgZmFjdG9yeSBjb21wb25lbnRzXG4gICAgLy8gYnV0IHdlJ2xsIGNvdW50IHRoaXMgYXMgdGltZSBzcGVudCByZW5kZXJpbmcgYXMgdGhlIG1vcmUgY29tbW9uIGNhc2UuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZVF1ZXVlKTtcbiAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdyZW5kZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIENvbXBvbmVudChwdWJsaWNQcm9wcywgcHVibGljQ29udGV4dCwgdXBkYXRlUXVldWUpO1xuICAgIH1cbiAgfSxcblxuICBwZXJmb3JtSW5pdGlhbE1vdW50V2l0aEVycm9ySGFuZGxpbmc6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBtYXJrdXA7XG4gICAgdmFyIGNoZWNrcG9pbnQgPSB0cmFuc2FjdGlvbi5jaGVja3BvaW50KCk7XG4gICAgdHJ5IHtcbiAgICAgIG1hcmt1cCA9IHRoaXMucGVyZm9ybUluaXRpYWxNb3VudChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gUm9sbCBiYWNrIHRvIGNoZWNrcG9pbnQsIGhhbmRsZSBlcnJvciAod2hpY2ggbWF5IGFkZCBpdGVtcyB0byB0aGUgdHJhbnNhY3Rpb24pLCBhbmQgdGFrZSBhIG5ldyBjaGVja3BvaW50XG4gICAgICB0cmFuc2FjdGlvbi5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgICAgIHRoaXMuX2luc3RhbmNlLnVuc3RhYmxlX2hhbmRsZUVycm9yKGUpO1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlKSB7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZSh0aGlzLl9pbnN0YW5jZS5wcm9wcywgdGhpcy5faW5zdGFuY2UuY29udGV4dCk7XG4gICAgICB9XG4gICAgICBjaGVja3BvaW50ID0gdHJhbnNhY3Rpb24uY2hlY2twb2ludCgpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudC51bm1vdW50Q29tcG9uZW50KHRydWUpO1xuICAgICAgdHJhbnNhY3Rpb24ucm9sbGJhY2soY2hlY2twb2ludCk7XG5cbiAgICAgIC8vIFRyeSBhZ2FpbiAtIHdlJ3ZlIGluZm9ybWVkIHRoZSBjb21wb25lbnQgYWJvdXQgdGhlIGVycm9yLCBzbyB0aGV5IGNhbiByZW5kZXIgYW4gZXJyb3IgbWVzc2FnZSB0aGlzIHRpbWUuXG4gICAgICAvLyBJZiB0aGlzIHRocm93cyBhZ2FpbiwgdGhlIGVycm9yIHdpbGwgYnViYmxlIHVwIChhbmQgY2FuIGJlIGNhdWdodCBieSBhIGhpZ2hlciBlcnJvciBib3VuZGFyeSkuXG4gICAgICBtYXJrdXAgPSB0aGlzLnBlcmZvcm1Jbml0aWFsTW91bnQocmVuZGVyZWRFbGVtZW50LCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3VwO1xuICB9LFxuXG4gIHBlcmZvcm1Jbml0aWFsTW91bnQ6IGZ1bmN0aW9uIChyZW5kZXJlZEVsZW1lbnQsIGhvc3RQYXJlbnQsIGhvc3RDb250YWluZXJJbmZvLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgZGVidWdJRCA9IDA7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGRlYnVnSUQgPSB0aGlzLl9kZWJ1Z0lEO1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxNb3VudCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgICB9LCBkZWJ1Z0lELCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgICAgLy8gV2hlbiBtb3VudGluZywgY2FsbHMgdG8gYHNldFN0YXRlYCBieSBgY29tcG9uZW50V2lsbE1vdW50YCB3aWxsIHNldFxuICAgICAgLy8gYHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlYCB3aXRob3V0IHRyaWdnZXJpbmcgYSByZS1yZW5kZXIuXG4gICAgICBpZiAodGhpcy5fcGVuZGluZ1N0YXRlUXVldWUpIHtcbiAgICAgICAgaW5zdC5zdGF0ZSA9IHRoaXMuX3Byb2Nlc3NQZW5kaW5nU3RhdGUoaW5zdC5wcm9wcywgaW5zdC5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3QgYSBzdGF0ZWxlc3MgY29tcG9uZW50LCB3ZSBub3cgcmVuZGVyXG4gICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGUgPSBSZWFjdE5vZGVUeXBlcy5nZXRUeXBlKHJlbmRlcmVkRWxlbWVudCk7XG4gICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG5vZGVUeXBlO1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQocmVuZGVyZWRFbGVtZW50LCBub2RlVHlwZSAhPT0gUmVhY3ROb2RlVHlwZXMuRU1QVFkgLyogc2hvdWxkSGF2ZURlYnVnSUQgKi9cbiAgICApO1xuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gY2hpbGQ7XG5cbiAgICB2YXIgbWFya3VwID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCB0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCksIGRlYnVnSUQpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgIHZhciBjaGlsZERlYnVnSURzID0gY2hpbGQuX2RlYnVnSUQgIT09IDAgPyBbY2hpbGQuX2RlYnVnSURdIDogW107XG4gICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vblNldENoaWxkcmVuKGRlYnVnSUQsIGNoaWxkRGVidWdJRHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgZ2V0SG9zdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHNhZmVseSkge1xuICAgIGlmICghdGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVubW91bnQgJiYgIWluc3QuX2NhbGxlZENvbXBvbmVudFdpbGxVbm1vdW50KSB7XG4gICAgICBpbnN0Ll9jYWxsZWRDb21wb25lbnRXaWxsVW5tb3VudCA9IHRydWU7XG5cbiAgICAgIGlmIChzYWZlbHkpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdldE5hbWUoKSArICcuY29tcG9uZW50V2lsbFVubW91bnQoKSc7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sobmFtZSwgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudC5iaW5kKGluc3QpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgbWVhc3VyZUxpZmVDeWNsZVBlcmYoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyZWRDb21wb25lbnQpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50LCBzYWZlbHkpO1xuICAgICAgdGhpcy5fcmVuZGVyZWROb2RlVHlwZSA9IG51bGw7XG4gICAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcbiAgICAvLyBFdmVuIGlmIHRoaXMgY29tcG9uZW50IGlzIHNjaGVkdWxlZCBmb3IgYW5vdGhlciB1cGRhdGUgaW4gUmVhY3RVcGRhdGVzLFxuICAgIC8vIGl0IHdvdWxkIHN0aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIHJlc2V0LlxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gVGhlc2UgZmllbGRzIGRvIG5vdCByZWFsbHkgbmVlZCB0byBiZSByZXNldCBzaW5jZSB0aGlzIG9iamVjdCBpcyBub1xuICAgIC8vIGxvbmdlciBhY2Nlc3NpYmxlLlxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSAwO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gd2hpY2ggYWxsb3cgdGhlIGludGVybmFscyB0byBiZSBwcm9wZXJseSBjbGVhbmVkIHVwIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IGluc3QucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY29udGV4dFR5cGVzO1xuICAgIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gICAgfVxuICAgIHZhciBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tDb250ZXh0VHlwZXMoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgJ2NvbnRleHQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0O1xuXG4gICAgaWYgKGluc3QuZ2V0Q2hpbGRDb250ZXh0KSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25CZWdpblByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGlsZENvbnRleHQgPSBpbnN0LmdldENoaWxkQ29udGV4dCgpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZFByb2Nlc3NpbmdDaGlsZENvbnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCcxMDcnLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dFR5cGVzKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBjaGlsZENvbnRleHQpIHtcbiAgICAgICAgIShuYW1lIGluIENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGtleSBcIiVzXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnMTA4JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2Fzc2lnbih7fSwgY3VycmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50Q29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIGNvbnRleHQgdHlwZXMgYXJlIHZhbGlkXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIGNvbnRleHQgZmllbGQgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tDb250ZXh0VHlwZXM6IGZ1bmN0aW9uICh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgY2hlY2tSZWFjdFR5cGVTcGVjKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgdGhpcy5nZXROYW1lKCksIG51bGwsIHRoaXMuX2RlYnVnSUQpO1xuICAgIH1cbiAgfSxcblxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBuZXh0Q29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50O1xuICAgIHZhciBwcmV2Q29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICB0aGlzLl9wZW5kaW5nRWxlbWVudCA9IG51bGw7XG5cbiAgICB0aGlzLnVwZGF0ZUNvbXBvbmVudCh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBwcmV2Q29udGV4dCwgbmV4dENvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBhbnkgb2YgYF9wZW5kaW5nRWxlbWVudGAsIGBfcGVuZGluZ1N0YXRlUXVldWVgLCBvciBgX3BlbmRpbmdGb3JjZVVwZGF0ZWBcbiAgICogaXMgc2V0LCB1cGRhdGUgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeTogZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmdFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIFJlYWN0UmVjb25jaWxlci5yZWNlaXZlQ29tcG9uZW50KHRoaXMsIHRoaXMuX3BlbmRpbmdFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fY29udGV4dCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVCYXRjaE51bWJlciA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFuIHVwZGF0ZSB0byBhIG1vdW50ZWQgY29tcG9uZW50LiBUaGUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBhbmRcbiAgICogc2hvdWxkQ29tcG9uZW50VXBkYXRlIG1ldGhvZHMgYXJlIGNhbGxlZCwgdGhlbiAoYXNzdW1pbmcgdGhlIHVwZGF0ZSBpc24ndFxuICAgKiBza2lwcGVkKSB0aGUgcmVtYWluaW5nIHVwZGF0ZSBsaWZlY3ljbGUgbWV0aG9kcyBhcmUgY2FsbGVkIGFuZCB0aGUgRE9NXG4gICAqIHJlcHJlc2VudGF0aW9uIGlzIHVwZGF0ZWQuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gcHJldlBhcmVudEVsZW1lbnRcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRQYXJlbnRFbGVtZW50XG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcmV2UGFyZW50RWxlbWVudCwgbmV4dFBhcmVudEVsZW1lbnQsIHByZXZVbm1hc2tlZENvbnRleHQsIG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdBdHRlbXB0ZWQgdG8gdXBkYXRlIGNvbXBvbmVudCBgJXNgIHRoYXQgaGFzIGFscmVhZHkgYmVlbiB1bm1vdW50ZWQgKG9yIGZhaWxlZCB0byBtb3VudCkuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTM2JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICB2YXIgd2lsbFJlY2VpdmUgPSBmYWxzZTtcbiAgICB2YXIgbmV4dENvbnRleHQ7XG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQgb3Igbm90XG4gICAgaWYgKHRoaXMuX2NvbnRleHQgPT09IG5leHRVbm1hc2tlZENvbnRleHQpIHtcbiAgICAgIG5leHRDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q29udGV4dCA9IHRoaXMuX3Byb2Nlc3NDb250ZXh0KG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgICAgd2lsbFJlY2VpdmUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBwcmV2UHJvcHMgPSBwcmV2UGFyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gbmV4dFBhcmVudEVsZW1lbnQucHJvcHM7XG5cbiAgICAvLyBOb3QgYSBzaW1wbGUgc3RhdGUgdXBkYXRlIGJ1dCBhIHByb3BzIHVwZGF0ZVxuICAgIGlmIChwcmV2UGFyZW50RWxlbWVudCAhPT0gbmV4dFBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHdpbGxSZWNlaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBbiB1cGRhdGUgaGVyZSB3aWxsIHNjaGVkdWxlIGFuIHVwZGF0ZSBidXQgaW1tZWRpYXRlbHkgc2V0XG4gICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xuICAgIC8vIGltbWVkaWF0ZWx5IHJlY29uY2lsZWQgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciB0aGUgbmV4dCBiYXRjaC5cbiAgICBpZiAod2lsbFJlY2VpdmUgJiYgaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfSwgdGhpcy5fZGVidWdJRCwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlKSB7XG4gICAgICBpZiAoaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBtZWFzdXJlTGlmZUN5Y2xlUGVyZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gaW5zdC5zaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvc2l0ZVR5cGUgPT09IENvbXBvc2l0ZVR5cGVzLlB1cmVDbGFzcykge1xuICAgICAgICAgIHNob3VsZFVwZGF0ZSA9ICFzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwoaW5zdC5zdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhdGNoTnVtYmVyID0gbnVsbDtcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IF9hc3NpZ24oe30sIHJlcGxhY2UgPyBxdWV1ZVswXSA6IGluc3Quc3RhdGUpO1xuICAgIGZvciAodmFyIGkgPSByZXBsYWNlID8gMSA6IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBhcnRpYWwgPSBxdWV1ZVtpXTtcbiAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIHByb3BzLCBjb250ZXh0KSA6IHBhcnRpYWwpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0U3RhdGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlcyBuZXcgcHJvcHMgYW5kIHN0YXRlLCBub3RpZmllcyBkZWxlZ2F0ZSBtZXRob2RzIG9mIHVwZGF0ZSBhbmRcbiAgICogcGVyZm9ybXMgdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgTmV4dCBlbGVtZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHMgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZSBOZXh0IG9iamVjdCB0byBzZXQgYXMgc3RhdGUuXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHQgTmV4dCBwdWJsaWMgb2JqZWN0IHRvIHNldCBhcyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7P29iamVjdH0gdW5tYXNrZWRDb250ZXh0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcGVyZm9ybUNvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24gKG5leHRFbGVtZW50LCBuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQsIHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICB2YXIgaGFzQ29tcG9uZW50RGlkVXBkYXRlID0gQm9vbGVhbihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZSk7XG4gICAgdmFyIHByZXZQcm9wcztcbiAgICB2YXIgcHJldlN0YXRlO1xuICAgIHZhciBwcmV2Q29udGV4dDtcbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBwcmV2UHJvcHMgPSBpbnN0LnByb3BzO1xuICAgICAgcHJldlN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICAgIHByZXZDb250ZXh0ID0gaW5zdC5jb250ZXh0O1xuICAgIH1cblxuICAgIGlmIChpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0sIHRoaXMuX2RlYnVnSUQsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LmNvbXBvbmVudFdpbGxVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMuX2NvbnRleHQgPSB1bm1hc2tlZENvbnRleHQ7XG4gICAgaW5zdC5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgIGluc3QuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gICAgdGhpcy5fdXBkYXRlUmVuZGVyZWRDb21wb25lbnQodHJhbnNhY3Rpb24sIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoaGFzQ29tcG9uZW50RGlkVXBkYXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBtZWFzdXJlTGlmZUN5Y2xlUGVyZihpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIF90aGlzMi5fZGVidWdJRCwgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRVcGRhdGUuYmluZChpbnN0LCBwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpLCBpbnN0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgdGhlIGNvbXBvbmVudCdzIGByZW5kZXJgIG1ldGhvZCBhbmQgdXBkYXRlIHRoZSBET00gYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2Q29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLl9yZW5kZXJlZENvbXBvbmVudDtcbiAgICB2YXIgcHJldlJlbmRlcmVkRWxlbWVudCA9IHByZXZDb21wb25lbnRJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgdmFyIG5leHRSZW5kZXJlZEVsZW1lbnQgPSB0aGlzLl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQoKTtcblxuICAgIHZhciBkZWJ1Z0lEID0gMDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVidWdJRCA9IHRoaXMuX2RlYnVnSUQ7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZSZW5kZXJlZEVsZW1lbnQsIG5leHRSZW5kZXJlZEVsZW1lbnQpKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIG5leHRSZW5kZXJlZEVsZW1lbnQsIHRyYW5zYWN0aW9uLCB0aGlzLl9wcm9jZXNzQ2hpbGRDb250ZXh0KGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZEhvc3ROb2RlID0gUmVhY3RSZWNvbmNpbGVyLmdldEhvc3ROb2RlKHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q29tcG9uZW50SW5zdGFuY2UsIGZhbHNlKTtcblxuICAgICAgdmFyIG5vZGVUeXBlID0gUmVhY3ROb2RlVHlwZXMuZ2V0VHlwZShuZXh0UmVuZGVyZWRFbGVtZW50KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQobmV4dFJlbmRlcmVkRWxlbWVudCwgbm9kZVR5cGUgIT09IFJlYWN0Tm9kZVR5cGVzLkVNUFRZIC8qIHNob3VsZEhhdmVEZWJ1Z0lEICovXG4gICAgICApO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBjaGlsZDtcblxuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQoY2hpbGQsIHRyYW5zYWN0aW9uLCB0aGlzLl9ob3N0UGFyZW50LCB0aGlzLl9ob3N0Q29udGFpbmVySW5mbywgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSwgZGVidWdJRCk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkZWJ1Z0lEICE9PSAwKSB7XG4gICAgICAgICAgdmFyIGNoaWxkRGVidWdJRHMgPSBjaGlsZC5fZGVidWdJRCAhPT0gMCA/IFtjaGlsZC5fZGVidWdJRF0gOiBbXTtcbiAgICAgICAgICBSZWFjdEluc3RydW1lbnRhdGlvbi5kZWJ1Z1Rvb2wub25TZXRDaGlsZHJlbihkZWJ1Z0lELCBjaGlsZERlYnVnSURzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXBsYWNlTm9kZVdpdGhNYXJrdXAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZDb21wb25lbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZGVuIGluIHNoYWxsb3cgcmVuZGVyaW5nLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVwbGFjZU5vZGVXaXRoTWFya3VwOiBmdW5jdGlvbiAob2xkSG9zdE5vZGUsIG5leHRNYXJrdXAsIHByZXZJbnN0YW5jZSkge1xuICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwKG9sZEhvc3ROb2RlLCBuZXh0TWFya3VwLCBwcmV2SW5zdGFuY2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgcmVuZGVyZWRFbGVtZW50O1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IG1lYXN1cmVMaWZlQ3ljbGVQZXJmKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluc3QucmVuZGVyKCk7XG4gICAgICB9LCB0aGlzLl9kZWJ1Z0lELCAncmVuZGVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3QucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgaWYgKHJlbmRlcmVkRWxlbWVudCA9PT0gdW5kZWZpbmVkICYmIGluc3QucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAvLyBkZXByZWNhdGluZyB0aGlzIGNvbnZlbmllbmNlLlxuICAgICAgICByZW5kZXJlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZEVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlbmRlcmVkRWxlbWVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyB8fCB0aGlzLl9jb21wb3NpdGVUeXBlICE9PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dCgpO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkRWxlbWVudCA9PT0gbnVsbCB8fCByZW5kZXJlZEVsZW1lbnQgPT09IGZhbHNlIHx8IFJlYWN0LmlzVmFsaWRFbGVtZW50KHJlbmRlcmVkRWxlbWVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnJlbmRlcigpOiBBIHZhbGlkIFJlYWN0IGVsZW1lbnQgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuIFlvdSBtYXkgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBfcHJvZEludmFyaWFudCgnMTA5JywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiB2b2lkIDA7XG5cbiAgICByZXR1cm4gcmVuZGVyZWRFbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBMYXppbHkgYWxsb2NhdGVzIHRoZSByZWZzIG9iamVjdCBhbmQgc3RvcmVzIGBjb21wb25lbnRgIGFzIGByZWZgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIFJlZmVyZW5jZSBuYW1lLlxuICAgKiBAcGFyYW0ge2NvbXBvbmVudH0gY29tcG9uZW50IENvbXBvbmVudCB0byBzdG9yZSBhcyBgcmVmYC5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhdHRhY2hSZWY6IGZ1bmN0aW9uIChyZWYsIGNvbXBvbmVudCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICEoaW5zdCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogX3Byb2RJbnZhcmlhbnQoJzExMCcpIDogdm9pZCAwO1xuICAgIHZhciBwdWJsaWNDb21wb25lbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudCAmJiBjb21wb25lbnQuZ2V0TmFtZSA/IGNvbXBvbmVudC5nZXROYW1lKCkgOiAnYSBjb21wb25lbnQnO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHVibGljQ29tcG9uZW50SW5zdGFuY2UgIT0gbnVsbCB8fCBjb21wb25lbnQuX2NvbXBvc2l0ZVR5cGUgIT09IENvbXBvc2l0ZVR5cGVzLlN0YXRlbGVzc0Z1bmN0aW9uYWwsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcyAnICsgJyhTZWUgcmVmIFwiJXNcIiBpbiAlcyBjcmVhdGVkIGJ5ICVzKS4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLicsIHJlZiwgY29tcG9uZW50TmFtZSwgdGhpcy5nZXROYW1lKCkpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcmVmcyA9IGluc3QucmVmcyA9PT0gZW1wdHlPYmplY3QgPyBpbnN0LnJlZnMgPSB7fSA6IGluc3QucmVmcztcbiAgICByZWZzW3JlZl0gPSBwdWJsaWNDb21wb25lbnRJbnN0YW5jZTtcbiAgfSxcblxuICAvKipcbiAgICogRGV0YWNoZXMgYSByZWZlcmVuY2UgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBOYW1lIHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAZmluYWxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGFjaFJlZjogZnVuY3Rpb24gKHJlZikge1xuICAgIHZhciByZWZzID0gdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlZnM7XG4gICAgZGVsZXRlIHJlZnNbcmVmXTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGEgdGV4dCBkZXNjcmlwdGlvbiBvZiB0aGUgY29tcG9uZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgaXRcbiAgICogaW4gZXJyb3IgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG5hbWUgb3IgbnVsbC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXROYW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX2luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yICYmIGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5uYW1lIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHVibGljbHkgYWNjZXNzaWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudCAtIGkuZS4gd2hhdFxuICAgKiBpcyBleHBvc2VkIGJ5IHJlZnMgYW5kIHJldHVybmVkIGJ5IHJlbmRlci4gQ2FuIGJlIG51bGwgZm9yIHN0YXRlbGVzc1xuICAgKiBjb21wb25lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSZWFjdENvbXBvbmVudH0gdGhlIHB1YmxpYyBjb21wb25lbnQgaW5zdGFuY2UuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIGlmICh0aGlzLl9jb21wb3NpdGVUeXBlID09PSBDb21wb3NpdGVUeXBlcy5TdGF0ZWxlc3NGdW5jdGlvbmFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH0sXG5cbiAgLy8gU3R1YlxuICBfaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDogbnVsbFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50Jyk7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgLy8gVGVtcG9yYXJ5IGhhY2suXG4gIC8vIElubGluZSByZXF1aXJlcyBkb24ndCB3b3JrIHdlbGwgd2l0aCBKZXN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNDBcbiAgLy8gUmVtb3ZlIHRoZSBpbmxpbmUgcmVxdWlyZXMgd2hlbiB3ZSBkb24ndCBuZWVkIHRoZW0gYW55bW9yZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzE3OFxuICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVidWdJRCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tcG9uZW50U3RhY2tJbmZvID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0Q3VycmVudFN0YWNrQWRkZW5kdW0oZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBjb21wb25lbnRTdGFja0luZm8pIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUmVhY3RUeXBlU3BlYztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHtcbiAgICBwcm9wOiAncHJvcCcsXG4gICAgY29udGV4dDogJ2NvbnRleHQnLFxuICAgIGNoaWxkQ29udGV4dDogJ2NoaWxkIGNvbnRleHQnXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBuZXh0RGVidWdJRCA9IDE7XG5cbmZ1bmN0aW9uIGdldE5leHREZWJ1Z0lEKCkge1xuICByZXR1cm4gbmV4dERlYnVnSUQrKztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROZXh0RGVidWdJRDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldE5leHREZWJ1Z0lELmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbm1vZHVsZS5leHBvcnRzID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RWxlbWVudFN5bWJvbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEl0ZXJhdG9yRm4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBLZXlFc2NhcGVVdGlscyA9IHJlcXVpcmUoJy4vS2V5RXNjYXBlVXRpbHMnKTtcbnZhciB0cmF2ZXJzZUFsbENoaWxkcmVuID0gcmVxdWlyZSgnLi90cmF2ZXJzZUFsbENoaWxkcmVuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYXZlcnNlQ29udGV4dCBDb250ZXh0IHBhc3NlZCB0aHJvdWdoIHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P1JlYWN0Q29tcG9uZW50fSBjaGlsZCBSZWFjdCBjaGlsZCBjb21wb25lbnQuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWUgU3RyaW5nIG5hbWUgb2Yga2V5IHBhdGggdG8gY2hpbGQuXG4gKiBAcGFyYW0ge251bWJlcj19IHNlbGZEZWJ1Z0lEIE9wdGlvbmFsIGRlYnVnSUQgb2YgdGhlIGN1cnJlbnQgaW50ZXJuYWwgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TaW5nbGVDaGlsZEludG9Db250ZXh0KHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUsIHNlbGZEZWJ1Z0lEKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICBpZiAodHJhdmVyc2VDb250ZXh0ICYmIHR5cGVvZiB0cmF2ZXJzZUNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgICB2YXIga2V5VW5pcXVlID0gcmVzdWx0W25hbWVdID09PSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghUmVhY3RDb21wb25lbnRUcmVlSG9vaykge1xuICAgICAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgIH1cbiAgICAgIGlmICgha2V5VW5pcXVlKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnZmxhdHRlbkNoaWxkcmVuKC4uLik6IEVuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgJyArICdgJXNgLiBDaGlsZCBrZXlzIG11c3QgYmUgdW5pcXVlOyB3aGVuIHR3byBjaGlsZHJlbiBzaGFyZSBhIGtleSwgb25seSAnICsgJ3RoZSBmaXJzdCBjaGlsZCB3aWxsIGJlIHVzZWQuJXMnLCBLZXlFc2NhcGVVdGlscy51bmVzY2FwZShuYW1lKSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChzZWxmRGVidWdJRCkpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5VW5pcXVlICYmIGNoaWxkICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdFtuYW1lXSA9IGNoaWxkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEZsYXR0ZW5zIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC4gQW55IG51bGxcbiAqIGNoaWxkcmVuIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICogQHJldHVybiB7IW9iamVjdH0gZmxhdHRlbmVkIGNoaWxkcmVuIGtleWVkIGJ5IG5hbWUuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbiwgc2VsZkRlYnVnSUQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKHRyYXZlcnNlQ29udGV4dCwgY2hpbGQsIG5hbWUpIHtcbiAgICAgIHJldHVybiBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lLCBzZWxmRGVidWdJRCk7XG4gICAgfSwgcmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmbGF0dGVuU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgcmVzdWx0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW5DaGlsZHJlbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9mbGF0dGVuQ2hpbGRyZW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFRyYW5zYWN0aW9uID0gcmVxdWlyZSgnLi9UcmFuc2FjdGlvbicpO1xudmFyIFJlYWN0SW5zdHJ1bWVudGF0aW9uID0gcmVxdWlyZSgnLi9SZWFjdEluc3RydW1lbnRhdGlvbicpO1xudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyVXBkYXRlUXVldWUnKTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG52YXIgbm9vcENhbGxiYWNrUXVldWUgPSB7XG4gIGVucXVldWU6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IGZhbHNlO1xuICB0aGlzLnVwZGF0ZVF1ZXVlID0gbmV3IFJlYWN0U2VydmVyVXBkYXRlUXVldWUodGhpcyk7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheX0gRW1wdHkgbGlzdCBvZiBvcGVyYXRpb24gd3JhcCBwcm9jZWR1cmVzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9XUkFQUEVSUztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcXVldWUgdG8gY29sbGVjdCBgb25ET01SZWFkeWAgY2FsbGJhY2tzIHdpdGguXG4gICAqL1xuICBnZXRSZWFjdE1vdW50UmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbm9vcENhbGxiYWNrUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgUmVhY3QgYXN5bmMgZXZlbnRzLlxuICAgKi9cbiAgZ2V0VXBkYXRlUXVldWU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy51cGRhdGVRdWV1ZTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge30sXG5cbiAgY2hlY2twb2ludDogZnVuY3Rpb24gKCkge30sXG5cbiAgcm9sbGJhY2s6IGZ1bmN0aW9uICgpIHt9XG59O1xuXG5fYXNzaWduKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG91dHNpZGUgY29tcG9uZW50V2lsbE1vdW50KCkgb24gdGhlIHNlcnZlci4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnKSA6IHZvaWQgMDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHVwZGF0ZSBxdWV1ZSB1c2VkIGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICogSXQgZGVsZWdhdGVzIHRvIFJlYWN0VXBkYXRlUXVldWUgd2hpbGUgc2VydmVyIHJlbmRlcmluZyBpcyBpbiBwcm9ncmVzcyBhbmRcbiAqIHN3aXRjaGVzIHRvIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgY29tcGxldGVkLlxuICogQGNsYXNzIFJlYWN0U2VydmVyVXBkYXRlUXVldWVcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKi9cblxudmFyIFJlYWN0U2VydmVyVXBkYXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlYWN0U2VydmVyVXBkYXRlUXVldWUodHJhbnNhY3Rpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZSk7XG5cbiAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmlzTW91bnRlZCA9IGZ1bmN0aW9uIGlzTW91bnRlZChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVDYWxsYmFjayA9IGZ1bmN0aW9uIGVucXVldWVDYWxsYmFjayhwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlQ2FsbGJhY2socHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuXG4gIFJlYWN0U2VydmVyVXBkYXRlUXVldWUucHJvdG90eXBlLmVucXVldWVGb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzSW5UcmFuc2FjdGlvbigpKSB7XG4gICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVGb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uIGVucXVldWVSZXBsYWNlU3RhdGUocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlUmVwbGFjZVN0YXRlKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuXG5cbiAgUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZVNldFN0YXRlID0gZnVuY3Rpb24gZW5xdWV1ZVNldFN0YXRlKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5pc0luVHJhbnNhY3Rpb24oKSkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0U3RhdGUocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0U2VydmVyVXBkYXRlUXVldWU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RTZXJ2ZXJVcGRhdGVRdWV1ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFNlcnZlclVwZGF0ZVF1ZXVlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgUmVhY3RET01FbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICAvLyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCB1c2VzIHRoaXM6XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG4gIHRoaXMuX2hvc3RDb250YWluZXJJbmZvID0gbnVsbDtcbiAgdGhpcy5fZG9tSUQgPSAwO1xufTtcbl9hc3NpZ24oUmVhY3RET01FbXB0eUNvbXBvbmVudC5wcm90b3R5cGUsIHtcbiAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgaG9zdFBhcmVudCwgaG9zdENvbnRhaW5lckluZm8sIGNvbnRleHQpIHtcbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICB0aGlzLl9ob3N0Q29udGFpbmVySW5mbyA9IGhvc3RDb250YWluZXJJbmZvO1xuXG4gICAgdmFyIG5vZGVWYWx1ZSA9ICcgcmVhY3QtZW1wdHk6ICcgKyB0aGlzLl9kb21JRCArICcgJztcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBub2RlID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KG5vZGVWYWx1ZSk7XG4gICAgICBSZWFjdERPTUNvbXBvbmVudFRyZWUucHJlY2FjaGVOb2RlKHRoaXMsIG5vZGUpO1xuICAgICAgcmV0dXJuIERPTUxhenlUcmVlKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCBpbnNlcnQgYSBjb21tZW50IG5vZGUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uXG4gICAgICAgIC8vIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlciAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm5cbiAgICAgICAgLy8gbm90aGluZy5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuICc8IS0tJyArIG5vZGVWYWx1ZSArICctLT4nO1xuICAgIH1cbiAgfSxcbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKCkge30sXG4gIGdldEhvc3ROb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKHRoaXMpO1xuICB9LFxuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlLnVuY2FjaGVOb2RlKHRoaXMpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUVtcHR5Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NRW1wdHlDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gICEoJ19ob3N0Tm9kZScgaW4gaW5zdEEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJykgOiBfcHJvZEludmFyaWFudCgnMzMnKSA6IHZvaWQgMDtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczMycpIDogdm9pZCAwO1xuXG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSB0ZW1wQS5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSB0ZW1wQi5faG9zdFBhcmVudCkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gaW5zdEEuX2hvc3RQYXJlbnQ7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBpbnN0Qi5faG9zdFBhcmVudDtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0Qikge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGluc3RBLl9ob3N0UGFyZW50O1xuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0QSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnaXNBbmNlc3RvcjogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNScpIDogdm9pZCAwO1xuICAhKCdfaG9zdE5vZGUnIGluIGluc3RCKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpc0FuY2VzdG9yOiBJbnZhbGlkIGFyZ3VtZW50LicpIDogX3Byb2RJbnZhcmlhbnQoJzM1JykgOiB2b2lkIDA7XG5cbiAgd2hpbGUgKGluc3RCKSB7XG4gICAgaWYgKGluc3RCID09PSBpbnN0QSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluc3RCID0gaW5zdEIuX2hvc3RQYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudEluc3RhbmNlKGluc3QpIHtcbiAgISgnX2hvc3ROb2RlJyBpbiBpbnN0KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRQYXJlbnRJbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKSA6IF9wcm9kSW52YXJpYW50KCczNicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBpbnN0Ll9ob3N0UGFyZW50O1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSBwYXRoLmxlbmd0aDsgaS0tID4gMDspIHtcbiAgICBmbihwYXRoW2ldLCAnY2FwdHVyZWQnLCBhcmcpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aFtpXSwgJ2J1YmJsZWQnLCBhcmcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gKiBzaG91bGQgd291bGQgcmVjZWl2ZSBhIGBtb3VzZUVudGVyYCBvciBgbW91c2VMZWF2ZWAgZXZlbnQuXG4gKlxuICogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZSBub3RoaW5nXG4gKiBcImVudGVyZWRcIiBvciBcImxlZnRcIiB0aGF0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgZm4sIGFyZ0Zyb20sIGFyZ1RvKSB7XG4gIHZhciBjb21tb24gPSBmcm9tICYmIHRvID8gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoZnJvbSwgdG8pIDogbnVsbDtcbiAgdmFyIHBhdGhGcm9tID0gW107XG4gIHdoaWxlIChmcm9tICYmIGZyb20gIT09IGNvbW1vbikge1xuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGZyb20uX2hvc3RQYXJlbnQ7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodG8gJiYgdG8gIT09IGNvbW1vbikge1xuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IHRvLl9ob3N0UGFyZW50O1xuICB9XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgcGF0aEZyb20ubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoRnJvbVtpXSwgJ2J1YmJsZWQnLCBhcmdGcm9tKTtcbiAgfVxuICBmb3IgKGkgPSBwYXRoVG8ubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhUb1tpXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FuY2VzdG9yOiBpc0FuY2VzdG9yLFxuICBnZXRMb3dlc3RDb21tb25BbmNlc3RvcjogZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IsXG4gIGdldFBhcmVudEluc3RhbmNlOiBnZXRQYXJlbnRJbnN0YW5jZSxcbiAgdHJhdmVyc2VUd29QaGFzZTogdHJhdmVyc2VUd29QaGFzZSxcbiAgdHJhdmVyc2VFbnRlckxlYXZlOiB0cmF2ZXJzZUVudGVyTGVhdmVcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01UcmVlVHJhdmVyc2FsLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKSxcbiAgICBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01MYXp5VHJlZSA9IHJlcXVpcmUoJy4vRE9NTGF6eVRyZWUnKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xuXG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGJldHdlZW4gY29tbWVudCBub2RlcyBzbyB0aGF0IHRoZXlcbiAqIGNhbiB1bmRlcmdvIHRoZSBzYW1lIHJlY29uY2lsaWF0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlbGVtZW50cy5cbiAqXG4gKiBUT0RPOiBJbnZlc3RpZ2F0ZSByZXByZXNlbnRpbmcgUmVhY3QgY29tcG9uZW50cyBpbiB0aGUgRE9NIHdpdGggdGV4dCBub2Rlcy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RET01UZXh0Q29tcG9uZW50XG4gKiBAZXh0ZW5kcyBSZWFjdENvbXBvbmVudFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gdGV4dDtcbiAgdGhpcy5fc3RyaW5nVGV4dCA9ICcnICsgdGV4dDtcbiAgLy8gUmVhY3RET01Db21wb25lbnRUcmVlIHVzZXMgdGhlc2U6XG4gIHRoaXMuX2hvc3ROb2RlID0gbnVsbDtcbiAgdGhpcy5faG9zdFBhcmVudCA9IG51bGw7XG5cbiAgLy8gUHJvcGVydGllc1xuICB0aGlzLl9kb21JRCA9IDA7XG4gIHRoaXMuX21vdW50SW5kZXggPSAwO1xuICB0aGlzLl9jbG9zaW5nQ29tbWVudCA9IG51bGw7XG4gIHRoaXMuX2NvbW1lbnROb2RlcyA9IG51bGw7XG59O1xuXG5fYXNzaWduKFJlYWN0RE9NVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBob3N0UGFyZW50LCBob3N0Q29udGFpbmVySW5mbywgY29udGV4dCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgcGFyZW50SW5mbztcbiAgICAgIGlmIChob3N0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgcGFyZW50SW5mbyA9IGhvc3RQYXJlbnQuX2FuY2VzdG9ySW5mbztcbiAgICAgIH0gZWxzZSBpZiAoaG9zdENvbnRhaW5lckluZm8gIT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRJbmZvID0gaG9zdENvbnRhaW5lckluZm8uX2FuY2VzdG9ySW5mbztcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRJbmZvKSB7XG4gICAgICAgIC8vIHBhcmVudEluZm8gc2hvdWxkIGFsd2F5cyBiZSBwcmVzZW50IGV4Y2VwdCBmb3IgdGhlIHRvcC1sZXZlbFxuICAgICAgICAvLyBjb21wb25lbnQgd2hlbiBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCB0aGlzLl9zdHJpbmdUZXh0LCB0aGlzLCBwYXJlbnRJbmZvKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZG9tSUQgPSBob3N0Q29udGFpbmVySW5mby5faWRDb3VudGVyKys7XG4gICAgdmFyIG9wZW5pbmdWYWx1ZSA9ICcgcmVhY3QtdGV4dDogJyArIGRvbUlEICsgJyAnO1xuICAgIHZhciBjbG9zaW5nVmFsdWUgPSAnIC9yZWFjdC10ZXh0ICc7XG4gICAgdGhpcy5fZG9tSUQgPSBkb21JRDtcbiAgICB0aGlzLl9ob3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBob3N0Q29udGFpbmVySW5mby5fb3duZXJEb2N1bWVudDtcbiAgICAgIHZhciBvcGVuaW5nQ29tbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlQ29tbWVudChvcGVuaW5nVmFsdWUpO1xuICAgICAgdmFyIGNsb3NpbmdDb21tZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVDb21tZW50KGNsb3NpbmdWYWx1ZSk7XG4gICAgICB2YXIgbGF6eVRyZWUgPSBET01MYXp5VHJlZShvd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSk7XG4gICAgICBET01MYXp5VHJlZS5xdWV1ZUNoaWxkKGxhenlUcmVlLCBET01MYXp5VHJlZShvcGVuaW5nQ29tbWVudCkpO1xuICAgICAgaWYgKHRoaXMuX3N0cmluZ1RleHQpIHtcbiAgICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLl9zdHJpbmdUZXh0KSkpO1xuICAgICAgfVxuICAgICAgRE9NTGF6eVRyZWUucXVldWVDaGlsZChsYXp5VHJlZSwgRE9NTGF6eVRyZWUoY2xvc2luZ0NvbW1lbnQpKTtcbiAgICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5wcmVjYWNoZU5vZGUodGhpcywgb3BlbmluZ0NvbW1lbnQpO1xuICAgICAgdGhpcy5fY2xvc2luZ0NvbW1lbnQgPSBjbG9zaW5nQ29tbWVudDtcbiAgICAgIHJldHVybiBsYXp5VHJlZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVzY2FwZWRUZXh0ID0gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRoaXMuX3N0cmluZ1RleHQpO1xuXG4gICAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgICAgLy8gTm9ybWFsbHkgd2UnZCB3cmFwIHRoaXMgYmV0d2VlbiBjb21tZW50IG5vZGVzIGZvciB0aGUgcmVhc29ucyBzdGF0ZWRcbiAgICAgICAgLy8gYWJvdmUsIGJ1dCBzaW5jZSB0aGlzIGlzIGEgc2l0dWF0aW9uIHdoZXJlIFJlYWN0IHdvbid0IHRha2Ugb3ZlclxuICAgICAgICAvLyAoc3RhdGljIHBhZ2VzKSwgd2UgY2FuIHNpbXBseSByZXR1cm4gdGhlIHRleHQgYXMgaXQgaXMuXG4gICAgICAgIHJldHVybiBlc2NhcGVkVGV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8IS0tJyArIG9wZW5pbmdWYWx1ZSArICctLT4nICsgZXNjYXBlZFRleHQgKyAnPCEtLScgKyBjbG9zaW5nVmFsdWUgKyAnLS0+JztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBjb21wb25lbnQgYnkgdXBkYXRpbmcgdGhlIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFRleHR9IG5leHRUZXh0IFRoZSBuZXh0IHRleHQgY29udGVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRUZXh0LCB0cmFuc2FjdGlvbikge1xuICAgIGlmIChuZXh0VGV4dCAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFRleHQ7XG4gICAgICB2YXIgbmV4dFN0cmluZ1RleHQgPSAnJyArIG5leHRUZXh0O1xuICAgICAgaWYgKG5leHRTdHJpbmdUZXh0ICE9PSB0aGlzLl9zdHJpbmdUZXh0KSB7XG4gICAgICAgIC8vIFRPRE86IFNhdmUgdGhpcyBhcyBwZW5kaW5nIHByb3BzIGFuZCB1c2UgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5XG4gICAgICAgIC8vIGFuZC9vciB1cGRhdGVDb21wb25lbnQgdG8gZG8gdGhlIGFjdHVhbCB1cGRhdGUgZm9yIGNvbnNpc3RlbmN5IHdpdGhcbiAgICAgICAgLy8gb3RoZXIgY29tcG9uZW50IHR5cGVzP1xuICAgICAgICB0aGlzLl9zdHJpbmdUZXh0ID0gbmV4dFN0cmluZ1RleHQ7XG4gICAgICAgIHZhciBjb21tZW50Tm9kZXMgPSB0aGlzLmdldEhvc3ROb2RlKCk7XG4gICAgICAgIERPTUNoaWxkcmVuT3BlcmF0aW9ucy5yZXBsYWNlRGVsaW1pdGVkVGV4dChjb21tZW50Tm9kZXNbMF0sIGNvbW1lbnROb2Rlc1sxXSwgbmV4dFN0cmluZ1RleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXRIb3N0Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBob3N0Tm9kZSA9IHRoaXMuX2NvbW1lbnROb2RlcztcbiAgICBpZiAoaG9zdE5vZGUpIHtcbiAgICAgIHJldHVybiBob3N0Tm9kZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9jbG9zaW5nQ29tbWVudCkge1xuICAgICAgdmFyIG9wZW5pbmdDb21tZW50ID0gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGhpcyk7XG4gICAgICB2YXIgbm9kZSA9IG9wZW5pbmdDb21tZW50Lm5leHRTaWJsaW5nO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgIShub2RlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ01pc3NpbmcgY2xvc2luZyBjb21tZW50IGZvciB0ZXh0IGNvbXBvbmVudCAlcycsIHRoaXMuX2RvbUlEKSA6IF9wcm9kSW52YXJpYW50KCc2NycsIHRoaXMuX2RvbUlEKSA6IHZvaWQgMDtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUgPT09ICcgL3JlYWN0LXRleHQgJykge1xuICAgICAgICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgaG9zdE5vZGUgPSBbdGhpcy5faG9zdE5vZGUsIHRoaXMuX2Nsb3NpbmdDb21tZW50XTtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBob3N0Tm9kZTtcbiAgICByZXR1cm4gaG9zdE5vZGU7XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2Nsb3NpbmdDb21tZW50ID0gbnVsbDtcbiAgICB0aGlzLl9jb21tZW50Tm9kZXMgPSBudWxsO1xuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZS51bmNhY2hlTm9kZSh0aGlzKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01UZXh0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NVGV4dENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG5cbnZhciBSRVNFVF9CQVRDSEVEX1VQREFURVMgPSB7XG4gIGluaXRpYWxpemU6IGVtcHR5RnVuY3Rpb24sXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB9XG59O1xuXG52YXIgRkxVU0hfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogUmVhY3RVcGRhdGVzLmZsdXNoQmF0Y2hlZFVwZGF0ZXMuYmluZChSZWFjdFVwZGF0ZXMpXG59O1xuXG52YXIgVFJBTlNBQ1RJT05fV1JBUFBFUlMgPSBbRkxVU0hfQkFUQ0hFRF9VUERBVEVTLCBSRVNFVF9CQVRDSEVEX1VQREFURVNdO1xuXG5mdW5jdGlvbiBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24oKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbn1cblxuX2Fzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9XG59KTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGEsIGIsIGMsIGQsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShjYWxsYmFjaywgbnVsbCwgYSwgYiwgYywgZCwgZSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3k7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZ2V0RXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2dldEV2ZW50VGFyZ2V0Jyk7XG52YXIgZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbicpO1xuXG4vKipcbiAqIEZpbmQgdGhlIGRlZXBlc3QgUmVhY3QgY29tcG9uZW50IGNvbXBsZXRlbHkgY29udGFpbmluZyB0aGUgcm9vdCBvZiB0aGVcbiAqIHBhc3NlZC1pbiBpbnN0YW5jZSAoZm9yIHVzZSB3aGVuIGVudGlyZSBSZWFjdCB0cmVlcyBhcmUgbmVzdGVkIHdpdGhpbiBlYWNoXG4gKiBvdGhlcikuIElmIFJlYWN0IHRyZWVzIGFyZSBub3QgbmVzdGVkLCByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnQoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdC5faG9zdFBhcmVudCkge1xuICAgIGluc3QgPSBpbnN0Ll9ob3N0UGFyZW50O1xuICB9XG4gIHZhciByb290Tm9kZSA9IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICB2YXIgY29udGFpbmVyID0gcm9vdE5vZGUucGFyZW50Tm9kZTtcbiAgcmV0dXJuIFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShjb250YWluZXIpO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHRoaXMudG9wTGV2ZWxUeXBlID0gdG9wTGV2ZWxUeXBlO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gIHRoaXMuYW5jZXN0b3JzID0gW107XG59XG5fYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gYW5jZXN0b3IgJiYgZmluZFBhcmVudChhbmNlc3Rvcik7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAgICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXBCdWJibGVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAgICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIG1vbml0b3JTY3JvbGxWYWx1ZTogZnVuY3Rpb24gKHJlZnJlc2gpIHtcbiAgICB2YXIgY2FsbGJhY2sgPSBzY3JvbGxWYWx1ZU1vbml0b3IuYmluZChudWxsLCByZWZyZXNoKTtcbiAgICBFdmVudExpc3RlbmVyLmxpc3Rlbih3aW5kb3csICdzY3JvbGwnLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgICBpZiAoIVJlYWN0RXZlbnRMaXN0ZW5lci5fZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBib29rS2VlcGluZyA9IFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5nZXRQb29sZWQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5yZWxlYXNlKGJvb2tLZWVwaW5nKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudExpc3RlbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RXZlbnRMaXN0ZW5lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHN1cHBsaWVkIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcbiAqIG1heSBiZSBuZWdhdGl2ZSBvciBleGNlZWQgdGhlIGVsZW1lbnQgYm91bmRhcmllcyAod2hpY2ggaXMgcG9zc2libGUgdXNpbmdcbiAqIGluZXJ0aWFsIHNjcm9sbGluZykuXG4gKlxuICogQHBhcmFtIHtET01XaW5kb3d8RE9NRWxlbWVudH0gc2Nyb2xsYWJsZVxuICogQHJldHVybiB7b2JqZWN0fSBNYXAgd2l0aCBgeGAgYW5kIGB5YCBrZXlzLlxuICovXG5cbmZ1bmN0aW9uIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uKHNjcm9sbGFibGUpIHtcbiAgaWYgKHNjcm9sbGFibGUuV2luZG93ICYmIHNjcm9sbGFibGUgaW5zdGFuY2VvZiBzY3JvbGxhYmxlLldpbmRvdykge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBzY3JvbGxhYmxlLnBhZ2VYT2Zmc2V0IHx8IHNjcm9sbGFibGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICB5OiBzY3JvbGxhYmxlLnBhZ2VZT2Zmc2V0IHx8IHNjcm9sbGFibGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBzY3JvbGxhYmxlLnNjcm9sbExlZnQsXG4gICAgeTogc2Nyb2xsYWJsZS5zY3JvbGxUb3BcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5VdGlscyA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5VdGlscycpO1xudmFyIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEhvc3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0SG9zdENvbXBvbmVudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBSZWFjdEluamVjdGlvbiA9IHtcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LmluamVjdGlvbixcbiAgRE9NUHJvcGVydHk6IERPTVByb3BlcnR5LmluamVjdGlvbixcbiAgRW1wdHlDb21wb25lbnQ6IFJlYWN0RW1wdHlDb21wb25lbnQuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLFxuICBFdmVudFBsdWdpblV0aWxzOiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbixcbiAgRXZlbnRFbWl0dGVyOiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuaW5qZWN0aW9uLFxuICBIb3N0Q29tcG9uZW50OiBSZWFjdEhvc3RDb21wb25lbnQuaW5qZWN0aW9uLFxuICBVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5qZWN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0SW5qZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdElucHV0U2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdElucHV0U2VsZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0cnVtZW50YXRpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5zdHJ1bWVudGF0aW9uJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VycmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAqL1xudmFyIE9OX0RPTV9SRUFEWV9RVUVVRUlORyA9IHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBgb25ET01SZWFkeWAgcXVldWUuXG4gICAqL1xuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkucmVzZXQoKTtcbiAgfSxcblxuICAvKipcbiAgICogQWZ0ZXIgRE9NIGlzIGZsdXNoZWQsIGludm9rZSBhbGwgcmVnaXN0ZXJlZCBgb25ET01SZWFkeWAgY2FsbGJhY2tzLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5ub3RpZnlBbGwoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFeGVjdXRlZCB3aXRoaW4gdGhlIHNjb3BlIG9mIHRoZSBgVHJhbnNhY3Rpb25gIGluc3RhbmNlLiBDb25zaWRlciB0aGVzZSBhc1xuICogYmVpbmcgbWVtYmVyIG1ldGhvZHMsIGJ1dCB3aXRoIGFuIGltcGxpZWQgb3JkZXJpbmcgd2hpbGUgYmVpbmcgaXNvbGF0ZWQgZnJvbVxuICogZWFjaCBvdGhlci5cbiAqL1xudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW1NFTEVDVElPTl9SRVNUT1JBVElPTiwgRVZFTlRfU1VQUFJFU1NJT04sIE9OX0RPTV9SRUFEWV9RVUVVRUlOR107XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFRSQU5TQUNUSU9OX1dSQVBQRVJTLnB1c2goe1xuICAgIGluaXRpYWxpemU6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkJlZ2luRmx1c2gsXG4gICAgY2xvc2U6IFJlYWN0SW5zdHJ1bWVudGF0aW9uLmRlYnVnVG9vbC5vbkVuZEZsdXNoXG4gIH0pO1xufVxuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24odXNlQ3JlYXRlRWxlbWVudCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG4gIC8vIE9ubHkgc2VydmVyLXNpZGUgcmVuZGVyaW5nIHJlYWxseSBuZWVkcyB0aGlzIG9wdGlvbiAoc2VlXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ2ApLCBidXQgc2VydmVyLXNpZGUgdXNlc1xuICAvLyBgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbmAgaW5zdGVhZC4gVGhpcyBvcHRpb24gaXMgaGVyZSBzbyB0aGF0IGl0J3NcbiAgLy8gYWNjZXNzaWJsZSBhbmQgZGVmYXVsdHMgdG8gZmFsc2Ugd2hlbiBgUmVhY3RET01Db21wb25lbnRgIGFuZFxuICAvLyBgUmVhY3RET01UZXh0Q29tcG9uZW50YCBjaGVja3MgaXQgaW4gYG1vdW50Q29tcG9uZW50YC5gXG4gIHRoaXMucmVuZGVyVG9TdGF0aWNNYXJrdXAgPSBmYWxzZTtcbiAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZChudWxsKTtcbiAgdGhpcy51c2VDcmVhdGVFbGVtZW50ID0gdXNlQ3JlYXRlRWxlbWVudDtcbn1cblxudmFyIE1peGluID0ge1xuICAvKipcbiAgICogQHNlZSBUcmFuc2FjdGlvblxuICAgKiBAYWJzdHJhY3RcbiAgICogQGZpbmFsXG4gICAqIEByZXR1cm4ge2FycmF5PG9iamVjdD59IExpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICogICBUT0RPOiBjb252ZXJ0IHRvIGFycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IFJlYWN0IGFzeW5jIGV2ZW50cy5cbiAgICovXG4gIGdldFVwZGF0ZVF1ZXVlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFJlYWN0VXBkYXRlUXVldWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmUgY3VycmVudCB0cmFuc2FjdGlvbiBzdGF0ZSAtLSBpZiB0aGUgcmV0dXJuIHZhbHVlIGZyb20gdGhpcyBtZXRob2QgaXNcbiAgICogcGFzc2VkIHRvIGByb2xsYmFja2AsIHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHJlc2V0IHRvIHRoYXQgc3RhdGUuXG4gICAqL1xuICBjaGVja3BvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmVhY3RNb3VudFJlYWR5IGlzIHRoZSBvdXIgb25seSBzdGF0ZWZ1bCB3cmFwcGVyXG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5LmNoZWNrcG9pbnQoKTtcbiAgfSxcblxuICByb2xsYmFjazogZnVuY3Rpb24gKGNoZWNrcG9pbnQpIHtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeS5yb2xsYmFjayhjaGVja3BvaW50KTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5fYXNzaWduKFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbiwgTWl4aW4pO1xuXG5Qb29sZWRDbGFzcy5hZGRQb29saW5nVG8oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQgPSByZXF1aXJlKCcuL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQnKTtcbnZhciBnZXRUZXh0Q29udGVudEFjY2Vzc29yID0gcmVxdWlyZSgnLi9nZXRUZXh0Q29udGVudEFjY2Vzc29yJyk7XG5cbi8qKlxuICogV2hpbGUgYGlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgb24gdGhlIFNlbGVjdGlvbiBvYmplY3QgYW5kIGBjb2xsYXBzZWRgXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIFJhbmdlIG9iamVjdCwgSUUxMSBzb21ldGltZXMgZ2V0cyB0aGVtIHdyb25nLlxuICogSWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhbmQgb2Zmc2V0cyBhcmUgdGhlIHNhbWUsIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQuXG4gKi9cbmZ1bmN0aW9uIGlzQ29sbGFwc2VkKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCkge1xuICByZXR1cm4gYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvck9mZnNldCA9PT0gZm9jdXNPZmZzZXQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHByb3ByaWF0ZSBhbmNob3IgYW5kIGZvY3VzIG5vZGUvb2Zmc2V0IHBhaXJzIGZvciBJRS5cbiAqXG4gKiBUaGUgY2F0Y2ggaGVyZSBpcyB0aGF0IElFJ3Mgc2VsZWN0aW9uIEFQSSBkb2Vzbid0IHByb3ZpZGUgaW5mb3JtYXRpb25cbiAqIGFib3V0IHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBpcyBmb3J3YXJkIG9yIGJhY2t3YXJkLCBzbyB3ZSBoYXZlIHRvXG4gKiBiZWhhdmUgYXMgdGhvdWdoIGl0J3MgYWx3YXlzIGZvcndhcmQuXG4gKlxuICogSUUgdGV4dCBkaWZmZXJzIGZyb20gbW9kZXJuIHNlbGVjdGlvbiBpbiB0aGF0IGl0IGJlaGF2ZXMgYXMgdGhvdWdoXG4gKiBibG9jayBlbGVtZW50cyBlbmQgd2l0aCBhIG5ldyBsaW5lLiBUaGlzIG1lYW5zIGNoYXJhY3RlciBvZmZzZXRzIHdpbGxcbiAqIGRpZmZlciBiZXR3ZWVuIHRoZSB0d28gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SUVPZmZzZXRzKG5vZGUpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGRvY3VtZW50LnNlbGVjdGlvbjtcbiAgdmFyIHNlbGVjdGVkUmFuZ2UgPSBzZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgdmFyIHNlbGVjdGVkTGVuZ3RoID0gc2VsZWN0ZWRSYW5nZS50ZXh0Lmxlbmd0aDtcblxuICAvLyBEdXBsaWNhdGUgc2VsZWN0aW9uIHNvIHdlIGNhbiBtb3ZlIHJhbmdlIHdpdGhvdXQgYnJlYWtpbmcgdXNlciBzZWxlY3Rpb24uXG4gIHZhciBmcm9tU3RhcnQgPSBzZWxlY3RlZFJhbmdlLmR1cGxpY2F0ZSgpO1xuICBmcm9tU3RhcnQubW92ZVRvRWxlbWVudFRleHQobm9kZSk7XG4gIGZyb21TdGFydC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHNlbGVjdGVkUmFuZ2UpO1xuXG4gIHZhciBzdGFydE9mZnNldCA9IGZyb21TdGFydC50ZXh0Lmxlbmd0aDtcbiAgdmFyIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgc2VsZWN0ZWRMZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnRPZmZzZXQsXG4gICAgZW5kOiBlbmRPZmZzZXRcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIHZhciBjdXJyZW50UmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblxuICAvLyBJbiBGaXJlZm94LCByYW5nZS5zdGFydENvbnRhaW5lciBhbmQgcmFuZ2UuZW5kQ29udGFpbmVyIGNhbiBiZSBcImFub255bW91c1xuICAvLyBkaXZzXCIsIGUuZy4gdGhlIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzXG4gIC8vIGRpdnMgZG8gbm90IHNlZW0gdG8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkXG4gIC8vIGVycm9yXCIgaWYgYW55IG9mIGl0cyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlXG4gIC8vIHdheSB0byBhdm9pZCBlcnJvcmluZyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3JcbiAgLy8gbm9uLWFub255bW91cyBkaXZzIGFuZCBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlO1xuICAgIGN1cnJlbnRSYW5nZS5lbmRDb250YWluZXIubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gSWYgdGhlIG5vZGUgYW5kIG9mZnNldCB2YWx1ZXMgYXJlIHRoZSBzYW1lLCB0aGUgc2VsZWN0aW9uIGlzIGNvbGxhcHNlZC5cbiAgLy8gYFNlbGVjdGlvbi5pc0NvbGxhcHNlZGAgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBidXQgSUUgc29tZXRpbWVzIGdldHNcbiAgLy8gdGhpcyB2YWx1ZSB3cm9uZy5cbiAgdmFyIGlzU2VsZWN0aW9uQ29sbGFwc2VkID0gaXNDb2xsYXBzZWQoc2VsZWN0aW9uLmFuY2hvck5vZGUsIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsIHNlbGVjdGlvbi5mb2N1c05vZGUsIHNlbGVjdGlvbi5mb2N1c09mZnNldCk7XG5cbiAgdmFyIHJhbmdlTGVuZ3RoID0gaXNTZWxlY3Rpb25Db2xsYXBzZWQgPyAwIDogY3VycmVudFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuXG4gIHZhciB0ZW1wUmFuZ2UgPSBjdXJyZW50UmFuZ2UuY2xvbmVSYW5nZSgpO1xuICB0ZW1wUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICB0ZW1wUmFuZ2Uuc2V0RW5kKGN1cnJlbnRSYW5nZS5zdGFydENvbnRhaW5lciwgY3VycmVudFJhbmdlLnN0YXJ0T2Zmc2V0KTtcblxuICB2YXIgaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPSBpc0NvbGxhcHNlZCh0ZW1wUmFuZ2Uuc3RhcnRDb250YWluZXIsIHRlbXBSYW5nZS5zdGFydE9mZnNldCwgdGVtcFJhbmdlLmVuZENvbnRhaW5lciwgdGVtcFJhbmdlLmVuZE9mZnNldCk7XG5cbiAgdmFyIHN0YXJ0ID0gaXNUZW1wUmFuZ2VDb2xsYXBzZWQgPyAwIDogdGVtcFJhbmdlLnRvU3RyaW5nKCkubGVuZ3RoO1xuICB2YXIgZW5kID0gc3RhcnQgKyByYW5nZUxlbmd0aDtcblxuICAvLyBEZXRlY3Qgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkLlxuICB2YXIgZGV0ZWN0aW9uUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRTdGFydChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpO1xuICBkZXRlY3Rpb25SYW5nZS5zZXRFbmQoZm9jdXNOb2RlLCBmb2N1c09mZnNldCk7XG4gIHZhciBpc0JhY2t3YXJkID0gZGV0ZWN0aW9uUmFuZ2UuY29sbGFwc2VkO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IGlzQmFja3dhcmQgPyBlbmQgOiBzdGFydCxcbiAgICBlbmQ6IGlzQmFja3dhcmQgPyBzdGFydCA6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0SUVPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZHVwbGljYXRlKCk7XG4gIHZhciBzdGFydCwgZW5kO1xuXG4gIGlmIChvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLnN0YXJ0O1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9IGVsc2UgaWYgKG9mZnNldHMuc3RhcnQgPiBvZmZzZXRzLmVuZCkge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5lbmQ7XG4gICAgZW5kID0gb2Zmc2V0cy5zdGFydDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gIH1cblxuICByYW5nZS5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gIHJhbmdlLnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0JywgcmFuZ2UpO1xuICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQgLSBzdGFydCk7XG4gIHJhbmdlLnNlbGVjdCgpO1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0TW9kZXJuT2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIGlmICghd2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlW2dldFRleHRDb250ZW50QWNjZXNzb3IoKV0ubGVuZ3RoO1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihvZmZzZXRzLnN0YXJ0LCBsZW5ndGgpO1xuICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogTWF0aC5taW4ob2Zmc2V0cy5lbmQsIGxlbmd0aCk7XG5cbiAgLy8gSUUgMTEgdXNlcyBtb2Rlcm4gc2VsZWN0aW9uLCBidXQgZG9lc24ndCBzdXBwb3J0IHRoZSBleHRlbmQgbWV0aG9kLlxuICAvLyBGbGlwIGJhY2t3YXJkIHNlbGVjdGlvbnMsIHNvIHdlIGNhbiBzZXQgd2l0aCBhIHNpbmdsZSByYW5nZS5cbiAgaWYgKCFzZWxlY3Rpb24uZXh0ZW5kICYmIHN0YXJ0ID4gZW5kKSB7XG4gICAgdmFyIHRlbXAgPSBlbmQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gICAgc3RhcnQgPSB0ZW1wO1xuICB9XG5cbiAgdmFyIHN0YXJ0TWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBzdGFydCk7XG4gIHZhciBlbmRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIGVuZCk7XG5cbiAgaWYgKHN0YXJ0TWFya2VyICYmIGVuZE1hcmtlcikge1xuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnRNYXJrZXIubm9kZSwgc3RhcnRNYXJrZXIub2Zmc2V0KTtcbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICBzZWxlY3Rpb24uZXh0ZW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2Uuc2V0RW5kKGVuZE1hcmtlci5ub2RlLCBlbmRNYXJrZXIub2Zmc2V0KTtcbiAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB1c2VJRU9mZnNldHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ3NlbGVjdGlvbicgaW4gZG9jdW1lbnQgJiYgISgnZ2V0U2VsZWN0aW9uJyBpbiB3aW5kb3cpO1xuXG52YXIgUmVhY3RET01TZWxlY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAgICovXG4gIGdldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IGdldElFT2Zmc2V0cyA6IGdldE1vZGVybk9mZnNldHMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICAgKi9cbiAgc2V0T2Zmc2V0czogdXNlSUVPZmZzZXRzID8gc2V0SUVPZmZzZXRzIDogc2V0TW9kZXJuT2Zmc2V0c1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVNlbGVjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYW55IG5vZGUgcmV0dXJuIHRoZSBmaXJzdCBsZWFmIG5vZGUgd2l0aG91dCBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cblxuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBkb2MgPSBvYmplY3QgPyBvYmplY3Qub3duZXJEb2N1bWVudCB8fCBvYmplY3QgOiBkb2N1bWVudDtcbiAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLy8gV2UgdXNlIGF0dHJpYnV0ZXMgZm9yIGV2ZXJ5dGhpbmcgU1ZHIHNvIGxldCdzIGF2b2lkIHNvbWUgZHVwbGljYXRpb24gYW5kIHJ1blxuLy8gY29kZSBpbnN0ZWFkLlxuLy8gVGhlIGZvbGxvd2luZyBhcmUgYWxsIHNwZWNpZmllZCBpbiB0aGUgSFRNTCBjb25maWcgYWxyZWFkeSBzbyB3ZSBleGNsdWRlIGhlcmUuXG4vLyAtIGNsYXNzIChhcyBjbGFzc05hbWUpXG4vLyAtIGNvbG9yXG4vLyAtIGhlaWdodFxuLy8gLSBpZFxuLy8gLSBsYW5nXG4vLyAtIG1heFxuLy8gLSBtZWRpYVxuLy8gLSBtZXRob2Rcbi8vIC0gbWluXG4vLyAtIG5hbWVcbi8vIC0gc3R5bGVcbi8vIC0gdGFyZ2V0XG4vLyAtIHR5cGVcbi8vIC0gd2lkdGhcbnZhciBBVFRSUyA9IHtcbiAgYWNjZW50SGVpZ2h0OiAnYWNjZW50LWhlaWdodCcsXG4gIGFjY3VtdWxhdGU6IDAsXG4gIGFkZGl0aXZlOiAwLFxuICBhbGlnbm1lbnRCYXNlbGluZTogJ2FsaWdubWVudC1iYXNlbGluZScsXG4gIGFsbG93UmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6IDAsXG4gIGFtcGxpdHVkZTogMCxcbiAgYXJhYmljRm9ybTogJ2FyYWJpYy1mb3JtJyxcbiAgYXNjZW50OiAwLFxuICBhdHRyaWJ1dGVOYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZVR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b1JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6IDAsXG4gIGJhc2VGcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZVByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJhc2VsaW5lU2hpZnQ6ICdiYXNlbGluZS1zaGlmdCcsXG4gIGJib3g6IDAsXG4gIGJlZ2luOiAwLFxuICBiaWFzOiAwLFxuICBieTogMCxcbiAgY2FsY01vZGU6ICdjYWxjTW9kZScsXG4gIGNhcEhlaWdodDogJ2NhcC1oZWlnaHQnLFxuICBjbGlwOiAwLFxuICBjbGlwUGF0aDogJ2NsaXAtcGF0aCcsXG4gIGNsaXBSdWxlOiAnY2xpcC1ydWxlJyxcbiAgY2xpcFBhdGhVbml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjb2xvckludGVycG9sYXRpb246ICdjb2xvci1pbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsXG4gIGNvbG9yUHJvZmlsZTogJ2NvbG9yLXByb2ZpbGUnLFxuICBjb2xvclJlbmRlcmluZzogJ2NvbG9yLXJlbmRlcmluZycsXG4gIGNvbnRlbnRTY3JpcHRUeXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50U3R5bGVUeXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogMCxcbiAgY3g6IDAsXG4gIGN5OiAwLFxuICBkOiAwLFxuICBkZWNlbGVyYXRlOiAwLFxuICBkZXNjZW50OiAwLFxuICBkaWZmdXNlQ29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246IDAsXG4gIGRpc3BsYXk6IDAsXG4gIGRpdmlzb3I6IDAsXG4gIGRvbWluYW50QmFzZWxpbmU6ICdkb21pbmFudC1iYXNlbGluZScsXG4gIGR1cjogMCxcbiAgZHg6IDAsXG4gIGR5OiAwLFxuICBlZGdlTW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAwLFxuICBlbmFibGVCYWNrZ3JvdW5kOiAnZW5hYmxlLWJhY2tncm91bmQnLFxuICBlbmQ6IDAsXG4gIGV4cG9uZW50OiAwLFxuICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6IDAsXG4gIGZpbGxPcGFjaXR5OiAnZmlsbC1vcGFjaXR5JyxcbiAgZmlsbFJ1bGU6ICdmaWxsLXJ1bGUnLFxuICBmaWx0ZXI6IDAsXG4gIGZpbHRlclJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlclVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZENvbG9yOiAnZmxvb2QtY29sb3InLFxuICBmbG9vZE9wYWNpdHk6ICdmbG9vZC1vcGFjaXR5JyxcbiAgZm9jdXNhYmxlOiAwLFxuICBmb250RmFtaWx5OiAnZm9udC1mYW1pbHknLFxuICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gIGZvbnRTaXplQWRqdXN0OiAnZm9udC1zaXplLWFkanVzdCcsXG4gIGZvbnRTdHJldGNoOiAnZm9udC1zdHJldGNoJyxcbiAgZm9udFN0eWxlOiAnZm9udC1zdHlsZScsXG4gIGZvbnRWYXJpYW50OiAnZm9udC12YXJpYW50JyxcbiAgZm9udFdlaWdodDogJ2ZvbnQtd2VpZ2h0JyxcbiAgZm9ybWF0OiAwLFxuICBmcm9tOiAwLFxuICBmeDogMCxcbiAgZnk6IDAsXG4gIGcxOiAwLFxuICBnMjogMCxcbiAgZ2x5cGhOYW1lOiAnZ2x5cGgtbmFtZScsXG4gIGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsOiAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsXG4gIGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbDogJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJyxcbiAgZ2x5cGhSZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50VHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudFVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6IDAsXG4gIGhvcml6QWR2WDogJ2hvcml6LWFkdi14JyxcbiAgaG9yaXpPcmlnaW5YOiAnaG9yaXotb3JpZ2luLXgnLFxuICBpZGVvZ3JhcGhpYzogMCxcbiAgaW1hZ2VSZW5kZXJpbmc6ICdpbWFnZS1yZW5kZXJpbmcnLFxuICAnaW4nOiAwLFxuICBpbjI6IDAsXG4gIGludGVyY2VwdDogMCxcbiAgazogMCxcbiAgazE6IDAsXG4gIGsyOiAwLFxuICBrMzogMCxcbiAgazQ6IDAsXG4gIGtlcm5lbE1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbFVuaXRMZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogMCxcbiAga2V5UG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5U3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXlUaW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoQWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyU3BhY2luZzogJ2xldHRlci1zcGFjaW5nJyxcbiAgbGlnaHRpbmdDb2xvcjogJ2xpZ2h0aW5nLWNvbG9yJyxcbiAgbGltaXRpbmdDb25lQW5nbGU6ICdsaW1pdGluZ0NvbmVBbmdsZScsXG4gIGxvY2FsOiAwLFxuICBtYXJrZXJFbmQ6ICdtYXJrZXItZW5kJyxcbiAgbWFya2VyTWlkOiAnbWFya2VyLW1pZCcsXG4gIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgbWFya2VySGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VyVW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcldpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAwLFxuICBtYXNrQ29udGVudFVuaXRzOiAnbWFza0NvbnRlbnRVbml0cycsXG4gIG1hc2tVbml0czogJ21hc2tVbml0cycsXG4gIG1hdGhlbWF0aWNhbDogMCxcbiAgbW9kZTogMCxcbiAgbnVtT2N0YXZlczogJ251bU9jdGF2ZXMnLFxuICBvZmZzZXQ6IDAsXG4gIG9wYWNpdHk6IDAsXG4gIG9wZXJhdG9yOiAwLFxuICBvcmRlcjogMCxcbiAgb3JpZW50OiAwLFxuICBvcmllbnRhdGlvbjogMCxcbiAgb3JpZ2luOiAwLFxuICBvdmVyZmxvdzogMCxcbiAgb3ZlcmxpbmVQb3NpdGlvbjogJ292ZXJsaW5lLXBvc2l0aW9uJyxcbiAgb3ZlcmxpbmVUaGlja25lc3M6ICdvdmVybGluZS10aGlja25lc3MnLFxuICBwYWludE9yZGVyOiAncGFpbnQtb3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlLTEnLFxuICBwYXRoTGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5Db250ZW50VW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVyblRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJuVW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyRXZlbnRzOiAncG9pbnRlci1ldmVudHMnLFxuICBwb2ludHM6IDAsXG4gIHBvaW50c0F0WDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c0F0WTogJ3BvaW50c0F0WScsXG4gIHBvaW50c0F0WjogJ3BvaW50c0F0WicsXG4gIHByZXNlcnZlQWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVBc3BlY3RSYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmVVbml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcjogMCxcbiAgcmFkaXVzOiAwLFxuICByZWZYOiAncmVmWCcsXG4gIHJlZlk6ICdyZWZZJyxcbiAgcmVuZGVyaW5nSW50ZW50OiAncmVuZGVyaW5nLWludGVudCcsXG4gIHJlcGVhdENvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXREdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZEV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZEZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc3RhcnQ6IDAsXG4gIHJlc3VsdDogMCxcbiAgcm90YXRlOiAwLFxuICByeDogMCxcbiAgcnk6IDAsXG4gIHNjYWxlOiAwLFxuICBzZWVkOiAwLFxuICBzaGFwZVJlbmRlcmluZzogJ3NoYXBlLXJlbmRlcmluZycsXG4gIHNsb3BlOiAwLFxuICBzcGFjaW5nOiAwLFxuICBzcGVjdWxhckNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyRXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6IDAsXG4gIHNwcmVhZE1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0T2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGREZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogMCxcbiAgc3RlbXY6IDAsXG4gIHN0aXRjaFRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgc3RvcE9wYWNpdHk6ICdzdG9wLW9wYWNpdHknLFxuICBzdHJpa2V0aHJvdWdoUG9zaXRpb246ICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaFRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJyxcbiAgc3RyaW5nOiAwLFxuICBzdHJva2U6IDAsXG4gIHN0cm9rZURhc2hhcnJheTogJ3N0cm9rZS1kYXNoYXJyYXknLFxuICBzdHJva2VEYXNob2Zmc2V0OiAnc3Ryb2tlLWRhc2hvZmZzZXQnLFxuICBzdHJva2VMaW5lY2FwOiAnc3Ryb2tlLWxpbmVjYXAnLFxuICBzdHJva2VMaW5lam9pbjogJ3N0cm9rZS1saW5lam9pbicsXG4gIHN0cm9rZU1pdGVybGltaXQ6ICdzdHJva2UtbWl0ZXJsaW1pdCcsXG4gIHN0cm9rZU9wYWNpdHk6ICdzdHJva2Utb3BhY2l0eScsXG4gIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgc3VyZmFjZVNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtTGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxlVmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXRYOiAndGFyZ2V0WCcsXG4gIHRhcmdldFk6ICd0YXJnZXRZJyxcbiAgdGV4dEFuY2hvcjogJ3RleHQtYW5jaG9yJyxcbiAgdGV4dERlY29yYXRpb246ICd0ZXh0LWRlY29yYXRpb24nLFxuICB0ZXh0UmVuZGVyaW5nOiAndGV4dC1yZW5kZXJpbmcnLFxuICB0ZXh0TGVuZ3RoOiAndGV4dExlbmd0aCcsXG4gIHRvOiAwLFxuICB0cmFuc2Zvcm06IDAsXG4gIHUxOiAwLFxuICB1MjogMCxcbiAgdW5kZXJsaW5lUG9zaXRpb246ICd1bmRlcmxpbmUtcG9zaXRpb24nLFxuICB1bmRlcmxpbmVUaGlja25lc3M6ICd1bmRlcmxpbmUtdGhpY2tuZXNzJyxcbiAgdW5pY29kZTogMCxcbiAgdW5pY29kZUJpZGk6ICd1bmljb2RlLWJpZGknLFxuICB1bmljb2RlUmFuZ2U6ICd1bmljb2RlLXJhbmdlJyxcbiAgdW5pdHNQZXJFbTogJ3VuaXRzLXBlci1lbScsXG4gIHZBbHBoYWJldGljOiAndi1hbHBoYWJldGljJyxcbiAgdkhhbmdpbmc6ICd2LWhhbmdpbmcnLFxuICB2SWRlb2dyYXBoaWM6ICd2LWlkZW9ncmFwaGljJyxcbiAgdk1hdGhlbWF0aWNhbDogJ3YtbWF0aGVtYXRpY2FsJyxcbiAgdmFsdWVzOiAwLFxuICB2ZWN0b3JFZmZlY3Q6ICd2ZWN0b3ItZWZmZWN0JyxcbiAgdmVyc2lvbjogMCxcbiAgdmVydEFkdlk6ICd2ZXJ0LWFkdi15JyxcbiAgdmVydE9yaWdpblg6ICd2ZXJ0LW9yaWdpbi14JyxcbiAgdmVydE9yaWdpblk6ICd2ZXJ0LW9yaWdpbi15JyxcbiAgdmlld0JveDogJ3ZpZXdCb3gnLFxuICB2aWV3VGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6IDAsXG4gIHdpZHRoczogMCxcbiAgd29yZFNwYWNpbmc6ICd3b3JkLXNwYWNpbmcnLFxuICB3cml0aW5nTW9kZTogJ3dyaXRpbmctbW9kZScsXG4gIHg6IDAsXG4gIHhIZWlnaHQ6ICd4LWhlaWdodCcsXG4gIHgxOiAwLFxuICB4MjogMCxcbiAgeENoYW5uZWxTZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgeGxpbmtBcmNyb2xlOiAneGxpbms6YXJjcm9sZScsXG4gIHhsaW5rSHJlZjogJ3hsaW5rOmhyZWYnLFxuICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgeGxpbmtTaG93OiAneGxpbms6c2hvdycsXG4gIHhsaW5rVGl0bGU6ICd4bGluazp0aXRsZScsXG4gIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICB4bWxCYXNlOiAneG1sOmJhc2UnLFxuICB4bWxuczogMCxcbiAgeG1sbnNYbGluazogJ3htbG5zOnhsaW5rJyxcbiAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgeG1sU3BhY2U6ICd4bWw6c3BhY2UnLFxuICB5OiAwLFxuICB5MTogMCxcbiAgeTI6IDAsXG4gIHlDaGFubmVsU2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogMCxcbiAgem9vbUFuZFBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHt9LFxuICBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiB7XG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rSHJlZjogTlMueGxpbmssXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxuICAgIHhsaW5rVGl0bGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXG4gICAgeG1sQmFzZTogTlMueG1sLFxuICAgIHhtbExhbmc6IE5TLnhtbCxcbiAgICB4bWxTcGFjZTogTlMueG1sXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7fVxufTtcblxuT2JqZWN0LmtleXMoQVRUUlMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBTVkdET01Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzW2tleV0gPSAwO1xuICBpZiAoQVRUUlNba2V5XSkge1xuICAgIFNWR0RPTVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzW2tleV0gPSBBVFRSU1trZXldO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RE9NQ29tcG9uZW50VHJlZSA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnRUcmVlJyk7XG52YXIgUmVhY3RJbnB1dFNlbGVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3RJbnB1dFNlbGVjdGlvbicpO1xudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBpc1RleHRJbnB1dEVsZW1lbnQgPSByZXF1aXJlKCcuL2lzVGV4dElucHV0RWxlbWVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8vIFRyYWNrIHdoZXRoZXIgYSBsaXN0ZW5lciBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKCFoYXNMaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gUmVhY3RET01Db21wb25lbnRUcmVlLmdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgLy8gVHJhY2sgdGhlIGlucHV0IG5vZGUgdGhhdCBoYXMgZm9jdXMuXG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSAndG9wU2VsZWN0aW9uQ2hhbmdlJzpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25TZWxlY3QnKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gcmVxdWlyZSgnLi9SZWFjdERPTUNvbXBvbmVudFRyZWUnKTtcbnZhciBTeW50aGV0aWNBbmltYXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQW5pbWF0aW9uRXZlbnQnKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RvdWNoRXZlbnQnKTtcbnZhciBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RyYW5zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcbnZhciBTeW50aGV0aWNXaGVlbEV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNXaGVlbEV2ZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFsndG9wQWJvcnQnXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICogICAndG9wQWJvcnQnOiB7IHNhbWVDb25maWcgfVxuICogfTtcbiAqL1xudmFyIGV2ZW50VHlwZXMgPSB7fTtcbnZhciB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7fTtcblsnYWJvcnQnLCAnYW5pbWF0aW9uRW5kJywgJ2FuaW1hdGlvbkl0ZXJhdGlvbicsICdhbmltYXRpb25TdGFydCcsICdibHVyJywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnY2xpY2snLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdFbnRlcicsICdkcmFnRXhpdCcsICdkcmFnTGVhdmUnLCAnZHJhZ092ZXInLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZm9jdXMnLCAnaW5wdXQnLCAnaW52YWxpZCcsICdrZXlEb3duJywgJ2tleVByZXNzJywgJ2tleVVwJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VEb3duJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdzY3JvbGwnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoRW5kJywgJ3RvdWNoTW92ZScsICd0b3VjaFN0YXJ0JywgJ3RyYW5zaXRpb25FbmQnLCAndm9sdW1lQ2hhbmdlJywgJ3dhaXRpbmcnLCAnd2hlZWwnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcbiAgdmFyIHRvcEV2ZW50ID0gJ3RvcCcgKyBjYXBpdGFsaXplZEV2ZW50O1xuXG4gIHZhciB0eXBlID0ge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBvbkV2ZW50LFxuICAgICAgY2FwdHVyZWQ6IG9uRXZlbnQgKyAnQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcEV2ZW50XVxuICB9O1xuICBldmVudFR5cGVzW2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufSk7XG5cbnZhciBvbkNsaWNrTGlzdGVuZXJzID0ge307XG5cbmZ1bmN0aW9uIGdldERpY3Rpb25hcnlLZXkoaW5zdCkge1xuICAvLyBQcmV2ZW50cyBWOCBwZXJmb3JtYW5jZSBpc3N1ZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvNzIzMlxuICByZXR1cm4gJy4nICsgaW5zdC5fcm9vdE5vZGVJRDtcbn1cblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlICd0b3BBYm9ydCc6XG4gICAgICBjYXNlICd0b3BDYW5QbGF5JzpcbiAgICAgIGNhc2UgJ3RvcENhblBsYXlUaHJvdWdoJzpcbiAgICAgIGNhc2UgJ3RvcER1cmF0aW9uQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcEVtcHRpZWQnOlxuICAgICAgY2FzZSAndG9wRW5jcnlwdGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVuZGVkJzpcbiAgICAgIGNhc2UgJ3RvcEVycm9yJzpcbiAgICAgIGNhc2UgJ3RvcElucHV0JzpcbiAgICAgIGNhc2UgJ3RvcEludmFsaWQnOlxuICAgICAgY2FzZSAndG9wTG9hZCc6XG4gICAgICBjYXNlICd0b3BMb2FkZWREYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRlZE1ldGFkYXRhJzpcbiAgICAgIGNhc2UgJ3RvcExvYWRTdGFydCc6XG4gICAgICBjYXNlICd0b3BQYXVzZSc6XG4gICAgICBjYXNlICd0b3BQbGF5JzpcbiAgICAgIGNhc2UgJ3RvcFBsYXlpbmcnOlxuICAgICAgY2FzZSAndG9wUHJvZ3Jlc3MnOlxuICAgICAgY2FzZSAndG9wUmF0ZUNoYW5nZSc6XG4gICAgICBjYXNlICd0b3BSZXNldCc6XG4gICAgICBjYXNlICd0b3BTZWVrZWQnOlxuICAgICAgY2FzZSAndG9wU2Vla2luZyc6XG4gICAgICBjYXNlICd0b3BTdGFsbGVkJzpcbiAgICAgIGNhc2UgJ3RvcFN1Ym1pdCc6XG4gICAgICBjYXNlICd0b3BTdXNwZW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRpbWVVcGRhdGUnOlxuICAgICAgY2FzZSAndG9wVm9sdW1lQ2hhbmdlJzpcbiAgICAgIGNhc2UgJ3RvcFdhaXRpbmcnOlxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ2xpY2snOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICBjYXNlICd0b3BNb3VzZU1vdmUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BNb3VzZU91dCc6XG4gICAgICBjYXNlICd0b3BNb3VzZU92ZXInOlxuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BEcmFnJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbmQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VudGVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFeGl0JzpcbiAgICAgIGNhc2UgJ3RvcERyYWdMZWF2ZSc6XG4gICAgICBjYXNlICd0b3BEcmFnT3Zlcic6XG4gICAgICBjYXNlICd0b3BEcmFnU3RhcnQnOlxuICAgICAgY2FzZSAndG9wRHJvcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVG91Y2hDYW5jZWwnOlxuICAgICAgY2FzZSAndG9wVG91Y2hFbmQnOlxuICAgICAgY2FzZSAndG9wVG91Y2hNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25FbmQnOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uSXRlcmF0aW9uJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvblN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRyYW5zaXRpb25FbmQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFNjcm9sbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFdoZWVsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29weSc6XG4gICAgICBjYXNlICd0b3BDdXQnOlxuICAgICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IF9wcm9kSW52YXJpYW50KCc4NicsIHRvcExldmVsVHlwZSkgOiB2b2lkIDA7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gICAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAgIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uQ2xpY2snICYmICFpc0ludGVyYWN0aXZlKGluc3QuX3RhZykpIHtcbiAgICAgIHZhciBrZXkgPSBnZXREaWN0aW9uYXJ5S2V5KGluc3QpO1xuICAgICAgdmFyIG5vZGUgPSBSZWFjdERPTUNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1trZXldKSB7XG4gICAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XSA9IEV2ZW50TGlzdGVuZXIubGlzdGVuKG5vZGUsICdjbGljaycsIGVtcHR5RnVuY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB3aWxsRGVsZXRlTGlzdGVuZXI6IGZ1bmN0aW9uIChpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkNsaWNrJyAmJiAhaXNJbnRlcmFjdGl2ZShpbnN0Ll90YWcpKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0RGljdGlvbmFyeUtleShpbnN0KTtcbiAgICAgIG9uQ2xpY2tMaXN0ZW5lcnNba2V5XS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2tleV07XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNBbmltYXRpb25FdmVudCwgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0FuaW1hdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEZvY3VzRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0ZvY3VzRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0ZvY3VzRXZlbnQsIEZvY3VzRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljRm9jdXNFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKCcuL2dldEV2ZW50S2V5Jyk7XG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNLZXlib2FyZEV2ZW50LCBLZXlib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0tleWJvYXJkRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RXZlbnRDaGFyQ29kZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRDaGFyQ29kZScpO1xuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgODogJ0JhY2tzcGFjZScsXG4gIDk6ICdUYWInLFxuICAxMjogJ0NsZWFyJyxcbiAgMTM6ICdFbnRlcicsXG4gIDE2OiAnU2hpZnQnLFxuICAxNzogJ0NvbnRyb2wnLFxuICAxODogJ0FsdCcsXG4gIDE5OiAnUGF1c2UnLFxuICAyMDogJ0NhcHNMb2NrJyxcbiAgMjc6ICdFc2NhcGUnLFxuICAzMjogJyAnLFxuICAzMzogJ1BhZ2VVcCcsXG4gIDM0OiAnUGFnZURvd24nLFxuICAzNTogJ0VuZCcsXG4gIDM2OiAnSG9tZScsXG4gIDM3OiAnQXJyb3dMZWZ0JyxcbiAgMzg6ICdBcnJvd1VwJyxcbiAgMzk6ICdBcnJvd1JpZ2h0JyxcbiAgNDA6ICdBcnJvd0Rvd24nLFxuICA0NTogJ0luc2VydCcsXG4gIDQ2OiAnRGVsZXRlJyxcbiAgMTEyOiAnRjEnLFxuICAxMTM6ICdGMicsXG4gIDExNDogJ0YzJyxcbiAgMTE1OiAnRjQnLFxuICAxMTY6ICdGNScsXG4gIDExNzogJ0Y2JyxcbiAgMTE4OiAnRjcnLFxuICAxMTk6ICdGOCcsXG4gIDEyMDogJ0Y5JyxcbiAgMTIxOiAnRjEwJyxcbiAgMTIyOiAnRjExJyxcbiAgMTIzOiAnRjEyJyxcbiAgMTQ0OiAnTnVtTG9jaycsXG4gIDE0NTogJ1Njcm9sbExvY2snLFxuICAyMjQ6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEV2ZW50S2V5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL2dldEV2ZW50S2V5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBEcmFnRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRHJhZ0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNEcmFnRXZlbnQsIERyYWdFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljRHJhZ0V2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1N5bnRoZXRpY1RvdWNoRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LCBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9TeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG5cbmZ1bmN0aW9uIFJlYWN0RE9NQ29udGFpbmVySW5mbyh0b3BMZXZlbFdyYXBwZXIsIG5vZGUpIHtcbiAgdmFyIGluZm8gPSB7XG4gICAgX3RvcExldmVsV3JhcHBlcjogdG9wTGV2ZWxXcmFwcGVyLFxuICAgIF9pZENvdW50ZXI6IDEsXG4gICAgX293bmVyRG9jdW1lbnQ6IG5vZGUgPyBub2RlLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFID8gbm9kZSA6IG5vZGUub3duZXJEb2N1bWVudCA6IG51bGwsXG4gICAgX25vZGU6IG5vZGUsXG4gICAgX3RhZzogbm9kZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGwsXG4gICAgX25hbWVzcGFjZVVSSTogbm9kZSA/IG5vZGUubmFtZXNwYWNlVVJJIDogbnVsbFxuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGluZm8uX2FuY2VzdG9ySW5mbyA9IG5vZGUgPyB2YWxpZGF0ZURPTU5lc3RpbmcudXBkYXRlZEFuY2VzdG9ySW5mbyhudWxsLCBpbmZvLl90YWcsIG51bGwpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUNvbnRhaW5lckluZm87XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01Db250YWluZXJJbmZvLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0ge1xuICB1c2VDcmVhdGVFbGVtZW50OiB0cnVlLFxuICB1c2VGaWJlcjogZmFsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GZWF0dXJlRmxhZ3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuXG52YXIgVEFHX0VORCA9IC9cXC8/Pi87XG52YXIgQ09NTUVOVF9TVEFSVCA9IC9ePFxcIVxcLVxcLS87XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcblxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MsIGNvbW1lbnRzIGFuZCBzZWxmLWNsb3NpbmcgdGFncylcbiAgICBpZiAoQ09NTUVOVF9TVEFSVC50ZXN0KG1hcmt1cCkpIHtcbiAgICAgIHJldHVybiBtYXJrdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCB0byB1c2VcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbGVtZW50IHJvb3QgUmVhY3QgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG1hcmt1cCBpcyB0aGUgc2FtZVxuICAgKi9cbiAgY2FuUmV1c2VNYXJrdXA6IGZ1bmN0aW9uIChtYXJrdXAsIGVsZW1lbnQpIHtcbiAgICB2YXIgZXhpc3RpbmdDaGVja3N1bSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFJlYWN0TWFya3VwQ2hlY2tzdW0uQ0hFQ0tTVU1fQVRUUl9OQU1FKTtcbiAgICBleGlzdGluZ0NoZWNrc3VtID0gZXhpc3RpbmdDaGVja3N1bSAmJiBwYXJzZUludChleGlzdGluZ0NoZWNrc3VtLCAxMCk7XG4gICAgdmFyIG1hcmt1cENoZWNrc3VtID0gYWRsZXIzMihtYXJrdXApO1xuICAgIHJldHVybiBtYXJrdXBDaGVja3N1bSA9PT0gZXhpc3RpbmdDaGVja3N1bTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE1hcmt1cENoZWNrc3VtO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBNT0QgPSA2NTUyMTtcblxuLy8gYWRsZXIzMiBpcyBub3QgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nLCBhbmQgaXMgb25seSB1c2VkIHRvIHNhbml0eSBjaGVjayB0aGF0XG4vLyBtYXJrdXAgZ2VuZXJhdGVkIG9uIHRoZSBzZXJ2ZXIgbWF0Y2hlcyB0aGUgbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LlxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiAoYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBTaGVldEpTIHZlcnNpb24pIGhhcyBiZWVuIG9wdGltaXplZFxuLy8gZm9yIG91ciB1c2UgY2FzZSwgYXQgdGhlIGV4cGVuc2Ugb2YgY29uZm9ybWluZyB0byB0aGUgYWRsZXIzMiBzcGVjaWZpY2F0aW9uXG4vLyBmb3Igbm9uLWFzY2lpIGlucHV0cy5cbmZ1bmN0aW9uIGFkbGVyMzIoZGF0YSkge1xuICB2YXIgYSA9IDE7XG4gIHZhciBiID0gMDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoO1xuICB2YXIgbSA9IGwgJiB+MHgzO1xuICB3aGlsZSAoaSA8IG0pIHtcbiAgICB2YXIgbiA9IE1hdGgubWluKGkgKyA0MDk2LCBtKTtcbiAgICBmb3IgKDsgaSA8IG47IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9hZGxlcjMyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMTUuNi4xJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdFZlcnNpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCdyZWFjdC9saWIvUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSByZXF1aXJlKCcuL1JlYWN0RE9NQ29tcG9uZW50VHJlZScpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcblxudmFyIGdldEhvc3RDb21wb25lbnRGcm9tQ29tcG9zaXRlID0gcmVxdWlyZSgnLi9nZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZScpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBlbGVtZW50LlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdGRvbS5maW5kZG9tbm9kZVxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR8RE9NRWxlbWVudH0gY29tcG9uZW50T3JFbGVtZW50XG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gVGhlIHJvb3Qgbm9kZSBvZiB0aGlzIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb21wb25lbnRPckVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICB9XG5cbiAgdmFyIGluc3QgPSBSZWFjdEluc3RhbmNlTWFwLmdldChjb21wb25lbnRPckVsZW1lbnQpO1xuICBpZiAoaW5zdCkge1xuICAgIGluc3QgPSBnZXRIb3N0Q29tcG9uZW50RnJvbUNvbXBvc2l0ZShpbnN0KTtcbiAgICByZXR1cm4gaW5zdCA/IFJlYWN0RE9NQ29tcG9uZW50VHJlZS5nZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIDogbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kRE9NTm9kZSB3YXMgY2FsbGVkIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiBfcHJvZEludmFyaWFudCgnNDQnKSA6IHZvaWQgMDtcbiAgfSBlbHNlIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCBhcHBlYXJzIHRvIGJlIG5laXRoZXIgUmVhY3RDb21wb25lbnQgbm9yIERPTU5vZGUgKGtleXM6ICVzKScsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpIDogX3Byb2RJbnZhcmlhbnQoJzQ1JywgT2JqZWN0LmtleXMoY29tcG9uZW50T3JFbGVtZW50KSkgOiB2b2lkIDA7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kRE9NTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9maW5kRE9NTm9kZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpblJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcmVhY3RQcm9wcyA9IHtcbiAgICBjaGlsZHJlbjogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgICBrZXk6IHRydWUsXG4gICAgcmVmOiB0cnVlLFxuXG4gICAgYXV0b0ZvY3VzOiB0cnVlLFxuICAgIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgICB2YWx1ZUxpbms6IHRydWUsXG4gICAgZGVmYXVsdENoZWNrZWQ6IHRydWUsXG4gICAgY2hlY2tlZExpbms6IHRydWUsXG4gICAgaW5uZXJIVE1MOiB0cnVlLFxuICAgIHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzogdHJ1ZSxcbiAgICBvbkZvY3VzSW46IHRydWUsXG4gICAgb25Gb2N1c091dDogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5ID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIGRlYnVnSUQpIHtcbiAgICBpZiAoRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChyZWFjdFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHJlYWN0UHJvcHNbbmFtZV0gfHwgd2FybmVkUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBkYXRhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBFdmVudFBsdWdpblJlZ2lzdHJ5LnBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIGlmIChzdGFuZGFyZE5hbWUgIT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIERPTSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlIHVuYWJsZSB0byBndWVzcyB3aGljaCBwcm9wIHRoZSB1c2VyIGludGVuZGVkLlxuICAgICAgLy8gSXQgaXMgbGlrZWx5IHRoYXQgdGhlIHVzZXIgd2FzIGp1c3QgYmxpbmRseSBzcHJlYWRpbmcvZm9yd2FyZGluZyBwcm9wc1xuICAgICAgLy8gQ29tcG9uZW50cyBzaG91bGQgYmUgY2FyZWZ1bCB0byBvbmx5IHJlbmRlciB2YWxpZCBwcm9wcy9hdHRyaWJ1dGVzLlxuICAgICAgLy8gV2FybmluZyB3aWxsIGJlIGludm9rZWQgaW4gd2FyblVua25vd25Qcm9wZXJ0aWVzIHRvIGFsbG93IGdyb3VwaW5nLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIGVsZW1lbnQucHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkoZWxlbWVudC50eXBlLCBrZXksIGRlYnVnSUQpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vua25vd24gcHJvcCAlcyBvbiA8JXM+IHRhZy4gUmVtb3ZlIHRoaXMgcHJvcCBmcm9tIHRoZSBlbGVtZW50LiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC11bmtub3duLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9IGVsc2UgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVbmtub3duIHByb3BzICVzIG9uIDwlcz4gdGFnLiBSZW1vdmUgdGhlc2UgcHJvcHMgZnJvbSB0aGUgZWxlbWVudC4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtdW5rbm93bi1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gaGFuZGxlRWxlbWVudChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwgfHwgdHlwZW9mIGVsZW1lbnQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVsZW1lbnQudHlwZS5pbmRleE9mKCctJykgPj0gMCB8fCBlbGVtZW50LnByb3BzLmlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyhkZWJ1Z0lELCBlbGVtZW50KTtcbn1cblxudmFyIFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vayA9IHtcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVW5rbm93blByb3BlcnR5SG9vaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2xpYi9SZWFjdERPTVVua25vd25Qcm9wZXJ0eUhvb2suanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJ3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rJyk7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC50eXBlICE9PSAnaW5wdXQnICYmIGVsZW1lbnQudHlwZSAhPT0gJ3RleHRhcmVhJyAmJiBlbGVtZW50LnR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlbGVtZW50LnByb3BzICE9IG51bGwgJiYgZWxlbWVudC5wcm9wcy52YWx1ZSA9PT0gbnVsbCAmJiAhZGlkV2FyblZhbHVlTnVsbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIHRoZSBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIGVsZW1lbnQudHlwZSwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRTdGFja0FkZGVuZHVtQnlJRChkZWJ1Z0lEKSkgOiB2b2lkIDA7XG5cbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rID0ge1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH0sXG4gIG9uQmVmb3JlVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01OdWxsSW5wdXRWYWx1ZVByb3BIb29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NTnVsbElucHV0VmFsdWVQcm9wSG9vay5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdENvbXBvbmVudFRyZWVIb29rID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgRE9NUHJvcGVydHkuQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eSh0YWdOYW1lLCBuYW1lLCBkZWJ1Z0lEKSB7XG4gIGlmICh3YXJuZWRQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZS5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVtsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBBUklBIGF0dHJpYnV0ZSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JbnZhbGlkQVJJQVByb3BzKGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBlbGVtZW50LnByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KGVsZW1lbnQudHlwZSwga2V5LCBkZWJ1Z0lEKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIGludmFsaWRQcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gaW52YWxpZFByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuXG4gIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCBlbGVtZW50LnR5cGUsIFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCkpIDogdm9pZCAwO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgZWxlbWVudC50eXBlLCBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldFN0YWNrQWRkZW5kdW1CeUlEKGRlYnVnSUQpKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCB8fCB0eXBlb2YgZWxlbWVudC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZWxlbWVudC50eXBlLmluZGV4T2YoJy0nKSA+PSAwIHx8IGVsZW1lbnQucHJvcHMuaXMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyhkZWJ1Z0lELCBlbGVtZW50KTtcbn1cblxudmFyIFJlYWN0RE9NSW52YWxpZEFSSUFIb29rID0ge1xuICBvbkJlZm9yZU1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoZGVidWdJRCwgZWxlbWVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBoYW5kbGVFbGVtZW50KGRlYnVnSUQsIGVsZW1lbnQpO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVVcGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uIChkZWJ1Z0lELCBlbGVtZW50KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGhhbmRsZUVsZW1lbnQoZGVidWdJRCwgZWxlbWVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW52YWxpZEFSSUFIb29rO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vbGliL1JlYWN0RE9NSW52YWxpZEFSSUFIb29rLmpzIiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjcmVhdGVIaXN0b3J5IGZyb20gJ2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxuLyoqXG4gKiBUaGUgcHVibGljIEFQSSBmb3IgYSA8Um91dGVyPiB0aGF0IHN0b3JlcyBsb2NhdGlvbiBpbiBtZW1vcnkuXG4gKi9cblxudmFyIE1lbW9yeVJvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhNZW1vcnlSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIE1lbW9yeVJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbW9yeVJvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuaGlzdG9yeSA9IGNyZWF0ZUhpc3RvcnkoX3RoaXMucHJvcHMpLCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIE1lbW9yeVJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBNZW1vcnlSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbk1lbW9yeVJvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGluaXRpYWxFbnRyaWVzOiBQcm9wVHlwZXMuYXJyYXksXG4gIGluaXRpYWxJbmRleDogUHJvcFR5cGVzLm51bWJlcixcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IE1lbW9yeVJvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL01lbW9yeVJvdXRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0xvY2F0aW9uVXRpbHMgPSByZXF1aXJlKCcuL0xvY2F0aW9uVXRpbHMnKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdW5kZWZpbmVkID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdW5kZWZpbmVkID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KSgpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gKDAsIF9Mb2NhdGlvblV0aWxzLmNyZWF0ZUxvY2F0aW9uKShlbnRyeSwgdW5kZWZpbmVkLCBjcmVhdGVLZXkoKSkgOiAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IF9QYXRoVXRpbHMuY3JlYXRlUGF0aDtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICAoMCwgX3dhcm5pbmcyLmRlZmF1bHQpKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBoaXN0b3J5LmluZGV4O1xuICAgICAgdmFyIG5leHRJbmRleCA9IHByZXZJbmRleCArIDE7XG5cbiAgICAgIHZhciBuZXh0RW50cmllcyA9IGhpc3RvcnkuZW50cmllcy5zbGljZSgwKTtcbiAgICAgIGlmIChuZXh0RW50cmllcy5sZW5ndGggPiBuZXh0SW5kZXgpIHtcbiAgICAgICAgbmV4dEVudHJpZXMuc3BsaWNlKG5leHRJbmRleCwgbmV4dEVudHJpZXMubGVuZ3RoIC0gbmV4dEluZGV4LCBsb2NhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0RW50cmllcy5wdXNoKGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICBpbmRleDogbmV4dEluZGV4LFxuICAgICAgICBlbnRyaWVzOiBuZXh0RW50cmllc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KSghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byByZXBsYWNlIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSAoMCwgX0xvY2F0aW9uVXRpbHMuY3JlYXRlTG9jYXRpb24pKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2hpc3RvcnkvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzQWJzb2x1dGUgPSBmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGhuYW1lKSB7XG4gIHJldHVybiBwYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKVxudmFyIHNwbGljZU9uZSA9IGZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpIHtcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgfWxpc3QucG9wKCk7XG59O1xuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIGhlYXZpbHkgb24gbm9kZSdzIHVybC5wYXJzZVxudmFyIHJlc29sdmVQYXRobmFtZSA9IGZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZSh0bykge1xuICB2YXIgZnJvbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJyc7XG5cbiAgdmFyIHRvUGFydHMgPSB0byAmJiB0by5zcGxpdCgnLycpIHx8IFtdO1xuICB2YXIgZnJvbVBhcnRzID0gZnJvbSAmJiBmcm9tLnNwbGl0KCcvJykgfHwgW107XG5cbiAgdmFyIGlzVG9BYnMgPSB0byAmJiBpc0Fic29sdXRlKHRvKTtcbiAgdmFyIGlzRnJvbUFicyA9IGZyb20gJiYgaXNBYnNvbHV0ZShmcm9tKTtcbiAgdmFyIG11c3RFbmRBYnMgPSBpc1RvQWJzIHx8IGlzRnJvbUFicztcblxuICBpZiAodG8gJiYgaXNBYnNvbHV0ZSh0bykpIHtcbiAgICAvLyB0byBpcyBhYnNvbHV0ZVxuICAgIGZyb21QYXJ0cyA9IHRvUGFydHM7XG4gIH0gZWxzZSBpZiAodG9QYXJ0cy5sZW5ndGgpIHtcbiAgICAvLyB0byBpcyByZWxhdGl2ZSwgZHJvcCB0aGUgZmlsZW5hbWVcbiAgICBmcm9tUGFydHMucG9wKCk7XG4gICAgZnJvbVBhcnRzID0gZnJvbVBhcnRzLmNvbmNhdCh0b1BhcnRzKTtcbiAgfVxuXG4gIGlmICghZnJvbVBhcnRzLmxlbmd0aCkgcmV0dXJuICcvJztcblxuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IHZvaWQgMDtcbiAgaWYgKGZyb21QYXJ0cy5sZW5ndGgpIHtcbiAgICB2YXIgbGFzdCA9IGZyb21QYXJ0c1tmcm9tUGFydHMubGVuZ3RoIC0gMV07XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nIHx8IGxhc3QgPT09ICcnO1xuICB9IGVsc2Uge1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgfVxuXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBmcm9tUGFydHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIHZhciBwYXJ0ID0gZnJvbVBhcnRzW2ldO1xuXG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXVzdEVuZEFicykgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgZnJvbVBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gIH1pZiAobXVzdEVuZEFicyAmJiBmcm9tUGFydHNbMF0gIT09ICcnICYmICghZnJvbVBhcnRzWzBdIHx8ICFpc0Fic29sdXRlKGZyb21QYXJ0c1swXSkpKSBmcm9tUGFydHMudW5zaGlmdCgnJyk7XG5cbiAgdmFyIHJlc3VsdCA9IGZyb21QYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgcmVzdWx0LnN1YnN0cigtMSkgIT09ICcvJykgcmVzdWx0ICs9ICcvJztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlUGF0aG5hbWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Jlc29sdmUtcGF0aG5hbWUvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIHZhbHVlRXF1YWwgPSBmdW5jdGlvbiB2YWx1ZUVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiB2YWx1ZUVxdWFsKGl0ZW0sIGJbaW5kZXhdKTtcbiAgfSk7XG5cbiAgdmFyIGFUeXBlID0gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpO1xuICB2YXIgYlR5cGUgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYVZhbHVlID0gYS52YWx1ZU9mKCk7XG4gICAgdmFyIGJWYWx1ZSA9IGIudmFsdWVPZigpO1xuXG4gICAgaWYgKGFWYWx1ZSAhPT0gYSB8fCBiVmFsdWUgIT09IGIpIHJldHVybiB2YWx1ZUVxdWFsKGFWYWx1ZSwgYlZhbHVlKTtcblxuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gdmFsdWVFcXVhbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdmFsdWUtZXF1YWwvaW5kZXguanMiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciBwcm9tcHRpbmcgdGhlIHVzZXIgYmVmb3JlIG5hdmlnYXRpbmcgYXdheVxuICogZnJvbSBhIHNjcmVlbiB3aXRoIGEgY29tcG9uZW50LlxuICovXG5cbnZhciBQcm9tcHQgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoUHJvbXB0LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBQcm9tcHQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb21wdCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFByb21wdC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gZW5hYmxlKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy51bmJsb2NrKSB0aGlzLnVuYmxvY2soKTtcblxuICAgIHRoaXMudW5ibG9jayA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeS5ibG9jayhtZXNzYWdlKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLnVuYmxvY2spIHtcbiAgICAgIHRoaXMudW5ibG9jaygpO1xuICAgICAgdGhpcy51bmJsb2NrID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMud2hlbikgdGhpcy5lbmFibGUodGhpcy5wcm9wcy5tZXNzYWdlKTtcbiAgfTtcblxuICBQcm9tcHQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMud2hlbikge1xuICAgICAgaWYgKCF0aGlzLnByb3BzLndoZW4gfHwgdGhpcy5wcm9wcy5tZXNzYWdlICE9PSBuZXh0UHJvcHMubWVzc2FnZSkgdGhpcy5lbmFibGUobmV4dFByb3BzLm1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICB9XG4gIH07XG5cbiAgUHJvbXB0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuZGlzYWJsZSgpO1xuICB9O1xuXG4gIFByb21wdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBQcm9tcHQ7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblByb21wdC5wcm9wVHlwZXMgPSB7XG4gIHdoZW46IFByb3BUeXBlcy5ib29sLFxuICBtZXNzYWdlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnN0cmluZ10pLmlzUmVxdWlyZWRcbn07XG5Qcm9tcHQuZGVmYXVsdFByb3BzID0ge1xuICB3aGVuOiB0cnVlXG59O1xuUHJvbXB0LmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBibG9jazogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWRcbiAgfSkuaXNSZXF1aXJlZFxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBQcm9tcHQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9lcy9Qcm9tcHQuanMiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciB1cGRhdGluZyB0aGUgbG9jYXRpb24gcHJvZ3JhbWF0aWNhbGx5XG4gKiB3aXRoIGEgY29tcG9uZW50LlxuICovXG5cbnZhciBSZWRpcmVjdCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhSZWRpcmVjdCwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gUmVkaXJlY3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZGlyZWN0KTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmlzU3RhdGljID0gZnVuY3Rpb24gaXNTdGF0aWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dC5yb3V0ZXIgJiYgdGhpcy5jb250ZXh0LnJvdXRlci5zdGF0aWNDb250ZXh0O1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgaWYgKHRoaXMuaXNTdGF0aWMoKSkgdGhpcy5wZXJmb3JtKCk7XG4gIH07XG5cbiAgUmVkaXJlY3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RhdGljKCkpIHRoaXMucGVyZm9ybSgpO1xuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gcGVyZm9ybSgpIHtcbiAgICB2YXIgaGlzdG9yeSA9IHRoaXMuY29udGV4dC5yb3V0ZXIuaGlzdG9yeTtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgcHVzaCA9IF9wcm9wcy5wdXNoLFxuICAgICAgICB0byA9IF9wcm9wcy50bztcblxuXG4gICAgaWYgKHB1c2gpIHtcbiAgICAgIGhpc3RvcnkucHVzaCh0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpc3RvcnkucmVwbGFjZSh0byk7XG4gICAgfVxuICB9O1xuXG4gIFJlZGlyZWN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcmV0dXJuIFJlZGlyZWN0O1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZWRpcmVjdC5wcm9wVHlwZXMgPSB7XG4gIHB1c2g6IFByb3BUeXBlcy5ib29sLFxuICBmcm9tOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB0bzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLm9iamVjdF0pXG59O1xuUmVkaXJlY3QuZGVmYXVsdFByb3BzID0ge1xuICBwdXNoOiBmYWxzZVxufTtcblJlZGlyZWN0LmNvbnRleHRUeXBlcyA9IHtcbiAgcm91dGVyOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGhpc3Rvcnk6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBwdXNoOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgcmVwbGFjZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWQsXG4gICAgc3RhdGljQ29udGV4dDogUHJvcFR5cGVzLm9iamVjdFxuICB9KS5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFJlZGlyZWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvUmVkaXJlY3QuanMiLCJ2YXIgaXNhcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG4vKipcbiAqIEV4cG9zZSBgcGF0aFRvUmVnZXhwYC5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoVG9SZWdleHBcbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gcGFyc2Vcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb0Z1bmN0aW9uID0gdG9rZW5zVG9GdW5jdGlvblxubW9kdWxlLmV4cG9ydHMudG9rZW5zVG9SZWdFeHAgPSB0b2tlbnNUb1JlZ0V4cFxuXG4vKipcbiAqIFRoZSBtYWluIHBhdGggbWF0Y2hpbmcgcmVnZXhwIHV0aWxpdHkuXG4gKlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xudmFyIFBBVEhfUkVHRVhQID0gbmV3IFJlZ0V4cChbXG4gIC8vIE1hdGNoIGVzY2FwZWQgY2hhcmFjdGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBhcHBlYXIgaW4gZnV0dXJlIG1hdGNoZXMuXG4gIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIGVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgdGhhdCB3b24ndCB0cmFuc2Zvcm0uXG4gICcoXFxcXFxcXFwuKScsXG4gIC8vIE1hdGNoIEV4cHJlc3Mtc3R5bGUgcGFyYW1ldGVycyBhbmQgdW4tbmFtZWQgcGFyYW1ldGVycyB3aXRoIGEgcHJlZml4XG4gIC8vIGFuZCBvcHRpb25hbCBzdWZmaXhlcy4gTWF0Y2hlcyBhcHBlYXIgYXM6XG4gIC8vXG4gIC8vIFwiLzp0ZXN0KFxcXFxkKyk/XCIgPT4gW1wiL1wiLCBcInRlc3RcIiwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgXCI/XCIsIHVuZGVmaW5lZF1cbiAgLy8gXCIvcm91dGUoXFxcXGQrKVwiICA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCJcXGQrXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAvLyBcIi8qXCIgICAgICAgICAgICA9PiBbXCIvXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgXCIqXCJdXG4gICcoW1xcXFwvLl0pPyg/Oig/OlxcXFw6KFxcXFx3KykoPzpcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKT98XFxcXCgoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKV0pKylcXFxcKSkoWysqP10pP3woXFxcXCopKSdcbl0uam9pbignfCcpLCAnZycpXG5cbi8qKlxuICogUGFyc2UgYSBzdHJpbmcgZm9yIHRoZSByYXcgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHN0clxuICogQHBhcmFtICB7T2JqZWN0PX0gb3B0aW9uc1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBwYXJzZSAoc3RyLCBvcHRpb25zKSB7XG4gIHZhciB0b2tlbnMgPSBbXVxuICB2YXIga2V5ID0gMFxuICB2YXIgaW5kZXggPSAwXG4gIHZhciBwYXRoID0gJydcbiAgdmFyIGRlZmF1bHREZWxpbWl0ZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJ1xuICB2YXIgcmVzXG5cbiAgd2hpbGUgKChyZXMgPSBQQVRIX1JFR0VYUC5leGVjKHN0cikpICE9IG51bGwpIHtcbiAgICB2YXIgbSA9IHJlc1swXVxuICAgIHZhciBlc2NhcGVkID0gcmVzWzFdXG4gICAgdmFyIG9mZnNldCA9IHJlcy5pbmRleFxuICAgIHBhdGggKz0gc3RyLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgaW5kZXggPSBvZmZzZXQgKyBtLmxlbmd0aFxuXG4gICAgLy8gSWdub3JlIGFscmVhZHkgZXNjYXBlZCBzZXF1ZW5jZXMuXG4gICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgIHBhdGggKz0gZXNjYXBlZFsxXVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgbmV4dCA9IHN0cltpbmRleF1cbiAgICB2YXIgcHJlZml4ID0gcmVzWzJdXG4gICAgdmFyIG5hbWUgPSByZXNbM11cbiAgICB2YXIgY2FwdHVyZSA9IHJlc1s0XVxuICAgIHZhciBncm91cCA9IHJlc1s1XVxuICAgIHZhciBtb2RpZmllciA9IHJlc1s2XVxuICAgIHZhciBhc3RlcmlzayA9IHJlc1s3XVxuXG4gICAgLy8gUHVzaCB0aGUgY3VycmVudCBwYXRoIG9udG8gdGhlIHRva2Vucy5cbiAgICBpZiAocGF0aCkge1xuICAgICAgdG9rZW5zLnB1c2gocGF0aClcbiAgICAgIHBhdGggPSAnJ1xuICAgIH1cblxuICAgIHZhciBwYXJ0aWFsID0gcHJlZml4ICE9IG51bGwgJiYgbmV4dCAhPSBudWxsICYmIG5leHQgIT09IHByZWZpeFxuICAgIHZhciByZXBlYXQgPSBtb2RpZmllciA9PT0gJysnIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgb3B0aW9uYWwgPSBtb2RpZmllciA9PT0gJz8nIHx8IG1vZGlmaWVyID09PSAnKidcbiAgICB2YXIgZGVsaW1pdGVyID0gcmVzWzJdIHx8IGRlZmF1bHREZWxpbWl0ZXJcbiAgICB2YXIgcGF0dGVybiA9IGNhcHR1cmUgfHwgZ3JvdXBcblxuICAgIHRva2Vucy5wdXNoKHtcbiAgICAgIG5hbWU6IG5hbWUgfHwga2V5KyssXG4gICAgICBwcmVmaXg6IHByZWZpeCB8fCAnJyxcbiAgICAgIGRlbGltaXRlcjogZGVsaW1pdGVyLFxuICAgICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgICAgcmVwZWF0OiByZXBlYXQsXG4gICAgICBwYXJ0aWFsOiBwYXJ0aWFsLFxuICAgICAgYXN0ZXJpc2s6ICEhYXN0ZXJpc2ssXG4gICAgICBwYXR0ZXJuOiBwYXR0ZXJuID8gZXNjYXBlR3JvdXAocGF0dGVybikgOiAoYXN0ZXJpc2sgPyAnLionIDogJ1teJyArIGVzY2FwZVN0cmluZyhkZWxpbWl0ZXIpICsgJ10rPycpXG4gICAgfSlcbiAgfVxuXG4gIC8vIE1hdGNoIGFueSBjaGFyYWN0ZXJzIHN0aWxsIHJlbWFpbmluZy5cbiAgaWYgKGluZGV4IDwgc3RyLmxlbmd0aCkge1xuICAgIHBhdGggKz0gc3RyLnN1YnN0cihpbmRleClcbiAgfVxuXG4gIC8vIElmIHRoZSBwYXRoIGV4aXN0cywgcHVzaCBpdCBvbnRvIHRoZSBlbmQuXG4gIGlmIChwYXRoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0aClcbiAgfVxuXG4gIHJldHVybiB0b2tlbnNcbn1cblxuLyoqXG4gKiBDb21waWxlIGEgc3RyaW5nIHRvIGEgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIHRoZSBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFmdW5jdGlvbihPYmplY3Q9LCBPYmplY3Q9KX1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZSAoc3RyLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb0Z1bmN0aW9uKHBhcnNlKHN0ciwgb3B0aW9ucykpXG59XG5cbi8qKlxuICogUHJldHRpZXIgZW5jb2Rpbmcgb2YgVVJJIHBhdGggc2VnbWVudHMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvW1xcLz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFbmNvZGUgdGhlIGFzdGVyaXNrIHBhcmFtZXRlci4gU2ltaWxhciB0byBgcHJldHR5YCwgYnV0IGFsbG93cyBzbGFzaGVzLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZW5jb2RlQXN0ZXJpc2sgKHN0cikge1xuICByZXR1cm4gZW5jb2RlVVJJKHN0cikucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAnJScgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKClcbiAgfSlcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBtZXRob2QgZm9yIHRyYW5zZm9ybWluZyB0b2tlbnMgaW50byB0aGUgcGF0aCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9GdW5jdGlvbiAodG9rZW5zKSB7XG4gIC8vIENvbXBpbGUgYWxsIHRoZSB0b2tlbnMgaW50byByZWdleHBzLlxuICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheSh0b2tlbnMubGVuZ3RoKVxuXG4gIC8vIENvbXBpbGUgYWxsIHRoZSBwYXR0ZXJucyBiZWZvcmUgY29tcGlsYXRpb24uXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHR5cGVvZiB0b2tlbnNbaV0gPT09ICdvYmplY3QnKSB7XG4gICAgICBtYXRjaGVzW2ldID0gbmV3IFJlZ0V4cCgnXig/OicgKyB0b2tlbnNbaV0ucGF0dGVybiArICcpJCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICB2YXIgcGF0aCA9ICcnXG4gICAgdmFyIGRhdGEgPSBvYmogfHwge31cbiAgICB2YXIgb3B0aW9ucyA9IG9wdHMgfHwge31cbiAgICB2YXIgZW5jb2RlID0gb3B0aW9ucy5wcmV0dHkgPyBlbmNvZGVVUklDb21wb25lbnRQcmV0dHkgOiBlbmNvZGVVUklDb21wb25lbnRcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGF0aCArPSB0b2tlblxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbdG9rZW4ubmFtZV1cbiAgICAgIHZhciBzZWdtZW50XG5cbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgIC8vIFByZXBlbmQgcGFydGlhbCBzZWdtZW50IHByZWZpeGVzLlxuICAgICAgICAgIGlmICh0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgICBwYXRoICs9IHRva2VuLnByZWZpeFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBiZSBkZWZpbmVkJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNhcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5yZXBlYXQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG5vdCByZXBlYXQsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdgJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IGJlIGVtcHR5JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudCA9IGVuY29kZSh2YWx1ZVtqXSlcblxuICAgICAgICAgIGlmICghbWF0Y2hlc1tpXS50ZXN0KHNlZ21lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhbGwgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgYCcgKyBKU09OLnN0cmluZ2lmeShzZWdtZW50KSArICdgJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXRoICs9IChqID09PSAwID8gdG9rZW4ucHJlZml4IDogdG9rZW4uZGVsaW1pdGVyKSArIHNlZ21lbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSB0b2tlbi5hc3RlcmlzayA/IGVuY29kZUFzdGVyaXNrKHZhbHVlKSA6IGVuY29kZSh2YWx1ZSlcblxuICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBtYXRjaCBcIicgKyB0b2tlbi5wYXR0ZXJuICsgJ1wiLCBidXQgcmVjZWl2ZWQgXCInICsgc2VnbWVudCArICdcIicpXG4gICAgICB9XG5cbiAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4ICsgc2VnbWVudFxuICAgIH1cblxuICAgIHJldHVybiBwYXRoXG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgYSByZWd1bGFyIGV4cHJlc3Npb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsuKyo/PV4hOiR7fSgpW1xcXXxcXC9cXFxcXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogRXNjYXBlIHRoZSBjYXB0dXJpbmcgZ3JvdXAgYnkgZXNjYXBpbmcgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBtZWFuaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gZ3JvdXBcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlR3JvdXAgKGdyb3VwKSB7XG4gIHJldHVybiBncm91cC5yZXBsYWNlKC8oWz0hOiRcXC8oKV0pL2csICdcXFxcJDEnKVxufVxuXG4vKipcbiAqIEF0dGFjaCB0aGUga2V5cyBhcyBhIHByb3BlcnR5IG9mIHRoZSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcmVcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEtleXMgKHJlLCBrZXlzKSB7XG4gIHJlLmtleXMgPSBrZXlzXG4gIHJldHVybiByZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZmxhZ3MgZm9yIGEgcmVnZXhwIGZyb20gdGhlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGZsYWdzIChvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zLnNlbnNpdGl2ZSA/ICcnIDogJ2knXG59XG5cbi8qKlxuICogUHVsbCBvdXQga2V5cyBmcm9tIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFSZWdFeHB9IHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHJlZ2V4cFRvUmVnZXhwIChwYXRoLCBrZXlzKSB7XG4gIC8vIFVzZSBhIG5lZ2F0aXZlIGxvb2thaGVhZCB0byBtYXRjaCBvbmx5IGNhcHR1cmluZyBncm91cHMuXG4gIHZhciBncm91cHMgPSBwYXRoLnNvdXJjZS5tYXRjaCgvXFwoKD8hXFw/KS9nKVxuXG4gIGlmIChncm91cHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgcHJlZml4OiBudWxsLFxuICAgICAgICBkZWxpbWl0ZXI6IG51bGwsXG4gICAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgcGFydGlhbDogZmFsc2UsXG4gICAgICAgIGFzdGVyaXNrOiBmYWxzZSxcbiAgICAgICAgcGF0dGVybjogbnVsbFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhwYXRoLCBrZXlzKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheSBpbnRvIGEgcmVnZXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gIHBhdGhcbiAqIEBwYXJhbSAge0FycmF5fSAgIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgdmFyIHBhcnRzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHBhdGhUb1JlZ2V4cChwYXRoW2ldLCBrZXlzLCBvcHRpb25zKS5zb3VyY2UpXG4gIH1cblxuICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnKD86JyArIHBhcnRzLmpvaW4oJ3wnKSArICcpJywgZmxhZ3Mob3B0aW9ucykpXG5cbiAgcmV0dXJuIGF0dGFjaEtleXMocmVnZXhwLCBrZXlzKVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIHBhdGggcmVnZXhwIGZyb20gc3RyaW5nIGlucHV0LlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gIHBhdGhcbiAqIEBwYXJhbSAgeyFBcnJheX0gIGtleXNcbiAqIEBwYXJhbSAgeyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvUmVnZXhwIChwYXRoLCBrZXlzLCBvcHRpb25zKSB7XG4gIHJldHVybiB0b2tlbnNUb1JlZ0V4cChwYXJzZShwYXRoLCBvcHRpb25zKSwga2V5cywgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBFeHBvc2UgYSBmdW5jdGlvbiBmb3IgdGFraW5nIHRva2VucyBhbmQgcmV0dXJuaW5nIGEgUmVnRXhwLlxuICpcbiAqIEBwYXJhbSAgeyFBcnJheX0gICAgICAgICAgdG9rZW5zXG4gKiBAcGFyYW0gIHsoQXJyYXl8T2JqZWN0KT19IGtleXNcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gdG9rZW5zVG9SZWdFeHAgKHRva2Vucywga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICB2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3RcbiAgdmFyIGVuZCA9IG9wdGlvbnMuZW5kICE9PSBmYWxzZVxuICB2YXIgcm91dGUgPSAnJ1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9rZW5zIGFuZCBjcmVhdGUgb3VyIHJlZ2V4cCBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5zW2ldXG5cbiAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgcm91dGUgKz0gZXNjYXBlU3RyaW5nKHRva2VuKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJlZml4ID0gZXNjYXBlU3RyaW5nKHRva2VuLnByZWZpeClcbiAgICAgIHZhciBjYXB0dXJlID0gJyg/OicgKyB0b2tlbi5wYXR0ZXJuICsgJyknXG5cbiAgICAgIGtleXMucHVzaCh0b2tlbilcblxuICAgICAgaWYgKHRva2VuLnJlcGVhdCkge1xuICAgICAgICBjYXB0dXJlICs9ICcoPzonICsgcHJlZml4ICsgY2FwdHVyZSArICcpKidcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgIGlmICghdG9rZW4ucGFydGlhbCkge1xuICAgICAgICAgIGNhcHR1cmUgPSAnKD86JyArIHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKSk/J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyk/J1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlID0gcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpJ1xuICAgICAgfVxuXG4gICAgICByb3V0ZSArPSBjYXB0dXJlXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlbGltaXRlciA9IGVzY2FwZVN0cmluZyhvcHRpb25zLmRlbGltaXRlciB8fCAnLycpXG4gIHZhciBlbmRzV2l0aERlbGltaXRlciA9IHJvdXRlLnNsaWNlKC1kZWxpbWl0ZXIubGVuZ3RoKSA9PT0gZGVsaW1pdGVyXG5cbiAgLy8gSW4gbm9uLXN0cmljdCBtb2RlIHdlIGFsbG93IGEgc2xhc2ggYXQgdGhlIGVuZCBvZiBtYXRjaC4gSWYgdGhlIHBhdGggdG9cbiAgLy8gbWF0Y2ggYWxyZWFkeSBlbmRzIHdpdGggYSBzbGFzaCwgd2UgcmVtb3ZlIGl0IGZvciBjb25zaXN0ZW5jeS4gVGhlIHNsYXNoXG4gIC8vIGlzIHZhbGlkIGF0IHRoZSBlbmQgb2YgYSBwYXRoIG1hdGNoLCBub3QgaW4gdGhlIG1pZGRsZS4gVGhpcyBpcyBpbXBvcnRhbnRcbiAgLy8gaW4gbm9uLWVuZGluZyBtb2RlLCB3aGVyZSBcIi90ZXN0L1wiIHNob3VsZG4ndCBtYXRjaCBcIi90ZXN0Ly9yb3V0ZVwiLlxuICBpZiAoIXN0cmljdCkge1xuICAgIHJvdXRlID0gKGVuZHNXaXRoRGVsaW1pdGVyID8gcm91dGUuc2xpY2UoMCwgLWRlbGltaXRlci5sZW5ndGgpIDogcm91dGUpICsgJyg/OicgKyBkZWxpbWl0ZXIgKyAnKD89JCkpPydcbiAgfVxuXG4gIGlmIChlbmQpIHtcbiAgICByb3V0ZSArPSAnJCdcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiBub24tZW5kaW5nIG1vZGUsIHdlIG5lZWQgdGhlIGNhcHR1cmluZyBncm91cHMgdG8gbWF0Y2ggYXMgbXVjaCBhc1xuICAgIC8vIHBvc3NpYmxlIGJ5IHVzaW5nIGEgcG9zaXRpdmUgbG9va2FoZWFkIHRvIHRoZSBlbmQgb3IgbmV4dCBwYXRoIHNlZ21lbnQuXG4gICAgcm91dGUgKz0gc3RyaWN0ICYmIGVuZHNXaXRoRGVsaW1pdGVyID8gJycgOiAnKD89JyArIGRlbGltaXRlciArICd8JCknXG4gIH1cblxuICByZXR1cm4gYXR0YWNoS2V5cyhuZXcgUmVnRXhwKCdeJyArIHJvdXRlLCBmbGFncyhvcHRpb25zKSksIGtleXMpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBnaXZlbiBwYXRoIHN0cmluZywgcmV0dXJuaW5nIGEgcmVndWxhciBleHByZXNzaW9uLlxuICpcbiAqIEFuIGVtcHR5IGFycmF5IGNhbiBiZSBwYXNzZWQgaW4gZm9yIHRoZSBrZXlzLCB3aGljaCB3aWxsIGhvbGQgdGhlXG4gKiBwbGFjZWhvbGRlciBrZXkgZGVzY3JpcHRpb25zLiBGb3IgZXhhbXBsZSwgdXNpbmcgYC91c2VyLzppZGAsIGBrZXlzYCB3aWxsXG4gKiBjb250YWluIGBbeyBuYW1lOiAnaWQnLCBkZWxpbWl0ZXI6ICcvJywgb3B0aW9uYWw6IGZhbHNlLCByZXBlYXQ6IGZhbHNlIH1dYC5cbiAqXG4gKiBAcGFyYW0gIHsoc3RyaW5nfFJlZ0V4cHxBcnJheSl9IHBhdGhcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0gICAgICAga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiBwYXRoVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc2FycmF5KGtleXMpKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IU9iamVjdH0gKi8gKGtleXMgfHwgb3B0aW9ucylcbiAgICBrZXlzID0gW11cbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKHBhdGggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gcmVnZXhwVG9SZWdleHAocGF0aCwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSlcbiAgfVxuXG4gIGlmIChpc2FycmF5KHBhdGgpKSB7XG4gICAgcmV0dXJuIGFycmF5VG9SZWdleHAoLyoqIEB0eXBlIHshQXJyYXl9ICovIChwYXRoKSwgLyoqIEB0eXBlIHshQXJyYXl9ICovIChrZXlzKSwgb3B0aW9ucylcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdUb1JlZ2V4cCgvKiogQHR5cGUge3N0cmluZ30gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBjcmVhdGVQYXRoLCBwYXJzZVBhdGggfSBmcm9tICdoaXN0b3J5L1BhdGhVdGlscyc7XG5pbXBvcnQgUm91dGVyIGZyb20gJy4vUm91dGVyJztcblxudmFyIG5vcm1hbGl6ZUxvY2F0aW9uID0gZnVuY3Rpb24gbm9ybWFsaXplTG9jYXRpb24ob2JqZWN0KSB7XG4gIHZhciBfb2JqZWN0JHBhdGhuYW1lID0gb2JqZWN0LnBhdGhuYW1lLFxuICAgICAgcGF0aG5hbWUgPSBfb2JqZWN0JHBhdGhuYW1lID09PSB1bmRlZmluZWQgPyAnLycgOiBfb2JqZWN0JHBhdGhuYW1lLFxuICAgICAgX29iamVjdCRzZWFyY2ggPSBvYmplY3Quc2VhcmNoLFxuICAgICAgc2VhcmNoID0gX29iamVjdCRzZWFyY2ggPT09IHVuZGVmaW5lZCA/ICcnIDogX29iamVjdCRzZWFyY2gsXG4gICAgICBfb2JqZWN0JGhhc2ggPSBvYmplY3QuaGFzaCxcbiAgICAgIGhhc2ggPSBfb2JqZWN0JGhhc2ggPT09IHVuZGVmaW5lZCA/ICcnIDogX29iamVjdCRoYXNoO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBzZWFyY2ggPT09ICc/JyA/ICcnIDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2ggPT09ICcjJyA/ICcnIDogaGFzaFxuICB9O1xufTtcblxudmFyIGFkZEJhc2VuYW1lID0gZnVuY3Rpb24gYWRkQmFzZW5hbWUoYmFzZW5hbWUsIGxvY2F0aW9uKSB7XG4gIGlmICghYmFzZW5hbWUpIHJldHVybiBsb2NhdGlvbjtcblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7XG4gICAgcGF0aG5hbWU6IGFkZExlYWRpbmdTbGFzaChiYXNlbmFtZSkgKyBsb2NhdGlvbi5wYXRobmFtZVxuICB9KTtcbn07XG5cbnZhciBzdHJpcEJhc2VuYW1lID0gZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShiYXNlbmFtZSwgbG9jYXRpb24pIHtcbiAgaWYgKCFiYXNlbmFtZSkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHZhciBiYXNlID0gYWRkTGVhZGluZ1NsYXNoKGJhc2VuYW1lKTtcblxuICBpZiAobG9jYXRpb24ucGF0aG5hbWUuaW5kZXhPZihiYXNlKSAhPT0gMCkgcmV0dXJuIGxvY2F0aW9uO1xuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHtcbiAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyKGJhc2UubGVuZ3RoKVxuICB9KTtcbn07XG5cbnZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKGxvY2F0aW9uKSA6IG5vcm1hbGl6ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbn07XG5cbnZhciBjcmVhdGVVUkwgPSBmdW5jdGlvbiBjcmVhdGVVUkwobG9jYXRpb24pIHtcbiAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycgPyBsb2NhdGlvbiA6IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xufTtcblxudmFyIHN0YXRpY0hhbmRsZXIgPSBmdW5jdGlvbiBzdGF0aWNIYW5kbGVyKG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdZb3UgY2Fubm90ICVzIHdpdGggPFN0YXRpY1JvdXRlcj4nLCBtZXRob2ROYW1lKTtcbiAgfTtcbn07XG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgdG9wLWxldmVsIEFQSSBmb3IgYSBcInN0YXRpY1wiIDxSb3V0ZXI+LCBzby1jYWxsZWQgYmVjYXVzZSBpdFxuICogY2FuJ3QgYWN0dWFsbHkgY2hhbmdlIHRoZSBjdXJyZW50IGxvY2F0aW9uLiBJbnN0ZWFkLCBpdCBqdXN0IHJlY29yZHNcbiAqIGxvY2F0aW9uIGNoYW5nZXMgaW4gYSBjb250ZXh0IG9iamVjdC4gVXNlZnVsIG1haW5seSBpbiB0ZXN0aW5nIGFuZFxuICogc2VydmVyLXJlbmRlcmluZyBzY2VuYXJpb3MuXG4gKi9cblxudmFyIFN0YXRpY1JvdXRlciA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XG4gIF9pbmhlcml0cyhTdGF0aWNSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0YXRpY1JvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRpY1JvdXRlcik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JldCA9IChfdGVtcCA9IChfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9SZWFjdCRDb21wb25lbnQuY2FsbC5hcHBseShfUmVhY3QkQ29tcG9uZW50LCBbdGhpc10uY29uY2F0KGFyZ3MpKSksIF90aGlzKSwgX3RoaXMuY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgICByZXR1cm4gYWRkTGVhZGluZ1NsYXNoKF90aGlzLnByb3BzLmJhc2VuYW1lICsgY3JlYXRlVVJMKHBhdGgpKTtcbiAgICB9LCBfdGhpcy5oYW5kbGVQdXNoID0gZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzLmJhc2VuYW1lLFxuICAgICAgICAgIGNvbnRleHQgPSBfdGhpcyRwcm9wcy5jb250ZXh0O1xuXG4gICAgICBjb250ZXh0LmFjdGlvbiA9ICdQVVNIJztcbiAgICAgIGNvbnRleHQubG9jYXRpb24gPSBhZGRCYXNlbmFtZShiYXNlbmFtZSwgY3JlYXRlTG9jYXRpb24obG9jYXRpb24pKTtcbiAgICAgIGNvbnRleHQudXJsID0gY3JlYXRlVVJMKGNvbnRleHQubG9jYXRpb24pO1xuICAgIH0sIF90aGlzLmhhbmRsZVJlcGxhY2UgPSBmdW5jdGlvbiAobG9jYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSBfdGhpcy5wcm9wcyxcbiAgICAgICAgICBiYXNlbmFtZSA9IF90aGlzJHByb3BzMi5iYXNlbmFtZSxcbiAgICAgICAgICBjb250ZXh0ID0gX3RoaXMkcHJvcHMyLmNvbnRleHQ7XG5cbiAgICAgIGNvbnRleHQuYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgICAgY29udGV4dC5sb2NhdGlvbiA9IGFkZEJhc2VuYW1lKGJhc2VuYW1lLCBjcmVhdGVMb2NhdGlvbihsb2NhdGlvbikpO1xuICAgICAgY29udGV4dC51cmwgPSBjcmVhdGVVUkwoY29udGV4dC5sb2NhdGlvbik7XG4gICAgfSwgX3RoaXMuaGFuZGxlTGlzdGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfSwgX3RoaXMuaGFuZGxlQmxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbm9vcDtcbiAgICB9LCBfdGVtcCksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgfVxuXG4gIFN0YXRpY1JvdXRlci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q2hpbGRDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICByb3V0ZXI6IHtcbiAgICAgICAgc3RhdGljQ29udGV4dDogdGhpcy5wcm9wcy5jb250ZXh0XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBTdGF0aWNSb3V0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgYmFzZW5hbWUgPSBfcHJvcHMuYmFzZW5hbWUsXG4gICAgICAgIGNvbnRleHQgPSBfcHJvcHMuY29udGV4dCxcbiAgICAgICAgbG9jYXRpb24gPSBfcHJvcHMubG9jYXRpb24sXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydiYXNlbmFtZScsICdjb250ZXh0JywgJ2xvY2F0aW9uJ10pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSB7XG4gICAgICBjcmVhdGVIcmVmOiB0aGlzLmNyZWF0ZUhyZWYsXG4gICAgICBhY3Rpb246ICdQT1AnLFxuICAgICAgbG9jYXRpb246IHN0cmlwQmFzZW5hbWUoYmFzZW5hbWUsIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSksXG4gICAgICBwdXNoOiB0aGlzLmhhbmRsZVB1c2gsXG4gICAgICByZXBsYWNlOiB0aGlzLmhhbmRsZVJlcGxhY2UsXG4gICAgICBnbzogc3RhdGljSGFuZGxlcignZ28nKSxcbiAgICAgIGdvQmFjazogc3RhdGljSGFuZGxlcignZ29CYWNrJyksXG4gICAgICBnb0ZvcndhcmQ6IHN0YXRpY0hhbmRsZXIoJ2dvRm9yd2FyZCcpLFxuICAgICAgbGlzdGVuOiB0aGlzLmhhbmRsZUxpc3RlbixcbiAgICAgIGJsb2NrOiB0aGlzLmhhbmRsZUJsb2NrXG4gICAgfTtcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgX2V4dGVuZHMoe30sIHByb3BzLCB7IGhpc3Rvcnk6IGhpc3RvcnkgfSkpO1xuICB9O1xuXG4gIHJldHVybiBTdGF0aWNSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblN0YXRpY1JvdXRlci5wcm9wVHlwZXMgPSB7XG4gIGJhc2VuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSlcbn07XG5TdGF0aWNSb3V0ZXIuZGVmYXVsdFByb3BzID0ge1xuICBiYXNlbmFtZTogJycsXG4gIGxvY2F0aW9uOiAnLydcbn07XG5TdGF0aWNSb3V0ZXIuY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRpY1JvdXRlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N0YXRpY1JvdXRlci5qcyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBtYXRjaFBhdGggZnJvbSAnLi9tYXRjaFBhdGgnO1xuXG4vKipcbiAqIFRoZSBwdWJsaWMgQVBJIGZvciByZW5kZXJpbmcgdGhlIGZpcnN0IDxSb3V0ZT4gdGhhdCBtYXRjaGVzLlxuICovXG5cbnZhciBTd2l0Y2ggPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoU3dpdGNoLCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBTd2l0Y2goKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN3aXRjaCk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIFN3aXRjaC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgd2FybmluZyghKG5leHRQcm9wcy5sb2NhdGlvbiAmJiAhdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IGluaXRpYWxseSB1c2VkIG5vIFwibG9jYXRpb25cIiBwcm9wIGFuZCB0aGVuIHByb3ZpZGVkIG9uZSBvbiBhIHN1YnNlcXVlbnQgcmVuZGVyLicpO1xuXG4gICAgd2FybmluZyghKCFuZXh0UHJvcHMubG9jYXRpb24gJiYgdGhpcy5wcm9wcy5sb2NhdGlvbiksICc8U3dpdGNoPiBlbGVtZW50cyBzaG91bGQgbm90IGNoYW5nZSBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gWW91IHByb3ZpZGVkIGEgXCJsb2NhdGlvblwiIHByb3AgaW5pdGlhbGx5IGJ1dCBvbWl0dGVkIGl0IG9uIGEgc3Vic2VxdWVudCByZW5kZXIuJyk7XG4gIH07XG5cbiAgU3dpdGNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHJvdXRlID0gdGhpcy5jb250ZXh0LnJvdXRlci5yb3V0ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgdmFyIGxvY2F0aW9uID0gdGhpcy5wcm9wcy5sb2NhdGlvbiB8fCByb3V0ZS5sb2NhdGlvbjtcblxuICAgIHZhciBtYXRjaCA9IHZvaWQgMCxcbiAgICAgICAgY2hpbGQgPSB2b2lkIDA7XG4gICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHJldHVybjtcblxuICAgICAgdmFyIF9lbGVtZW50JHByb3BzID0gZWxlbWVudC5wcm9wcyxcbiAgICAgICAgICBwYXRoUHJvcCA9IF9lbGVtZW50JHByb3BzLnBhdGgsXG4gICAgICAgICAgZXhhY3QgPSBfZWxlbWVudCRwcm9wcy5leGFjdCxcbiAgICAgICAgICBzdHJpY3QgPSBfZWxlbWVudCRwcm9wcy5zdHJpY3QsXG4gICAgICAgICAgZnJvbSA9IF9lbGVtZW50JHByb3BzLmZyb207XG5cbiAgICAgIHZhciBwYXRoID0gcGF0aFByb3AgfHwgZnJvbTtcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgY2hpbGQgPSBlbGVtZW50O1xuICAgICAgICBtYXRjaCA9IHBhdGggPyBtYXRjaFBhdGgobG9jYXRpb24ucGF0aG5hbWUsIHsgcGF0aDogcGF0aCwgZXhhY3Q6IGV4YWN0LCBzdHJpY3Q6IHN0cmljdCB9KSA6IHJvdXRlLm1hdGNoO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG1hdGNoID8gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7IGxvY2F0aW9uOiBsb2NhdGlvbiwgY29tcHV0ZWRNYXRjaDogbWF0Y2ggfSkgOiBudWxsO1xuICB9O1xuXG4gIHJldHVybiBTd2l0Y2g7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblN3aXRjaC5jb250ZXh0VHlwZXMgPSB7XG4gIHJvdXRlcjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICByb3V0ZTogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkXG4gIH0pLmlzUmVxdWlyZWRcbn07XG5Td2l0Y2gucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG4gIGxvY2F0aW9uOiBQcm9wVHlwZXMub2JqZWN0XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IFN3aXRjaDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2VzL1N3aXRjaC5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcbmltcG9ydCBSb3V0ZSBmcm9tICcuL1JvdXRlJztcblxuLyoqXG4gKiBBIHB1YmxpYyBoaWdoZXItb3JkZXIgY29tcG9uZW50IHRvIGFjY2VzcyB0aGUgaW1wZXJhdGl2ZSBBUElcbiAqL1xudmFyIHdpdGhSb3V0ZXIgPSBmdW5jdGlvbiB3aXRoUm91dGVyKENvbXBvbmVudCkge1xuICB2YXIgQyA9IGZ1bmN0aW9uIEMocHJvcHMpIHtcbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudFJlZiA9IHByb3BzLndyYXBwZWRDb21wb25lbnRSZWYsXG4gICAgICAgIHJlbWFpbmluZ1Byb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHByb3BzLCBbJ3dyYXBwZWRDb21wb25lbnRSZWYnXSk7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZSwgeyByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyb3V0ZUNvbXBvbmVudFByb3BzKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgX2V4dGVuZHMoe30sIHJlbWFpbmluZ1Byb3BzLCByb3V0ZUNvbXBvbmVudFByb3BzLCB7IHJlZjogd3JhcHBlZENvbXBvbmVudFJlZiB9KSk7XG4gICAgICB9IH0pO1xuICB9O1xuXG4gIEMuZGlzcGxheU5hbWUgPSAnd2l0aFJvdXRlcignICsgKENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSkgKyAnKSc7XG4gIEMuV3JhcHBlZENvbXBvbmVudCA9IENvbXBvbmVudDtcbiAgQy5wcm9wVHlwZXMgPSB7XG4gICAgd3JhcHBlZENvbXBvbmVudFJlZjogUHJvcFR5cGVzLmZ1bmNcbiAgfTtcblxuICByZXR1cm4gaG9pc3RTdGF0aWNzKEMsIENvbXBvbmVudCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB3aXRoUm91dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXIvZXMvd2l0aFJvdXRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gICAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gICAgY29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgbWl4aW5zOiB0cnVlLFxuICAgIHByb3BUeXBlczogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlXG59O1xuXG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgICBuYW1lOiB0cnVlLFxuICAgIGxlbmd0aDogdHJ1ZSxcbiAgICBwcm90b3R5cGU6IHRydWUsXG4gICAgY2FsbGVyOiB0cnVlLFxuICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlID0gdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbic7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGN1c3RvbVN0YXRpY3MpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHsgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpc0dldE93blByb3BlcnR5U3ltYm9sc0F2YWlsYWJsZSkge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghUkVBQ1RfU1RBVElDU1trZXlzW2ldXSAmJiAhS05PV05fU1RBVElDU1trZXlzW2ldXSAmJiAoIWN1c3RvbVN0YXRpY3MgfHwgIWN1c3RvbVN0YXRpY3Nba2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tcG9uZW50W2tleXNbaV1dID0gc291cmNlQ29tcG9uZW50W2tleXNbaV1dO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsImNvbnN0IGNvbnN0YW50cyA9IHtcbiAgRVhQRVJJRU5DRV9JRDogJ0JpcmRzIE5lZWQgYSBIb21lJyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnN0YW50cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvY29uc3RhbnRzLmpzIiwibW9kdWxlLmV4cG9ydHMgPSB7XCJleHBlcmllbmNlSWRcIjpcIkJpcmRzIE5lZWQgQSBIb21lXCJ9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zY3JpcHRzL2NvbmZpZy5qc29uXG4vLyBtb2R1bGUgaWQgPSAyMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHdpdGhSb3V0ZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXInXG5cbmltcG9ydCBNZXRhVGFnIGZyb20gJy4uL2NvbXBvbmVudHMvTWV0YVRhZyc7XG5pbXBvcnQgTmF2aWdhdGlvbiBmcm9tICcuLi9jb21wb25lbnRzL05hdmlnYXRpb24nO1xuaW1wb3J0IFByZXNlbnRhdGlvbiBmcm9tICcuLi9jb21wb25lbnRzL1ByZXNlbnRhdGlvbic7XG5cbmNsYXNzIEhvbWUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbW91bnRlZDogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBtb3VudGVkOiB0cnVlXG4gICAgfSk7XG4gICAgbGV0IHRpdGxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndGl0bGUnKTtcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIHRpdGxlLmlubmVyVGV4dCA9IHRoaXMucHJvcHMuY29udGVudC50aXRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGl0bGUnKTtcbiAgICAgIHRpdGxlLmlubmVyVGV4dCA9IHRoaXMucHJvcHMuY29udGVudC50aXRsZTtcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKS5wcmVwZW5kKHRpdGxlKTtcbiAgICB9XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG1vdW50ZWQ6IGZhbHNlXG4gICAgfSlcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc29sZS5sb2codGhpcy5wcm9wcyk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9e1xuICAgICAgICAgIFtcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY29uc3RhbnRzLkVYUEVSSUVOQ0VfSUQudG9Mb3dlckNhc2UoKVxuICAgICAgICAgIF0uam9pbignICcpXG4gICAgICAgIH0+XG4gICAgICAgIDxNZXRhVGFnIHRhZ3M9e3RoaXMucHJvcHMuY29udGVudC5tZXRhZGF0YX0vPlxuICAgICAgICA8TmF2aWdhdGlvbiAvPlxuICAgICAgICA8UHJlc2VudGF0aW9uIHRpdGxlPXt0aGlzLnByb3BzLmNvbnRlbnQudGl0bGV9IGdhbGxlcmllcz17dGhpcy5wcm9wcy5jb250ZW50LmdhbGxlcmllc30gaG91c2VzPXt0aGlzLnByb3BzLmNvbnRlbnQuaG91c2VzfSBwaWNzPXt0aGlzLnByb3BzLmNvbnRlbnQucGljc30gLz5cbiAgICAgIDwvZGl2PlxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aFJvdXRlcihIb21lKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9leHBlcmllbmNlcy9Ib21lLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YVRhZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBtb3VudGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG1vdW50ZWQ6IHRydWVcbiAgICB9KTtcbiAgICBsZXQgaGVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKTtcbiAgICB0aGlzLnByb3BzLnRhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICBsZXQgbWV0YXRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB0YWcpIHtcbiAgICAgICAgbWV0YXRhZy5zZXRBdHRyaWJ1dGUoa2V5LCB0YWdba2V5XSk7XG4gICAgICB9XG4gICAgICBoZWFkLnByZXBlbmQobWV0YXRhZyk7XG4gICAgfSk7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG1vdW50ZWQ6IGZhbHNlXG4gICAgfSlcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvY29tcG9uZW50cy9NZXRhVGFnLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF2aWdhdGlvbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzcz17XG4gICAgICAgIFtcbiAgICAgICAgICAnbmF2aWdhdGlvbidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICAgIH0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlclwiPlxuICAgICAgICA8aDEgY2xhc3M9XCJicmFuZGluZ1wiPkNvRGVzaWduPC9oMT5cbiAgICAgIDwvZGl2PlxuICAgICAgPG5hdiByb2xlPVwibmF2aWdhdGlvblwiPlxuICAgICAgPC9uYXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL2NvbXBvbmVudHMvTmF2aWdhdGlvbi5qcyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tICdoaXN0b3J5L2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIEhUTUw1IGhpc3RvcnkuXG4gKi9cblxudmFyIEJyb3dzZXJSb3V0ZXIgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHMoQnJvd3NlclJvdXRlciwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQnJvd3NlclJvdXRlcigpIHtcbiAgICB2YXIgX3RlbXAsIF90aGlzLCBfcmV0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyb3dzZXJSb3V0ZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZXQgPSAoX3RlbXAgPSAoX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkpLCBfdGhpcyksIF90aGlzLmhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KF90aGlzLnByb3BzKSwgX3RlbXApLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gIH1cblxuICBCcm93c2VyUm91dGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSwgY2hpbGRyZW46IHRoaXMucHJvcHMuY2hpbGRyZW4gfSk7XG4gIH07XG5cbiAgcmV0dXJuIEJyb3dzZXJSb3V0ZXI7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cbkJyb3dzZXJSb3V0ZXIucHJvcFR5cGVzID0ge1xuICBiYXNlbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZm9yY2VSZWZyZXNoOiBQcm9wVHlwZXMuYm9vbCxcbiAgZ2V0VXNlckNvbmZpcm1hdGlvbjogUHJvcFR5cGVzLmZ1bmMsXG4gIGtleUxlbmd0aDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEJyb3dzZXJSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvQnJvd3NlclJvdXRlci5qcyIsImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgY3JlYXRlSGlzdG9yeSBmcm9tICdoaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5JztcbmltcG9ydCB7IFJvdXRlciB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIGEgPFJvdXRlcj4gdGhhdCB1c2VzIHdpbmRvdy5sb2NhdGlvbi5oYXNoLlxuICovXG5cbnZhciBIYXNoUm91dGVyID0gZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEhhc2hSb3V0ZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIEhhc2hSb3V0ZXIoKSB7XG4gICAgdmFyIF90ZW1wLCBfdGhpcywgX3JldDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIYXNoUm91dGVyKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBfcmV0ID0gKF90ZW1wID0gKF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoYXJncykpKSwgX3RoaXMpLCBfdGhpcy5oaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShfdGhpcy5wcm9wcyksIF90ZW1wKSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICB9XG5cbiAgSGFzaFJvdXRlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJvdXRlciwgeyBoaXN0b3J5OiB0aGlzLmhpc3RvcnksIGNoaWxkcmVuOiB0aGlzLnByb3BzLmNoaWxkcmVuIH0pO1xuICB9O1xuXG4gIHJldHVybiBIYXNoUm91dGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5IYXNoUm91dGVyLnByb3BUeXBlcyA9IHtcbiAgYmFzZW5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGdldFVzZXJDb25maXJtYXRpb246IFByb3BUeXBlcy5mdW5jLFxuICBoYXNoVHlwZTogUHJvcFR5cGVzLm9uZU9mKFsnaGFzaGJhbmcnLCAnbm9zbGFzaCcsICdzbGFzaCddKSxcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IEhhc2hSb3V0ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvSGFzaFJvdXRlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfTG9jYXRpb25VdGlscyA9IHJlcXVpcmUoJy4vTG9jYXRpb25VdGlscycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgSGFzaFBhdGhDb2RlcnMgPSB7XG4gIGhhc2hiYW5nOiB7XG4gICAgZW5jb2RlUGF0aDogZnVuY3Rpb24gZW5jb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGggOiAnIS8nICsgKDAsIF9QYXRoVXRpbHMuc3RyaXBMZWFkaW5nU2xhc2gpKHBhdGgpO1xuICAgIH0sXG4gICAgZGVjb2RlUGF0aDogZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbiAgICB9XG4gIH0sXG4gIG5vc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBfUGF0aFV0aWxzLnN0cmlwTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoXG4gIH0sXG4gIHNsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogX1BhdGhVdGlscy5hZGRMZWFkaW5nU2xhc2hcbiAgfVxufTtcblxudmFyIGdldEhhc2hQYXRoID0gZnVuY3Rpb24gZ2V0SGFzaFBhdGgoKSB7XG4gIC8vIFdlIGNhbid0IHVzZSB3aW5kb3cubG9jYXRpb24uaGFzaCBoZXJlIGJlY2F1c2UgaXQncyBub3RcbiAgLy8gY29uc2lzdGVudCBhY3Jvc3MgYnJvd3NlcnMgLSBGaXJlZm94IHdpbGwgcHJlLWRlY29kZSBpdCFcbiAgdmFyIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgdmFyIGhhc2hJbmRleCA9IGhyZWYuaW5kZXhPZignIycpO1xuICByZXR1cm4gaGFzaEluZGV4ID09PSAtMSA/ICcnIDogaHJlZi5zdWJzdHJpbmcoaGFzaEluZGV4ICsgMSk7XG59O1xuXG52YXIgcHVzaEhhc2hQYXRoID0gZnVuY3Rpb24gcHVzaEhhc2hQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gcGF0aDtcbn07XG5cbnZhciByZXBsYWNlSGFzaFBhdGggPSBmdW5jdGlvbiByZXBsYWNlSGFzaFBhdGgocGF0aCkge1xuICB2YXIgaGFzaEluZGV4ID0gd2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignIycpO1xuXG4gIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNsaWNlKDAsIGhhc2hJbmRleCA+PSAwID8gaGFzaEluZGV4IDogMCkgKyAnIycgKyBwYXRoKTtcbn07XG5cbnZhciBjcmVhdGVIYXNoSGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShfRE9NVXRpbHMuY2FuVXNlRE9NLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhbkdvV2l0aG91dFJlbG9hZCA9ICgwLCBfRE9NVXRpbHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2gpKCk7XG5cbiAgdmFyIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBfRE9NVXRpbHMuZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGhhc2hUeXBlID0gcHJvcHMuaGFzaFR5cGUsXG4gICAgICBoYXNoVHlwZSA9IF9wcm9wcyRoYXNoVHlwZSA9PT0gdW5kZWZpbmVkID8gJ3NsYXNoJyA6IF9wcm9wcyRoYXNoVHlwZTtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/ICgwLCBfUGF0aFV0aWxzLnN0cmlwVHJhaWxpbmdTbGFzaCkoKDAsIF9QYXRoVXRpbHMuYWRkTGVhZGluZ1NsYXNoKShwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIF9IYXNoUGF0aENvZGVycyRoYXNoVCA9IEhhc2hQYXRoQ29kZXJzW2hhc2hUeXBlXSxcbiAgICAgIGVuY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZW5jb2RlUGF0aCxcbiAgICAgIGRlY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZGVjb2RlUGF0aDtcblxuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKCkge1xuICAgIHZhciBwYXRoID0gZGVjb2RlUGF0aChnZXRIYXNoUGF0aCgpKTtcblxuICAgICgwLCBfd2FybmluZzIuZGVmYXVsdCkoIWJhc2VuYW1lIHx8ICgwLCBfUGF0aFV0aWxzLmhhc0Jhc2VuYW1lKShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gKDAsIF9QYXRoVXRpbHMuc3RyaXBCYXNlbmFtZSkocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICB2YXIgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAgIGlmICghZm9yY2VOZXh0UG9wICYmICgwLCBfTG9jYXRpb25VdGlscy5sb2NhdGlvbnNBcmVFcXVhbCkocHJldkxvY2F0aW9uLCBsb2NhdGlvbikpIHJldHVybjsgLy8gQSBoYXNoY2hhbmdlIGRvZXNuJ3QgYWx3YXlzID09IGxvY2F0aW9uIGNoYW5nZS5cblxuICAgICAgaWYgKGlnbm9yZVBhdGggPT09ICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBJZ25vcmUgdGhpcyBjaGFuZ2U7IHdlIGFscmVhZHkgc2V0U3RhdGUgaW4gcHVzaC9yZXBsYWNlLlxuXG4gICAgICBpZ25vcmVQYXRoID0gbnVsbDtcblxuICAgICAgaGFuZGxlUG9wKGxvY2F0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBwYXRocyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBwYXRocyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZigoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKSh0b0xvY2F0aW9uKSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKCgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGZyb21Mb2NhdGlvbikpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICAvLyBFbnN1cmUgdGhlIGhhc2ggaXMgZW5jb2RlZCBwcm9wZXJseSBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZS5cbiAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgdmFyIGFsbFBhdGhzID0gWygwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGluaXRpYWxMb2NhdGlvbildO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gJyMnICsgZW5jb2RlUGF0aChiYXNlbmFtZSArICgwLCBfUGF0aFV0aWxzLmNyZWF0ZVBhdGgpKGxvY2F0aW9uKSk7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUFVTSCwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcHVzaEhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoaGlzdG9yeS5sb2NhdGlvbikpO1xuICAgICAgICB2YXIgbmV4dFBhdGhzID0gYWxsUGF0aHMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICBuZXh0UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgYWxsUGF0aHMgPSBuZXh0UGF0aHM7XG5cbiAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoOyBhIG5ldyBlbnRyeSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaycpO1xuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9ICgwLCBfTG9jYXRpb25VdGlscy5jcmVhdGVMb2NhdGlvbikocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSAoMCwgX1BhdGhVdGlscy5jcmVhdGVQYXRoKShsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUkVQTEFDRSwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmluZGV4T2YoKDAsIF9QYXRoVXRpbHMuY3JlYXRlUGF0aCkoaGlzdG9yeS5sb2NhdGlvbikpO1xuXG4gICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsUGF0aHNbcHJldkluZGV4XSA9IHBhdGg7XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgKDAsIF93YXJuaW5nMi5kZWZhdWx0KShjYW5Hb1dpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKTtcblxuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgKDAsIF9ET01VdGlscy5hZGRFdmVudExpc3RlbmVyKSh3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICAoMCwgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIpKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZUhhc2hIaXN0b3J5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9oaXN0b3J5L2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwiZXhwb3J0IHsgTWVtb3J5Um91dGVyIGFzIGRlZmF1bHQgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL01lbW9yeVJvdXRlci5qcyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IFJvdXRlIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmltcG9ydCBMaW5rIGZyb20gJy4vTGluayc7XG5cbi8qKlxuICogQSA8TGluaz4gd3JhcHBlciB0aGF0IGtub3dzIGlmIGl0J3MgXCJhY3RpdmVcIiBvciBub3QuXG4gKi9cbnZhciBOYXZMaW5rID0gZnVuY3Rpb24gTmF2TGluayhfcmVmKSB7XG4gIHZhciB0byA9IF9yZWYudG8sXG4gICAgICBleGFjdCA9IF9yZWYuZXhhY3QsXG4gICAgICBzdHJpY3QgPSBfcmVmLnN0cmljdCxcbiAgICAgIGxvY2F0aW9uID0gX3JlZi5sb2NhdGlvbixcbiAgICAgIGFjdGl2ZUNsYXNzTmFtZSA9IF9yZWYuYWN0aXZlQ2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3JlZi5jbGFzc05hbWUsXG4gICAgICBhY3RpdmVTdHlsZSA9IF9yZWYuYWN0aXZlU3R5bGUsXG4gICAgICBzdHlsZSA9IF9yZWYuc3R5bGUsXG4gICAgICBnZXRJc0FjdGl2ZSA9IF9yZWYuaXNBY3RpdmUsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsndG8nLCAnZXhhY3QnLCAnc3RyaWN0JywgJ2xvY2F0aW9uJywgJ2FjdGl2ZUNsYXNzTmFtZScsICdjbGFzc05hbWUnLCAnYWN0aXZlU3R5bGUnLCAnc3R5bGUnLCAnaXNBY3RpdmUnXSk7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGUsIHtcbiAgICBwYXRoOiAodHlwZW9mIHRvID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0bykpID09PSAnb2JqZWN0JyA/IHRvLnBhdGhuYW1lIDogdG8sXG4gICAgZXhhY3Q6IGV4YWN0LFxuICAgIHN0cmljdDogc3RyaWN0LFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4oX3JlZjIpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IF9yZWYyLmxvY2F0aW9uLFxuICAgICAgICAgIG1hdGNoID0gX3JlZjIubWF0Y2g7XG5cbiAgICAgIHZhciBpc0FjdGl2ZSA9ICEhKGdldElzQWN0aXZlID8gZ2V0SXNBY3RpdmUobWF0Y2gsIGxvY2F0aW9uKSA6IG1hdGNoKTtcblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgX2V4dGVuZHMoe1xuICAgICAgICB0bzogdG8sXG4gICAgICAgIGNsYXNzTmFtZTogaXNBY3RpdmUgPyBbYWN0aXZlQ2xhc3NOYW1lLCBjbGFzc05hbWVdLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KS5qb2luKCcgJykgOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBpc0FjdGl2ZSA/IF9leHRlbmRzKHt9LCBzdHlsZSwgYWN0aXZlU3R5bGUpIDogc3R5bGVcbiAgICAgIH0sIHJlc3QpKTtcbiAgICB9XG4gIH0pO1xufTtcblxuTmF2TGluay5wcm9wVHlwZXMgPSB7XG4gIHRvOiBMaW5rLnByb3BUeXBlcy50byxcbiAgZXhhY3Q6IFByb3BUeXBlcy5ib29sLFxuICBzdHJpY3Q6IFByb3BUeXBlcy5ib29sLFxuICBsb2NhdGlvbjogUHJvcFR5cGVzLm9iamVjdCxcbiAgYWN0aXZlQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGFjdGl2ZVN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgaXNBY3RpdmU6IFByb3BUeXBlcy5mdW5jXG59O1xuXG5OYXZMaW5rLmRlZmF1bHRQcm9wcyA9IHtcbiAgYWN0aXZlQ2xhc3NOYW1lOiAnYWN0aXZlJ1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTmF2TGluaztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9OYXZMaW5rLmpzIiwiZXhwb3J0IHsgUHJvbXB0IGFzIGRlZmF1bHQgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1Byb21wdC5qcyIsImV4cG9ydCB7IFJlZGlyZWN0IGFzIGRlZmF1bHQgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1JlZGlyZWN0LmpzIiwiZXhwb3J0IHsgUm91dGUgYXMgZGVmYXVsdCB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGUuanMiLCJleHBvcnQgeyBSb3V0ZXIgYXMgZGVmYXVsdCB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvUm91dGVyLmpzIiwiZXhwb3J0IHsgU3RhdGljUm91dGVyIGFzIGRlZmF1bHQgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1yb3V0ZXItZG9tL2VzL1N0YXRpY1JvdXRlci5qcyIsImV4cG9ydCB7IFN3aXRjaCBhcyBkZWZhdWx0IH0gZnJvbSAncmVhY3Qtcm91dGVyJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy9Td2l0Y2guanMiLCJleHBvcnQgeyBtYXRjaFBhdGggYXMgZGVmYXVsdCB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci1kb20vZXMvbWF0Y2hQYXRoLmpzIiwiZXhwb3J0IHsgd2l0aFJvdXRlciBhcyBkZWZhdWx0IH0gZnJvbSAncmVhY3Qtcm91dGVyJztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9lcy93aXRoUm91dGVyLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExpbmsgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcblxuaW1wb3J0IENvbnRlbnRTZXJ2aWNlcyBmcm9tICcuLi9zZXJ2aWNlcy9Db250ZW50U2VydmljZXMnO1xuY29uc3QgY29udGVudFNlcnZpY2VzID0gbmV3IENvbnRlbnRTZXJ2aWNlcztcblxuaW1wb3J0IEhlYWRlciBmcm9tICcuL0hlYWRlcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByZXNlbnRhdGlvbiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBnYWxsZXJpZXMgPSB0aGlzLnByb3BzLmdhbGxlcmllcy5tYXAoKGdhbGxlcnksIGlkeCkgPT4ge1xuICAgICAgcmV0dXJuIDxsaSBrZXk9e2lkeH0+XG4gICAgICAgIDxMaW5rIHRvPXtgL2dhbGxlcnkvJHtnYWxsZXJ5LmlkfWB9PlxuICAgICAgICAgIDxoMj57Z2FsbGVyeS50aXRsZX08L2gyPlxuICAgICAgICAgIDxwPntnYWxsZXJ5LmRlc2N9PC9wPlxuICAgICAgICAgIDxpbWcgc3JjPXtjb250ZW50U2VydmljZXMuZ2V0UGljRm9yKCdHJywgZ2FsbGVyeS5pZCkuc3JjfSBhbHQ9XCJcIi8+XG4gICAgICAgIDwvTGluaz5cbiAgICAgIDwvbGk+XG4gICAgfSk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3M9e1xuICAgICAgICBbXG4gICAgICAgICAgJ3ByZXNlbnRhdGlvbidcbiAgICAgICAgXS5qb2luKCcgJylcbiAgICAgIH0+XG4gICAgICAgIDxIZWFkZXIgdHlwZT1cIjFcIiB0ZXh0PXt0aGlzLnByb3BzLnRpdGxlfS8+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICB7Z2FsbGVyaWVzfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2NyaXB0cy9jb21wb25lbnRzL1ByZXNlbnRhdGlvbi5qcyIsImltcG9ydCBjb250ZW50IGZyb20gJy4uL2NvbnRlbnQuanNvbidcblxuY2xhc3MgQ29udGVudFNlcnZpY2VzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5nYWxsZXJpZXMgPSBjb250ZW50LmdhbGxlcmllcztcbiAgICB0aGlzLmhvdXNlcyA9IGNvbnRlbnQuaG91c2VzO1xuICAgIHRoaXMucGljcyA9IGNvbnRlbnQucGljcztcbiAgfVxuICBnZXRHYWxsZXJ5KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2FsbGVyaWVzLmZpbHRlcihnYWxsZXJ5PT57XG4gICAgICByZXR1cm4gZ2FsbGVyeS5pZCA9PT0gaWQ7XG4gICAgfSlbMF07XG4gIH1cbiAgZ2V0SG91c2UoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5ob3VzZXMuZmlsdGVyKGhvdXNlPT57XG4gICAgICByZXR1cm4gaG91c2UuaWQgPT09IGlkO1xuICAgIH0pWzBdO1xuICB9XG4gIGdldFBpYyhpZCkge1xuICAgIHJldHVybiB0aGlzLnBpY3MuZmlsdGVyKHBpYz0+e1xuICAgICAgcmV0dXJuIHBpYy5pZCA9PT0gaWQ7XG4gICAgfSlbMF07XG4gIH1cbiAgZ2V0UGljRm9yKHR5cGUsIGlkKSB7XG4gICAgcmV0dXJuIHRoaXMucGljcy5maWx0ZXIoKHBpYyk9PntcbiAgICAgIHJldHVybiBwaWMudHlwZSA9PT0gdHlwZSAmJiBwaWMueGlkID09PSBpZDtcbiAgICB9KVswXTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb250ZW50U2VydmljZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zY3JpcHRzL3NlcnZpY2VzL0NvbnRlbnRTZXJ2aWNlcy5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhlYWRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBtb3VudGVkOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG1vdW50ZWQ6IHRydWVcbiAgICB9KVxuICB9XG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICBtb3VudGVkOiBmYWxzZVxuICAgIH0pXG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IEhlYWRlclRhZyA9IGBoJHt0aGlzLnByb3BzLnR5cGV9YDtcbiAgICByZXR1cm4gKFxuICAgICAgPEhlYWRlclRhZ1xuICAgICAgICBjbGFzcz17W1xuICAgICAgICAgIFwiaGVhZGVyXCJcbiAgICAgICAgXS5qb2luKCcgJyl9XG4gICAgICAgIHJlZj17KGNvbXBvbmVudCkgPT4ge3RoaXMuaGVhZGVyID0gY29tcG9uZW50fX1cbiAgICAgID5cbiAgICAgICAge3RoaXMucHJvcHMudGV4dH1cbiAgICAgIDwvSGVhZGVyVGFnPlxuICAgICk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NjcmlwdHMvY29tcG9uZW50cy9IZWFkZXIuanMiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEtMiEuL21haW4ubGVzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0yIS4vbWFpbi5sZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMS0yIS4vbWFpbi5sZXNzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy9tYWluLmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDIzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5leHBvcnRzLmkocmVxdWlyZShcIi0hLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL25vcm1hbGl6ZS5jc3Mvbm9ybWFsaXplLmNzc1wiKSwgXCJcIik7XG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiaHRtbCxcXG5ib2R5IHtcXG4gIGJvcmRlcjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG5ib2R5IHtcXG4gIGJhY2tncm91bmQ6IG9yYW5nZTtcXG59XFxuLmJvaWxlcnBsYXRlIHtcXG4gIGNvbG9yOiBncmVlbjtcXG59XFxuQGZvbnQtZmFjZSB7XFxuICBmb250LWZhbWlseTogJ0xlZ29JY29ucyc7XFxuICBzcmM6IHVybChcIiArIHJlcXVpcmUoXCIuL2ZvbnRzL2xlZ28taWNvbnMuZW90XCIpICsgXCIpO1xcbiAgc3JjOiB1cmwoXCIgKyByZXF1aXJlKFwiLi9mb250cy9sZWdvLWljb25zLmVvdFwiKSArIFwiPyNpZWZpeCkgZm9ybWF0KCdlbWJlZGRlZC1vcGVudHlwZScpLCB1cmwoXCIgKyByZXF1aXJlKFwiLi9mb250cy9sZWdvLWljb25zLndvZmZcIikgKyBcIikgZm9ybWF0KCd3b2ZmJyksIHVybChcIiArIHJlcXVpcmUoXCIuL2ZvbnRzL2xlZ28taWNvbnMudHRmXCIpICsgXCIpIGZvcm1hdCgndHJ1ZXR5cGUnKSwgdXJsKFwiICsgcmVxdWlyZShcIi4vZm9udHMvbGVnby1pY29ucy5zdmdcIikgKyBcIiNMZWdvSWNvbnMpIGZvcm1hdCgnc3ZnJyk7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbn1cXG5AZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiAnTG92ZWRieXRoZUtpbmcnO1xcbiAgc3JjOiB1cmwoXCIgKyByZXF1aXJlKFwiLi9mb250cy9Mb3ZlZGJ5dGhlS2luZy5lb3RcIikgKyBcIik7XFxuICBzcmM6IHVybChcIiArIHJlcXVpcmUoXCIuL2ZvbnRzL0xvdmVkYnl0aGVLaW5nLmVvdFwiKSArIFwiPyNpZWZpeCkgZm9ybWF0KCdlbWJlZGRlZC1vcGVudHlwZScpLCB1cmwoXCIgKyByZXF1aXJlKFwiLi9mb250cy9Mb3ZlZGJ5dGhlS2luZy53b2ZmXCIpICsgXCIpIGZvcm1hdCgnd29mZicpLCB1cmwoXCIgKyByZXF1aXJlKFwiLi9mb250cy9Mb3ZlZGJ5dGhlS2luZy50dGZcIikgKyBcIikgZm9ybWF0KCd0cnVldHlwZScpLCB1cmwoXCIgKyByZXF1aXJlKFwiLi9mb250cy9Mb3ZlZGJ5dGhlS2luZy5zdmdcIikgKyBcIiNMb3ZlZGJ5dGhlS2luZykgZm9ybWF0KCdzdmcnKTtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxufVxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6ICdVYnVudHUtUmVndWxhcic7XFxuICBzcmM6IHVybCgnL2ZvbnRzL1VidW50dS1SZWd1bGFyLmVvdCcpO1xcbiAgc3JjOiB1cmwoJy9mb250cy9VYnVudHUtUmVndWxhci53b2ZmMicpIGZvcm1hdCgnd29mZjInKSwgdXJsKCcvZm9udHMvVWJ1bnR1LVJlZ3VsYXIuZW90PyNpZWZpeCcpIGZvcm1hdCgnZW1iZWRkZWQtb3BlbnR5cGUnKTtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxufVxcbkBmb250LWZhY2Uge1xcbiAgZm9udC1mYW1pbHk6ICdVYnVudHUnO1xcbiAgc3JjOiB1cmwoJy9mb250cy9VYnVudHUud29mZicpIGZvcm1hdCgnd29mZicpLCB1cmwoJy9mb250cy9VYnVudHUudHRmJykgZm9ybWF0KCd0cnVldHlwZScpLCB1cmwoJy9mb250cy9VYnVudHUuc3ZnI1VidW50dScpIGZvcm1hdCgnc3ZnJyk7XFxuICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbn1cXG4uY29kZXNpZ24ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG59XFxuLmNvZGVzaWduID4gKiB7XFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXG59XFxuLm5hdmlnYXRpb24ge1xcbiAgd2lkdGg6IDI1JTtcXG4gIHBhZGRpbmc6IDIlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2RkZDtcXG59XFxuLm5hdmlnYXRpb24gLmhlYWRlciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbn1cXG4ubmF2aWdhdGlvbiAubG9nbyB7XFxuICB3aWR0aDogMzBweDtcXG4gIG1hcmdpbi1yaWdodDogMTBweDtcXG59XFxuLm5hdmlnYXRpb24gaDEge1xcbiAgZm9udC1mYW1pbHk6ICdVYnVudHUnLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gIGZvbnQtc2l6ZTogMWVtO1xcbn1cXG4ubmF2aWdhdGlvbiBuYXYgdWwge1xcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcz97XCJnbG9iYWxWYXJzXCI6e1wiZm9udFBhdGhcIjpcIicvZm9udHMnXCJ9fSEuL3N0eWxlcy9tYWluLmxlc3Ncbi8vIG1vZHVsZSBpZCA9IDIzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qISBub3JtYWxpemUuY3NzIHY3LjAuMCB8IE1JVCBMaWNlbnNlIHwgZ2l0aHViLmNvbS9uZWNvbGFzL25vcm1hbGl6ZS5jc3MgKi9cXG5cXG4vKiBEb2N1bWVudFxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW5cXG4gKiAgICBJRSBvbiBXaW5kb3dzIFBob25lIGFuZCBpbiBpT1MuXFxuICovXFxuXFxuaHRtbCB7XFxuICBsaW5lLWhlaWdodDogMS4xNTsgLyogMSAqL1xcbiAgLW1zLXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7IC8qIDIgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xcbn1cXG5cXG4vKiBTZWN0aW9uc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBtYXJnaW4gaW4gYWxsIGJyb3dzZXJzIChvcGluaW9uYXRlZCkuXFxuICovXFxuXFxuYm9keSB7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDktLlxcbiAqL1xcblxcbmFydGljbGUsXFxuYXNpZGUsXFxuZm9vdGVyLFxcbmhlYWRlcixcXG5uYXYsXFxuc2VjdGlvbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuLyoqXFxuICogQ29ycmVjdCB0aGUgZm9udCBzaXplIGFuZCBtYXJnaW4gb24gYGgxYCBlbGVtZW50cyB3aXRoaW4gYHNlY3Rpb25gIGFuZFxcbiAqIGBhcnRpY2xlYCBjb250ZXh0cyBpbiBDaHJvbWUsIEZpcmVmb3gsIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuaDEge1xcbiAgZm9udC1zaXplOiAyZW07XFxuICBtYXJnaW46IDAuNjdlbSAwO1xcbn1cXG5cXG4vKiBHcm91cGluZyBjb250ZW50XFxuICAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSA5LS5cXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRS5cXG4gKi9cXG5cXG5maWdjYXB0aW9uLFxcbmZpZ3VyZSxcXG5tYWluIHsgLyogMSAqL1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBtYXJnaW4gaW4gSUUgOC5cXG4gKi9cXG5cXG5maWd1cmUge1xcbiAgbWFyZ2luOiAxZW0gNDBweDtcXG59XFxuXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gRmlyZWZveC5cXG4gKiAyLiBTaG93IHRoZSBvdmVyZmxvdyBpbiBFZGdlIGFuZCBJRS5cXG4gKi9cXG5cXG5ociB7XFxuICBib3gtc2l6aW5nOiBjb250ZW50LWJveDsgLyogMSAqL1xcbiAgaGVpZ2h0OiAwOyAvKiAxICovXFxuICBvdmVyZmxvdzogdmlzaWJsZTsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBhbmQgc2NhbGluZyBvZiBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiAqIDIuIENvcnJlY3QgdGhlIG9kZCBgZW1gIGZvbnQgc2l6aW5nIGluIGFsbCBicm93c2Vycy5cXG4gKi9cXG5cXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IG1vbm9zcGFjZSwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKiBUZXh0LWxldmVsIHNlbWFudGljc1xcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogMS4gUmVtb3ZlIHRoZSBncmF5IGJhY2tncm91bmQgb24gYWN0aXZlIGxpbmtzIGluIElFIDEwLlxcbiAqIDIuIFJlbW92ZSBnYXBzIGluIGxpbmtzIHVuZGVybGluZSBpbiBpT1MgOCsgYW5kIFNhZmFyaSA4Ky5cXG4gKi9cXG5cXG5hIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50OyAvKiAxICovXFxuICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbi1za2lwOiBvYmplY3RzOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIDEuIFJlbW92ZSB0aGUgYm90dG9tIGJvcmRlciBpbiBDaHJvbWUgNTctIGFuZCBGaXJlZm94IDM5LS5cXG4gKiAyLiBBZGQgdGhlIGNvcnJlY3QgdGV4dCBkZWNvcmF0aW9uIGluIENocm9tZSwgRWRnZSwgSUUsIE9wZXJhLCBhbmQgU2FmYXJpLlxcbiAqL1xcblxcbmFiYnJbdGl0bGVdIHtcXG4gIGJvcmRlci1ib3R0b206IG5vbmU7IC8qIDEgKi9cXG4gIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lOyAvKiAyICovXFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUHJldmVudCB0aGUgZHVwbGljYXRlIGFwcGxpY2F0aW9uIG9mIGBib2xkZXJgIGJ5IHRoZSBuZXh0IHJ1bGUgaW4gU2FmYXJpIDYuXFxuICovXFxuXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7XFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxuICovXFxuXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2UgYW5kIHNjYWxpbmcgb2YgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4gKiAyLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuY29kZSxcXG5rYmQsXFxuc2FtcCB7XFxuICBmb250LWZhbWlseTogbW9ub3NwYWNlLCBtb25vc3BhY2U7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHN0eWxlIGluIEFuZHJvaWQgNC4zLS5cXG4gKi9cXG5cXG5kZm4ge1xcbiAgZm9udC1zdHlsZTogaXRhbGljO1xcbn1cXG5cXG4vKipcXG4gKiBBZGQgdGhlIGNvcnJlY3QgYmFja2dyb3VuZCBhbmQgY29sb3IgaW4gSUUgOS0uXFxuICovXFxuXFxubWFyayB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmYwO1xcbiAgY29sb3I6ICMwMDA7XFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbnNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogODAlO1xcbn1cXG5cXG4vKipcXG4gKiBQcmV2ZW50IGBzdWJgIGFuZCBgc3VwYCBlbGVtZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgbGluZSBoZWlnaHQgaW5cXG4gKiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxuc3ViLFxcbnN1cCB7XFxuICBmb250LXNpemU6IDc1JTtcXG4gIGxpbmUtaGVpZ2h0OiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG5zdWIge1xcbiAgYm90dG9tOiAtMC4yNWVtO1xcbn1cXG5cXG5zdXAge1xcbiAgdG9wOiAtMC41ZW07XFxufVxcblxcbi8qIEVtYmVkZGVkIGNvbnRlbnRcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDktLlxcbiAqL1xcblxcbmF1ZGlvLFxcbnZpZGVvIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gaU9TIDQtNy5cXG4gKi9cXG5cXG5hdWRpbzpub3QoW2NvbnRyb2xzXSkge1xcbiAgZGlzcGxheTogbm9uZTtcXG4gIGhlaWdodDogMDtcXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBib3JkZXIgb24gaW1hZ2VzIGluc2lkZSBsaW5rcyBpbiBJRSAxMC0uXFxuICovXFxuXFxuaW1nIHtcXG4gIGJvcmRlci1zdHlsZTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogSGlkZSB0aGUgb3ZlcmZsb3cgaW4gSUUuXFxuICovXFxuXFxuc3ZnOm5vdCg6cm9vdCkge1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG59XFxuXFxuLyogRm9ybXNcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIDEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzIChvcGluaW9uYXRlZCkuXFxuICogMi4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gRmlyZWZveCBhbmQgU2FmYXJpLlxcbiAqL1xcblxcbmJ1dHRvbixcXG5pbnB1dCxcXG5vcHRncm91cCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xcbiAgbGluZS1oZWlnaHQ6IDEuMTU7IC8qIDEgKi9cXG4gIG1hcmdpbjogMDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBTaG93IHRoZSBvdmVyZmxvdyBpbiBJRS5cXG4gKiAxLiBTaG93IHRoZSBvdmVyZmxvdyBpbiBFZGdlLlxcbiAqL1xcblxcbmJ1dHRvbixcXG5pbnB1dCB7IC8qIDEgKi9cXG4gIG92ZXJmbG93OiB2aXNpYmxlO1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEVkZ2UsIEZpcmVmb3gsIGFuZCBJRS5cXG4gKiAxLiBSZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEZpcmVmb3guXFxuICovXFxuXFxuYnV0dG9uLFxcbnNlbGVjdCB7IC8qIDEgKi9cXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBQcmV2ZW50IGEgV2ViS2l0IGJ1ZyB3aGVyZSAoMikgZGVzdHJveXMgbmF0aXZlIGBhdWRpb2AgYW5kIGB2aWRlb2BcXG4gKiAgICBjb250cm9scyBpbiBBbmRyb2lkIDQuXFxuICogMi4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKi9cXG5cXG5idXR0b24sXFxuaHRtbCBbdHlwZT1cXFwiYnV0dG9uXFxcIl0sIC8qIDEgKi9cXG5bdHlwZT1cXFwicmVzZXRcXFwiXSxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl0ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBidXR0b247IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBib3JkZXIgYW5kIHBhZGRpbmcgaW4gRmlyZWZveC5cXG4gKi9cXG5cXG5idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsXFxuW3R5cGU9XFxcImJ1dHRvblxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJyZXNldFxcXCJdOjotbW96LWZvY3VzLWlubmVyLFxcblt0eXBlPVxcXCJzdWJtaXRcXFwiXTo6LW1vei1mb2N1cy1pbm5lciB7XFxuICBib3JkZXItc3R5bGU6IG5vbmU7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4vKipcXG4gKiBSZXN0b3JlIHRoZSBmb2N1cyBzdHlsZXMgdW5zZXQgYnkgdGhlIHByZXZpb3VzIHJ1bGUuXFxuICovXFxuXFxuYnV0dG9uOi1tb3otZm9jdXNyaW5nLFxcblt0eXBlPVxcXCJidXR0b25cXFwiXTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwicmVzZXRcXFwiXTotbW96LWZvY3VzcmluZyxcXG5bdHlwZT1cXFwic3VibWl0XFxcIl06LW1vei1mb2N1c3Jpbmcge1xcbiAgb3V0bGluZTogMXB4IGRvdHRlZCBCdXR0b25UZXh0O1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBwYWRkaW5nIGluIEZpcmVmb3guXFxuICovXFxuXFxuZmllbGRzZXQge1xcbiAgcGFkZGluZzogMC4zNWVtIDAuNzVlbSAwLjYyNWVtO1xcbn1cXG5cXG4vKipcXG4gKiAxLiBDb3JyZWN0IHRoZSB0ZXh0IHdyYXBwaW5nIGluIEVkZ2UgYW5kIElFLlxcbiAqIDIuIENvcnJlY3QgdGhlIGNvbG9yIGluaGVyaXRhbmNlIGZyb20gYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBJRS5cXG4gKiAzLiBSZW1vdmUgdGhlIHBhZGRpbmcgc28gZGV2ZWxvcGVycyBhcmUgbm90IGNhdWdodCBvdXQgd2hlbiB0aGV5IHplcm8gb3V0XFxuICogICAgYGZpZWxkc2V0YCBlbGVtZW50cyBpbiBhbGwgYnJvd3NlcnMuXFxuICovXFxuXFxubGVnZW5kIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBkaXNwbGF5OiB0YWJsZTsgLyogMSAqL1xcbiAgbWF4LXdpZHRoOiAxMDAlOyAvKiAxICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxuICB3aGl0ZS1zcGFjZTogbm9ybWFsOyAvKiAxICovXFxufVxcblxcbi8qKlxcbiAqIDEuIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDktLlxcbiAqIDIuIEFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lLCBGaXJlZm94LCBhbmQgT3BlcmEuXFxuICovXFxuXFxucHJvZ3Jlc3Mge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrOyAvKiAxICovXFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBkZWZhdWx0IHZlcnRpY2FsIHNjcm9sbGJhciBpbiBJRS5cXG4gKi9cXG5cXG50ZXh0YXJlYSB7XFxuICBvdmVyZmxvdzogYXV0bztcXG59XFxuXFxuLyoqXFxuICogMS4gQWRkIHRoZSBjb3JyZWN0IGJveCBzaXppbmcgaW4gSUUgMTAtLlxcbiAqIDIuIFJlbW92ZSB0aGUgcGFkZGluZyBpbiBJRSAxMC0uXFxuICovXFxuXFxuW3R5cGU9XFxcImNoZWNrYm94XFxcIl0sXFxuW3R5cGU9XFxcInJhZGlvXFxcIl0ge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xcbiAgcGFkZGluZzogMDsgLyogMiAqL1xcbn1cXG5cXG4vKipcXG4gKiBDb3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBDaHJvbWUuXFxuICovXFxuXFxuW3R5cGU9XFxcIm51bWJlclxcXCJdOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uLFxcblt0eXBlPVxcXCJudW1iZXJcXFwiXTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcblxcbi8qKlxcbiAqIDEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiAqIDIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxcbiAqL1xcblxcblt0eXBlPVxcXCJzZWFyY2hcXFwiXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cXG59XFxuXFxuLyoqXFxuICogUmVtb3ZlIHRoZSBpbm5lciBwYWRkaW5nIGFuZCBjYW5jZWwgYnV0dG9ucyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4gKi9cXG5cXG5bdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24sXFxuW3R5cGU9XFxcInNlYXJjaFxcXCJdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuLyoqXFxuICogMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4gKiAyLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxuICovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKiBJbnRlcmFjdGl2ZVxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLypcXG4gKiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBJRSA5LS5cXG4gKiAxLiBBZGQgdGhlIGNvcnJlY3QgZGlzcGxheSBpbiBFZGdlLCBJRSwgYW5kIEZpcmVmb3guXFxuICovXFxuXFxuZGV0YWlscywgLyogMSAqL1xcbm1lbnUge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcblxcbi8qXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gYWxsIGJyb3dzZXJzLlxcbiAqL1xcblxcbnN1bW1hcnkge1xcbiAgZGlzcGxheTogbGlzdC1pdGVtO1xcbn1cXG5cXG4vKiBTY3JpcHRpbmdcXG4gICA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFIDktLlxcbiAqL1xcblxcbmNhbnZhcyB7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcblxcbi8qKlxcbiAqIEFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIElFLlxcbiAqL1xcblxcbnRlbXBsYXRlIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbi8qIEhpZGRlblxcbiAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXFxuXFxuLyoqXFxuICogQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gSUUgMTAtLlxcbiAqL1xcblxcbltoaWRkZW5dIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIhLi9ub2RlX21vZHVsZXMvbm9ybWFsaXplLmNzcy9ub3JtYWxpemUuY3NzXG4vLyBtb2R1bGUgaWQgPSAyNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vZm9udC13b2ZmO2Jhc2U2NCxkMDlHUmdBQkFBQUFBT3BVQUFzQUFBQUE2Z2dBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQlBVeTh5QUFBQkNBQUFBR0FBQUFCZ0R4SUd1R050WVhBQUFBRm9BQUFBZEFBQUFIVHVKSmV2WjJGemNBQUFBZHdBQUFBSUFBQUFDQUFBQUJCbmJIbG1BQUFCNUFBQTRWd0FBT0ZjTElsaHZHaGxZV1FBQU9OQUFBQUFOZ0FBQURZTFdDZ2lhR2hsWVFBQTQzZ0FBQUFrQUFBQUpBZkhCSVpvYlhSNEFBRGpuQUFBQXpBQUFBTXdKZ0VjQTJ4dlkyRUFBT2JNQUFBQm1nQUFBWnFDOWt2OGJXRjRjQUFBNkdnQUFBQWdBQUFBSUFEakFrMXVZVzFsQUFEb2lBQUFBYW9BQUFHcXBkakR1WEJ2YzNRQUFPbzBBQUFBSUFBQUFDQUFBd0FBQUFNRC9RR1FBQVVBQUFLWkFzd0FBQUNQQXBrQ3pBQUFBZXNBTXdFSkFBQUFBQUFBQUFBQUFBQUFBQUFBQVJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQTZaRUR3UC9BQUVBRHdBQkFBQUFBQVFBQUFBQUFBQUFBQUFBQUlBQUFBQUFBQXdBQUFBTUFBQUFjQUFFQUF3QUFBQndBQXdBQkFBQUFIQUFFQUZnQUFBQVNBQkFBQXdBQ0FBRUFJT0FJNXBmcEpla242WkgvL2YvL0FBQUFBQUFnNEFIbUFPa0E2U2Zwa2YvOS8vOEFBZi9qSUFNYURCZWtGNk1YT2dBREFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFCLy84QUR3QUJBQUFBQUFBQUFBQUFBZ0FBTnprQkFBQUFBQUVBQUFBQUFBQUFBQUFDQUFBM09RRUFBQUFBQVFBQUFBQUFBQUFBQUFJQUFEYzVBUUFBQUFBQkFBWC85UVA3QTRjQUtBQUFBVFUwSmlzQklnWWRBU2NtSWdjQk1BWVhGall4RVNFUk5EWTdBVElXRlJFaEVUQVdOelltTVNjRFF4QVJSQkVPcHdrZEMvNGVDaDBkVmdFRUVSR2RFUklCQTEwYkdRcTRBcC9IRGhNVkRHT0FDQWora0NnbUl3bitTZ0VtRGhJVEQvN2NBYlVISnlVa2pBQUZBQUQvd0FRQUE4QUFFd0EwQURnQVBBQkFBQUFCSWc0Q0ZSUWVBak15UGdJMU5DNENBelVqRlM0REp6TTFJejRETnhVek5SNERGeU1WTXc0REJ4c0JCUmNuRndjM0p3TWxKd0lBYXJ1TFVGQ0x1MnBxdTR0UVVJdTdQMVpMaFdWQkNHOXZDRUZsaFV0V1M0VmxRUWR1YmdkQlpZVkxONWYrcGNTMmE3MVNEcGNCVzhRRHdGQ0x1MnBxdTR0UVVJdTdhbXE3aTFEOFdHNXVCMEZsaFV0V1M0VmxRUWh2YndoQlpZVkxWa3VGWlVFSEFVY0JXcGpDZUdwVHZVcitwcGpDQUFBQUFRQUFBREVFQUFOUEFBd0FBQ1VSSXpVaEZTTTFJUlVqRVNFRUFIdit6WnIrdzNzQzdERUNtWVdGaFlYOVp3QUFBUUF3LzhBRHpRUEFBQjRBQUFFak5UUW1JeUVpQmhVd0ZCVWpJZ1lWRVJRV0Z4VWhOVDRCTlJFMkppTURHem9SQ3Y1M0RBODlTMnBpUlFKUFIyQUNhVXNERDVZS0VROE1sQUpvU3Y1MFJXY0ZZR0FGWkVnQmowaG5BQUFGQUFzQWV3UDFBdTBBTWdCQUFFMEFXUUJtQUFBQkxnRU9BVEVPQVNzQklpWW5NQzRCQmdjT0FoWXhIZ0UzUGdNeFBnRXpJVElXRnpBZUFoY1dOamN3Tmk0Qkp3VVZJeFVqTlNNMU16VXpGVE1WQlNJbU5UUTJNeklXRlE0Qkl6VWlKalUwTmpNeUZoVU9BUmNpSmpVME5qTXlGaFVPQVNNRHBUTjNaa01LSUEwMkRDRUtRMlozTXpNbUJBMEhNaXdXUURzcUNSME1BVVlNSFFrcU8wQVdMRElIRFFVbU12M3pUVkZOVFZOTkFTd1dJQ0FZRnlFQkloY1dJQ0FZRnlFQkluVVhJU0FZRmlJQ0lCWUNxbE1xRVNrSEN3c0hLUkVxVTFTbWhGSXROUU1DTWpzeENnME9DVEU3TWdJRE5TMVNoS1pVV2t0TlRWTk5Ud2FvSUJZWElTRVhGaUNZSVJjWElTQVlGeUZTSWhZWElTQVlGaUlBQWdBaS8rSUQzZ09lQUJRQUlRQUFBU0lPQWhVVUhnSXpNajRDTlRRdUFpTURCaVkxRVRRMkZ3VVdGQWNGQWdCanJvSkxTNEt1WTJPdWdrdExncTVqVlFZTENnY0JQUWNIL3NNRG5rdUNybU5qcm9KTFM0S3VZMk91Z2t2OU1BUUZDQUhTQ1FRRjZRUU9CZU1BQWdBZy85c0R4Z09rQUE0QUtnQUFBUjRCQnc0REp6QTJOejRCRndFbURnSUhEZ014QmhZeEZ4WTJNVEErQWpjK0F5Y0JUVEltSVFvc1VuOWRVem9MWFRnQ2VSbHhmbkFaRjB4SE5CQVVPQmNrTUUxZUwwZHNRUThWQVFrbFFUVVFOek1oQ0VhdUlrQW9BcHNOUTJadEhSdGlYMFlTSURRUEV5dElYalJRajNCS0RBQUFBd0FBLy8wRUFBT0RBQm9BTGdBNkFBQUJJelUwSmlNaElnWWRBU01pQmhVUkZCWXpJVEkyTlJFMEppTUJJaTRDTlRRK0FqTXlIZ0lWRkE0Q0p5SW1OVFEyTXpJV0ZSUUdBOGEwUHl6K3Npdy90UmNpSWhjRGpSZ2lJaGorT2pGWFFTWW1RVmN4TVZkQkppWkJWekU4VlZVOFBGVlZBdWNzTEVSRUxDd2hGLzJHRnlFaEZ3SjZGeUg5bkNaQlZ6RXhWMEVtSmtGWE1URlhRU1plVlR3OFZWVThQRlVBQUFBQUF3QUUvOEFEL0FQQUFEd0FSQUJMQUFBQkp5TStBVEVoTUJZWEl3Y1VCaDRCRng0QkZ4VWVBUlVVQmdjd0JoVU9BUWNPQVRFaE1DWW5MZ0VuTkNZeExnRTFORFkzTlQ0Qk56NENKalVGTXg0QkZ5NEJOd0UrQVRjekZnWUQvQVM1QWdMOWVnSUN1UVFJTFg2RUsyUVFCd2tKQndjT0hSQXRIZ0dHSGkwUUhRNEhCd2tKQnhCa0s0UitMUWo4UTRVSEhSbVZNUVFDd0JrZEI0VUVNUU5aR3lNcEtTTWJBazU4bTAxU1BnNEJCM1lMQ3hNSEJRRUlHQTh1TmpZdUR4Z0lBUVVIRXdzTGRnY0JEajVTVFp0OFRnSWxibGxlZldvKy90dGVXVzQrYWdBRUFBRC83QVFEQTN3QUZnQXFBRGNBUXdBQUFTTVJGQVlqSVJVVUZqTWhGek0xTXpJMk5SRXVBU01ESVNJR0ZSRVVGanNCRlRNM0lUSTJOUkUwSmdFak5UUTJOeFVPQVIwQk14VXpJelUwTmpjVkRnRWRBVE1EeG9VVEQvNnFDaElCUzFVS09oSW9BaWtTNGYxU0VpVWxFajBwY1FIWER5Y2svbDV3T0RnY0NTWGliamcySFN0SUFreis2QklHc1JBa1Mwc2lFZ0d1RHlRQk1Cc1MvaHdTRjNSMEdSQUI1QkliL29WME1UWURMUVVoRndSd2RERTJBeTBGSVJjRUFBQURBQUQvd0FRQUE4QUFEd0FUQUJjQUFBRWpOU0VpQmhVUkZCWXpJUkV6SnpjRElSRWhCU0VWSVFRQWlmek5IQ2dvSEFNemlZbUo3LzI4QWtUK1RRRWkvdDRETjRrb0hQeUlIQ2dDWm9tSS9POEROS3VKQUFBQUJBQXovOEFEelFQQUFCQUFGQUFZQUNRQUFBRWhJZ1lWRVJRV015RXlOalVSTkNZakF5RTFJVFVoTlNFMUlSRXpOVE1WTXpVekZUTURpZnp1SENnb0hBTVNIQ2dvSElMOThnSU8vZklDRHYzMlBhUk9uVDREd0NnYy9JZ2NLQ2djQTNnY0tQeWRLVklwYlFGVlJVVkZSUUFBQUFBRUFEUC93QVBOQThBQUVBQlhBRndBWVFBQUFTRWlCaFVSRkJZeklUSTJOUkUwSmlNRlBnRXpQZ0V6SGdFWEhnRVhIZ0VYSGdFM01ESXhQZ0V6TWhZVkZBWWpJaVluTVE0QkJ3NEJCdzRCQnc0Qkl5NEJJeUltTnpRMk56NEJOejRCSnk0Qkp5WUdKeUltTndFaE5TRVZOU0UxSVJVRGlmenVIQ2dvSEFNU0hDZ29IUDF6QkF3SkVrOEhEQkVIQmdvRkJRMEhDWElFQVEwdEhDZzVPU2dZS1E0ZU9SMEZDUVVLRHdjTEhSTVdMaFlNRUFFT0Nnd1lEQjBRREFZZEN3OEpEdzRQQmdJTC9mSUNEdjN5QWc0RHdDZ2MvSWdjS0NnY0EzZ2NLUE1JQ1FJREFRMEpCdzhIQmdnQ0JBRUJGeHc1S0NrNEVSRUNBUUlCQmdNSEZRb09EUUVCRVF3S0RnSUNCZ1lPT1JrTUV3TURBUUVXRGYyQk16TitNek1BQUFBS0FFdi8xd080QTZjQUtBQXNBREFBTlFBNkFENEFRZ0JIQUV3QVVRQUFBU0V3SWpFaUJoVXdGQlVSTUJReEZCWXpPZ0V4SVRJd016STJOVEEwTVJFd05ERTBKaU13SWpFVElSRWhBU0VWSVRVaEZTRTFOeUVWSVRVMUlSVWhGU0VWSVFFaEZTRTFOU0VWSVRVaE14VWpOUU41L1JFQkdpUWtHUUVCQXU4QkFSa2tKQm9CQXYwU0F1NzlaZ0dtL2xvQ09QM0lCUUkzL2NrQ04vM0pBalA5elFFUUFTZisyUUVuL3RuKzYvbjVBNmNrR2dFQi9LOEJHaVFrR2dFRFVnRWFKUHh5QTB6OU15cVJKaWJUS2lwbkpiTWxBV1FsSld3cUtwK2ZBQUFBQUFnQUFQL0FCQUFEd0FBREFBY0FHQUFjQUNFQUpnQXFBQzRBQUFFak5UTXBBUlVoRXhFVUJpTWhJaVkxRVRRMk15RXlGaFVISVJFaEFTTVZNelVwQVJVaE5RVWpGVE1sSVJVaEFWVm1aZ0c4L3FzQlZlOG9IUHlJSENnb0hBTjRIQ2hWL0tvRFZ2MnFabVlCdlA2ckFWWCtSR1ptQWJ6K3F3RlZBbHBtWmdFaS9JZ2NLQ2djQTNnY0tDZ2NFZnlxQWQ1bVptWm16V1ptWmdBQUFBSUFsUC9BQTJ3RHdBQXpBRUFBQUFFVUJnY09BUWNPQVFjT0FRY2pOVFEyTno0Qk56NEJOejRCTlRRbUp5NEJJeUlHQnc0QkJ5YytBVGMrQVRNeUZoY2VBUlVCSWdZVkZCWXpNalkxTkNZakEyd1FEdzlBTVNNdENRa0tBZXNIQndjV0RnNUNNeDRlRFEwTkpSa2JMQkVSRlFYeENETXJMSXBjU0hVc1BEditoelpNVERZMlRFdzJBcThiTlJvYVFDWWNMUklRS0JnT0lEUVRGQ1FRRUR3cUdTMFdGU0VNREF3U0VSQTFKaDVDYlNrcUt4NGVLR3BEL2hSTU5UWk1URFkxVEFBQ0FBRC93QVFBQThBQUR3QTdBQUFCTWhZZEFSUUdJeUVpSmowQk5EWXpBUzRESnk0QkJ5WUdCdzREQndZV016b0JNeHdCRlJRV016SWlNekkyTlR3Qk5Ub0JNekkySndQY0R4VVZEL3hJRHhVVkR3TDNJVUZDUVNFRkNnWUdDd1FoUVVKQklRd01GUngrR3hJTlBCUThEUkliZmh3VkRBd0R3QlVQUVE4VkZROUJEeFg5cXlkUFQwNG9CUVVCQVFVRktFNVBUeWNPSlhkc2R3d1NFZ3gzYkhjbERnQUFBQUFDQUFEL3dBUUFBOEFBRUFBOEFBQVhJaVk5QVRRMk15RXlGaDBCRkFZaklSTWVBeGNlQVRjV05qYytBemMySmlNcUFTTThBVFUwSmlNaU1pTWlCaFVjQVJVcUFTTWlCaGNrRHhVVkR3TzREeFVWRC94SXdTRkJRa0VoQlFvR0Jnb0ZJVUZDUVNFTURCVWNmaHNTRFR3VVBBMFNHMzRjRlF3TVFCVVBRUThWRlE5QkR4VUNWU2RQVDA0b0JRVUJBUVVGS0U1UFR5Y09KWGRzZHd3U0VneDNiSGNsRGdBQUFBQUZBT3Ivd0FNV0E4QUFFQUFmQUNzQU1BQllBQUFCSVNJR0ZSRVVGak1oTWpZMUVUUW1Jd2N6TWhZVkZBWXJBU0ltTlRRMk14TWlKalUwTmpNeUZoVVVCamNoRVNFUkFUb0JNendCTlRRMk16SWlNeklXRlJ3QkZUb0JNeklXQnc0QkJ3NEJKd1ltSnk0Qkp5WTJNd0xFL25naU1EQWlBWWdpTURBaTcxc0ZCUVVGV3dVRkJRVXVFUmNYRVJBWEY4WCtVQUd3L3NNS01Rc0hCQmdJR0FRSEN6RUtDUVFFR2pJYUFnUUNBZ1FDR1RNWkJRVUlBOEF3SXZ5a0lqQXdJZ05jSWpCTEJnUUVCZ1lFQkFiOGVoY1JFQmdZRUJFWGV3S3MvVlFCVmk0cUxnVUdCZ1V1S2k0T0JoNDlId0lDQVFFQ0FoODlIZ1lPQUFFQUovL0FBOWtEd0FBNEFBQUJOUVVSRkFZeERnRVZGQll6TURJeE9BRXhNalkzUGdFMVBBRXhFU1VSRkFZeERnRVZGQll6TWpBeE1qQXhNalkzUGdFMU5DWXhFVEVEMlAxQVZVRmJYa0lCTVZFZ0lTRUJtRlZBVzExQ0FRRXdVaUFnSWdFRExKVGYva1lpQndGY1FVTmRIUjBlVEN3d2xnRWVoLzZiSWdZQ1hFRkNYaDRkSFV3dEw1WUJad0FBQUFZQUcvL0FBK1VEd0FBWEFDTUFLZ0F4QUhVQWVnQUFBU0lHRlJRV0Z6QVVNUmNlQVRNeU5qOEJQZ0UxTkNZakVTSW1OVFEyTXpJV0ZSUUdBUmN3TWpNcUFUY0hNQ0lqT2dFQkp5WUdCd1lXSHdFUkp6VXdKaU1pQmpFVkJ4RTNQZ0VuTGdFUEFTVW1CZ2NPQVJVUkZCWVhCUll5TXhZeU16b0JOem9CTnlVRk1oWXpNalkzUGdFMUVUUW1Kd0VuRVJjUkFwZFBjQkFPZ2dVUkNRa1FCWUlQRDI5UElTMHRJU0F1THY2dEFnSUJBZ0lXQWdJQkFRTUNVVDBPR2dVRURBNFJ4UTBnSVF6SEdBNEtCQVFhRHpmKzN3Z1JCd2NIRGd3QktnRUNBUUlFQVFJREFnRURBUUVnQVNFQ0JnSUdDd1VIQnc0TS9YM1EwQVBBY0U4Yk5CY0J5Z2NKQ1FmS0Z6VWJUM0QrOHk0Z0lTMHRJU0F1L1E4QkFRRUN3eEVFRHc0T0hnUUgvZVE2K0JrWitEMENIQW9FSHc0UERnUVFVd0lEQlFVUENmMkVEQlFEVlFFQkFRRlNVd0VFQXdVUUNBSjlEQk1FL2FJNUFoUTcvZTRBQUFBQ0FGVUFGUU9yQTJzQUR3QVRBQUFCSVNJR0ZSRVVGak1oTWpZMUVUUW1BeUVSSVFOdy9TQVlJeU1ZQXVBWUl5TWkvVFFDekFOckl4ajlJQmdqSXhnQzRCZ2ovTzhDekFBQkFBQUFOUVFBQTBzQUpRQUFDUUVPQVNNaUppY0JMZ0UxTkRZL0FUNEJNeklXSHdFQlBnRXpNaFlmQVI0QkZSUUdCekVENy8ydkNSVU1EQlVJL3NZSUNRa0lVUWdWREF3VkNiOEIxd2tWREF3VkNGRUlDUWtJQXBmOXJ3a0lDQWtCT1FrVkRBd1VDVkFKQ1FrSnZ3SFhDUWdJQ1ZBSkZRd01GQWtBQWdBRkFBZ0VCd040QUNRQU9BQUFBVDRCTlRRbUx3RXVBU01pQmdjQkp5NEJJeUlHRHdFT0FSVVVGaGNCSGdFek1qWTNBUU1SSVJFaE55RWlCaFVSRkJZeklUSTJOUkVIQS9nSUJ3Y0lRd2dSQ2dzUkNQNXlvZ2NTQ2dvU0IwUUhDQWdIQVFrSEVnb0tFZ2NCOWVMOU5BSmNSUDFXR0NNakdBTGdHQ05GQXQ4SUVRb0tFZ2RFQndnSUIvNXlvZ2NJQ0FkRUJ4SUtDaElIL3ZjSENBZ0hBZlgrcHY3SEFzMUVJaG45SVJnakl4Z0Joa1FBQlFCZC84QURvd1BBQUFzQUR3QWRBQ3NBT1FBQUFSVWhOVE15TmpVekZCWXpGeEVoRVJjMEppTWlCaFVSRkJZek1qWTFFelFtSXlJR0ZSRVVGak15TmpVVE5DWWpJZ1lWRVJRV016STJOUU9qL0xyc0hTbmlLUjIvL1JUa0ZnOFFGUlVRRHhhM0ZnOFBGaFlQRHhhM0ZSQVBGaFlQRUJVRGVtTmpLUjBkS2E3ODlBTU1teEFWRlJEK0tCQVdGaEFCMkJBVkZSRCtLQkFXRmhBQjJCQVZGUkQrS0JBV0ZoQUFBd0JpLzhBRG5nUEFBQndBS0FBOEFBQVRFUlFXTXlFeU5qVVJOQ1luTlRRdUFpc0JJZzRDSFFFT0FSVWxJVFUwTmpzQk1oWWRBVEVGTkRZek1oWVZGQVlIRmdZeEl6QW1OeTRCTldKSE1nSktNa2MvTGlwSllqZEtOMkpKS2k0L0FtSCtlbXRNR0V4ci90dzVLQ2c2SUI4TUdDNFlEQjhmQWFqK2tqTkhSek1CYmk5R0JaSTNZa2txS2tsaU41SUZSaTk2ZVV4cmEweDU4Q2s1T1NraE9BZ29Sa1lvQ0RnaEFBQUFBQUlBWXYvQUE1NER3QUFsQURnQUFBRStBVHNCTWhZZEFTRU9BUlVSRkJZeklUSTJOUkUwSmljMU5DNENLd0VpRGdJVk14TVdCakVqTUNZM0xnRTFORFl6TWhZVkZnWUJQZ2xuUmhoTWEvNE1MajlITWdKS01rYy9MaXBKWWpkS04ySkpLbS9sREJndUdBd2ZJRG9vS0RrQklBS3lRMTFyVEhrRlJpLytrak5IUnpNQmJpOUdCWkkzWWtrcUswbGpOLzRmS0VaR0tBZzNJaWs1T1NraE9BQUVBQUFBRlFRQUEyc0FVZ0JmQUxJQXZnQUFBVFVuTGdFbk1TWTBQd0VuQnc0Qkp6RXVBUzhCSXdjT0FRY3hCaVl2QVFjWEhnRUhPQUV4RGdFUEFSVVhIZ0VYTVJZR0R3RVhOejRCRnpFZUFSOEJNemMrQVRjeE5oWWZBVGNuTGdFM01UNEJQd0VGSWlZMU5EWXpNaFlWRkFZakJUVW5MZ0VuTVNZMlB3RW5CdzRCSnpFdUFTOEJJd2NPQVFjeEJpWXZBUWNYRmhRSE1RNEJEd0VWRng0QkZ6Z0JNUllVRHdFWE56WXlGekVlQVI4Qk16YytBVGN4TmpJZkFUY25MZ0UzTVQ0QlB3RUhJaVkxTkRZek1oWVZGQVlDd1RNUEZnWUdCeGhETWc0ZkRnOFZCUk5mRWdVV0RnOGZEakZERndjQkJnWVhEek16RHhjR0JnRUhGME14RGg4UERoWUZFbDhTQmhVUERoOE9Na01ZQmdFR0JoWVBNLzZnTmt4TU5qVk1URFVDbnhzSURBTUVBUVFNSkJvSEVRZ0hEQU1KTXdrRERBY0lFUWNhSkF3RUF3TU1DQnNiQ0F3REF3UU1KQm9IRVFnSERBTUpNd2tEREFjSUVBZ2FKQXdFQVFRRERBZ2J1eDBvS0IwY0tDZ0IxV0FUQlJZT0R5QU9Na1FZQmdFR0JoY1BORFFQRndZR0FRWVlSRElPSUE4T0ZnVVRZQk1GRmc0UElBNHlSQmdIQVFjR0ZnODBNdzhYQndZQkJ4aEVNZzhmRHc0V0JoSlRUVFkyVFUwMk5rM0lNd29EQ3dnSUVRY2JKQTBEQVFNRURBZ2JHd2dNQkFNQkF3MGtHd2NSQ0FnTEF3b3pDZ01MQ0FnUkJ4c2tEQVFEQXd3SUhCd0lEQU1EQXcwa0dnZ1JDQWNNQXdvc0tCMGRLU2tkSFNnQUFBQUFBZ0FBLzhBRUFBUEFBQzhBU0FBQUFUb0JNendETlRRMk16SWlNeklXRlJ3REZUb0JNeklXQnc0REJ3NEJJeUltSnk0REp5WTJNeVVoRlNFUklSRWhOU0VpQmhVUkZCWXpJVEkyTlJFMEppTUJJeGRyRnc4S05CSTBDZzhYYXhjU0N3c2JPRGMzSEFRSkJRVUpCQnczTnpnYkN3c1NBcFQrNGdFVy9LSUJGZjdqSGlzckhnTnVIeW9xSHdIWE1uaDdlRElLRUJBS01uaDdlRElmRENKQ1EwSWlCQVFFQkNKQ1EwSWlEQi9ZVVAyeUFrNVFLaDc5b2g0ckt4NENYaDRxQUFBQUFBUUFBUC95QkFBRGpnQURBQnNBSHdBMEFBQUJGU0UxQVRJMk56NEJOVFFtSnk0Qkl5SUdCdzRCRlJRV0Z4NEJBelVoRlFFeUZoY2VBUlVSSXhVaE5TTVJORFkzUGdFeklRTTAvWmdDbWdzVEJ3Z0lDQWdIRXdzTEVnY0hCd2NIQnhLUC9tZ0NNaDgzRmhjWHpQMll6QmNYRnpZZkFzd0RqczNOL2pJSEJ3Z1NDZ3NUQ0FnSEJ3Z0lFd3NLRWdnSEIvNmEvLzhDTWhjV0Z6WWcvczNOelFFeklEWVhGaGNBQUFNQUFQL0FCQUFEd0FBWkFGTUFkd0FBQVRRbUp5NEJJeUlHQnc0QkZSUVdGeDRCTXpJMk56NEJOVEVCRkFZSERnRWpJaVl2QVE0Qkl5SW1KeTRCSnk0Qkp5NEJOVFEyTno0Qk56NEJOejRCTXpJV0Z4NEJGeDRCRng0QkZSUUdCeGNlQVJVeEFTTTFOQ1lyQVNJR0hRRWpJZ1lkQVJRV093RVZGQlk3QVRJMlBRRXpNalk5QVRRbUFzVXBLQ2hpT1RsaEtDa29LQ2tvWVRrNVlpZ29LUUU3REFzTUhCQVFIQXZUTjN0RUxGUW9LRVVlSFM0UkVSRVJFUkV1SFI1RktDaFVMQ3hVS1NoRkhSMHVFUkVTSnliVERBditQMmNJQlRRRkIyY0ZCd2NGWndjRk5BVUlad1VIQndJUE9XRXBLQ2dvS0NsaE9UbGlLQ2tvS0NrcFlUbitBQkFjREFzTURBdlRKaVlSRVJFdUhSMUZLU2hVTEN4VUtDaEZIaDB1RVJFUkVSRVJMaDBlUlNnb1ZDeEVlemZUQ3h3UUFpWm5CUWNIQldjSEJUUUZDR1lHQndjR1pnZ0ZOQVVIQUFBQUFBTUFBUC9BQkFBRHdBQVpBRk1BWkFBQUFUUW1KeTRCSXlJR0J3NEJGUlFXRng0Qk16STJOejRCTlRFQkZBWUhEZ0VqSWlZdkFRNEJJeUltSnk0Qkp5NEJKeTRCTlRRMk56NEJOejRCTno0Qk16SVdGeDRCRng0QkZ4NEJGUlFHQnhjZUFSVXhBU0lHSFFFVUZqTWhNalk5QVRRbUl5RUN4U2tvS0dJNU9XRW9LU2dvS1NoaE9UbGlLQ2dwQVRzTUN3d2NFQkFjQzlNM2UwUXNWQ2dvUlI0ZExoRVJFUkVSRVM0ZEhrVW9LRlFzTEZRcEtFVWRIUzRSRVJJbkp0TU1DLzBrQlFjSEJRRWJCUWNIQmY3bEFnODVZU2tvS0Nnb0tXRTVPV0lvS1Nnb0tTbGhPZjRBRUJ3TUN3d01DOU1tSmhFUkVTNGRIVVVwS0ZRc0xGUW9LRVVlSFM0UkVSRVJFUkV1SFI1RktDaFVMRVI3TjlNTEhCQUNKZ2NGTkFVSUNBVTBCUWNBQUFBQUFRQllBQmdEcUFOb0FDUUFBQ1VuTnpZMEx3RW1CZzhCSnlZaUR3RUdGQjhCQndZVUh3RVdNajhCRnhZeVB3RTJOQ2NEcVBQekRBeDhEQ0VNOC9NTUlReDhEQXp6OHd3TWV3d2lEUFB6RENFTWZBd016ZlB5RENJTWZBd0JEUEx6REF4OERDRU04L01NSWd4N0RBeno4d3dNZkF3aERBQUFBUUFBLzhBRUFBUEFBQ1FBQUFFaEVUUW1Ld0VpQmhVUklTSUdIUUVVRmpNaEVSUVdPd0V5TmpVUklUSTJQUUUwSmlNRDEvNnBHQkd1RVJqK3FSRVlHQkVCVnhnUnJoRVlBVmNSR0JnUkFrQUJWeEVZR0JIK3FSZ1JyaEVZL3FrUkdCZ1JBVmNZRWE0UkdBQUFBUUFBQVVBRUFBSkFBQkFBQUFFeUZoMEJGQVlqSVNJbVBRRTBOak1oQTljUkdCZ1IvRklSR0JnUkE2NENRQmdScmhFWUdCR3VFUmdBQUFBQUFnQUEvOEFFQUFQQUFCTUFPQUFBQVNJT0FoVVVIZ0l6TWo0Q05UUXVBaE1IQmlJdkFRY0dJaThCSmpRL0FTY21ORDhCTmpJZkFUYzJNaDhCRmhRUEFSY1dGQWNDQUdxN2kxQlFpN3RxYXJ1TFVGQ0x1MzVEQnhJSGhZVUhFZ2REQndlRmhRY0hRd2NTQjRXRkJ4SUhRd2NIaFlVSEJ3UEFVSXU3YW1xN2kxQlFpN3RxYXJ1TFVQMWJRd2NIaFlVSEIwTUhFZ2VGaFFjU0IwTUhCNFdGQndkREJ4SUhoWVVIRWdjQUFBSUFBUC9BQkFBRHdBQVVBRGtBQUFFaURnSVZGQjRDTXpJK0FqVTBMZ0lqQVJRR0t3RVZGQVlyQVNJbVBRRWpJaVk5QVRRMk93RTFORFk3QVRJV0hRRXpNaFlkQVFJQWFydUxVRkNMdTJwcXU0dFFVSXU3YWdFUkRRbTNEUWxjQ1EyM0NRME5DYmNOQ1Z3SkRiY0pEUVBBVUl1N2FtcTdpMUJRaTd0cWFydUxVUDNTQ1EyM0NRME5DYmNOQ1YwSkRMY0pEUTBKdHd3SlhRQUFBQUlBQVAvQUJBQUR3QUFVQUNVQUFBRWlEZ0lWRkI0Q016SStBalUwTGdJakFSUUdJeUVpSmowQk5EWXpJVElXSFFFQ0FHcTdpMUJRaTd0cWFydUxVRkNMdTJvQkVRMEovZ29KRFEwSkFmWUpEUVBBVVl1NmFtcTdpMUJRaTd0cWFycUxVZjNTQ1EwTUNsd0pEUXdLWEFBREFBQUFZd1FBQXgwQUdBQXhBRm9BQUFFeUZoY2VBUlVVQmdjT0FTTWlKaWN1QVRVME5qYytBVE1STWpZM1BnRTFOQ1luTGdFaklnWUhEZ0VWRkJZWEhnRXpFVEllQWhjZUF4Y09Bd2NPQXlNaUxnSW5MZ01uUGdNM1BnTXpBZ0FjTVJVVkZCUVZGVEVjSERFVkZSUVVGUlV4SERCU0lpTWlJaU1pVWpBd1VpSWpJaUlqSWxJd0sxSk9TaU1pUERJcER3OHBNandpSTBwT1Vpc3JVazVLSXlJOE1pa1BEeWt5UENJalNrNVNLd0pMRkJVVk1Sd2NNUlVWRkJRVkZURWNIREVWRlJUK2pDSWpJbEl3TUZJaklpSWlJaU5TTURCU0lpTWlBa1lNR0NRWUdEZy9SeWNuUno4NEdCZ2tHQXdNR0NRWUdEZy9SeWNuUno4NEdCZ2tHQXdBQUFRQUFBQUdCQUFEZWdBSkFDUUFSUUJsQUFBQk16SVdGeDRCSFFFbkJ3NEJGUlFXRng0Qk16STJOeWNPQVNNaUppY3VBVFUwTmpjbkFUY0JCeTRCSnk0Qkp3NEJJeUl1QWljdUF5YytBVGN1QVNjdUFTY3hCU0lHQnljK0FUTXlIZ0lYSGdNWERnRUhKejRCTlRRbUp5NEJJekVCK3dZY01oUVZGWkxKRFE0aklpTlNNQmt6RzBnSkR3Y2NNUlVWRlFNQ1NQNytPd001T3dVaUhSMHREeTlsTnl0U1Rrb2pJend5S1E4YldEd05KUmNZR3dNQjBSWXFGV1FxWFRJclVrNUtJaU03TWlrUEdsQTFpQWtKSXlJaVV6QUNZeFVWRlRFY0NaVWxHek1aTUZNaUlpTU5Ea2dEQWhVVkZESWNCaEFKU0FFQk8vekhPd1VpSEIwc0R4UVREQmdrR0JnM1FFY25SSE13RFNZWUdCc0RmZ2tKWlJBUURCZ2tHQmc0UDBjblFXNHVpQlVxRmpCU0l5SWpBQUFDQVVUL3dBSzhBOEFBQ2dBWEFBQWxNeEVqTlNFUk14VWhOUk15RmhVVUJpTWlKalUwTmpNQlJHVmxBUk5sL29pME1VWkdNVEpHUmpKTEFaT0wvZUtMaXdOMVNETXpTRWd6TTBnQUNRQUFBQzRFQUFOU0FCd0FPQUJWQUhFQWpRQ3FBTVlBNGdEK0FBQWxGUlFHQnc0Qkt3RWlKaWN1QVQwQk5EWTNQZ0U3QVRJV0Z4NEJGUkVWRkFZSERnRXJBU0ltSnk0QlBRRTBOamMrQVRzQk1oWVhIZ0VCRlJRR0J3NEJLd0VpSmljdUFUMEJORFkzUGdFN0FUSVdGeDRCRlFFVkZBWUhEZ0VyQVNJbUp5NEJQUUUwTmpjK0FUc0JNaFlYSGdFQkZSUUdCdzRCS3dFaUppY3VBVDBCTkRZM1BnRTdBVElXRng0QkFSVVVCZ2NPQVNzQklpWW5MZ0U5QVRRMk56NEJPd0V5RmhjZUFSVUJGUlFHQnc0Qkt3RWlKaWN1QVQwQk5EWTNQZ0U3QVRJV0Z4NEJBUlVVQmdjT0FTc0JJaVluTGdFOUFUUTJOejRCT3dFeUZoY2VBUkVWRkFZSERnRXJBU0ltSnk0QlBRRTBOamMrQVRzQk1oWVhIZ0VCSkFjSkNCTUx0d3dUQ0FnSUNBZ0lFd3kzQ3hRSENRY0hDUWdUQzdjTUV3Z0lDQWdJQ0JNTXR3c1VCd2tIQVc0SUNBZ1RDN2dMRXdnSUNBZ0lDQk1MdUFzVENBZ0kvcElIQ1FjVUM3Y01Fd2dJQ0FnSUNCTU10d3NVQndrSEFXNElDQWdUQzdnTEV3Z0lDQWdJQ0JNTHVBc1RDQWdJQVc0SUNBZ1RETGNMRkFjSkJ3Y0pCeFFMdHd3VENBZ0kvcElJQ0FnVEM3Z0xFd2dJQ0FnSUNCTUx1QXNUQ0FnSUFXNElDQWdURExjTEZBY0pCd2NKQnhRTHR3d1RDQWdJQ0FnSUV3eTNDeFFIQ1FjSENRY1VDN2NNRXdnSUNOSnREQk1JQ0FnSUNBZ1RERzBNRXdnSUNBZ0lDQk1NQVNWdUN4UUlDQWdJQ0FnVUMyNExGQWdJQ0FnSUNCVCswRzBNRXdnSUNBZ0lDQk1NYlF3VENBZ0lDQWdJRXd3Q1NXME1Fd2dJQ0FnSUNCTU1iUXdUQ0FnSUNBZ0lFLzdRYmdzVUNBZ0lDQWdJRkF0dUN4UUlDQWdJQ0FnVS90QnREQk1JQ0FnSUNBZ1RERzBNRXdnSUNBZ0lDQk1NQWtsdERCTUlDQWdJQ0FnVERHME1Fd2dJQ0FnSUNCUCswRzRMRkFnSUNBZ0lDQlFMYmdzVUNBZ0lDQWdJRkFFWmJRd1RDQWdJQ0FnSUV3eHREQk1JQ0FnSUNBZ1RBQUFBQXdBQUFCVUVBQU5yQUJzQU9BQlVBQUFsRlJRR0J3NEJJeUVpSmljdUFUMEJORFkzUGdFeklUSVdGeDRCRVJVVUJnY09BU01oSWlZbkxnRTlBVFEyTno0Qk15RXlGaGNlQVJVUkZSUUdCdzRCSXlFaUppY3VBVDBCTkRZM1BnRXpJVElXRng0QkJBQUdCd1lQQ2Z4V0NROEdCd1lHQndZUENRT3FDUThHQndZR0J3WVBDZnhXQ1E4R0J3WUdCd1lQQ1FPcUNROEdCd1lHQndZUENmeFdDUThHQndZR0J3WVBDUU9xQ1E4R0J3YVZWUWtQQmdZSEJ3WUdEd2xWQ1E4R0J3WUdCd1lQQVUxV0NBOEhCZ1lHQmdjUENGWUlEd2NHQmdZR0J3OElBVlZWQ1E4R0J3WUdCd1lQQ1ZVSkR3WUdCd2NHQmc4QUFBQUNBQUQvd0FRQUE4QUFHUUJUQUFBQk5DWW5MZ0VqSWdZSERnRVZGQllYSGdFek1qWTNQZ0UxTVFFVUJnY09BU01pSmk4QkRnRWpJaVluTGdFbkxnRW5MZ0UxTkRZM1BnRTNQZ0UzUGdFek1oWVhIZ0VYSGdFWEhnRVZGQVlIRng0QkZURUN4U2tvS0dJNU9XRW9LU2dvS1NoaE9UbGlLQ2dwQVRzTUN3d2NFQkFjQzlNM2UwUXNWQ2dvUlI0ZExoRVJFUkVSRVM0ZEhrVW9LRlFzTEZRcEtFVWRIUzRSRVJFbUp0TU1Dd0lQT1dFcEtDZ29LQ2xoT1RsaUtDZ3BLU2dvWWpuK0FCQWNEQXNNREF2VEppWVJFUkV1SFIxRktTaFVMQ3hVS0NoRkhoMHVFUkVSRVJFUkxoMGVSU2dvVkN4RWV6ZlRDeHdRQUFrQUF2L2pCQUFEblFBOUFFRUFSZ0JLQUU0QVVnQlhBR2NBZWdBQUpTTWhOeUVUSVM4Q01TSW1JeWN1QVNNaUJnY0dGaDhCRXdjVk13NEJGUlFXTXpJMk5UUW1Kek1PQVJVVUZqTXlOalUwSmljN0FUNEJOVFFtSXdNekJ5TVZNd2NqTlNjekZTTVZNeFVqQVRNVkl4Y1ZJeWN6QXlJbU5UUTJNeklXRng0QkZSUUdJeUVpSmpVME5qYytBVE15RmhjZUFSVVVCaU1EaEFIOW14c0NVWGI4enhrRkZRSUNBV2NDQlFNTkZBTUZEdzlXZ0MwUUF3UkVNQzlFQkFQbEJBTkRNREJFQkFRWkFROFdGZytRcFNTQmR5VlMvTHk4dkx6Kzg4MnFxbjBqb0hjUkZ4Y1JDQTRHQlFZWEVBRzlFQmdHQmdZT0NBZ1BCUVlHRnhIS1J3SG9hQlVHQVI0QkFROE1EeHNGR2YzbmV5Z0pGQW93UkVRd0NoUUpDUlFLTUVSRU1Bb1VDUUVXRHhBV0FkSjNRSFoydDNkQWRnRXRkMEIyZHY1S0Z4RVFGd1lGQmc0SUVSY1hFUWdPQmdVR0JnVUdEZ2dSRndBQUFRRUMvOEFEaHdQQUFDUUFBQUVVQmdjQkRnRWpJaVl2QVM0Qk5UUTJOd2tCTGdFMU5EWS9BVDRCTXpJV0Z3RWVBUlVEaHd3TS9sTU1IaEVSSGd3eURBd01EQUUvL3NFTURBd01NZ3dkRWhJZERBR3REQXdCd0JFZURmNVVEQXdNRERJTUhoRVNIUTBCUHdFL0RSMFNFUjBOTVF3TkRReitWQXdlRVFBQUFBQUJBSG4vd0FMK0E4QUFKQUFBRXpRMk53RStBVE15Rmg4QkhnRVZGQVlIQ1FFZUFSVVVCZzhCRGdFaklpWW5BUzRCTlhrTURBR3REQjRSRVI0TU1nd01EQXord1FFL0RBd01ERElNSFJJU0hReitVd3dNQWNBUkhnMEJyQXdNREF3eURCNFJFaDBNL3NEK3dRd2VFaEVlRERFTURRME1BYXdNSGhFQUFRQUFBTUlFQUFOSEFDUUFBQUV5RmhjQkhnRVZGQVlQQVE0Qkl5SW1Kd2tCRGdFaklpWXZBUzRCTlRRMk53RStBVE1DQUJFZURRR3NEQXdNRERJTUhoRVNIUTMrd2Y3QkRSMFNFUjBOTVF3TkRRd0JyQXdlRVFOSERBeitVd3dlRVJFZURESU1EQXdNQVQvK3dRd01EQXd5REIwU0VoME1BYTBNREFBQUFBQUJBQUFBT1FRQUFyNEFJd0FBSlNJbUp3RXVBVFUwTmo4QlBnRXpNaFlYQ1FFK0FUTXlGaDhCSGdFVkZBWUhBUTRCQWdBUkhnMytWQXdNREF3eURCNFJFaDBOQVQ4QlB3MGRFaEVlRERFTURRME0vbFFNSGprTURBR3REQjRSRVI0TU1nd01EQXord1FFL0RBd01ERElNSFJJU0hReitVd3dNQUFBQUFRRFYvOEFES3dQQUFDVUFBRGMwTmpjSkFTNEJOVFEyUHdFK0FUTXlGaGNCSGdFVkZBWUhBUTRCSXlJbUx3RXVBVFV4MVFZRkFaUCtiUVVHQmdVekJRd0hCZ3dGQWQ0RkJnWUYvaUlGREFZSERBVXpCUVlWQnd3RkFaTUJrd1VNQndjTEJUUUZCUVVGL2lJR0N3Y0hDd2IrSWdVRkJRVTBCUXdHQUFFQTFmL0FBeXNEd0FBbEFBQUJGQVlIQ1FFZUFSVVVCZzhCRGdFaklpWW5BUzRCTlRRMk53RStBVE15Rmg4QkhnRVZNUU1yQlFiK2JRR1RCZ1VGQmpNRkRBWUhEQVgrSWdVR0JnVUIzZ1VNQndZTUJUTUdCUU5yQnd3Ri9tMytiUVVNQndZTUJUUUZCUVVGQWQ0R0N3Y0hEQVVCM2dVRkJRVTBCUXNIQUFBQUFRQUFBSlVFQUFMckFDVUFBQ1VpSmljSkFRNEJJeUltTHdFdUFUVTBOamNCUGdFek1oWVhBUjRCRlJRR0R3RU9BU014QTZzSERBWCtiZjV0QlF3SEJnd0ZOQVVGQlFVQjNnWUxCd2NMQmdIZUJRVUZCVFFGREFhVkJnVUJrLzV0QlFZR0JUTUZEQWNHREFVQjNnVUdCZ1grSWdVTUJnY01CVE1GQmdBQUFBQUJBQUFBbFFRQUF1c0FKUUFBRXpJV0Z3a0JQZ0V6TWhZZkFSNEJGUlFHQndFT0FTTWlKaWNCTGdFMU5EWS9BVDRCTXpGVkJ3d0ZBWk1Ca3dVTUJ3WU1CVFFGQlFVRi9pSUdDd2NIQ3diK0lnVUZCUVUwQlFzSEF1c0dCZjV0QVpNRkJnWUZNd1VNQndZTUJmNGlCUVlHQlFIZUJRd0dCd3dGTXdVR0FBQUFBQUlBQVAvQUJBQUR3QUFsQUVvQUFBRUhEZ0VWRkJZZkFRY09BUlVVRmg4QkhnRXpNalkzQVQ0Qk5UUW1Kd0V1QVNNaUJnY3hBVFEyTno0Qk56NEJNeklXRng0QkZ4NEJGUlFHQnc0QkJ3NEJJeUltSnk0Qkp5NEJOUUdpUkFZSEJ3Yk56UVlIQndaRUJnOEpDUThHQVM4R0JnWUcvdEVHRHdrSkR3YitYaUlqSWwwN080QkdSb0E3TzEwaUl5SWlJeUpkT3p1QVJrYUFPenRkSWlNaUF3MUVCdzhJQ1E4R3pjMEdEd2tJRHdkRUJnWUdCZ0V2Qmc4SkNROEdBUzhHQmdZRy9yTkdnRHM3WFNJaklpSWpJbDA3TzRCR1JvQTdPMTBpSXlJaUl5SmRPenVBUmdBQUFBQUNBQUQvd0FRQUE4QUFKQUJJQUFBbE56NEJOVFFtTHdFM1BnRTFOQ1l2QVM0Qkl5SUdCd0VPQVJVVUZoY0JIZ0V6TWpZM0FSUUdCdzRCQnc0Qkl5SW1KeTRCSnk0Qk5UUTJOejRCTno0Qk16SVdGeDRCRng0QkFsNUVCZ2NIQnMzTkJnY0hCa1FHRHdrSkR3YiswUVlHQmdZQkx3WVBDUWtQQmdHaUlpTWlYVHM3Z0VaR2dEczdYU0lqSWlJaklsMDdPNEJHUm9BN08xMGlJeUp6UkFjUENBa1BCczNOQmc4SkNBOEhSQVlHQmdiKzBRWVBDUWtQQnY3UkJnWUdCZ0ZOUm9BN08xMGlJeUlpSXlKZE96dUFSa2FBT3p0ZElpTWlJaU1pWFRzN2dBQUFBQUFDQUFEL3dBUUFBOEFBSlFCS0FBQVRGeDRCTXpJMlB3RVhIZ0V6TWpZL0FUNEJOVFFtSndFdUFTTWlCZ2NCRGdFVkZCWVhNUUVpSmljdUFTY3VBVFUwTmpjK0FUYytBVE15RmhjZUFSY2VBUlVVQmdjT0FRY09BU096UkFjUENBa1BCczNOQmc4SkNBOEhSQVlHQmdiKzBRWVBDUWtQQnY3UkJnWUdCZ0ZOUm9BN08xMGlJeUlpSXlKZE96dUFSa2FBT3p0ZElpTWlJaU1pWFRzN2dFWUJZa1FHQndjR3pjMEdCd2NHUkFZUENRa1BCZ0V2QmdZR0J2N1JCZzhKQ1E4Ry9sNGlJeUpkT3p1QVJrYUFPenRkSWlNaUlpTWlYVHM3Z0VaR2dEczdYU0lqSWdBQ0FBRC93QVFBQThBQUpRQkpBQUFCSnk0Qkl5SUdEd0VuTGdFaklnWVBBUTRCRlJRV0Z3RWVBVE15TmpjQlBnRTFOQ1luTVFFeUZoY2VBUmNlQVJVVUJnY09BUWNPQVNNaUppY3VBU2N1QVRVME5qYytBVGMrQVFOTlJBY1BDQWtQQnMzTkJnOEpDQThIUkFZR0JnWUJMd1lQQ1FrUEJnRXZCZ1lHQnY2elJvQTdPMTBpSXlJaUl5SmRPenVBUmthQU96dGRJaU1pSWlNaVhUczdnQUllUkFZSEJ3Yk56UVlIQndaRUJnOEpDUThHL3RFR0JnWUdBUzhHRHdrSkR3WUJvaUlqSWwwN080QkdSb0E3TzEwaUl5SWlJeUpkT3p1QVJrYUFPenRkSWlNaUFBQUJBQUFBSHdQckEyRUFIZ0FBSlFFMk5DY0JKaUlIQmhRZkFTRWlCaFVVRmpNaEJ3NEJGUlFXRnhZeU53SjlBVzRWRmY2U0Zqd1dGUlh4L1VNZUt5c2VBcjN4Q2dzTENoWThGaDhCYlJZOEZnRnRGaFlWUFJYeEt4NGVLL0VMR3c0T0d3b1dGZ0FBQUFFQUZRQWZCQUFEWVFBZkFBQUpBUVlVRndFV01qYzJOQzhCSVRJMk5UUW1JeUUzUGdFMU5DWW5KaUlITVFHRC9wSVZGUUZ1Rmp3V0ZSWHhBcjBlS3lzZS9VUHhDZ3NMQ2hZOEZnTmgvcE1XUEJiK2t4WVdGVDBWOFNzZUhpdnhDeHNPRGhzS0ZoWUFBUUJmLzhBRG9nT3JBQjhBQUFrQkppSUhBUVlVRnhZeVB3RVJGQll6TWpZMUVSY2VBVE15TmpjMk5DY3hBNkgra3hZOEZ2NlRGaFlWUFJYeEt4NGVLL0VMR3c0T0d3c1ZGZ0k5QVc0VkZmNlNGandXRlJYeC9VTWVLeXNlQXIzeENnc0xDaFk4RmdBQkFGLy8xUU9oQThBQUh3QUFFd0VXTWpjQk5qUW5KaUlQQVJFMEppTWlCaFVSSnk0Qkl5SUdCd1lVRnpGZkFXMFdQQllCYlJZV0ZUMFY4U3NlSGl2eEN4c09EaHNLRmhZQlEvNlNGUlVCYmhZOEZoVVY4UUs5SGlzckh2MUQ4UW9MQ3dvV1BCWUFBQUVBaWYvSEEya0R1UUFNQUFBWEJpWTFFVFEyRndFV0JnY0JzQThZRnc4Q3VnOEJELzFJT1FzTEVRUFFFUXNML2hrTEhRcitKd0FBQVFDWC84Y0Rkd081QUF3QUFBRTJGaFVSRkFZbkFTWTJOd0VEVVE0WUZ3LzlSZzhCRHdLNUE3a0xDeEg4TUJFS0NnSG5DeDBLQWRrQUFBQUFBUUFIQUZjRCtRTTNBQXdBQUJNbU5qTWhNaFlIQVFZbUp3RUhDd3NSQTlBUkN3ditHUXNkQ3Y0bkF4RVBGeGNQL1VZUEFROEN1UUFCQUFjQVNRUDVBeWtBQ3dBQUpSWUdJeUVpSmpjQk5oWVhBL2tMQ3hIOE1CRUxDd0huQ3gwS2NBOFlGdzhDdWc4QkR3QUFBUUFBLzhBRUFBUEFBSmdBQUFFbkxnRWpJZ1lQQVE0QkZSUVdId0VoRVJjZUFUTXlOajhCUGdFMU5DWXZBUzRCSXlJR0R3RU9BUlVVRmg4QkhnRXpNalkvQVJFaE56NEJOVFFtTHdFdUFTTWlCZzhCRGdFVkZCWWZBUjRCTXpJMlB3RStBVFUwSmk4QklSRW5MZ0VqSWdZUEFRNEJGUlFXSHdFZUFUTXlOajhCUGdFMU5DWXZBUzRCSXlJR0R3RVJJUWNPQVJVVUZoOEJIZ0V6TWpZL0FUNEJOVFFtSndQMnFBVU1Cd2NMQlJRRUJRVUVWZjdRVkFVTEJ3Y01CUk1GQlFVRnFRVUxCd2NNQktrRkJRVUZGQVFNQndjTEJWVCt4RlVFQlFVRUZBVU1CZ2NNQmFnRkJRVUZxQVVNQndjTEJSUUVCUVVFVkFFN1ZBVUxCd2NNQlJNRkJRVUZxQVVNQndjTEJha0ZCUVVGRkFRTUJ3Y0xCVlFCTUZVRUJRVUVGQVVNQmdjTUJhZ0ZCUVVGQWRhcEJRVUZCUlFFREFjSERBVlVBVGRVQlFVRkJSTUZEQWNIQ3dXcEJRVUZCYWtGQ3djSERBVVRCUVVGQlZUK3lWVUVEQWNIREFVVEJRVUZCYWtGREFjR0RBV3BCUVVGQlJRRURBY0hDd1pVL3N4VUJRVUZCUk1GREFjSEN3V3BCUVVGQmFrRkN3Y0hEQVVUQlFVRkJWUUJORlVFREFjSERBVVRCUVVGQmFrRkRBY0dEQVVBQUFJQUFQL0FCQUFEd0FBVEFLd0FBQUVpRGdJVkZCNENNekkrQWpVMExnSVREZ0VqSWlZdkFTNEJOVFEyUHdFakZUYytBVE15Rmg4QkhnRVZGQVlQQVE0Qkl5SW1Md0V1QVRVME5qOEJQZ0V6TWhZZkFUVWpGeDRCRlJRR0R3RU9BU01pSmk4QkxnRTFORFkvQVQ0Qk16SVdId0VlQVJVVUJnOEJNelVIRGdFaklpWXZBUzRCTlRRMlB3RStBVE15Rmg4QkhnRVZGQVlQQVE0Qkl5SW1Md0VWTXljdUFUVTBOajhCUGdFek1oWWZBUjRCRlJRR0R3RUNBR3E3aTFCUWk3dHFhcnVMVUZDTHU2QURDUVVHQ1FNUEJBTURCRUh6UFFRRkJnVUpBdzhFQkFRRWdBUUpCUVVKQklFREJBTUVEZ1FKQlFVSEJEM3lRQVFEQXdRUEF3a0dCUWtEZ1FRREF3U0JBd2tGQmdnRUR3UUVCQVJBOGowRUJnVUZDUVFPQkFRRUJJQUVDUVVGQ1FTQUJBUUVBdzhFQ0FVRkJ3UTk4VDhFQXdNRUR3TUpCZ1VKQTRFRUF3TUVnUVBBVVl1NmFtcTdpMUJRaTd0cWFycUxVZjF0QkFRRUJBNEVDQVVGQndROThVQUVBd01FRHdNSkJnVUpCSUFFQkFRRWdBUUpCUVlJQkE4RUF3TUVRUEU4QkFZRkJRa0RFQU1FQkFPQkJBa0ZCUWtFZ0FRRUJBTVBCQWdGQlFjRVBmRkFCQVFFQkE0RUNRVUdDQVNBQkFRRUJJQUVDQVlGQ1FRT0JBUUVCRUR4UEFRR0JRVUpCQTRFQkFRRWdBUUlCZ1VKQklBQUFBRUFBUC9hQkFBRHBnQXFBQUFCQnk0REl5SU9BaFVVSGdJek5TSXVBalUwUGdJek1oWVhCdzRCRndVV05qY1ROaVlIQTd4VUlsVmpiVGxsc1lWTlNZS3lha04yVnpNeVYzUkRRbmd0V2g4RUhBRW5IQ3dFSXdNb0h3TU9KaXhITVJwTWhMSmtaYkdFVEtRelYzVkRRM1ZYTXpNdEtRNHdFOUFVRkNJQlpDSWNEZ0FBQUFFQW0vL0hBMWNEdVFBTUFBQVhCaVkxRVRRMkZ3RVdGQWNCd0E0WEZ3NENsdzRQL1dvNUN3c1JBOUFSQ2dyK0dRc2RDdjRuQUFBQUFnQUEvOEFFQUFQQUFBOEFJQUFBQlJRR0l5RWlKalVSTkRZeklUSVdGU0UwSmlNaElnWVZFUlFXTXlFeU5qVVJBWTBiRXY3TkVoc2JFZ0V6RWhzQ2N4c1MvczBUR2hvVEFUTVNHeElUR3hzVEE2UVRHeHNURXhzYkUveGNFeHNiRXdPa0FBRUFBUC9BQkFBRHdBQVBBQUFGRkFZaklTSW1OUkUwTmpNaE1oWVZCQUFnRi94dUZ5QWdGd09TRnlBSkZ5QWdGd09TRnlBZ0Z3QUFBZ0FBLzhBRUFBUEFBQk1BSUFBQUFTSU9BaFVVSGdJek1qNENOVFF1QWdNR0pqVVJORFlYQlJZVUJ3VUNBR3E3aTFCUWk3dHFhcnVMVUZDTHU4VUhEQXdIQVZRSEIvNnNBOEJRaTd0cWFydUxVRkNMdTJwcXU0dFEvUDBGQlFrQjlBa0ZCZm9GRHdYekFBQUFBd0FBLzhBRUFBUEFBQk1BSXdBekFBQUJJZzRDRlJRZUFqTXlQZ0kxTkM0Q0F4UUdLd0VpSmpVUk5EWTdBVElXRlJNVUJpc0JJaVkxRVRRMk93RXlGaFVDQUdxN2kxQlFpN3RxYXJ1S1VWR0t1NVVLQjNJSENnb0hjZ2NLNmdvSGNnY0tDZ2R5QndvRHdGQ0x1MnBxdTR0UVVJdTdhbXE3aTFEOVVnY0pDUWNCWEFjSkNRZitwQWNKQ1FjQlhBY0pDUWNBQUFJQUFQL0FCQUFEd0FBVEFDTUFBQUVpRGdJVkZCNENNekkrQWpVMExnSVRGQVlqSVNJbU5SRTBOak1oTWhZVkFnQnF1NHRRVUl1N2FtcTZpMUZSaTdwTkRBait1Z2dNREFnQlJnZ01BOEJRaTd0cWFycUxVVkdMdW1wcXU0dFEvVjBJREF3SUFVWUlEQXdJQUFFQUFQL2xBL01EbWdBV0FBQUpBU1lHSFFFbEpnWVZFUlFXTnlVVkZCWTNBVFkwSndQei9aRU5GdjdCRFJVVkRnRStGZzBDYmc0TkFkRUJ5UW9KRWRycUNna1IvR3dRQ2duazB4QUtDUUc5Q2hzS0FBRUFEZi9tQkFBRG13QVdBQUFCQlRVMEpnY0JCaFFYQVJZMlBRRUZGalkxRVRRbUJ3UGQvc0lXRGYyU0RnMENidzBXQVQ4TkZSVU9BNXZrMHhBS0NmNURDUndLL2pjS0NSSGE2Z29KRVFPVUVBb0pBQUVBQVAvMUJBQURpZ0FrQUFBQkl5SUdGUkVCSmdZZEFTVW1CaFVSRkJZM0pSVVVGamNCRVJRV093RXlOalVSTkNZakE5MDlEaFg5K2cwVi9zd01GUlVOQVRNVkRRSUdGUTQ5RHhRVUR3T0pGQS8rcHdGOUNna1EwK0lLQ1JEOGlnOEtDZDNORHdvSkFYUCtzZzhVRkE4RFRBOFVBQUFBQUFFQUFQLzJCQUFEaXdBa0FBQUJCVFUwSmdjQkVUUW1Ld0VpQmhVUkZCWTdBVEkyTlJFQkZqWTlBUVVXTmpVUk5DWUhBOTcrelJVTi9mb1ZEajBQRkJRUFBRNFZBZ1lORlFFMERCVVZEUU9MM2MwUENnbitqUUZPRHhRVUQveTBEeFFVRHdGWi9vTUtDUkRUNGdvSkVBTjJEd29KQUFBQUFBUUFHZ0J3QStZREpnQVFBQ2NBT3dCVEFBQVRGUlFXTXpnQk1UTVJJeUlHRlRnQk1TVVJNQlF4RkFZaklpWXZBUkUzUGdFek1oWVZNQlF4Rng0QkZSUUdCeGNXTWpjK0FUVTBKaWN1QVFjM0hnRVZGQVlIRnhZeU56NEROVFF1QWljbUlnY2FKaHFHaGhvbUFrZ1hFQVlMQlAzOUJRb0dFQmRRSFNFaEhTTUpJd2tkSWlJZENDTUpTekU1T1RJbENTTUpHU2djRHc0Y0tCa0pJd2tDUGVVYkpnRm5KaHZBL1p3QkVSY0RBNUVCaDVJREF4Y1JBWjBjVFN3clRSMGpDUWttWGpRMFhpWUpBUXBMTW9WTVRJVXlKUWtLSGtSTFVDc3FVRXRFSGdrSkFBQUFBQU1BR3dCeUErVURLQUFXQUMwQWFRQUFFeFU0QVRFVUZqTTRBVEV6RVNNNEFURWlCaFU0QVRFbEVUZ0JGUlFHSXlJbUx3RVJOejRCTXpJV0ZUQVVNUUVlQVJVVUJnOEJEZ0VqSWlZdkFRY09BU01pSmk4QkxnRTFORFkvQVNjdUFUVTBOajhCUGdFek1oWWZBVGMrQVRNeUZoOEJIZ0VWRkFZUEFSc21HNGFHR3lZQ1NSY1JCUXNFL2YwRUN3VVJGd0Y4QWdNREFpRUNCUU1FQlFKSFJ3SUdBd01HQWlFQ0FnSUNSMGNDQWdJQ0lRSUdBd01HQWtkSEFnVUVBd1VDSVFJREF3SkhBai9sR3lZQlp5WWJ3UDJiQVJBWEF3S1NBWWVTQXdNWUVBSCtoZ0lGQXdRRkFpRUNBd01DUjBjQ0F3TUNJUUlGQkFNRkFrZEhBd1VEQXdZQ0lRSURBd0pIUndJREF3SWhBZ1lEQXdVRFJ3QUFBQUFFQUFEL3dBUUFBOEFBRmdBdEFFUUFXd0FBQVNZMFB3RW5KalkzSlRZV0J3TU9BUzhCQndZaUx3RUJCeWNtSWc4QkJoUWZBUWNHRmhjRkZqWW5BeTRCQnlVbUlnOEJKeVlHQndNR0ZqY2xQZ0V2QVRjMk5DOEJFemMySmljbEpnWVhFeDRCUHdFWEZqSS9BVFkwTHdFQ1lnTURkVVVGQkFjQldRY0pBVGtCQ2dWRGRBUUtBNDBCVmtWMEJBb0RqUU1EZFVNRkJBY0JWUWNKQVRVQkNnWDlXUU1LQkhSREJRb0JPUUVKQndGWkJ3UUZSWFVEQTQwWlF3VUVCLzZyQndrQk5RRUtCVVYwQkFvRGpRTURkUUt2QXdvRWRFUUdDUUkwQVFrSC9xd0hCQVpDZEFRRWpQNStSWFVEQTQwRENnTjFRZ1VLQVRrQkNRY0JXQWNFQlRNRUJIUkNCZ1FIL3F3SENRRTFBUWtHUkhRRUNnT01BZFJEQlFvQk9RRUlDUDZvQndRRlJIUURBNHdFQ2dOMEFBQUFCQUFFLzhNRC9RTzhBQllBTFFCRUFGc0FBQUVUUGdFZkFUYzJNaDhCRmhRUEFSY1dCZ2NGQmlZM0V4NEJQd0VYRmpJL0FUWTBMd0UzTmlZbkpTWUdGeE1sRnhZeVB3RVhGalkzRXpZbUJ3VU9BUjhCQndZVUZ4TVhCd1lXRndVV05pY0RMZ0VQQVNjbUlnOEJCaFFYQWw4NUFRb0ZRM1FFQ1FTTkF3TjFSUVVFQi82bkNBZ0JOQUVLQlVWMEJBb0RqUU1EZFVNRkJBZitxd2NKQVRYOWNZd0VDUVIwUXdVS0FUa0JDQWorcHdjRUJVVjBCQVFEZEVJR0JBY0JWUWNKQVRVQkNnVkZkQVFKQkl3RUJBSXVBVlFJQXdWQ2RBTURqQVFLQTNSRkJRb0JOUUVKQi8zTEJ3UUZSWFVEQTQwRENnTjFRZ1VLQVRrQkNBaitxRnlNQXdOMFFnVUVCd0ZVQndrQk5RRUtCVVYwQXdvRUFzcDBRZ1VLQVRrQkNBZ0JXQWNFQlVWMEJBU01Bd29FQUFBQUFBTUFBQUFtQS9zRFdnQXRBRzRBb0FBQUV6VTBOanNCTWhZWEhnRVhIZ0VYSGdFSERnRUhEZ0VIRGdFSERnRWpJaVluTGdFbkxnRW5MZ0VyQVNJbU5RVStBVGMrQVRjVkZCWS9BVFkwTHdFbUJoMEJEZ0VIRGdFSERnRUhEZ0VIRGdFSERnRUhEZ0VyQVNJR0hRRVVGanNCTWpZM1BnRTNQZ0UzUGdFM1BnRTNGeVlHSFFFdUFTY3VBU2N1QVNjdUFTTWlCZ2NPQVFjT0FRY09BUWNHRmhjZUFSY2VBUmNlQVJjVkZCWS9BVFkwTHdFQUNBWHhHaklYRmljUkNoSUpBd0VEQ2hJSkNCRUlBZ01CQWdVREJBVUNDaElKQ3hRSkNoUUw4UVVJQXJFS0V3a0hEZ2NKQmZrR0Jmb0ZDUncyRnhZbUVCMHdGaEFmRHhZckZRb1RDQWtSQ3ZFRkNBZ0Y4aDQ1R1JVbUVSMHdGaEFlRHhjckZGQUZDUWtRQ1FrVEN3a1RDUUlHQXdNRkFnSURBUWdSQ0FrU0NnTUJBd2dUQ2hFbkZoVXVHQWtGK2dVRitnSmFnd1lIQ3drS0d3OElFd2tFQ1FRTkdnME5HUTBDQlFJREF3TUNEQlVKQ2c0RkJRVUlCUzBKREFRREF3RnBCZ1FFc2dRTEJMY0VCQVpxQVE0TUN4MFBIRDhoR0M4WElUZ1JDUTBFQXdRSUJZTUdCdzhNQ3gwUUcwQWdHREFXSVRnU2l3UUVCbWtCQlFRRkRnb0pGUXdDQXdNREFnVUNEUmtORFJvTkJBa0RDaE1JRHhzSkNRc0JhUWNFQkxJRUN3UzNBQUFCQUFELzJnUUFBNllBS2dBQUV4YytBek15SGdJVkZBNENJelV5UGdJMU5DNENJeUlHQnhjZUFRY0ZCaVluQXlZMkYwUlVJbFZqYlRsbHNZVk5TWUt5YWtOMlZ6TXlWM1JEUW5ndFdoOEVIUDdaSEN3RUl3TW9Id01PSml4SE1ScE1oTEZsWmJHRVRLUXpWM1ZEUTNWWE16TXRLUTR3RTlBVUZDSUJaQ0ljRGdBQUFBQUNBQUQvd0FRQUE4QUFKUUJMQUFBbERnTWpJaTRDSndjR0pqY1RQZ0VYQlJZR0R3RWVBVE15UGdJM1BnRVhIZ0VIRXdjdUF5TWlEZ0lIQmhZWEZqWTNQZ016TWhZWEJ3NEJGd1VXTmpjVE5pWUhBN1VsWDI5N1FUUmxYbFlrVXg0bkF5SUVLeHNCSVJzRUgwNHRhamdzVlUxQkdSTkNHeHdORWdsVEpGWmVaVFJCZTI5ZkpSSU1IQnhDRXhsQlRWVXNPR290VGg4RUd3RWhHeXNFSWdNbkhxTTFWVG9mRkNnNUpDVU9HeUVCWFNFVEU4c1RMdzRqSUNJVktUb2tIQXdTRWtJYkFxa2xKVGdvRkI4NlZEWWJRUk1TREJ3bE9Ta1ZJaUFqRGk0VXl4TVRJUUZkSVJzT0FBQUFBQUVCRlAvQUF1d0R3QUFjQUFBQkl4VXpFVE1STXpjak1EUTFORFl6T2dFeE5UQWlJeUlHRlJ3Qk1RRi9hMnZPa0ErZkVoNFlWM3dTZEdzQ2NhLzkvZ0lFclVrYUhodXpaR0ZVTmdBRUFBRC93QVFBQThBQUN3QkRBRm9BYlFBQUFTTVZJelVqTlRNMU14VXpBUlFPQWlNaUxnSTFORFkzUGdFM0xnRTFORFkzRGdFaklpNENOVFEyTno0Qk15RUhJeDRCRlJRR0J3NEJGUlFXSHdFZUFSVURQZ0UxTkM0Q0l5SUdCdzRCRlJRZUFqTXlOamNUTkNZbkppSWpJZ1lIRGdFVkZCWXpNalkxQkFDSFJZYUdSWWYraWk5Y2gxZEtiVWNqTFR3L2x5NFBHZ2dHREJZS05sUTZIaUlzT29rM0FSeFlVUmRHUnlzTkdSZ0xNUzFGeUJnS0ZTdEJLaHMwRUJJTUZDcEFMQmt6RUcxSFRRZ05DZ3BiS2hkZWdtMWlaZ0czaDRkQ2g0Zit4UzliU0N3Z05rWWxKRndqSnhRREVpb2ZFUmNNQVFFa1BFc25MMlFsTUJjMkUxRk5TbE1oRFI4V0Zob0pKaVZSUmdGOEZ6VVNKVlpLTWhVVUZUY2FJbE5KTVJrUS9sQXpTRFlCQnc0SU8wZElYRk0rQUFBQUFBVUFHdi9XQStZRG93QkFBSDRBbVFDcEFMd0FBQk1STkRZMVBnRTNQZ0UzUGdFM1BnRXpJVElXTXg0QkZ4NEJGeDRCRng0QkZSRVVCaFVPQVFjT0FRY09BUWNPQVFjaExnRWpMZ0VuTGdFbkxnRW5MZ0UxSlNNOEFUVXVBU2N1QVNjdUFTY3VBU01tSWdjT0FRY09BUWNPQVFjT0FSVUdGQmNlQVJjZUFSY2VBUmNlQVRNV05qY3lOamMrQVRjK0FUVStBVGNqRkE0Q0l5SXVBalUwUGdJek1ESXhNaDRDRlRnQk1RY3lOalUwSmlNaU1ERWlCaFVVRmhjQk9nRXpNaFlWRkFZaktnRWpMZ0UxTkRZM0dnRUJCQWNRU1RzZ1JDTUhEd2dCUUFJRkFodzVHejVhR1E0TEFRRUJBUUVFQnhCSk95QkVJZ2dQQ1A3QUFnVUNIRGtiUGxvWkRnc0JBUUVEZFFFQkFnTURGUklaUXlVclZpc3JWU3NjT2h3Y01oUWVHd0lEQWdFQkFRTURBaFlSR1VNbEsxWXJLMVVySHo4Zk5VY09CQVlDQVFHVkowUmJORFJiUkNjblJGczBBVE5iUkNmNlFtQmVRZ0ZEWDE1REFRTUJBUUVZSWlJWUFRRUJGeUVoRndFZEFVQUNCUUljT1JzK1doa09Dd0VCQVFFQkJBY1FTVHNnUkNJSUR3ait3QUlGQWgwNEd6NWFHZzBMQVFFQkFRRUJBUVFIRUVrN0lFUWlDQThJb0I0OUhoMDVIUnd5RkI0YkFnTUNBUUVCQXdNQ0ZoRVpReVVyVmlzclZTc2NPaHdjTWhRZUd3SURBZ0VCQVFNRkNENDBFQ01UTVdNeE5GdEVKeWRFV3pRMFcwUW5KMFJiTktKZlFVUmdYME5EWGdFQjRDSVpHQ0lCSWhjWUlnRUFBd0FBLzhBRUFBUEFBQXNBRHdBekFBQVRGQVlqSWlZMU5EWXpNaFlESXhFekFTTVJNekE4QWpVME5qTXlGaFVjQXpFek1Ed0NOVFF1QWlNaUJqRTFNZnBKTkRSSlNUUTBTUkxVMUFGU3k4dEJQenM1MGlWQ1d6ZHNZUU5DTkVwS05EUktTdjcxL1ZVQ3EvMVZVbk42S0VkUlQwa2xlblJVVkgrWlJFVm1ReUZ3WEFBQUFRQjAvOE1EakFQQUFGQUFBQUVpRGdJVkZCWVhGalkzUGdFM05pWW5MZ0UxTkQ0Q016SWVBaFVVRGdJaklpWTNQZ0UxTkNZaklnWVZGQll4TUE0Q0J3WVdGeFFXTno0Qk56NEJNUjRCTXpJK0FqVTBMZ0lqQWhocG5XbzBPajRLRVFJREJ3TUNBd2dTRlNsTGEwTTdXejRoR3pGRktpNDZDdzRtSnlndlF4TVVHeGdFRVE0QkN3TUVVeE1GSkJCUU1FZDFVeTQxWVlwVUE4QkVhb00rVEh3WkJBZ0xCeUFJQ3d3S0ZUZ21PR1pOTHlJOVVqRS9jbFV5UWk4NGNDa2tORmRCS2pOWGIya1NSNUFKQlFJRUJuVkdFNDRkTEQxc2xGWkJlbDQ0QUFBQkFBQUFJQVFBQTJBQU9RQUFBUTRCQno0Qk53NEJCeTRCSXlJT0FoY3VBeWNPQVI0QkZ5NEJKd1lXRnc0Qkp4NEJGdzRESng0RE16SStBaWMrQVRjRUFCdzlJQ0V3REI5REpCeFFMVE5WT1JjTFFYdHVZQ2NVQ3hFc0l4b3dGUUpmVEJjd0dCUnJSU0ZLVDFNcUkweFJWaXlTNDVsTUJSODFGUUwrRFJFREV6d2xFaG9ISGlRc1NGMHhBeUk1VGpBa1QwdERHQUVPQzBsNER3WURCVDVTQWhvbEZnY0ZGaU1ZRFhDejMyOFdOeUFBQUFBQkFBQUFJd1FBQTEwQVJ3QUFBUjRCRlJ3QkJ3NERCdzRESXlJbUx3SXVBU01pQmdjblB3RStBVGN5TmpNeUZoY2VBUmNlQVJjZUFUTXlOamMrQVRjME5qVTBKaU1pQmdjK0F6TTZBVE1EYTBwTEFRRWNORTB5TkdGWVVDVXRTeDRxS2hjeEd3VW9JakZMU3pKTEdnUUhBelpDRFFnTUJRUUlCQkVtRlE4eElDQWlBd0VqSXhFbUZCSTFSVll6QXdZREExMENWRk1GREFValUxOXNQVDlmUHlCTlRvMk9URTBXRnpvL1BpZ3JBd0ZOVFN4SEd4d21DMGhKTHk4eFNCY0ZDUVFnSHdjSE4xUTRIQUFMQUZuL3dBT25BOEFBRHdBWUFDRUFQQUJWQUlRQWtnRENBTklBN0FFSUFBQWxOVFFtSXlJR0J4VWVBVE15TmpVeE56TTFOQ1lqSWdZVkpSVWpFU01SSXpVekZ4RWpOUTRCSXlJbUp5NEJQUUV6RlJ3QkZ4UVdNekkyTnpVekZ4VVVCZ2NPQVNNaUppY1ZJeEV6RlQ0Qk16SVdGeDRCRlJjVkhBRUhEZ0VIRGdFaklpWW5MZ0U5QVRRMk56NEJNeklXRng0QkhRRWpGUlFXTXpJMk56QTBOendCUFFFekFSVVVCaU1pSmowQk5EWXpNaFlCTkNZbkxnRW5MZ0VuTGdFaklnWUhEZ0VIRGdFSERnRVZGQllYSGdFWEhnRVhIZ0V6TWpZM1BnRTNQZ0UzUGdFQk55TUhKeU1YTUJZWEhnRVhGVE0xRnpVMEppY3VBU01pQmdjT0FSMEJGQllYSGdFek1qWTNQZ0VYTXhFakZRNEJJeUltSnp3QlBRRWpGUlFXRng0Qk16STJOeFV4QW5RTEN3Y01CZ1lNQndzTGpqTU5EUXdOL2tnOU9UeXltelFQSFE0TkVBTURBak1CQmdVSUVBZzB3Z01DQlJRUURob01ORFFNR2c0UUZBVUNBOEVCQVFZRkNoOFVGQ0FMQ0FnSUNBc2VGQlFlQ2dnSVpnME5DUXdDQVRUK3BRd05EQXdNREEwTUFab0hCd1FSREEwZEVUU2ZhbXFlTkJFZURBMFFCQWdIQndnRUVBME1IUkUwbjJwcW5qVVJIUXdORUFRSUIvMjdSVGtvS0R3U0NRa05FZ1E1M3dnSkN4NFRFeDRMQ0FnSUNBc2VFeE1lQ3drSWl6UTBDQkVIQmdZQk5BSURCQkFORGgwUWdIa1VFd1lHclFZR0V4SmVHeE1VRkJPeU52NjdBVVUyWWY3bUhoRVJDd29IRkEvZjBBa0tBUVVHREF6WFZYRVVIQWdRRUJBUEd3RjdmQkFQRUJBSUhSUmtCZ3dRQmdnUEJ4QVBEZzhLSWhaa0ZpRUxEZzhQRGdzaEZqc3lGQk1LQ2dNQ0F3WUVFQUo3ZUJRVUZCUjRGQlFVL2NkRVpDQVJIQXdMRFFJR0JnWUdBZzBMREJ3UklXVkNSR1FnRVJ3TERBMENCZ1lHQmdJTkRBc2NFU0JrQWpua2xwWTFHeG9vUFJXYm16NWtGaUlMRGc4UERnc2lGbVFYSVFzUERnNFBDaUpHQVIzYURBd0hCZ0VLQ2RIaER4VUhDZ29SRVI4QUFBSUFBUC9BQkFBRHdBQVRBREVBQUFFaURnSVZGQjRDTXpJK0FqVTBMZ0lUTUNJaklnWVZIQUV4TXdjakVTTVJJelV6TURRMU5EWXpPZ0V4RlRFQ0FHcTdpMUJRaTd0cWFydUxVRkNMdXlJMER4RUxYd2xXZkVCQVFVVUxTZ1BBVUl1N2FtcTZpMUZSaTdwcWFydUxVUDdJRUJNUExHZit5Z0UwYVNBek9qeHJBQUFBQUFVQUFQL0FCQUFEd0FBU0FDWUFXQUJsQUhnQUFBRU9BU01pSmpVME5qYytBVE15RmhVVUJnY0ZGQTRDSXlJdUFqVTBQZ0l6TWg0Q0FUUW1Md0V1QVRVME5qYytBVFUwSmljek55TWlCZ2NPQVJVVUZqTXlOamNPQVJVVUZoY09BUWNPQVJVVUZqTXlOalUzSXpVakZTTVZNeFV6TlRNMUJTSW1JeUlHQnc0QkZSUVdNekkyTlRRbUp3SGRDaDhQTlRJSUNnb2dFRE0wQmc0Q0kxQ0x1MnBxdTR0UVVJdTdhbXE3aTFEK1ZTa2NIUWNPRGdnYUt5b09NVFdySVZNakd4UkhRUVlPQndRRkVBa2NXeVlrRzFWWmFuRGVVU3BSVVNwUi9wSUZDQVlHTnhrT09VOUNPejBxTHdJS0NnOW5LUkFoRFF3TmFpc0xJQTVLYXJxTFVWR0x1bXBxdTR0UVVJdTcvdnNwTVJjV0JoQU5EaElJRkRJdExqRUxJUTRkRmowY0wxQUJBUWNPQ3hJYUN3SU1GeFU0RmkxSFlEcTlVbEluVWxJbmNnRUZDQVVrS3lzM01TWWZLeUVBQlFBQS84QUVBQVBBQUFzQUl3QXpBRWNBV0FBQUFUUTJNeklXRlJRR0l5SW1KUlFHSXlJbU5UUTJOeU1WRkJZeklUSTJQUUVqSGdFVk55TWlCaDBCRkJZN0FUSTJQUUUwSmdVVURnSWpJaTRDTlRRK0FqTXlIZ0luTkNZaklTSUdGUkVVRmpNaE1qWTFFUUdYUFN3clBqMHNMRDBCRVdKR1JtSURBekFNQ1FGNkNRd3dBd01WUHdrTURBay9DUXdNQVRwUWk3dHFhcnVMVUZDTHUycHF1NHRRN3lVYS9sd2FKU1VhQWFRYUpRSEFMRDA5TENzK1BpdEdZbUpHQ3hVSzV3a01EQW5uQ2hVTDBnd0pQd2tNREFrL0NRelNhcnFMVVZHTHVtcHF1NHRRVUl1N2FCb2xKUnIrWEJvbEpSb0JwQUFBQUFRQUFQL0FCQUFEd0FBVEFCY0FJd0ErQUFBQklnNENGUlFlQWpNeVBnSTFOQzRDQVNNUk15Y2lKalUwTmpNeUZoVVVCZ0VqTURRMU5DWWpJZ1lWSEFFeEl4RXpGVEEyTXpJV0ZSd0JNUUlBYXJ1TFVGQ0x1MnBxdTR0UVVJdTcvd0J3Y0RnY0p5Y2NHeWNuQWNSd0hpQWhJMnhzTkRvNVN3UEFVSXU3YW1xNmkxRlJpN3BxYXJ1TFVQenZBV3d3Snh3Y0p5Y2NIQ2YrWkpnbkp5c3NKaXFWQVd3eFBFZEtTWjBBQUFBQ0FBRC93QVFBQThBQUV3QmVBQUFCSWc0Q0ZSUWVBak15UGdJMU5DNENBeUltSnpBR0J3NEJCd1ltTlM0Qk56NERNVEFtTlRRMk16SVdGUlFHQndZV016STJOVFFtSXlJR0ZSUVdGeDRCQnc0QkJ3NEJKeTRCTlRRK0FqTXlIZ0lWRkE0Q0l3SUFhcnVMVUZDTHUycHF1b3RSVUl1N09oMHhDUllEQ3pJREFnWUJDQW9DRHhBTUN5Z2NHUmNYQ0FjakhESStURWRSWGcwTEJRRUJBZ1FDQVFvR0pTUWdQMTgvTTFNN0lCd3lSeW9Ed0ZDTHUycHF1NHRRVUl1N2FtcTdpMUQ5ZHhvU1Znd3BSd1FDQVFNR1Zpc0xQME0wSHhrb05COFdHVU1pSENod1REdE5aME1YSWd3R0J3Y0ZFd1FIQlFNUFNpNG1UMEFwSWpsSkp6VlpRU1FBQUFJQUFQL0FCQUFEd0FBVEFFTUFBQUVpRGdJVkZCNENNekkrQWpVMExnSVRGZzRDSXlJbUp4WTJOeTRCSnhZMk55NEJOeDRCTXk0Qk54NEJGeVkyTXpJV0Z6NEJOdzRCQno0Qk53NEJCd0lBYXJ1TFVGQ0x1MnBxdTR0UVVJdTdnQU1zV0lKVU0xNG9NRjBtS0Q0TERod01LellCREJzUEtCVVlMWUJNRGtrNkdpNFFGU1lTQnh3U0VpTVFEQjhSQThCUWk3dHFhcnFMVVZHTHVtcHF1NHRRL25oQWdHZEFIUmtGR1I0Qkx5UURBZ01KUlNvSENCdGRLVGREQkRoY0ZSRUVEd29WSWd3RENRY1NIdzBBQUFBQ0FBRC93QVFBQThBQUV3QlZBQUFCSWc0Q0ZSUWVBak15UGdJMU5DNENFdzRCQnc0Qkl5SW1Md0l1QVNNaUJnY25Qd0UrQVRjeU5qTXlGaGNlQVJjZUFSY2VBVE15TmpjK0FUYzhBVFUwSmlNaUJnYytBVE02QVRNZUFSVWNBUlVDQUdxN2kxQlFpN3RxYXJ1TFVGQ0x1OGtDUHp3L2Fpc2NMUklaR1E0ZEVBUVhGUjB0TFI0dEVBSUVBaUFvQ0FRSEF3TUZBZ3NXRFFrZEZCTVVBaFVVQ3hjTUZsTStBZ01DTEMwRHdGQ0x1MnBxdTR0UVVJdTdhbXE3aTFEK2hTcHlTVXhNTHk1VlZTNHVEZzBqSlNVWUdnSUJMaTRiS2hFUUZ3Y3JMQndkSFNzT0F3VURFeE1GQkVOREFUTXlBd2NEQUFBQURBQUEvOEFFQUFQQUFBNEFHQUFoQUQwQVZnQ0dBSlFBeFFEVkFPOEJDZ0VlQUFBQk5UUW1JeUlHQnhVZUFUTXlOalUzTXpVMEppTWlCaDBCSlJVakZTTTFJelV6RnhVak5RNEJJeUltSnk0QlBRRXpGUndCTXhRV016STJOelV6TVJjVkZBWUhEZ0VqSWlZbkZTTTFNeFUrQVRNeUZoY2VBUlVYRlJ3QkJ4UUdCdzRCSXlJbUp5NEJQUUUwTmpjK0FUTXlGaGNlQVIwQkl4VVVGak15Tmpjd05EVTJORDBCTXhVREZSUUdJeUltUFFFME5qTXlGaE0wSmljdUFTY3VBU2N1QVNNaUJnY09BUWNPQVFjT0FSVVVGaGNlQVJjZUFSY2VBVE15TmpjK0FUYytBVGMrQVRVQk55TUhKeU1YTUJZWEhnRVhGVE0xRnpVMEppY3VBU01pQmdjT0FSMEJGQllYSGdFek1qWTNQZ0VYTXpVakZRNEJJeUltTlNJMFBRRWpGUlFXRng0Qk16STJOeFVGRkE0Q0l5SXVBalUwUGdJek1oNENBa1lIQndRSEJBUUhCQWNIVlI0SENBZ0gvdmdsSWlSclhSOEpFZ2dJQ2dJQkFSNEJBd1FFQ2dVZmRBRUNBd3dKQ1E4SUh4OEhFQWtKREFNQ0FYUUJCQU1HRWcwTUVnY0ZCUVVFQnhNTERCSUdCUVU5Q0FjR0J3RUJIOUFJQndjSUNBY0hDUFlFQlFJS0NBY1NDaDlmUUQ5ZklBb1NCd2dLQWdRRkJRUUNDZ2dIRWdvZllEOC9ZQjhLRWdjSUNRTUVCZjZqS2lNWEdTUUxCZ1VJQ3dJaWhnVUZCeElMREJJR0JRVUZCUVlTREFzU0J3VUZVeDhmQlFrRkF3UUJId0lCQXdrSUNCSUpBWVpRaTd0cWFydUxVRkNMdTJwcXU0dFFBUUJKQ3d3RUEyZ0VBd3NMT1E4TURBd01EM3NodzhNaE82a1NDZ3NIQmdRTkNJWjhCZ1lFQXdjSGdUTkREQkVGQ2dvS0NSRGtTd2tLQ2dvRkVRdzhCQVlLQkFVSkJBa0tDUWtHRkE0N0RoUUdDUWtKQ1FZVURpTWVEQXNHQmdJQkFRUURDZ0VCZlVnTURBd01TQXdNRFA2cktUd1RDaEVIQndnQkF3UUVBd0VJQndjUkNoUThLQ2s4RXdvUkJ3Y0lBUVFEQXdRQkNBY0hFUW9UUENrQkxJbGFXaUFRRUJjbERWeGNKVHdPRkFZSkNRa0pCaFFPUEEwVUJ3a0pDUWtHRkNtcmd3Y0lCQVFHQm42SUNBMEVCZ2NMQ2hKT2FycUxVVkdMdW1wcXU0dFFVSXU3QUFBQ0FBRC93QVFBQTY4QU5nQkhBQUFCRnhFd0JpTXFBeU1pSmljbU5qVTBKalUwTmpVMEpqVTBOalUwSmpVME5qTWhMZ0VuTGdFM1BnRVhIZ01YSGdNWEJTTWlCaFVSRkJZN0FUSTJOeE0ySmlNQ3pVbU9VU2gyZDJrZEZ5b1BFQkUwR0RFbUpqQWNBUzBES3hFVkd4c2hXUTBIRWhZWERCWTlQRE1OQVNLUENBNE9DREVJRHdKV0FRa0pBWU00L3I1SklDSWhLUVlHTFI4ZkhRd01GaXNxR0FjSUhDOHVJeTlPTHk5c0lDY1RHQXcrU1VVU0ltVmlUZ3NWRHdqK2ZRZ01EQWdCaFFnTkFBSUFBUC9SQkFBRHdBQTJBRWNBQUFFbkVUQTJNem9ETXpJV0Z4WUdGUlFXRlJRR0ZSUVdGUlFHRlJRV0ZSUUdJeUVlQVJjZUFRY09BU2N1QXljdUF5Y2xNekkyTlJFMEppc0JJZ1lIQXdZV013RXpTWTVSS0haM2FSMFhLZzhRRVRRWU1TWW1NQnorMHdNckVSVWJHeUZaRFFjU0ZoY01GajA4TXczKzNvOElEZzRJTVFnUEFsWUJDUWtCL1RnQlFra2dJaUlvQmdZdEh4OGREQXdXS3lvWUNBY2NMeTRrTGs0dkwyd2dKeE1ZREQ1SlJSSWlaV0pPQ3hVUENBR0RDQXdNQ1A1N0NBMEFCQUFBQUFvRUFBTjhBQm9BSHdBa0FDZ0FBQUVoSWdZVkVSUVdPd0VWRkJZM1BnTXhJVEkyTlJFMEppTUZJUlVoTlFFaE5TRVZKU0UxSVFPOC9JZ2NLQ2djWngwTkFUUThNUUpGSENnb0hQenZBaUw5M2dHWi9tY0JtUUVSL1ZZQ3FnTjhLQjM5M2h3b3VSQUdDQUkrU2owb0hBSWlIU2lyUkVUK3EwUkVpRVFBQUFBQUFRQUEvL29FQUFOdUFENEFBQUVpQmdjT0FRY09BUWNPQVFjdUFTY3VBU2N1QVNjdUFTTWlCZ2NPQVJVVUZoY2VBUmNlQVJjZUFSY2VBUmNCSGdFek1qWTNBVDRCTlRRbUp5NEJJd0x5RWlNU0VpTVFEeDBLQ2hnTENoVU5DaDBRRHlNU0VpUVNRR1VrSmlVR0NBY1FCd2dVQ2dvUUJRVUhCUUZtQlFzSUNBc0ZBV1pEUHlRa0htVkRBMjRHQ0FVU0N3b1VCd29TQ2dvVUNBb1JDZ3NRQndZSUpDUWpZME1TS0JRVkl3MFBHd3dORkFVRkJnUCtwQVVGQlFVQldVT0FRRUJqSXlRa0FBQUJBQWYvd0FQMkE3MEFNZ0FBQVM0Qkx3SXVBU2N4SXc0QkR3SU9BUWNHRmg4QkF3WVdGeDRCT3dFeU5qOEJGeDRCT3dFK0FUYytBU2NETno0Qkp3UDJDQ0lYL1hRS0l4Y0tGU0lLY2Z3WEpRVUlEUSs1TFFJUEVnb1pEUW9JRHdqaDRRZ1VEUTRLRkFjU0VnVXN1QW9MQndJK0Z4NEZKdThVR1FNREdSVHZKZ0loRnhjckVMdis4aGNyRFFvS0JRVi9md1VGQXdZSURTc1hBUTIvRUM0VUFBQUFBQU1BQUFCSUJBQUROd0FQQUJNQUh3QUFBU0VpQmhVUkZCWXpJVEkyTlJFMEpnY0pBU0VCRVFFZUFUTXlOamNCRVNFRHZQeUlIQ2dvSEFONEhDZ29jZjZaL3BrQ3p2enVBWTBHRUFnSUVBWUJqZnlxQXpjbkhQMllIQ2dvSEFKb0hDZFYvcG9CWnYyOEFoRCtjd1lHQmdZQmpQM3hBQUFBQUFJQUFBQW9BL2tEZ3dBVEFDc0FBQ1VWSVJFek55TWlCaFVSRkJZeklUSTJQUUVIQVFNbUJoMEJNQTRDQno0RE1SVVVGajhCTmpRbkF1LzlpR2gzNmkwL1B5MENqUzAvZGdFSzhnY01rYnl6STBtOXFYUU1CL0VJQit0TkFZdDNQeTMrWHl3L1B5ek9kZ0dZQVFBRkJRbHVLVzIvbFU1UUlnSnJDUVlHK1FVUEJnQUFBQUlBVUFBUUE3QURjQUFtQUZFQUFBRStBVGMrQVI0QkZ3Y3VBUWNPQVE4QkJoUVhGakkvQVI0Qk53Y09BU0ltSnk0Qk5EWS9BUUVITmhZWE56WXlGeFlVRHdFR0lpY3VBU2NISGdFWEhnRVhGalkzUGdFL0FUNEJOQ1luTGdFaUJnY0JDQTRmRVM1bVlWVWVZQlJjTXhNa0Q3Z3FLaXAzS1RrblVTbDlLR1ZwWlNrb0tDZ291QUVrZlNsUkp6a3BkeW9xS3JncWR5a0tFQVZnQ0JBS0drRW5NV1l0RVI4T3VDZ29LQ2dvWm1sbEtBSk1EaGNKR2d3WE9pMWdMekFNQkJNUHVDcDJLaW9xT1E4TkEzMG9LQ2dvS1dWcFpTaTRBU1I5QXcwUE9Ta3BLbmNwdUNvcUNSZ0xYd3dVQ2hvbUNRd09HQWtZRHJjcFpXbGxLQ2tvS0NnQUFBQUFCQUFBLzhBRUFBUEFBQW9BRGdBaUFETUFBQUUzRVNFUkZ4NEJNekkyRXlFWE53VVVEZ0lqSWk0Q05UUStBak15SGdJbk5DWWpJU0lHRlJFVUZqTWhNalkxRVFJTDd2NEE3Z01LQlFVSnlmNVMxOWNCTUZDTHUycHF1NHRRVUl1N2FtcTdpMURVR0JIOTZ4QVlHQkFDRlJFWUFWcnQvc1FCUE8wRUJBUUJFZGZYcDJxN2kxQlFpN3RxYXJ1TFVGQ0x1MGdSRnhjUi9vNFJGeGNSQVhJQUFBTUFBUC9BQkFBRHdBQVRBQ1lBUGdBQUFTSU9BaFVVSGdJek1qNENOVFF1QWhNVUJpTWhJaVk5QVRRMk93RUhJeFVoTlRjM0J3WW1QUUV3RGdJSFBnTXhOVFEySHdFV0ZBY0NBR3E3aTFCUWk3dHFhcnVMVUZDTHUyd21HLzU1R3lZbUc0eEhQd0Y3UjFtUkJBaEZaWElzRld4d1Z3Y0ZrUVFFQThCUWk3dHFhcnVMVUZDTHUycHF1NHRRL1QwYUppWWEreG9tUiswdVI1K1dBd01HUUFFVU1DOVpjMEVaUWdVREE1b0RDUU1BQXdBQS84QUVBQVBBQUJNQU5BQmJBQUFCSWc0Q0ZSUWVBak15UGdJMU5DNENBd1lpSnlZMFB3RStBVGMyRmhjSExnRUhEZ0VQQVFZVUZ4WXlQd0VlQVRjSEFRY09BUWNPQVNjdUFTY3VBU2MzSGdFWEZqSS9BVFkwSnlZaUR3RXVBUWMzTmpJWEZoUUhBZ0JxdTR0UVVJdTdhbXE3aTFCUWk3dURMWUV1TFMxcEJ4SUpOWFlpTndzMUhBc1ZDR2dZR0JoREdDQVdMaGRIQVE1b0NCSUpHam9jRmlVT0Jna0VOZ01KQlJoREdHZ1lHQmhER0NBVkx4ZEhMWUV1TFMwRHdGR0x1bXBxdTR0UVVJdTdhbXE2aTFIOUJTNHVMWUV1YUFnTkJSMGNNellhR3dZREN3aG9HRU1ZRnhjZ0NBY0NSd0VOYUFnTkJRNElCd1VWRHdZTEJ6WUhEUVVZR0dnWVF4Y1lHQ0FKQndKSExpNHVnQzRBQUFFQUFQL0FCQUFEd0FBcUFBQUJEZ0VqSWlZbkxnRTFORFkzTmk0Q0l5SU9BakVVSGdJWEhnTXpNRDRDTlRRdUFnY0M3ek1pTkRObU16UlZWVFFaSmsxYUdScEdRQzB3VFdJeU1wR2Frak5BVFVCQ1dsc2FBVm8wVlZVME0yWXpOQ0l6R2x0YVFrQk5RRE9TbXBFeU1tSk5NQzFBUmhvWldrMG1HUUFFQUlyL3dBTjJBOEFBRFFBWEFDTUFMd0FBQVNNMU5DWWpJZ1lkQVNNRElRTWxORFl6TWhZZEFTRTFBeUltTlRRMk16SVdGUlFHSVNJbU5UUTJNeklXRlJRR0ExYWhha3RMYXFFZ0F1d2cvaHRVT3p0VS91SVNGaDRlRmhVZUhnRXVGaDRlRmhVZUhnS3RYa3RxYWt0ZS9STUM3VjQ3VTFNN1hsNys5eDRWRlI0ZUZSVWVIaFVWSGg0VkZSNEFBQUFCQUFBQVNBUUFBemdBSUFBQUFTY3VBU2MxSXc0Qkl5SW1KeU1WRGdFUEFSYzNIZ0VWRVNFUk5EWTNGemNuQTZsYUVDWVVlaEJLTGk5S0Qzb1dLUkN5b2tnQ0FnSXBBZ0ZFb2xjQ3BtZ1NGUUlCS1RVMUtRRUJGUlBPZlZNRkRRZitTd0cxQmdzRlQzMWxBQUFIQUFELzVBUUFBNXdBSndCUEFGOEFjQUI5QUlrQWpRQUFBU00zUGdFMU5DWWpJZ1lQQVNjdUFTTWlCaFVVRmg4Qkl5SUdGUkVVRmpNaE1qWTFFVFFtSXhNVUJpTWhJaVkxRVRRMk15RW5MZ0UxTkRZek1oWWZBVGMrQVRNeUZoVVVCZzhCSVRJV0ZSRUJJU0lHRlJFVUZqTWhNalkxRVRRbUV4UUdJeUVpSmpVUk5EWXpJVElXRlJFM01oWVZGQVlqSWlZMU5EWXpKelEyTXpJV0ZSUUdJeUltQlJjSE5RTitzaGdORHpnb0V5TU5YVndOSXhNb09BOE5HTEkzVEV3M0F2czJURXcyT2lBYS9RVWFJaUlhQVZpTkJBUVFDd1VLQTQyTkJBb0ZDeEFFQkkwQldCb2cvc1ArY0RKSlNUSUJrRE5JU0NrNkpmNXRKakExSlFHVEpqV0FGeUVoRnhnaElSZzRJQmdYSVNFWEdDRCtYSVdGQXVRWERTSVRLRGNQRFZ4Y0RRODRKeE1pRFJkUE52NEhOa3hNTmdINU5rLzlnaG9nSUJvQitSb2pqZ01LQmdzUEJBU05qUVFFRHdzR0NnT09JeHIrQndINVNEUC9BRE5JU0RNQkFETkkvb01sTlRJbEFRY2xOVFltL3Y3aklSY1lJU0VZRnlGaUZ5RWhGeGNoSVVGcmE5WUFBQUFIQUFELzVBUUFBNXdBSndCUEFHQUFjQUI4QUlnQWxRQUFBU00zUGdFMU5DWWpJZ1lQQVNjdUFTTWlCaFVVRmg4Qkl5SUdGUkVVRmpNaE1qWTFFVFFtSXhNVUJpTWhJaVkxRVRRMk15RW5MZ0UxTkRZek1oWWZBVGMrQVRNeUZoVVVCZzhCSVRJV0ZSRUJJU0lHRlJFVUZqTWhNalkxRVRRbUl4TVVCaU1oSWlZMUVUUTJNeUV5RmhVWEZBWWpJaVkxTkRZek1oWW5ORFl6TWhZVkZBWWpJaVlGTXhVak5UTTFNeFV6TlRNVkEzNnlHQTBQT0NnVEl3MWNYUTBqRXlnM0RnMFlzalpOVFRZQyt6Wk1URFk2SUJyOUJSb2hJUm9CV0kwRUJCQUxCUW9FalkwRENnVUxFQVFFalFGWUdpRCt3LzV3TWtoSU1nR1FNMGhJTTF3NkpmNXRKVEUxSmdHU0pqVzRJUmNYSVNFWEZ5RndJUmNYSVNFWEZ5SCs2eFhYRkVnZlJ3TGtGdzBpRXlnM0RnNWRYUTBQT0NjVElnMFhUemIrQnpaTVREWUIrVFpQL1lJYUlDQWFBZmthSTQ0RENnWUxEd1FFalkwRUJBOExCZ29EamlNYS9nY0IrVWd6L3dBelNFZ3pBUUF6U1A2REpUVXlKUUVISlRVMkpsY1lJU0VZRnlFaGd4Y2hJUmNYSVNGcG1wb1VGQlFVQUFBSEFBRC81QVFBQTV3QUp3QlBBR0FBY1FCOUFJa0F1UUFBQVNNM1BnRTFOQ1lqSWdZUEFTY3VBU01pQmhVVUZoOEJJeUlHRlJFVUZqTWhNalkxRVRRbUl4TVVCaU1oSWlZMUVUUTJNeUVuTGdFMU5EWXpNaFlmQVRjK0FUTXlGaFVVQmc4QklUSVdGUkVCSVNJR0ZSRVVGak1oTWpZMUVUUW1JeE1VQmlNaElpWTFFVFEyTXlFeUZoVVJOeFFHSXlJbU5UUTJNeklXSnpRMk16SVdGUlFHSXlJbUJ6QVVGUlFHQnc0Qkt3RWlKalUwTmpNd05qMEJCeFV3RkJVVUJnY09BU014T0FFeElpWTFORFl6TURZOUFUY1ZBMzZ5R0EwUE9DZ1RJdzFjWFEwakV5ZzREdzBZc2paTlRUWUMrelpNVERZNklCcjlCUm9oSVJvQldJMEVCQkFMQlFvRWpZMERDZ1VNRHdRRWpRRllHaUQrdy81d01raElNZ0dRTTBoSU0xdzZKZjV0SlRFMUpnR1NKalc0SVJjWElTRVhGeUZ3SVJjWElTRVhGeUhwQ2drSUZ3MEJFaG9aRWhoeENRa0pGZzRTR2hrU0Y4TUM1QmNOSWhNb053NE9YVjBORHpnbkV5SU5GMDgyL2djMlRFdzJBZmsyVC8yQ0dpQWdHZ0g1R2lPT0F3b0ZDeEFFQkkyTkJBUVBDd1lLQkkwakd2NEhBZmxJTS84QU0waElNd0VBTTBqK2d5VTFNaVVCQnlVMU5pYisvcW9YSVNFWEdDRWhneGNoSVJjWElTR3FLZzBNRlFrSUNCb1NFaG9DQ1dNbFR5b05EQlVJQ0FnWkV4SVpBZ3A2UFlzQUFBY0FBUC9rQkFBRG5BQW5BRThBWUFCeEFIMEFpUUNvQUFBQkl6YytBVFUwSmlNaUJnOEJKeTRCSXlJR0ZSUVdId0VqSWdZVkVSUVdNeUV5TmpVUk5DWWpFeFFHSXlFaUpqVVJORFl6SVNjdUFUVTBOak15Rmg4Qk56NEJNeklXRlJRR0R3RWhNaFlWRVFFaElnWVZFUlFXTXlFeU5qVVJOQ1lqRXhRR0l5RWlKalVSTkRZeklUSVdGUkUzRkFZaklpWTFORFl6TWhZbk5EWXpNaFlWRkFZaklpWUhGUlFHQnhVak5TNEJQUUUwTmpzQk1EUXhORFk3QVRJV0hRRXpNaFlWQTM2eUdBMFBPQ2dUSXcxY1hRMGpFeWc0RHcwWXNqWk5UVFlDK3paTVREWTZJQnI5QlJvaElSb0JXSTBFQkJBTEJRb0VqWTBEQ2dVTUR3UUVqUUZZR2lEK3cvNXdNa2hJTWdHUU0waElNMXc2SmY1dEpURTFKZ0dTSmpXNElSY1hJU0VYRnlGd0lSY1hJU0VYRnlIMkdSS1dFaGtiRkE4RUEyTURCQThUR3dMa0Z3MGlFeWczRHcxY1hBMFBPQ2NUSWcwWFR6YitCelpNVERZQitUWlAvWUlhSUNBYUFma2FJNDREQ2dZTER3UUVqWTBFQkE4TEJnb0RqaU1hL2djQitVZ3ovd0F6U0VnekFRQXpTUDZESlRVeUpRRUhKVFUySnY3K3F4Z2hJUmdYSVNHREZ5RWhGeGNoSVlKb0V4b0JHaG9CR2hOb0V4c25Bd1FFQXljYkV3QUFDd0FBLytRRUFBT2NBQ1lBVGdCZkFIQUFmUUNKQUtnQXJBREJBTk1BNkFBQUFTTTNQZ0UxTkNZaklnWVBBU2N1QVNNaUJoVVVGaDhCSXlJR0ZSRVVGak1oTWpZMUVUUW1FeFFHSXlFaUpqVVJORFl6SVNjdUFUVTBOak15Rmg4Qk56NEJNeklXRlJRR0R3RWhNaFlWRVFFaElnWVZFUlFXTXlFeU5qVVJOQ1lqRXhRR0l5RWlKalVSTkRZeklUSVdGUkUzRkFZaklpWTFORFl6TWhZVkp6UTJNeklXRlJRR0l5SW1CVE1WRGdFaklpWTFORFl6TWhZZkFTTTFMZ0VqSWdZVkZCWXpNalkzTVRjekZTTTNNeFVqTlE0Qkl5SW1QUUV6RlJRV016STJQUUUzSWdZSE5TTVZNelVlQVRNeU5qVTBKaU1YSXpVME5qRXpOVFEyTVRNeUZoMEJNeklXSFFFRGZySVlEUTg0S0JNaURseGREU01US0RjT0RSaXlOazFOTmdMN05reE1CQ0FhL1FVYUlTRWFBVmlOQkFRUUN3VUtCSTJOQXdvRkRBOEVCSTBCV0JvZy9zUCtjREpJU0RJQmtETklTRE5jT2lYK2JTVXhOU1lCa2lZMXVDRVhGeUVoRnhjaGNDRVhGeUVoRnhjaC9nd21CaUlZSFNjbkhSZ2hCZ0VtQXc0SkRoTVREZ2dQQXpRakk0SWpJUVlSQ1JnZEl3Z1FDdzE2Q3hNSEpDSUlGQXNhSlNVYUdqRUNCd0liQVFFSEFRRUM1QmNOSWhNb053OE5YVjBORHpnbkV5SU5GMDgyL2djMlRFdzJBZmsyVC8yQ0dpQWdHZ0g1R2lPT0F3b0dDdzhFQkkyTkJBUVBDd1lLQkkwakd2NEhBZmxJTS84QU0waElNd0VBTTBqK2d5VTFNaVVCQnlVMU5pYisvcW9YSVNFWEdDRWhHSnNYSVNFWEZ5RWgzQUVXR2lnZEhpZ1pGd0VCQmdvV0VBOFZDUWVRdm9XRkN3Y0dJQnBOVFFVVURndE5BZ2NIUmI0TkJ3Z29IQjBvWmprQkFRZ0JBUUVCQ0FFQk9RQUFFd0FBQUVBRUFBTkFBQjRBSWdBMkFFZ0FYUUJ0QUgwQWpRQ2RBSzBBdlFETkFOSUE0Z0R5QVFJQkVnRWlBVElBQUFFekJ3NEJJeUltTlRRMk16SVdGeFVqSnk0Qkl5SUdGUlFXTXpJMk56VVhNeEVqRnhRR0l5SW1QUUVqRlJRV016STJOeFV6TlNNRkZBWWpJaVluRlNNUk14VStBVE15RmhVbk5DWXJBVFUwSmlzQklnWWRBU01pQmgwQk16VVRFUlFHSXlFaUpqVVJORFl6SVRJV0FUUW1Ld0VpQmgwQkZCWTdBVEkyTlRVMEppc0JJZ1lkQVJRV093RXlOalUxTkNZckFTSUdIUUVVRmpzQk1qWTFOVFFtS3dFaUJoMEJGQlk3QVRJMk5UVTBKaXNCSWdZZEFSUVdPd0V5TmpVMU5DWXJBU0lHSFFFVUZqc0JNalkxQVJFaEVTRTNOQ1lyQVNJR0hRRVVGanNCTWpZMU5UUW1Ld0VpQmgwQkZCWTdBVEkyTlRVMEppc0JJZ1lkQVJRV093RXlOalUxTkNZckFTSUdIUUVVRmpzQk1qWTFOVFFtS3dFaUJoMEJGQlk3QVRJMk5UVTBKaXNCSWdZZEFSUVdPd0V5TmpVQlB6VUJCekFqS1RnNEtTSXdDRFFCQkJRTkV4c2JFd3dWQlVveE1iZ1REeGdKTXlraURSY0pNRElCQnpRbUVCd0xNRElMR3c4bU5EVUJBUXNDQVNVQ0FRb0JBa1h0U3pmOUJEWk1URFlDL0RkTC9Gd01DQlVJREF3SUZRZ01EQWdWQ0F3TUNCVUlEQXdJRlFnTURBZ1ZDQXdNQ0JVSURBd0lGUWdNREFnVkNBd01DQlVJREF3SUZRZ01EQWdWQ0F3REtmejJBd3BjREFnVUNRd01DUlFJREF3SUZBa01EQWtVQ0F3TUNCUUpEQXdKRkFnTURBZ1VDUXdNQ1JRSURBd0lGQWtNREFrVUNBd01DQlFKREF3SkZBZ01BWHdCSUNRNEtpbzVKQ0VCQVFnT0hoY1ZIdzBLQVVFQkRzQVBGQjBHYlcwa0xnb0pEN3RkS1RrTUNoSUJEbUlKQ3prcElRSUJDd0VDQWdFTEFRSlFVQUVDL2dZMlRFdzJBZm8xVDAvOTFBZ01EQWdVQ1F3TUNYc0lEQXdJRlFrTEN3bDdDQXdNQ0JRSkRBd0plZ2tNREFrVUNRd01DWHNJREF3SUZRZ01EQWg3Q1F3TUNSUUpEQXdKL2MwQ2hQMThSd2dNREFnVUNRd01DWHNJREF3SUZRa0xDd2w3Q0F3TUNCUUpEQXdKZWdrTURBa1VDUXdNQ1hzSURBd0lGUWdNREFoN0NRd01DUlFKREF3SkFBZ0FBdi9BQkFBRHdBQW1BQ29BTGdBeUFEY0FQUUJDQUUwQUFBRWhKVDRCTHdFdUFTY3VBU01pQmlNRkRnRWZBUjRCTVFZVUZSRVVGak1oTWpZMUVUUW1Jd2NqTnpNaEJ5TTNJd2NqTlNVbk54Y0hKUWNuTnhjakJUY1hCeWNCSVNJbU5SRWhFUlFHSXdPeS9tb0JkeDhqQmhZREVRMEpGZ3NFQ0FUODRDQWpCeFlDRFFWQU9nTFdPbFF1SUhlaFlhRCt0MkNwWWFkaExnRXFpcU9Lb3dIbG9JbW5nZ0g4eWgyS2poa0RHdjFDRGlZRE9Ua09BbWRVQmpZZWJROGFDQVlIQVo4R05CNXZCd1VJRkF2K0xUbGFXamtCMHg4aXJWeGNYRnhjaTFzaFdpSmtJVm9oVmpRSFhCNXovVHdqSHdGRi9yc2dJZ0FBQkFBQUFDWUVBQU5hQUNRQUx3QTZBRDRBQUFFak5UUW1Ld0VpQmgwQkl6VTBKaXNCSWdZZEFTTWlCaFVSRkJZeklUSTJOUkUwSmlNbE5EWTdBVElXSFFFak5TRTBOanNCTWhZZEFTTTFBU0VSSVFQTlNDZ2I1eHNzS0NzYjV4c3BTQlVlSGhVRG1oWWRIUmIrandNQzdBSUQ5djVTQXdMc0FnUDJBd3I4a0FOd0F0UkRHeWdvRzBOREd5Z29HME1aRnYyMEZSNGVGUUpNRmhrNkFRTUNBbU5qQVFNQ0FtTmovV0FDSHdBQUFBQURBQUQvd0FQK0E4QUFSZ0NDQUprQUFBRXVBU3NCSWdZSExnTW5MZ0VuTGdFbkxnRWpJZ1lIQmhZWEhnRVhJeUlHRlJRV0Z3NEJGUlFXRnc0QkZSUVdGd1lXRng0Qk15RXlOamNlQVRzQk1qWTNFelltSndFakRnRWpLZ01qSWlZbkpqWTFOQ1kxTkRZMU5DWTFORFkxTkNZMU5EWXpJUzRCSnk0Qk56NEJNeklXRng0QkZ4NERGeDRCTVRNUkV3TU9BU3NCSWlZMU1Ed0NOVFEyTXpvQk16SVdCd1BzRFNZV2VnNGJEUXcyT1M4RUNCWUhDZzBIRGpVaUowNGJJZ01rQkFvRmxVSk9Cd1lHQnhBTEF3TVlEUUlGQ3hoSkt3RmdNazBiRURFYUtTYzFCMGtFQ1EzKyt6QVJRakVpWkdkWkdSTWtEZzBPTEJRcElDQXBHQUVCQXlRUEVoY1hFaThUQ3hFRUN5Y1RGRGcxS0FNQ0NpM0tTZ0VOQnlrTkV3c0tCbkFQQndnQkFhTVFFd2NIRmxWWVJ3Y01SaGNpS0EwYUhTWWdLSGRRREJZSVQwQVVJUTBNSHhNY0tBNEpGUTBkTFJBUktoZ3lOaDhTRlJ3MEhnRkRGU2tRL3FFUEtDQWNIQ1lGQlNZYUdoZ0tDaElrSkJJSEJoY25KeHNoU3lnbllCb1ZGUWNIRlpJZUhWZFVRUVlHRXY3TEFTVCt1d2NQRXdkaWQyY0ZDZ01LQndBREFBRC93QVArQThBQVJRQ0JBSmdBQUFFRExnRXJBU0lHQnk0Qkl5RWlCZ2NPQVJjT0FSVVVGaGNPQVJVVUZoY09BUlVVRmpzQkRnRUhEZ0VYSGdFek1qWTNQZ0UzUGdFM1BnTTNIZ0U3QVRJMk56NEJCU013QmdjT0F3Y09BUWNPQVNNaUppY21OamMrQVRjaElpWTFORFkxTkNZMU5EWTFOQ1kxTkRZMU5DWTNQZ0V6T2dNek1oWVhNeEV6S2dFaklpWTFQQU14TkRZN0FUSVdGeE1XQmlNRC9ra0hOU2NwR2pFUUcwMHkvcUFyU1JnTEJRSU5HQU1EQ3hBSEJnWUhUa0tWQlFvRUpBTWlHMDRuSWpVT0J3MEtCeFlJQkM4NU5nd05HdzU2RmlZTkRRbis1UzBLQWdNbk5qZ1VFeWNMQkJFTEV5OFNGeGNTRHlRRC92OFlLU0FnS2hVdER3ME9KQk1aV21aa0l6QkNFaSs4RDNBR0Nnc1REU2tIRFFGS0FRZ0hBaXNCUXg0MEhCVVNIell5R0NvUkVDMGREUlVKRGlnY0V4OE1EU0VVUUU4SUZneFFkeWdnSmgwYURTZ2lGMFlNQjBkWVZSWUhCeE1RRUNrUEVnWUdRVlJYSFI2U0ZRY0hGUlVhWUNjb1N5RWJKeWNYQmdjU0pDUVNDZ29YR3hvbUJRVW1IQndnS0EvK3l3TUtCV2QzWWdjVER3Zit1d2NLQUFBQUFBWUFBUC9iQkFBRHBRQUVBQWtBRGdBdUFFc0FVQUFBRXlFVklUVTFJVFVoRlRVaE5TRVZFeUltTlJFME5qTWhNaFlWRVJRR0l5RU9BUWNPQVFjT0FTc0JJaVk5QVRNbkhnRTdBUndCRlRNK0FUY2hNalkzUGdFMUVUUW1JeUVpQmhVUkZ4TWhOU0VWc0FFZC91TUIwLzR0QXFEOVlBOVZhbXBWQW9KVmFtcFYvb1FMRndzUkl4RUxJQkljSVM0VWJnUTZNRHNjSWtZaUFhRXBPQW9DQWp3ei9YNHpQQUZmQXFEOVlBRnhJaUpWSWlMdklpTDl4bVJWQWJkV1pHUlcvbE5XYlFrZURoVW9GQTRNTENGVHJ5OHhJbHNpS2xNaUtDUUlFZ29Cc1Rjek16ZitUeEFCRkNJaUFBQUFDUUFBLytJRUFBT2VBRGNBV1FCekFIY0Fld0NBQUlVQXFBRExBQUFCRVRRbUl5RWlCaFVSRkJZN0FSNEJGeDRCRng0Qk93RXlOajBCTXhVVUZqc0JGUlFXT3dFeU5qYytBVGMrQVRzQk1qWTlBVFFtSndVY0FSVWpMZ0VuSXlJbUp5NEJOUkUwTmpNaE1oWVZFUlFHRlJ3QkZRNEJJeUVGRkFZckFRNEJCeU04QVRVaklpWTlBVE15Tmpjek1oWWRBUUVoRlNFVk14VWpCU0VWSVRVMUlSVWhOVGN1QVRVME5qYytBVGMrQVRNeUZoY1dGQWNPQVFjT0FRY2VBUlVVQmlzQklpWW5JeTRCTlRRMk56NEJOejRCTXpJV0Z4WUdCdzRCQnc0QkJ4NEJGUlFHSXpFaUppY0RtbUJOL2I5TlgxOU5JZ29WQ2c4Z0R3c2NFQmtlS2lsRk9BZ3RIZzBRSFFvSUVRa0RCZ05JT0VnNEx2M3JHUjgvSGtRbE1na0NBall1QWtFdk5nRUVOU3YrbUFJekh4bHFFU0VSRUZBYUhMQTRSQVlSR1IvK05BRUEvd0RoNGY3Q0FhVCtYQUkrL2NLWUNRb0lCd2NYRGhRUUJRVUlBd1lDQVFVRkR4VUZFeG9iRXdFT0Z3cVNDZ2tIQ0FjV0R4TVJCQVVJQkFZQkFnRUVCUkFVQlJJYkd4UU9HQWtCcVFGT1RWcGFUZjU5VFdNSEhBd1RKQklNRENnZVNoSTNSd2dlTEE0TUNoVUxBd3RITjN3eFF3ZWRIMUlmSjBvZkpDQUlEd2tCaHpFdUxqSCtlUU1GQWdFQ0FTb3NXaG9jRnlRWEZ5d1BIQm83UFRRV0dud0NSeDVkSDlnZUhud2ZIMnNKRmcwT0dnc0xGQWtNQmdRREJ3c0VBZ01GQ3hNSEFSc1RFeHdKQ0FrV0RRNGFDd3NVQ1F3R0JBTUhDd1FDQXdVTEV3Y0JHeE1USEFrSUFBWUFBUC85QkFBRGd3QVRBQ2dBTlFCUEFGd0FZUUFBQVRRdUFpTWlEZ0lWRkI0Q016SStBZ2NpTGdJMU5ENENNekllQWhVVURnSWpOU0ltTlRRMk16SVdGUlFHSXdFMU5DWWpJU0lHSFFFaklnWVZFUlFXTXlFeU5qVVJOQ1lqSlRRMk15RXlGaDBCSVRBME5RRVJJUkVoQXU4bVFWY3hNVmRCSmlaQlZ6RXhWMEVtN3lwTE9DRWhPRXNxS2tzNElDQTRTeW8yVFUwMk5rMU5OZ0VQUGl6K3Rpdyt0eGdpSWhnRGpCZ2lJaGo5aWdZRkFVb0VBdjZsL3Y0RFpQeWNBWEl4VjBFbUprRlhNVEZYUVNZbVFWZWNJRGhMS2l0S09DRWhPRW9yS2tzNElFdE1OalpOVFRZMlRBSDNMQ3hFUkN3c0lSZjloaGNoSVJjQ2VoY2hRUVFKQkFWeVZSbjlJd0pPL2JJQUFBQUFCZ0FFLzhBRC9BUEFBRklBandDcEFMUUF6Z0RaQUFBQkp5NEJLd0U4QVRFMkppY3VBU01oSWdZSERnRVhNQlFWSXlJR0R3RU9BUjRCRng0QkZ6QVdGUjRCRlE0QkJ3NEJCd1lXRng0Qk15RXlOamMrQVNjdUFTY3VBU2MwTmpjd05qRStBVGMrQWlZbkFRNEJCekVPQVJVVUZoY3dGaGNlQVJjZUFURWhNRFkzUGdFM1BnRXhQZ0UxTkNZbk1TNEJKeTRDTmpVM015NEJNU0V3QmdjekZ4UVdEZ0VIRXlNaUJoVU9BUWNPQVFjR0ZoY2VBVE15TmpjK0FTY3VBU01IUGdFM1BnRTNNeFlHQnlVdUFTYzBKaXNCSWdZSEJoWVhIZ0V6TWpZM1BnRW5MZ0VuSnpNZUFSY2VBUmN1QVRjRC9BTURIeFJzQVFnSUNCUUwvYjRMRkFnSUNBRnNGQjhEQXdNQk1IWjBJVXdYQWdNRUR4d05MU0VDQlFRSENCZ05BVndOR0FnSEJBVUNJUzBOSEE4RUF3SVhUQ0p6ZGpBQkEvN0NKbGNRQ0FjSUJ3VUJEQm9PS1JyK3BCb3BEaG9NQVFVSENBY0lFVlluZG5Bb0J3T21BZ0lDUWdJQ3BnTUhLSEIzMDNjR0NnUVFEUVFMQmdFRUJBSUZBZ01GQTRZeEJBRUpCNDRCQXdJTUVBVllBaVpiL2hRTkVBUUtCbmNIQ1FFRU1ZWURCUU1DQlFJRUJBRUdDd1NaV1FRUURBSURBbHdtQWdNNkZSVVpDQVFMRkFnSUNBY0lDQllMQWdrWkZSWVFXWG1QUmpvOER3RUJFRE1PQ2hnTkxUb0dEUndNQ3c0T0N3d2NEQVk2TGcwWUNnMDBFUUVQUER0R2pucFpFUDV4U1RjTkJtb0tDaEVHQkFFSUZnNHBNVEVwRGhZSEFRVUdFUW9KYXdZTk4wbEdpVzVGQWhjaElTRWhGd0ZHYm9sR0FYWUpCMGRJS2c4a0ZnVUxBd0VCQWdKd1pUNEhDZWNHQ2dVb1IwRW5UbEFlS2toSEJ3a0pCejVsY0FJQ0FRRURDd1VXSkErblFVY29CUXNGVUU0bkFBQUZBRFAvd0FQTkE4QUFFQUFVQUJnQUhBQXFBQUFCSVNJR0ZSRVVGak1oTWpZMUVUUW1JeEVoRVNFQklSVWhOU0VWSVNVaEVUTTFNeFV6TlRNVk14RWpBNG44N2h3b0tCd0RFaHdvS0J6ODdnTVMvWEFDRHYzeUFnNzk4Z0dBL29BL28wK2VQNDREd0NnYy9JZ2NLQ2djQTNnY0tQeEVBM2o5RENxbEtwVUJWVVZGUlVYK3F3QUFCUUF6LzhBRHpRUEFBQkFBRkFBWUFCd0FZd0FBQVNFaUJoVVJGQll6SVRJMk5SRTBKaU1SSVJFaEFTRVZJVFVoRlNFQkZBWWpJaVluSXc0QkJ5SUdCdzRCQnc0Qkp5SW1JeUltTnpRMk56NEJOejRCSnk0Qkp5WWlJeUltTno0Qk56NEJNeDRCRng0QkZ4NEJGeDRCTnpBeU5UNEJNeklXRlFPSi9PNGNLQ2djQXhJY0tDZ2MvTzRERXYxd0FnNzk4Z0lPL2ZJQ0Rqa3BGeW9OQVIwNUhnVUpCQXNQQndzZEVoY3VGd3NRQVE0S0RCZ01IaEFOQmgwTER3a1BEZzhHQkF3SkVrOEhEQklIQlFvR0JBMEhDWElGQVF3dUd5azVBOEFvSFB5SUhDZ29IQU40SENqOFJBTjQvUXdxcFNvQmJpazZFaElDQWdJR0F3Z1ZDZzhOQVFFU0N3b1FBUUlHQmc4NkdRd1VBZ01YRFFnSkFRRURBUTBKQnhBSEJnY0RBd0lCQVJZZE9pa0FBQUFBQlFBei84QUR6UVBBQUJBQUZBQVlBQndBT3dBQUFTRWlCaFVSRkJZeklUSTJOUkUwSmlNUklSRWhBU0VWSVRVaEZTRUJGUlFHQnhVaE5TNEJQUUUwTmpzQlBBRTFORFk3QVRJV0hRRXpNaFlWQTRuODdod29LQndERWh3b0tCejg3Z01TL1hBQ0R2M3lBZzc5OGdIYUtoNysraDhxTUNJV0NRYXBCZ2tXSWpBRHdDZ2MvSWdjS0NnY0EzZ2NLUHhFQTNqOURDcWxLZ0dvc0NBdUJDc3JCQzRnc0NJd0J5TVdCZ2tKQmtBd0lnQUZBQlQvd0FQb0E4QUFMUUJFQUdBQWVRQ1NBQUFUSGdNek1qWTNQZ0UzSGdFZkFSNEJNekkyUHdFMkppOEJMZ0VuUGdFbkxnTWpJZ1lIRGdNWEJUYytBVE15Rmg4QkhnRVBBUTRCSXlJbUx3RXVBVGNCUGdFek1oNENGeFlHQnc0QkJ3NEJJeUl1QWljbVBnSTNCdzRCRng0Qk16STJOejRCTno0Qkp5NEJJeUlHQnc0QkJ4YytBVGMrQVRNeUZoY1dCZ2NPQVFjT0FTTWlKaWNtTmpjVUVrUllhamtlT3h3SERnWUJFQTM1RFNBUkZDUU5XUm9FSFBrTEhROFhBeFVUUTFscU9SNDZIVVZwUEFvWUFpaFpCQXdHQlFvRStRa0JDRmtFREFZRkNnVDVDUUVJL3NrWU1CZ3ZWMGszRHhRSEdocFdPQmN4R0M5WFNUY1BGQWt4VmpscUV3VU9HSFJJRXlVU0trSVVGQVVQRjNWSUV5UVNLMElVR1JFNkpnOGhFRDluRkEwRUVoRTZKUkFoRUQ5bUZRMEZFUUhaT0Z0Qkl3b0tBd1VERWlFTjZBd05FUTVsSGs4YTZBc01BajJCUHpkYlFTUUtDaGxpZjVGSXZXVUZCUVFFNkFrWkNXVUZCUVFFNkFrWkNRSlNDQWtlTlVzdE9uYzJOazhVQ0FrZE5rc3RPM2hvVVJTNEtsc3NSVllIQmc4OUtTcGJLMFpWQmdZUFBTa05KVFVOQmdWTFBTWlFKU1ExRFFZR1REMG1VQ1FBRUFBRS8rRUQvd09mQURvQWR3QjdBSUFBaEFDSUFJd0FrQUNVQUpnQW5RQ2lBS2NBckFDOEFNOEFBQUV1QVNNaEp5NEJMd0VxQVNNbkxnRWpJZ1lIQmhZWE1qQXhGeE1IRGdFVkZ4UVdGeDRCTXpJMk56TWVBVE15TmpjK0FUVTBKaWNUTmlZbkF5RUhJVElXRlJRR0t3RWVBUlVVQmlNaUpqVTBOamNqSGdFVkZBWWpJaVkxTkRZM0l5YzNBeWN1QVRjK0FUTXlGak1mQVJZeUZ6VWZBaUVERXlNVk15YzFNd2NqRnlNVk15YzFNd2NESXhVekp5TTFNeGNqRlRNbkl6VXpKelVqRnpNbkZTTW5Nd016TlNNWE55TW5NeFVITkRZek1oWVhIZ0VWRkFZaklpWTFJVFEyTno0Qk16SVdGeDRCRlJRR0l5SW1OUVAyQnhRTC9WY1JBeElNSFFFQkFWa0dEZ2NnTkFrTEppVUJLR0VoQWdFQkJBUURYMEk5V3dwQUNsczlRRjBIRmhzUkRtNENCQWVpL2Z3WEFoWU9FaElPRmdNRE95a3FPd1FEeUFNRU95b3BPd01ERGdFbmJrd05EQU1FRVFzQ0JRSUdWQUVCQWhJRUZnTEhaeGVpZ20xeUZWMWtlVnBGU1JWdnRyWVZpNHNWdHJZVmk0dkd4UittRllBVmxXcC9uaDlxV1JWdWZ4VU9CdzBGQlFVVUR3NFZBWVFGQlFVTkJ3Y01CUVVGRkE0UEZBTCtDUXBGREJNRENSb0NBaWNmSlVjTUMvNWtYQVFJQlRZSERRWkJXMDA2T2sxVlB3d3RHeFVsRFFIRkN4WUkvaHd3RkEwTkZBZ1NDU2s3T3lrSkVnZ0lFZ2twT3pzcENSSUlJMnNCMHhZRUZ3MExEUUVDR0FFQkFRWVNXLzVLQVhpREZWaFlPb01WV0ZnQkZvTVZXSktERlZnN2c0TnRXRmorNjRPREZWaFk5dzhVQlFVRkRRY09GQlFPQncwRkJRVUZCUVVOQnc0VUZBNEFBQUFJQUJNQU5RUGdBellBRFFBZEFDRUFTQUJWQUdnQWV3Q09BQUFsRkFZeElUQW1OVFEyTVNFd0ZnTWhJZ1lWRVJRV015RXlOalVSTmlZRElSRWhCeVlHTVE0Qkt3RWlKaWN1QVFjR0ZqRWVBVGMrQVRFK0FUc0JNaFlYSGdFWEZqWTNNRFluQnhVakZTTTFJelV6TlRNVk14Y2lKalUwTmpNeUZoVTRBVEVVQmlNNEFURTFJaVkxTkRZek1oWVZPQUV4RkFZak9BRXhGeUltTlRRMk16SVdGVGdCTVJRR0l6Z0JNUVBnSHZ4dkhoNERrUjVaL09RVEhSMFRBeHdVR3dFY0p2MElBdmpnSjFzRUN3VVZCZ3NFQlZVbkp3Z0RFeEVSTmdRSkJuMEZDZ1FETXhFUkV3SUlKc3NjSENFaEhCeDJDUXdNQ1FrTURBa0pEQXdKQ1F3TUNUVUpEQXdKQ1F3TUNWWVpDQWdaR0FnSUFzZ2VGUDNTRXhrWkV3SXVGQjc5dGdJRXIwQWxBd1FFQXdNaVAwQnhFUlVDQVR3REJRVURCRGdCQWhRUmNqOGlIaHdjSVJ3Y1F3d0pDUXdNQ1FrTU9nMElDUXdNQ1FnTkh3d0pDUXdNQ1FrTUFBUUFBQUFtQkFBRFdnQVRBQ1FBTUFBMEFBQWxJU0ltTlJFME5qTWhNaFlkQVNNMUlSRWhGUUVSRkFZckFTSW1OUkUwTmpzQk1oWVZBelFtSXlJR0ZSUVdNekkyRXlFUklRSnEvY3NXSHg4V0EwUVdIMGo4NGdJaUFaWWZGdUFXSnljVzRCWWZqdzRKQ2c0T0Nna09adjhBQVFDc0hoVUNSeFVmSHhWMFlQM2hSd0dQL2lRVkpDUVZBZHdWSGg0Vi9qRUtEZzRLQ1E0T0FlTCtYQUFBQUFBSkFBRC80UVA2QTU4QVRRQlNBSVVBa2dDZUFLb0F0Z0M2QU1jQUFBRXVBU01pQmdjdUFTY3VBU01pSmljMU5DWXJBU0lHRlJFVUZqc0JNalkxRVI0Qk16SVdGeDRCRnk0Qkl6RWlCZ2NPQWhZWEhnRXpPZ0UzTWpZM014NEJGem9CTXpJMk56NEJMZ0VuQVNNUk14RWxEZ0VqS2dFakxnRXhMZ0VyQVNJR0J6QUdCeW9CSXlJbUp6QW1OejRCTXpJV01SNEJPd0V5Tmpjd05qTXlGaGNXQmpFbE14VWpGU00xSXpVek5UTVZCUlFHSXlJbU5UUTJNeklXSnhRR0l5SW1OVFEyTXpJV0ZSUUdJeUltTlRRMk16SVdBVE1SSXdNME5qTXlGaFVVQmlNaUpqVUR5QnRNTFNJM0RnSVdIaFEySVZocUZpTVc2UlljSEJicEZpTWdhMDBiS1JBWEV3SU9PQ010VEJzZEdBVUhBZ2M2S2dJRkF3bytPbzA2UGdvREJRSXFPZ2dCQndVWUhmMUV4TVFDc1FRV0ZRRUNBaGRKQkE4SHB3Y1BCRWtYQVFNQkZSWUVDalFXTWhjaExnVVFCaDBHRUFVdklCY3pGVFFLL3NZREp5NG5KeTRCSmhFTERCRVJEQXNSUnhFTERCRVJEQXNSRVFzTUVSRU1DeEg5WFI0ZUxTRVhHQ0VoR0JjaEFXVXNMeFVKSDFVaUZoZGpKb0VWR3hzVi9LWVdIaDRXQXFJcFNCRVNHa29lQ1JzeExEQmZUamNITGpZQkdrTkRHZ0UyTFFjMlQxNHYvc1FETHZ6U0xoVWJBbEFGQndjRlVBSWJGWmxWSkJvYkJBWUdCQnNhSkZXWnhDNG1KaTRuSnhrTUVSRU1EQkFRSGd3UkVRd01FQkJiQ3hFUkN3d1JFUUZzL2dnQ2VSZ2hJUmdYSVNFWEFBQUFBQXNBT3YvQUE4WUR3QUFQQUI4QUxBQTRBRVVBVWdCdkFKQUFsQUNaQUtrQUFBRW1CZ2NHSmljbU5qYytBUmNXQmdjaE5oWVhGalkzTmlZbkxnRUhCaFlYRnhRR0l5SW1OVFEyTXpJV0ZTYzBKaU1pQmhVVUZqTXlOaGNVQmlNaUpqVTBOak15RmhVbk5DWWpJZ1lWRkJZek1qWTFCdzRCSXprQklpWW5MZ0UxTVRZV0Z4NEJNekkyTno0QkZ6TVVCZ2NCRVJRR0J4VWhOUzRCTlJFMFBnSTdBVFUwTmpNaE1oWWRBVE15SGdJVkpTRTFJUUVoRlNFMUV6UW1JeUVpQmhVUkZCWXpJVEkyTlFMUkVIZ05Bd3NDQWdFRUVYOFVBUUVDL2w0UWVBMERDd0lDQVFRUWZ4VUJBUUtWR1JJU0dSa1NFaGtZQ3dnSUN3c0lDQXZtR1JJU0dSa1NFaGtZQ3dnSUN3c0lDQXNmRHpJYUdqTU9Dd1VDQmd3TU1Sb2FNUXdMQndFQkJRc0JhMWRCL2FSQlZ4ODJTQ29USWhrQlloa2lGQ2xJTmgvOWtnRlEvckFCay80cUFkYWFUamI5L2paT1RqWUNBalpPQWZZZEV3b0NCd01FQ0FJTUVTY0RCd0lkRXdvQ0J3TUVDQUlNRVNjREJ3SkpGQndjRkJNY0hCTVNCd3NMQndnS0Nnb1VIQndVRXh3Y0V4SUhDd3NIQ0FvS0NMb0tDd3NLQ0JBQkFnRUdCZ29LQmdZQkFnRVFDQUZQL28xR2F4QmdZQkJyUmdGektVazJIMm9aSWlJWmFoODJTU21tZ3Z5K09Ua0NHemROVFRmK2l6Wk9UallBQUFzQVZmL2VBNnNEb2dBY0FDSUFLQUE1QUVZQVVnQmZBR3NBZXdDTEFLSUFBQUVqTlRRbUl5RWlCaDBCSXlJR0ZSRVVGaGNWSVRVK0FUVVJOQ1lqSVRVaEZTRTFBUlVoTlNFVk54UUdJeUVpSmpVUk5EWXpJVElXRlJFbElnWVZGQll6TWpZMU5DWWpGU0ltTlRRMk16SVdGUlFHTnlJR0ZSUVdNekkyTlRRbUl4VWlKalUwTmpNeUZoVVVCaWNHSmhjbU5qVXhNRFkzTVI0QkJ6RTNKalkzTVI0Qk9RRVVGZ2MyQmljeEJ6NEJGekV5RmhjV0ZBY0dKaWNpQmdjT0FUVStBVGNDOEJJaEZ2NnlGaUVTVFc1U1BRSTRQVkp1VGY1eUFUeit4QUY2L2tnQnVJOUlNLzRnTTBoSU13SGdNMGorTlJFWEZ4RVFHQmdRQ0FvS0NBY0tDcmtRR0JnUUVSY1hFUWNLQ2djSUNncWhUendCQVFHUkRBVUdIbjRkQmdVTWtBRUJBVHhQZkFZdEZ4QWlCd2NEQXhraElSMEdCZzRDQmdZREIyTVhJU0VYWTI1Ti9xTkRaQTliV3c5a1F3RmRUVzViZXlEOUxCVTFJTHd6U1VrekFWMHlTVWt5L3FQc0doSVRHaG9URWhvc0NnY0hDZ29IQndvc0doSVRHaG9URWhvc0NnY0hDZ29IQndvK0VCRUNBZ1lDQ0J3QkpRY0JCeVlCSFFzQ0JnRUJFQkxaQmcwQkNRNE5CQUlDRXdFUEF3SUJBZ1VPQmdBQUFCQUFPdi9BQThZRHdBQWdBQ1VBS3dBOEFFd0FYQUJwQUhVQWdnQ09BSzBBOWdFQ0FSSUJJZ0V1QUFBQkl6VTBKaU1oSWdZZEFTTWlEZ0lWRVJRV0Z4VWhOVDRCTlJFMExnSWpJVFVoRlNFQkZTRTFJUlUzRkFZaklTSW1OUkUwTmpNaE1oWVZFUUUyRmhjZUFRY09BU2N1QVFjdUFUY0ZKZ1lIQmlZbkpqWTNQZ0VYRmdZSEJTSUdGUlFXTXpJMk5UUW1JeFVpSmpVME5qTXlGaFVVQmpjaUJoVVVGak15TmpVMEppTVZJaVkxTkRZek1oWVZGQVlITVNZR0J3NEJJeUltSnk0QkJ6RUdGaGNlQVRNNUF6STJOejRCSnpjaU1DTXdKZ2N3QmlNaUpqRW1CakVpQmlNbkZSY2VBVEV5RmhjZUFSY2VBUmNlQVRjK0FUYytBVGMrQVRNeUZoY2VBUmNlQVJjV05qYytBVGMrQVRjK0FUTXdOajhCTlFjRklpWTFORFl6SGdFVkZBWVhEZ0VIRGdFbkxnRXhOaklYSGdFSEZ3WW1KeTRCSnlZMk56WXlGekFHQnpjR0pqVTBOamN5RmhVVUJnTC9FeUlaL3A0WkloTXFTRFlmVjBFQ1hFRlhIelpJS3Y1WkFWRCtzQUdTL2l3QjFKbE5OLzRDTjB4TU53SC9OazM5cXhSL0VRTUJBZ0VNQXcxM0VRRUJBUUdqRVhjTkF3c0NBZ0VERVg4VUFRRUIvc2dTR1JrU0Voa1pFZ2dMQ3dnSUN3dkdFaGtaRWhJWkdSSUlDd3NJQ0FzTEJRRUhEQXN4R2hveEN3d0hBUUVGQ3c4ekdSb3lEd3NGQWFZQkFaeG1DUU1EQ1dhY0FRSUJjVzhCQWdrSEFRSU5CUVVTRXhNcEVSRW1DZ29ZQXdRSEJBUUhCQU1ZQ2dvbUVSRXBFeE1TQlFVTkFnRUhDUUlCYjNQOThnWUhDQVVHQndqTkRpQUtDalloSVFRRFRna0xZd3J4SVRZS0NpQU9DbU1MQ1U0RUJTRTZCZ2dIQmdVSUJ3TWJhaGtpSWhscUh6WklLdjZOUm1zUVlHQVFhMFlCY3lwSU5oOWhndjBoRnpraXhqWk5UVFlCY3pkTVREZitqUUV6S0JFTkFnZ0RCQVlDQ1JRZEFnWURDeDBVQ1FJR0JBTUlBZzBSS0FNR0FpMGJGQlFiR3hRVUd5OExCd2NMQ3djSEN5OGJGQlFiR3hRVUd5OExCd2NMQ3djSEM0NENBZ1lGQ2dvRkJnSUNBUkFJQ2dzTENnZ1FBZU1JSUFNRElBZ0JIU3NaQWdFUkNBYzBEUTBTQlFVREFRSVZFQTh4Q0FnREF3Z0lNUThRRlFJQkF3VUZFZzBOTkFjSUVRRUJHaXNjR2dNQ0FRSUJBd0VDQWk0MklBUUVBd29MYUI0QkFSTWxWd29EQkFRZ05pVVRBUUVlYUF1R0FRSUNBUU1CQWdFQ0F3QUFBQWtBT3YvQUE4WUR3QUFnQUNVQUt3QThBSThBc1FDK0FPQUE3UUFBQVNNMU5DWWpJU0lHSFFFaklnNENGUkVVRmhjVklUVStBVFVSTkM0Q0l5RTFJUlVoQVJVaE5TRVZOeFFHSXlFaUpqVVJORFl6SVRJV0ZSRWxCaVlIRGdFbkxnRTNORFl4UGdFM1BnRVhGZ1lQQVNjd0ppY21CZ2NHRmhjV05qYzJGaGNlQVRNeU5qYytBUmNlQVRjK0FTY3VBUWNPQVRFSEp5NEJOellXRng0QkZ6QVVGUllHQndZbUp5WUdKeE1tQmdjT0FTY2lCaGNlQVRNV05qY09BUlVVRmpNeU5qVTBKaWMrQVJjK0FTY0hGQVlqSWlZMU5EWXpNaFlWSndZbUp5NEJCd1lXRnpZV0Z3NEJGUlFXTXpJMk5UUW1KeDRCTnpJMk56WW1Jd2NpSmpVME5qTXlGaFVVQmlNREFCUWlHZjZlR1NJVEtrZzJIMWRCQWx4QlZ4ODJTQ24rV0FGUS9yQUJrdjRzQWRTWlRUYitBVGRNVERjQi96Wk4vbjQzVVJzWEpCNGZFQVFCQXhRU0ZSb0ZCUUlDQWdJTUNBTWFCQVFKREJwQUhRNGVDd1lnR3hvaEJnc2REaDFCR1EwSUJBVVpCQWdMQWdJQ0FnUUZHaFVTRlFRRkR4OGRKUmNiVURmRkN6b2NGUmtUQXdNQkFnb0dBZ3dJQlFVWkVoRWFGQThhTXdnQ0F3Uk1Dd2NJQ3dzSUJ3dWRFaGtWSFRrTEJBTUNDRE1hRHhRYUVSSVpCUVVJREFJR0NnSUJBd1JEQ0FzTENBZ0xDd2dERzJvWklpSVphaDgyU0NyK2pVWnJFR0JnRUd0R0FYTXFTRFlmWVlMOUlSYzRJY1kyVFUwMkFYTTNURXczL28wTUdSc0dCQWtNREQ4ZkFRSVJIUXdQQndjSEZ3Z09BeFVEQVJJUUN4Z01HRFVHQXdZQkFSY1lBUUlHQXdVMEdBd1lEQThTQVFNVkJBNEpGd1lJQnc0TUhSRUNBUjgrRGd3SUJBVWNHQUVYRmhVUkRRWUJDd1FGQmdFQkFRWVBDUlFiR3hRUkdnTVFIU0VERXdsSENBb0tDQWNMQ3djbEFRWU5FUlVXQ1JNRElSMFFBeG9SRkJzYkZBa1BCZ0VCQVFZRkJBczNDZ2dIQ3dzSENBb0FBQUFNQURyL3dBUEdBOEFBSUFBbEFDc0FQQUJJQUZRQVlBQnNBSHdBakFEckFTc0FBQUVqTlRRbUl5RWlCaDBCSXlJT0FoVVJGQllYRlNFMVBnRTFFVFF1QWlNaE5TRVZJUUVWSVRVaEZUY1VCaU1oSWlZMUVUUTJNeUV5RmhVUkpTSUdGUlFXTXpJMk5UUW1CeUltTlRRMk16SVdGUlFHTnlJR0ZSUVdNekkyTlRRbUJ5SW1OVFEyTXpJV0ZSUUdKVDRCRng0QkJ3NEJKeVlHQnk0Qk55VXVBUWNHSmljbU5qYzJGaGNXQmdjWExnRWpMZ0VuSmdZWEhnRVhEZ0VIRGdFaktnRWpMZ0VuTUNJeEp6NEJOelltQnc0QkJ5b0JCdzRCRlJ3QkZSNEJGeFkyTnpJbU5USVdNeDRCRng0QkZ4NEJNekkyTno0Qk56NEJOejRCTnhRR0Z4UVdOejRCTnp3Qk5UUW1Kd2NPQVNNaUppY3VBU2MwTmpjV05qY3FBU011QVNjdUFUVWVBUmNXTWpNeU5qY3lOak1jQVFjVUJnY1VCZ2NPQVFjT0FRY3FBU01lQVRjZUFSY09BUWNEQUJRaUdmNmVHU0lUS2tnMkgxZEJBbHhCVng4MlNDbitXQUZRL3JBQmt2NHNBZFNaVFRiK0FUZE1URGNCL3paTi9oZ1JHUmtSRWhnWUVnY0xDd2NJQ3d2Q0VoZ1lFaEVaR1JFSUN3c0lDQW9LL3RnTGRCRUVBZ0VCQ1FNTmJnb0NBZ0VCZEF4dURRTUpBZ0VEQXhGMERRRUNBUmtDQXdJSEV3Y0NDQVVDQndNSkZBc1lOaDBEQmdJeFdTSUJCZ01GQVFZSUF3Y1RCZ0lFQWdJQ0FRb0pBZ0lCQVFJQkJnTUJBZ0VDQ2hJVVZDY3VSeEVQREFRQ0FnSUNCUUlDQVFNQkNnb0JBZ05NRDBNcExVZ05BZ1FCQkFJVkp4QUNCZ01aTVFZR0FSdEtKd29WQ2hvMUdRUUpCQUVCQVFFQkFRSUNCQ29YQWdJQkRDSVJBZ0lCQWdVREF4dHFHU0lpR1dvZk5rZ3EvbzFHYXhCZ1lCQnJSZ0Z6S2tnMkgyR0MvU0VYT0NIR05rMU5OZ0Z6TjB4TU4vNk4raHNVRXhzYkV4UWJMd3NIQndzTEJ3Y0xMeHNVRXhzYkV4UWJMd3NIQndzTEJ3Y0xPeXdaQ1FFSUF3UUpBZ2NWSWdFR0JCUWlEd1lDQ0FRRUJ3SUlFeXdEQmdLeUFRRUJBd1VDQ1FZREJBRURCQUlFQXdFTUJ3SUJBd0VHQ2dJRUFnRUJBUU1DQVFJQkF4VUZBUUVCQmdRQ0J3NEhHQzhRRUE0T0RRc3RHd2NQQndFQkFRUUdBUUVCQVFRVkF3RUNBUUVFQVgwTERRNE1BUVFDQ0FrQ0FRRURBZ2tMQ3hvR0Jna0JBUVFGQWdFRUFnTUhBd01GQWdRSEF3Y0lBUUlDQVFJSEJBVUhBZ0FBQUFBTkFEci93QVBHQThBQUlBQWxBQ3NBUEFCSkFGVUFlZ0NIQUowQXBBREhBUVFCT3dBQUFTTTFOQ1lqSVNJR0hRRWpJZzRDRlJFVUZoY1ZJVFUrQVRVUk5DNENJeUUxSVJVaEFSVWhOU0VWTnhRR0l5RWlKalVSTkRZeklUSVdGUkVsSWdZVkZCWXpNalkxTkNZakZTSW1OVFEyTXpJV0ZSUUdKU1lHQnc0QkJ3NEJGeDRCTnpJMk53NEJGUlFXTXpJMk5UUW1KejRCTno0QkZ6NEJKd2NVQmlNaUpqVTBOak15RmhVbkZBWW5MZ0VuTGdFSEpqUTNOaFlYSGdFWEhnRUhBejRCTVRBV055VU9BUWNpSmljbUZoY1VCaFVxQVRFVkZBWVhIZ0VYSGdFK0FUYzJKaWN4UGdFSEJ6b0JNeDRCRlRBMk56NEJOeDRCTVRBMk56NEJOeFlVTVRBMk56NEJOeklXRnh3QkZRNEJJeUltSnp3Qk5UNEJOeDRCRng0Qk1UQW1Oem9CTXdjbU5ERXdCZ2NpSmpVbU5EY2VBVE15TmpjVUZoVVdCZ2NPQVFjdUFURXdGQWNPQVNNdUFURXdGQWNHSWlNdUFURVVCZ2NxQVNNREFCUWlHZjZlR1NJVEtrZzJIMWRCQWx4QlZ4ODJTQ24rV0FGUS9yQUJrdjRzQWRTWlRUYitBVGRNVERjQi96Wk4vaFlSR1JrUkVoa1pFZ2NMQ3djSUN3c0JMd3M3SFJZWkV3UURBUUlMQlFJSUJRVUZHUkVTR1JVUEFRTUJIRGdKQWdNRVZ3c0lCd3dNQndnTG9nc0dCaVFXR2k4TkFRVU5NQm9XR2hNRUJnRjlCUWNGQ3dFOE5vQXpIaWtaRWdVSkF3SUlBd0lCQ3dJS1luQmVCUXdDQWhBTEZla0ZEUVlDQlFVRURCZ01CQUVGQkEwWkRRWUhCUWdQQ0FRRkFUUjVNeFVsRGdFREF3a1RDd1FHQVFRR0RBY29BUVFERkJvRUFROHJHekYwTkFFQkJBTUdHQkFEQlFRTUhBNERCUVVNR1F3RUF3UUNEaHNNQXh0cUdTSWlHV29mTmtncS9vMUdheEJnWUJCclJnRnpLa2cySDJHQy9TRVhPQ0hHTmsxTk5nRnpOMHhNTi82Tit4d1RGQnNiRkJNY0x3b0lCd3NMQndnS2V4RXBHQkVEQlFFTUF3UURBZ0VCQnc4SkZCc2JGQkVhQXdFQ0FSVTFIUU1TQjJrSUNnb0lCd3NMQnl3RkJRRUJDUkFTSXhrRER3WU9GaElQQ1FNQkN3VCswQUllSEFHTkdCTUJCQVFFREFZS0hRTURBU1FNQmdRQkFnSUVDZ29VU2hFTEZnay9Bd29JRUFZQkFnSUdFQkVIQWdRREJSSVZCZ0lGQWdnRUJ4QUhEZ2tCQVFVTEJnTUpBd0VDQVFZUER3WlFCZ3NLQmdNQkJoSUdBUUlJREFNSkJRVUpBZ1FGQWdjT0VRVUNBZ2NPRVFVQkJnd0dDUVFBQUFBQURBQTYvOEFEeGdQQUFDQUFKUUFyQUR3QVNRQlZBR0lBYmdDRUFKb0F2UURxQUFBQkl6VTBKaU1oSWdZZEFTTWlEZ0lWRVJRV0Z4VWhOVDRCTlJFMExnSWpJVFVoRlNFQkZTRTFJUlUzRkFZaklTSW1OUkUwTmpNaE1oWVZFU1VpQmhVVUZqTXlOalUwSmlNVklpWTFORFl6TWhZVkZBWTNJZ1lWRkJZek1qWTFOQ1lqRlNJbU5UUTJNeklXRlJRR0p3NEJJeUltSnk0QkJ5NEJOellXRng0QkZ6SVdCemMrQVRjK0FSY1dCZ2NtQmdjT0FTTWlKaWNtTmpNZkFRNEJJeUltSnpjbUJqRTNIQUV4RkJZWEhnRVZQZ0UzUGdFMU1EUTFGekFtQnhjVUJnY1VOZ2NPQVFjT0FURXdKaWN1QVNjMEZqVXVBVFV1QVRVZUFUTXhPZ0V6T2dFek1USTJOeFFHQndNQUZDSVovcDRaSWhNcVNEWWZWMEVDWEVGWEh6WklLZjVZQVZEK3NBR1MvaXdCMUpsTk52NEJOMHhNTndIL05rMytGeElaR1JJUkdSa1JDQXNMQ0FjTEM4VVJHUmtSRWhrWkVnY0xDd2NJQ3d1UkFnb0ZCU0FVSERVSkFnRUJDem9jRlNRSkF3SUNTUWtrRlJ3NkN3RUJBZ2sxR3hRaEJRVUtBZ0lDQTA4SERFWXFLa1lNQnhrRkJnb2FHRkVCVUJnYUNnWUZHUU1mQVJzQkF3Y0dFbEJRRWdZSEF4b0JId0VCRUVBbUFRSUJBUUlCSmtBUUFRRURHMm9aSWlJWmFoODJTQ3IralVackVHQmdFR3RHQVhNcVNEWWZZWUw5SVJjNEljWTJUVTAyQVhNM1RFdzMvbzM2R3hRVUd4c1VGQnN2Q3djSEN3c0hCd3N2R3hRVUd4c1VGQnN2Q3djSEN3c0hCd3RJQXdZRUJnZ1FEUUlIQXhVR0NnZ0hBUWtFRFFFSENBb0dGUU1IQWcwUUNBWUVCZ01FQ2NNR0F3a0pBd1lESGdVQkFRODFEQWtDQVFFQ0NRdzFEd0VCQlI0RE1RWUhBZ1VEQWdnSEF3Y0RBd2NEQndnQ0F3VUNCd1lHREFRQ0NRa0NCQXdHQUFBQUFBd0FPdi9BQThZRHdBQWdBQ1VBS3dBOEFFZ0FWQUJnQUd3QWZBQ01BTW9BNWdBQUFTTTFOQ1lqSVNJR0hRRWpJZzRDRlJFVUZoY1ZJVFUrQVRVUk5DNENJeUUxSVJVaEFSVWhOU0VWTnhRR0l5RWlKalVSTkRZeklUSVdGUkVsSWdZVkZCWXpNalkxTkNZSElpWTFORFl6TWhZVkZBWTNJZ1lWRkJZek1qWTFOQ1lISWlZMU5EWXpNaFlWRkFZbFBnRVhIZ0VIRGdFbkpnWUhMZ0UzSlM0QkJ3WW1KeVkyTnpZV0Z4WUdCeGN1QVNjK0FUY3lGQlVlQVRjK0FUVXVBUWNpQmhjZUFSY09BUWNPQVFjR0ppY2lCZ2NHRmhjZUFUY3pQZ0UzSGdFWEhnRXpNalkzUGdFM05qUW5CdzRCQndZbUp5NEJKejRCTng0QkZ6UW1KejRCTng0QkZ4WVVCd01BRkNJWi9wNFpJaE1xU0RZZlYwRUNYRUZYSHpaSUtmNVlBVkQrc0FHUy9pd0IxSmxOTnY0Qk4weE1Od0gvTmszK0ZoRVpHUkVTR1JrU0J3c0xCd2dMQzhZU0dSa1NFUm9hRVFnTEN3Z0lDd3orMHhKdkR3TUNBZ0lLQXd4cERnRUJBUUZ5Q21zTUF3a0JBUU1ERUhFTEFRSUNUUWdqR1FZTEJBRUJCZ1FFQlFNWUVRSUJBZ1FIQXdvdUV4azNFeEliQ3djTUFRSUtCZ1lpRGdFU0l4RU1FUWdMR2hVRkN3VVJIQWNIQnhJR0ZRMFVGZzRIRHdvRkVnc01IUThkREFNTEJ4WWVCd1FGQXh0cUdTSWlHV29mTmtncS9vMUdheEJnWUJCclJnRnpLa2cySDJHQy9TRVhPQ0hHTmsxTk5nRnpOMHhNTi82Tit4d1RGQndjRkJNY0x3b0lCd3NMQndnS0x4d1RGQndjRkJNY0x3b0lCd3NMQndnS1FDd1RDQUVJQXdRSkFRWVBJUUVHQkJFa0RnZ0NDUVFFQ0FJS0VpOEVCZ0xkRWhVSUNBNEhBZ0VFQlFFQkJnUVJDZ0VFQVFFRUF3NHJEaEVaQWdJQ0FRRURCZ1FDQWdnQ0Fnb0lDQmNNRUJ3QkF3WWJFaEFnRFRVUEZRVUhFeFVLRlFnR0N3RUNEZzhWRkFNRkRnRUhFUTRKRnd3QUFBQUFFZ0FBLzhBRUFBUEFBRVFBVVFCZkFHTUFad0I0QUlNQWtBQ2RBS2tBdGdEREFOQUEzQURwQVBVQkN3RVBBQUFCSXlJR0hRRU9BUWNPQVIwQkZCWVhIZ0VYRlJRV093RVVCakVoTURRMU16STJQUUUrQVRjK0FUYytBVDBCTkNZbkxnRW5MZ0VuTlRRbUt3RTFOQ1lqSVNJR0hRRURJeUltTlR3Qk5UUTJPd0VWQVRJV0ZSd0JGU0U4QVRVME5qTURGU00xQVNFMUlSTVJGQVlqSVNJbU5SRTBOak1oTWhZVkV4UUdLd0UxTXpJV0hRRTNGQVlyQVRVek1oWVZIQUVWSlRRbUl5SUdGUlFXTXpJMk5RY2lKalUwTmpNeUZoVVVCaVVpQmhVVUZqTXlOalUwSmlNVklpWTFORFl6TWhZVkZBWWpOU0lHRlJRV016STJOVFFtSXhVaUpqVTBOak15RmhVVUJpVWlCaFVVRmpNeU5qVTBKaU1WSWlZMU5EWXpNaFlWRkFZRkl5SUdCdzRCSHdFZUFUc0JNalkvQVRZMEp5NEJCeU1uTXdFWFpDdzREeFFGRWhVWUZnVVJDemdzREFFQ2hBd3NPQVVJQkFZR0F4a1ZFaFlDQ1FnRkNRVTZLbVFwUGY3ekp6bTdEUWNEQXdjTkFpd01EUDdBREFqcklnS1UvZ3NCOVhFTEMvMVZDd3dNQ3dLckN3c3VBd2tXRndnRElnUUhEQXdIQlA0YlJqRXhSa1l4TVVaM0t6MDlLeXM5UFFFV01VWkdNVEZHUmpFclBUMHJLejA5S3lJeE1TSWlNVEVpQ1EwTkNRa05EZjYySWpFeElpSXdNQ0lKRGc0SkNRME5BUXJuQXdVQ0FnRUJGZ0VHQkwwRUJnRVZBUUlDQlNHckRNTURPVGtzY0FnWUVBd25HWWdjS2dvTEVBWmtMVGtaVEVRaE9TMWpBZ2NEQmdzRkRDMFhoeGNxRFFnUkNBVUhBMjhxT3kwWlFUUW1MZjRhQXdjaVNDRUlCS0VDS0FrSUJqOGRIRUlFQlF6K3AvTHkvZU5GQWUvK1N3MEtDZzBDU2cwS0RnbitiZ2tEOGdNSjJpSUlBNkVEQ1NGSElwWXlSVVV5TVVaR01XZzlLeXM5UFNzclBkOUZNakZGUlRFeVJkNDhLeXM5UFNzclBMb3dJeUl3TUNJak1FY01DUWtORFFrSkRFY3dJeUl3TUNJak1FY01DUWtORFFrSkRQQUNBd0lHQXpnRUJBUUVPUU1GQWdNQ09TSUFEZ0FJQUFzRCtBTjFBRWNBVndCakFIa0FpUUNWQUtzQTZRRUxBUnNCSlFGUEFWOEJnUUFBQVJZR0J3NEJJd1ltSnk0Qkp3NEJCdzRCSnlJbUp5NEJOejRCRnpJV0Z4NEJNejRCTnljdUFUVTBOamMrQVRNd01qRTZBVE15RmhVVUJnOEJIZ0VYTWpZM1BnRXpOaFlYTndZbUp5NEJKelEyTnpZV0Z4NEJCeWN5TmpVMEppTWlCaFVVRmpjMEppTWlCZ2MrQVRNeUZoVVVCZ2N5RmpNeU5pY0ZEZ0VuSmpZM1BnRVhIZ0VWRGdFSEp6UW1JeUlHRlJRV016STJOeTRCSXlJR0ZRWVdNekkyTXk0Qk5UUTJNeklXRndVdUFTY3VBVGMrQVRNeUZoY2VBUmMrQVRjK0FUTXlGaGMrQVRjK0FUTXlGaGNXQmdjT0FROEJEZ01IRGdFSEZTRTFMZ0VuTGdFbkxnRXZBVGNlQVJjK0FUY2lKaWN1QVRjK0FSY2VBUmMrQVRjdUFTY3VBU01pQmdjR0ZoYzNQZ0UzTGdFbklnWUhCaFlYSGdFM0FUQTBOU2NISEFFeElSTXVBeWN1QVNNeElnWUhEZ0VIT0FFeERnTUhIZ01YSGdFWE54YytBVGMrQXpjM1BnRW5MZ0VqSWdZSEhnRVhNalkzTnk0Qkl5SUdCdzRCQng0QkZ6NEJNellXRnhZR0J3NEJJeDRCRno0Qk56NEJKd0puQXdRR0JCSUtBd2NEQ1IwS0N4MEpBd1lFQ2hFRkJRUUNBUVFEQWdZREJBc0hFQ0FEQVNVb0VBMExIeEFCQVFFQklqa3RLUUVESVE4SERBTURCZ01DQkFHS0p6d2NIUThCRVRBbVFROE9EU1psQ1FzTENRZ0xDME1kRlEwVkJ3WVJDUk1hR0JJQ0JBRVZIUUgremh3OEp5Y09EUkJCSmpBUkFROGRCd3dJQ0FzTENBZ01EQVlXRFJRZEFSMFZBUVFCRVJnYUVnb1FCdjduRFRJV0ZoOFJEMUk0Q2hRTENoUUlFQ2daSjJBNFdvd3FDQlFLQ3hRS09GSVBFUjhXRmpJTkNBWVlIU0VPRFNJUC9sRUhEZ2dKTFJ3T0ZRVUlJQU1GQWdNR0JBb1VDQTBIQndZWUR3Y1BCd1VOQndzYUVBWU5CeG93REJabURod0NCZ01FRFFZSkRBUUVBd2NIRVFjQjE1Q2tBVFNrQVFvVUhoWWdkazh4VkNFYUp3d1JHUkVKQWdVV0d4ME1GQ01GcHBnTkpnc0lHUnNZQmlnSUJBUUREQWtHRGdVREJnSUhFUVpkRERBYUJ3MEdFUnNMQ0EwR0J4QUlEeGNHQmdjT0NCUUtCQVlDQWdZRURtWVdBVWNGQ3dZR0NBRUJBUU1RRFEwUUF3RUJBUWdHQmdzRkF3TUJCUVlJQmdFV0JpZ0hQZzBJRFFRRkJSUVBEa0VES0FZV0FRWUlCZ1VCQXdPSUR5WVJFQmdTQ3pzT0RDSVZGbVlQVVFzSENBc0xDQWNMQlJZZkRRd0hDUjBVRkJ3QkFTQVhMaEVtRHc5bUZoVWlEQTQ3Q3hJWUVEc0lDd3NJQndzTEZnd05IeFlYSUFFQkhCUVVIUWtIZ0FZZEdobFVQVHhEQWdNQ0F3SVJHd3NSRWk0c0FnTUNBd0pEUEQxVUdSb2RCZ1FxV2xBK0R3MFhCbWR5QXcwR0JqRk9KMVVwQkQ0Q0F3RVFKaFVIQmdvY0R3OFFBUUVGQkJFZ0RnRUZCQUVDSUN0U1FnaGFDeFlMQkFVQkNBa0pEZ1VGQlFIOThpd1ZBd1FWS3dHQURFbFpXQnNqSmc4UEN4NFRHMHhMUWhFdFdVczBDQTBQQWdrSUJBNExDREpIVlN5UUJSQUpDUWtIQlFzWEN3UUZRQ3NnQWdFRUJRRVBJeElGQmdFUkR4QWRDZ1lIRXlRUEFnUUNDRUpTQUFBQUZnQUMvOWNEL0FPcEFEd0FYd0NuQUxnQTJRRHFBUDBCQkFFUEFSOEJMd0U3QVVnQldBRm5BWFFCZ0FHTkFaa0I0d0lGQWhnQUFBRXVBU2MxTmlZdkFTNEJJeW9CSXk0Qkp6VXVBU014S2dFUEFRNEJCdzRCRnhRV0ZRNEJId0VlQVI4Q054NEJGdzhCQlQ4QlBnRS9BVFltSndNR0lpTWlKaWNsTGdFbkxnRS9BVDRCTXpJV0Z3VWVBUmNlQVE4Qk1BWVZEZ0VISlFZbUx3RThBVFUrQVRjK0FUY2xOaFlmQVNvQkl5SUdEd0V1QVNNaUJnY09BUWNPQVE4QkJpSW5JaVlqRGdFSEJoWVhIZ0V6TWpZM1BnRTNQZ0UvQVRZV0Z4NEJNdzhCTnpBbUJ3NEJNVDRCTnpZV0Z6RXlGakVuRGdFeExnRTFQZ0U3QVRJV014WXlQd0UrQVRjK0FUYzJGaGNjQVFjd0JnY2xNaFl6Rng0QkR3RW5OVDRCTno0Qk15VStBVDhCTWpZek1oWWZBUVV1QVNjbU5qY1RKekUzQnpFSEZ6Y2VBUmNGT0FFeEJ5VUJJaVkxUGdFM05qSVhIZ0VIRGdFSE55WTJOejRCRng0Qk54WUdCd1ltSnhjV0ppY21CZ2NpTmpjMkZnY21OaGNlQVFjR0pnY09BVFVGRmdZakxnRUhJaVkxTkRZM05oWVhKeTRCTnpZeUZ4NEJCdzRCSnk0QkZ3WVdGeFkyTnpZbUp5WUdCemNPQVNjdUFUYytBUmNlQVJjV05qYzJKaWNtQmdjR0ZoYzNIZ0VIRGdFbkxnRTNQZ0VYSWdZWEhnRVhEZ0VIQmlZbk9BRXhPQUV4TGdFbkxnRW5QZ0UzTWpRbkpnWUhCaFlYRmpZM01EWTNIZ0VYRkFZSERnRVhIZ0VmQVJZMk56NEJOeFFXRlJRV016STJOVFltSndjdUFTYzRBUlV1QVNjd0pqRXVBVGtDTkRZWE1EWW5NQllYTVJRV01UQUdKemNHSmljdUFTY21OamNlQVJjd0ZqY09BUWNENGdzZkVna3VLY1lGQ2dVQkFnRVNTQzRHT1NVRUNBUElGQ0lNREFvREFUTTNDU0VIUENvQkM4RUlGUTREREFIVkRRTXJQZ29yQ0E0VXBBTUdBd1VJQmY3UEVCd0pDZ1lETHdZdkhnUUpCUUV4RUJ3SkNnWUVMZ0VKSmhmOWtDTTVCaU1CRlJJSEVBZ0JOQ001QlJBQkF3SXBRQWdEQlE0S0F3Y0VCZ3dHQ1JNSkJnZ1ZDZ1lOQmhrUEJBVUJCZ01KQ0FNRkF3c1FCd29VRVJFTEZ3d0dEQVlLMHN3ckdoVWtEQjBPSFNJRkFRSkVLQzRDQWdNSUJ3TUZDZ1VMRndnSENoVUtCZ3NGQ0FzRkFTNG9BU2dCQXdMRkRBMEREUDRDQmdRREVBcitNUVFKQnNjQkF3RUtFUUVIL3Y4QkF3SUJBd01xQjhjS3R2UUhCUW9HQVRFRy9ybis1d0lDSXk0RUFRa0NBZ01CQlRzaG5BSUJBZ0lKQVFZNEl3RUJBaUJFQ0Y0RUVBNFpDd2dKRGdvS0tNOEJJd3dMRlFrSUVCWU1Dd0ptQVFNQkEwZ0tBZ1VDQXd4TUF2c0JBUUVPVVFzQ0FRRUNCd0lJVFFVRERRd01GQU1DREF3TUZBTXJBUWdHQlFZQkFRa0ZCZ1Z5Q3hVQ0F3MExEQlVDQXcwTUN3VUdBUUVKQlFVR0FRRUpHUUlCQWdJREFnSUdBeDR6RnhjbERnd0pCUU1HQXdFQkN4SURBUUlEQWdVQkFRRUJBd01CQVFJQkJnWWpId0ZKT1FRREJnSUJBd01EQkFFUEM0VUxFQVVEQmdJQkJRVXVFUUVFS3c0Qkl4MWhCemdQRUQ0RUF3TUJEaTRiUGh3QkN3WUNDeElkQ2dJcFJna3BBUUVxTndnQkpqQUJId01WRVJBbkV3RUJBUnBuUE5Bd1NoSUZTQjRSSGcwUlJXSktEaEJHTDg0a1JoLytaZ0VCQVVBREV3NFBJUkRlSFNZQkFVQURFdzRQSVJEZUFnRVhJUWZhQmlvaTRBSURBaGNwRGdVR0FUQUdLaU5sTkNnTEJnZ0JBUUVGQWdRSEFRRUJBUUVCSFE0UkdnY0VCZ0VCQWdnREJRZ0RBd0VCQVFFQ01TRmtCQVVFREJNS0F3VUxDQUVlQmdVQkJ3TUVBd0VCQVFFQ0J3UUNCUUVDQWdZQ0F3RUtCdFFCS1FNVUREazJBUW9iRXdvTmxRUUdBUjhCRGdzcEtRa1VEUVlMQmYzS0xCOHVIWTRvQWdRQlFDWkZBZlFFQWdZbUNRSUJBUVVDRENjQlBRSUZBZ0lEQWdnV0JRRUZBUWtUQ21RTkRRUUdFZ0VhQkFVS01SRVdBZ0VWQWdJT0RnY1NEcFVEQkJnYUF3Y0NBd1FCQXgwZkxBRUVBaDBJQWdVREFnUUJCd0ZVRFJZQ0F3OE5EUllDQXc4TkF3VUZBUUVKQlFRR0FRRUpTZ0lQRFF3V0F3SVBEUXdXQXpjQkNBVUZCZ0VDQ0FVRkJWQUNBUUVFQVFFQkFRY0NCUVVPQmdZRkJBRUNBUUlCQXdNTEF3UUJBUUlEQWdFREJRTUJCQUlLSWhNU0lBWUJEbHNPQVFRQ0FRTUJBd1FEQXdzS0FtZ0RCZ1FCQWdRQ0FRVUhBd2NTQkFNSEVnRUJEQWNyQndnREF4SU1DQkVFQnhBR0J3TUpFd1VBQUFBQUFnQUFBQWtFQUFOM0FFVUFoUUFBQVRRbUp5NEJKeTRCSnk0Qkp5NEJJeUlHQnc0QkJ3NEJCdzRCQnc0Qkl5SW1KeTRCSnk0Qkp5NEJKeTRCSXlJR0J3NEJCdzRCQnc0QkJ3NEJGUlFXRndrQlBnRTFNVE1VQmdjQkRnRWpJaVluQVM0Qkp5NEJKeTRCSnk0Qkp5NEJOVFEyTno0Qk16SVdGeDRCRng0QkZ4NEJGejRCTno0Qk56NEJOejRCTXpJV0Z4NEJGVFVEdHdZR0J3OEtDUmdORGhzTkRSd1BEeUFSRVNBT0R4Z0xDaEVIQlE0SkNRNEZCeEVLQ3hnUERpQVJFU0FQRHh3TkRSc09EUmdKQ2c4SEJnWTFOZ0ZNQVVzMk5rbEJRdjZjQlEwSEJ3MEYvcHNEQ0FVRkR3c0xFd2tKRHdjR0J5UWxKR1JBRWlRU0V5SVFFQnNNQ3hZS0NoWUxEQnNRRUNJVEVpUVNRR1FrSlNRQ2JCY29FaEljQ2dzUkJ3WUpBZ0lEQ0FjSEVnc0xGUWtLRWdnR0JnWUdDQklLQ1JVTEN4SUhCd2dEQWdJSkJnY1JDd29jRWhFcEZ6Qm1OZjdBQVQ4MlpqQkFnRUwrcWdZRkJRWUJWd01IQlFZU0RnMGNEZzhpRlJRbkV6OWpJeU1rQmdZSEVBc0tGQWtKRXdzTEV3a0pGQW9MRUFjR0JpUWpJMk0vQVFBQ0FBVC93QVA4QThBQU53QjJBQUFCTGdFdkFpNEJKeXNCQnc0QkR3SU9BUWNHRmg4QkF3WVdGeDRCT3dFM1BnRS9BUmNlQVRzQk56c0JQZ0UzUGdFbkF6YytBU2NCSGdFWEV3VXlGaGNXQmc4QkV4UUdCdzRCSXlJd01TSW1JeVVGQmlJSE1DSXhNQ1l4SWlZbkxnRTFFeWN1QVRjK0FUTWxFejRCTnpBeU1UTXdGaGNEL0Fja0YvNXlDaVVWQWdvRUZTTUpjZjRZSXdjSEN4QzZMQVFSRWdvYURnUUdDQTRINHVNSUZRc0NCQUlDQ3hRSUVoRUVMTG9QQ3dmK0N3SUNBWUlCSWdRR0FRRUNBdEl5QXdNQkJBRUJBZ1FCL3Z6Ky9RRURBUUVCQWdRQkJBSXgwZ0lDQVFFR0JBRWlnUUlHQXdFQkJRSUNQeFlmQkNiekZCa0NBUUlaRlBJbkJCOFdGeXdSdmY3ekZ5b09DQWtCQVFRRWZYd0ZCZ0VDQ0FjTkt4WUJEcjRRTFJZQk93RURBdjdzTEFZRUJBZ0MxLzdSQlFjQ0FnRUJqNDhCQVFFQkFRSUlCQUV2MXdNSUJBTUdMUUVVQXdRQkFRRUFBQUFFQUFEL3dBUUFBOEFBRUFBVUFDZ0FVQUFBQVNFaUJoVVJGQll6SVRJMk5SRTBKaU1ESVJFaEp4VWpOU0VSTXhVaklpWTFFVFEyTXlFeUZoVURPZ0V6UEFFMU5EWXpNaUl6TWhZVkhBRVZPZ0V6TWhZSERnRUhEZ0VuQmlZbkxnRW5Kall6QThMOWpSa2xKUmtDY3hrbEpSa1EvYTBDVStWTC9jbUNrUmtqSXhrQ1ZSa2ozaEJLRUFzSEpBMGtCd3NRU2hBTUNBZ21UU1lEQmdNRUJnTW1UU1lJQ0F3REdpY2IvU3NjSnljY0F0VWJKL3o1QXJXNEloUDlhMDhsR2dLMEd5VWxHLzN0Umo5R0J3c0xCMFkvUmhVSkxsd3ZBd01CQVFNREwxd3VDUlVBQUFBRUFBRC93QVFBQThBQUVBQVZBQ2tBTmdBQUZ5RXlOalVSTkNZaklTSUdGUkVVRmpNM0VTRVJJUU1STkRZeklUSVdIUUVqTlNFUk14VWpJaVkxQlFZbU5SRTBOaDhCRmhRUEFla0MxQnduSnh6OUxCd25KeHdQQXJiOVN2Z2xHd0t6R3lWUC9Xc1RJaHNsQWZNRUJ3Y0V4d1FFeDBBbEdRSnpHU1VsR2YyTkdTVk9BbFA5clFFaEFsVVpJeU1aa1lMOXlVc2pHWThEQXdVQkpRVURBNUlEQ1FPT0FBUUFBUC9BQkFBRHdBQVRBQ1FBTUFBOEFBQVRFVFEyTXlFeUZoMEJJelVoRVRNVkl5SW1OUUVSRkFZaklTSW1OUkUwTmpNaE1oWVZCeUVSUGdFZUFSY2VBVGNSQXpJMk5UUW1JeUlHRlJRV0FDVWJBck1iSlUvOWF4TWlHeVVFQUNjYy9Td2NKeWNjQXRRY0oxTDlTaHhWWUdFblZKdHV5VEJEUXpBdlJFUUJMd0pWR1NNakdaR0MvY2xMSXhrQlFmMk9HU1VsR1FKeUdpVWxHZy8rbEN3b0FTY2hTQkFCQWJqK3hVTXdMME5ETHpCREFBZ0FBUC9BQkFBRHdBQUxBQmdBSlFBeEFEMEFTUUJWQUdJQUFBRVVCaU1pSmpVME5qTXlGZ01pQmhVVUZqTXlOalUwSmlNQklpWTFORFl6TWhZVkZBWWpKVFFtSXlJR0ZSUVdNekkyRXhZVUJ3WWlKeVkwTnpZeUFRWVVGeFl5TnpZMEp5WWlFd1lpSnlZME56WXlGeFlVQVNZaUJ3WVVGeFl5TnpZMEp3SjZQQ3NxUER3cUt6eG5Jekl5SXlReU1pUUJyUnNsSlJzYUppWWEvUTA4S2lzOFBDc3FQR0FlSGg1VkhoNGVIbFVCL1JjWEZ6OFhGaFlYUDBRUEt3OFBEdzhyRHcvOXR4NVZIaDRlSGxVZUhoNERXU284UENvclBEejg1eklrSXpJeUl5UXlBUXdtR2hzbUpoc2FKa0FyUER3cktqdzhBWm9lVlI0ZUhoOVVIaC85Z0JaQUZ4WVdGMEFXRndIZUR3OFBLZzhQRHc4cS9nNGVIaDVWSGg0ZUhsVWVBQUFFQURBQUJBUGVBMzhBRlFBckFFQUFWZ0FBSlFFdUFTTWlCZ2NCRGdFWEhnRXpJVEkyTnpZbUp3Y2hJaVluSmpZM0FUNEJNeklXRndFZUFRY09BU01sTXhNME5qVTBKaWN1QVNNaUJnY09BUlVjQVJVVERnRVZGQllYSGdFek1qWTNQZ0UxTkNZbkxnRUhBOVQrcHhVK0lTUThGUDZrRlFRU0QwTXBBclVwUXhJUEJSUjAvVXNWSGdjSUJBb0JXUW9kREJBWkN3RllDd1FJQlIwVS9vOHNIQU1HQ0FjUkRRMFVCUWNHRFFjR0JnY0lGQW9LRkFjSUJnWUlFaWtRM3dKVkpDY25KUDJySkZBZkh5a3BIeDlRSkhRSERRMGZFZ0pWRWhNVEV2Mm5FaHNORFFlcUFVRUlEZ0lLRkFnSEJnWUhDQlVNQXcwRi9xY0hGQW9LRkFnSEJnWUhDQlFLQ2hRSERRTVFBQUFBQUFZQVV2L09BN2dEdGdBOEFFZ0FoZ0RIQU5NQkVRQUFBUzRCSXlJR0J3NEJCeFVVRmhjeUZqTTZBVE1PQVFjT0FSMEJIZ0VYRGdFVkZCWXpNalkxTkNZblBnRTNOVFEyTlRBMk56NEJOejRCTlRRbUp3TWlKalUwTmpNeUZoVVVCaE1PQVFjT0FRY09BUWN3QmdjR0pqRTFORFkzUGdFM1BnRTNQZ0UxTkNZbkxnRWpJZ1lIRGdFSE1BWW5MZ0V4UGdFM1BnRXpNaFlYSGdFVkZBWUhCUzRCSnk0Qkl5SUdCdzRCRHdFVkJoWVhEZ0VIRlFjVkZCWVZEZ0VIQmhZWEhnRVhIZ0V6TWpZM05qUW5QZ0UvQVRVd05ERStBVGMrQVRjK0FUYzJKaWNERGdFbkxnRTNQZ0VYSGdFM0RnRUhEZ0VIRGdFSERnRUhNQVluTGdFeE5UNEJOejRCTno0Qk56NEJOelltSnk0Qkp5WUdCdzRCQnpBR0p5NEJNVDRCTno0QkZ4NEJGeDRCQndKUEoxNDdTblFtSkMwSUpWMEtFQWdGQndVRkJ3VUZBZ0lNQ2hBU1dVQkFXaFFTQ3dzQ0JBOGFKakFORHc4ME5kRWtNVEVrSkRJeXdRb3FJUmNlQlFVR0F4UXdNUjRCQXdVTENBb3FJUlFSQ1FnRkdBOFNIZ29LRHdJZ05qZ1RCU01jSFZzOU1VMGNKaWdLQ2dFekZEMG1GU2dTR1NzVkhpNFFBd01JUXdnS0F3TURDaEFGQlFVTERDUVhDQThJS1VFS0JRVUZCZ01EQXdzS0hDb1BFQlFGRFJBZndnVW9GQlVXQlFVb0ZCY1dvQU1MQ2dnaUZ4SVZCUVVLQWhRY0h3MENDUVlGQ3djSUlCa1FFQUlEQVFVQ0R3b0tGQWdIRHdVWUh4NEhDaDhVRlRza0hDb1FGd3dJQTRNWkdpY2tKRnc1Qmd0U0RRUUtGQXNTTFJrbUNCY0tGQzhjUUZwYVFCdzFGUW9ZQ2c0S0N3TVVGUnd6RnhvekdqMWxKUDA2TVNRa01URWtKREVCdXhJcEdoSWZEQXNaRUNNQ0JTb0xGQ01ORFJnTENpZ2NFQjRRREJnSUJRVUxEUW9nR2h3SUJ5SXJSeGtkSFJRVUdrY3JFaU1RMHhjakNnVUZDZ29TTkNRRUF3Vk5Id29aRUFjTkRnVUhCUW9hRHhjdUZ4VWRCUUlCTWlZUUlnOEZDd1VEQndNREJRTU1Gd3dRSXhJcFVDVCtqeFFYQmdVbkZCVVdCUVVsemdvVUNBY1VDZ2dNQ0FVUENoQUZCaUFIRFJNRkNBc0ZCUkFLQlE4TEJ3OEZCUWtEQXdFRkJoRVBDUXdORmhra0NnMEJDZ2daRHhVdUdRQUFBQU1BQUFBbUJBQURXZ0FMQUJnQVRBQUFBVFVoRlNNMUlSVWpFU0VSQVNJbU5UUTJNeklXRlJRR0l4TU9BUWNPQVFjT0FURWpOVFEyTno0Qk56NEJOejRCTlRRbUp5NEJJeUlHQnc0QkJ5YytBVGMrQVRNeUZoY2VBUlVXQmdjRG12N016UDdNWmdRQS9ma2NLQ2djSENnb0hMVUlJeGtTR1FVRkJaWVNBZ01UQlFnbUdnOFRCZ2NJRVEwTkdRb0hDd0ovQmhvWEYwZ3dKejBYSHg4Q0NBZ0MwWW1KaVluOVZRS3IvWThwSEJ3b0tCd2NLUUZTRENNVkR4WUxCeUlIRWhzS0NoUUhDQ0VWRFJnTENoTUZCUWdKQ0FjZEVoRWtPQlFYRmhBUEZEa2tEeHNRQUFRQUFBQW1CQUFEV2dBTEFCY0FNd0EvQUFBQk5TRVZJelVoRlNNUklSRUZORFl6TWhZVkZBWWpJaVlCTVJRbUp5NEJJeUlHQnc0Qkp6RW1OamMrQVRNeE1oWVhIZ0VWRVNJbU5UUTJNeklXRlJRR0E1cit6TXorekdZRUFQejlNQ0loTURBaEpDNEIwQXNYRlZzeE1Gd1VGd3dEQWcwVUhGNHhNRnNjRkFRaE1URWhJVEV4QXRHSmlZbUovVlVDcStna05UVWtKRFV6L3NNREF3b0tGUklOQ2dNREF4a05GQTRPRkE4WEF3RUtOU1FrTlRVa0pqTUFBQUFBQWdCeEFENERpUU0rQUYwQWJ3QUFBUTRCRHdFT0FSVVVGak15TmpjK0FUVTBKaWN1QVNNaURnSVZGQjRDTXpJMk56NEJOeGNPQVFjT0FTTWlKaWN1QVRVME5qYytBek15SGdJVkZBWUhEZ0VqSWlZbkxnRTFEZ0VqSWlZMU5ENENNeklXRnpjek5RTStBVFUwSmlNaUJnY09BUlVVRmpNK0FRTGhCUkVGTndJQkN3ME5IUXdpSmpZd0gxRXhSblZVTGl0T2JVTWtSaDRhS3g0M0pDc2lMbDB3WDVFMk16TTNOaDlHVWx3MVRvSmVOUzBwSkZVdUdpY0tBd1FhTnlaRFRTTTdVQzBtS3hJS1pyVVFFeDBYR1M0UkVCTWFHaGt0QXBBTlFBL0dDQXdIQ2c0T0NobGJNejFtSEJJVUxGQnVRMEJvU2lrS0N3Y1VGRTRWRkFvTkR6UTJNWWxOVW8wMUh5NGZEeTlWZEVVK2NDa2tKQk1QQlFvTkhScGFUVGxqU2lzWEhCOEQvdllmU3g4Y0lTSWZIMGNmSkNRREpBQUFCZ0JVLzlvRHFRT2pBQVVBQ3dBUkFCY0F4QURKQUFBbEl4Y3pOU2NoQnhVek55TVJNeWNqRlJjbEJ6TVZOelVEUEFFMU5DWW5MZ0VuTGdFMVBBRTFQQU0xTkRZM1BnRTNQZ0UxUEFFMVBBRTFKaUlqS2dFaklnWUhEZ0VIRGdFaktnRWpLZ0VqSWlZbkxnRW5MZ0VqS2dFaktnRUhGQVlWSEFFVkZCWVhIZ0VYSGdFVkhBRVZIQU1WRkFZSERnRUhEZ0VWSEFFVkZCWVhIZ0VYSGdFek9nRTNNaFlYSGdFWEhnRVZCaFFWRkJZWEhnRVhIZ0VYTmpBM1BnRTNQZ0UxUEFFMU5EWTNQZ0UzTmpJek9nRXpNalkzUGdFM1BnRTFKd2NuRVNFRGRwRXprVFA5RkRhUk5wR1JNNVEyQW80MmxET0NBUUlFQ1FVQ0FnSUNCQWdFQXdJQ0F3RWlSQ0lEQkFJRUN3UURCQVFGQ3dZeVpUSURCZ0lGQ2dRQ0JBTWpSeU1CQXdFQkFnRUdDZ1VDQWdJQkJRc0ZBZ0lDQVJJbEVnRURBZ1lMQlFZSUF3UlpCZ0lDQVFJQ0VDQVFBUUlCQVFFUklSRUNBUUVCQmwwRkFRUUJCdzRIQWdRQ0VpUVNBUUtObVpvQk0yRStpRGMwaXo0REFVR0xOc0ZCZ0RhTC9XVWpSaU1DQXdJRUNBUUNCUU1FQndRQ04wTTVCQU1EQWdRSUJBSUZCQ0JDSUFJREFnRUNBZ1VLQlFJQ0FnTUZDUVVDQWdFQkFRRWhSQ0VDQkFFRkN3VUNCUU1HQ3dVQk5VQTRCQUVDQVFVTEJRSUVBaUpFSWdJRUFSTWxFZ0VDQVFNRUJWa0ZBZ1VEQnd3SEF3UUNFU0FRQVFJQkFRRVJJaEVDQXdNSER3Y0NBd0VHWFFVQ0FnRVRKQk1CQXdKRW5Kd0JNd0FBQUFBREFBRC93QVFBQThBQUV3QWFBQ1lBQUFFaURnSVZGQjRDTXpJK0FqVTBMZ0lESXpVSEp6Y3pBUlVqTlNNMU16VXpGVE1WQWdCcXU0dFFVSXU3YW1xN2kxQlFpN3ZlZENaRVpuZ0JhbmgzZDNoM0E4QlFpN3RxYXJ1TFVGQ0x1MnBxdTR0US9UcjJKbWRtL3RwM2QzaDNkM2dBQUFVQUFBQXRCQUFEUGdBREFBY0FOUUE2QUQ4QUFBRWhFU0VCSVJFaEFTNEJOellXRng0QkJ6TW1OamMrQVJjV0JnY3dCakV6UGdFbkxnRUhEZ0VITGdFbkpnWUhCaFlYTXpBbU1RVWpFU0VSQlNFUklSRUNOd0hKL2pmOXlRR1QvbTBCTUVBckNBZE5NUzQ2QllVRk9pNHVUUW9JSzBBRFpod1hDZytBU0NsQUVoSkFLVXFCRHdvV0dXb0RBZkxyQWNuOXRmNUxBWk1CTy83eUFRNys4Z0tNR2pBU0VnY1ZGQndwS1I0U0ZRUVNFakVaQnlrdUdpWVJIQkl0R2hvd0Vod1JLUmN1S1FjSC92TUJEUVArOWdFS0FBQUFCZ0FpQUNzRDNnTklBQnNBT1FCVkFIRUFqd0NyQUFBbEZSUUdCdzRCSXlFaUppY3VBVDBCTkRZM1BnRXpJVElXRng0QkVSVVVCZ2NPQVNNaElpWW5MZ0U5QVRRMk56NEJNeUV5RmhjZUFSVXhFUlVVQmdjT0FTTWhJaVluTGdFOUFUUTJOejRCTXlFeUZoY2VBUUVWRkFZSERnRXJBU0ltSnk0QlBRRTBOamMrQVRzQk1oWVhIZ0VSRlJRR0J3NEJLd0VpSmljdUFUMEJORFkzUGdFN0FUSVdGeDRCRlRFUkZSUUdCdzRCS3dFaUppY3VBVDBCTkRZM1BnRTdBVElXRng0QkE5NEdCZ1lPQ1AyWkNBNEdCZ1lHQmdZT0NBSm5DQTRHQmdZR0JnWU9DUDJaQ0E0R0JnWUdCZ1lPQ0FKbkNBNEdCZ1lHQmdZT0NQMlpDQTRHQmdZR0JnWU9DQUpuQ0E0R0JnYjg4QVlHQmc0SVhBZ09CZ1lHQmdZR0RnaGNDQTRHQmdZR0JnWU9DRndJRGdZR0JnWUdCZzRJWEFnT0JnWUdCZ1lHRGdoY0NBNEdCZ1lHQmdZT0NGd0lEZ1lHQnFOUUNBNEdCZ1lHQmdZT0NGQUlEZ1lHQmdZR0JnNEJOazhJRGdZR0JnWUdCZzRJVHdnT0JnWUdCZ1lHRGdnQlAxQUlEZ1lHQmdZR0JnNElVQWdPQmdZR0JnWUdEdjE3VUFnT0JnWUdCZ1lHRGdoUUNBNEdCZ1lHQmdZT0FUWlBDQTRHQmdZR0JnWU9DRThJRGdZR0JnWUdCZzRJQVQ5UUNBNEdCZ1lHQmdZT0NGQUlEZ1lHQmdZR0JnNEFBQUFBQndBYy8vZ0Q1QU9HQUV3QVVRQmVBR3NBZHdDRUFKUUFBQUV1QVNNaUJnY3VBU2N1QVNNaUppYzFOQ1lyQVNJR0ZSRVVGanNCTWpZMUVSNEJNeklXRng0QkZ5NEJJeUlHQnc0Q0ZoY2VBVE15TmpNK0FUY3pIZ0VYTWhZek1qWTNQZ0V1QVNjQkl4RXpFUU1pSmpVME5qTXlGaFVVQmlNQkZTTVZJelVqTlRNMU14VVhGeUltTlRRMk16SVdGUTRCSnlJbU5UUTJNeklXRlE0Qkl4Y2lKalUwTmpNeUZoVTRBVEVVQmlNRHRCbEpLaG95RmdJVkhSTXlJRk5sRlNJVjNoVWFHaFhlRmlFZlpVa1pKdzhYRVFJTk5TSXFTUmtjRmdVR0FnYzNLQUlGQWdvN040WTNPd29EQlFJbk53Z0JCZ1FYSFAwYUlDQVVGaDhmRmhZZ0lCWUJ5U1lxSmlZcUpwTUxFQkFMREJBQkR3d0xFQkFMREJBQkVBdEVDeEFRQ3dzUUVBc0JhU290RHc0ZFVTRVZGVjhrZWhVWUdCWDgwUlVkSFJVQ2dDWkZFQkVaUmgwSkdTNHJMVnBMTkFZc013RUJGa05ERmdFQk15c0hNMHRaTGY4QUFlUCtIUUlxSHhZV0lDQVdGaC8rakNraElTb2xKUUZTRUFzTEVCQUxDeEJLRUF3TEVCQUxEQkFvRUF3TEVCQUxEQkFBQUFBQUJ3Q3YvOXdEVUFPZUFCWUFHZ0JCQUU0QVlRQjBBSWNBQUFFaElnWVZFUlFXTXlFNEFUTXlOalUwTURVVE5DWWpFeUVSSVFNbUJqRU9BU3NCSWlZbkxnRUhCaFl4SGdFM1BnRXhQZ0U3QVRJV0Z4NEJGeFkyTnpBMkp3Y1ZJeFVqTlNNMU16VXpGVE1YSWlZMU5EWXpNaFlWT0FFeEZBWWpPQUV4TlNJbU5UUTJNeklXRlRnQk1SUUdJemdCTVJjaUpqVTBOak15RmhVNEFURVVCaU00QVRFQzRQNUFMa05ETGdIQUFTeEFBMEl1TFAzbEFodHZKMWtFQ3dVVkJnb0ZCRlVtSndnREVoRVJOZ01LQm5zRkNnUURNeEFSRXdJSUpzWWRJQjBkSUIxeUNBME5DQWtNREFrSURRMElDUXdNQ1RRSURRMElDUXdNQ1FPZVFDMzlGaXcvUUN3QkFRTG5MVUQ4NXdLYS91dy9KZ01FQkFNREl6OC9jQkVUQVFFN0JBVUZCQVEzQVFFVUVIQS9JUjBjSENFY0hFUU1DUWtNREFrSkREb01DQWtNREFrSURCOE1DUWdNREFnSkRBQUFBLy85LzhBRUFBUEFBQmNBS0FCQUFBQUJKemN2QVFjbkJ5Y1BBUmNIRndjZkFUY1hOeGMvQVNjQk14VVVCZ2NPQVNzQklpWW5MZ0U5QVJNT0FTTWlKaWN1QVRVME5qYytBVE15RmhjZUFSVVVCZ1FBWmkrU0k1Sm5jSkF6bVI1d1pqQ1RJcE5tY1k4d21oLytRVlVCQWdNQ0Fqb0RCUUlEQkU0SEVRb0tFQWdJQmdZSUNCQUtDaEVIQ0FZR0FhVndrQythSDNGbUw1SWprbWR3a0MrYUgzRm1MNUlqa2dGWmNSUWxFaEkxTXhRU0pSUngvb2tHQ0FZSUJSSUxDaE1GQlFnRkNBVVRDZ3NRQUFBQUJBQUFBQVFFQUFOOEFCQUFJQUF4QUVJQUFBRTBOak1oTWhZZEFSUUdJeUVpSmowQklUUTJNeUV5RmgwQkZBWWpJU0ltTlFFME5qTWhNaFlkQVJRR0l5RWlKajBCSVRRMk15RXlGaDBCRkFZaklTSW1QUUVDV1NnY0FSOGNLQ2djL3VFY0tQMm5LQndCSHh3b0tCeis0UndvQWxrb0hBRWZIQ2dvSFA3aEhDajlweWdjQVI4Y0tDZ2MvdUVjS0FNM0hTZ29IZG9jS0NnYzJoMG9LQjNhSENnb0hQN0pIU2dvSGQwZEtDZ2QzUjBvS0IzZEhTZ29IZDBBQUFBREFBQUFKZ1FBQTFvQUlnQXFBQzhBQUNVaE5TRXlOalVSTkNZaklTSUdGUkVVRmpNaEZTRXdCaFVVRmpFaE1EWTFOaVl4QVNFUklUQThBaGNoRVNFUkErWCtZd0ZqRkNJaUZQeTFGU2tuRndGYy9tTWZId1BDSHdNZS9LY0M3LzBSUkFKbi9abHJJam9VQWtzVkh4OFYvYlVVT2lJSkdSb0pDUm9jQmdLcS9kNnJ6YXBFL21ZQm1nQUFBQVlBQXdBeEEvMERVd0FOQUI0QUlnQW5BQ3dBTVFBQUpTRXdCaFVVRmpFaE1EWTFOQ1lsSVRJMk5SRTBKaU1oSWdZVkVSUVdNeE1oRVNFVElSRWhFUVV6RlNNMU5UTVZJelVEM3Z4RUh4OER2QjhmL0lJRFFCVWJHeFg4d0JVZkh4VVVBeGo4NkVnQmx2NXFBZUducDZlbmRRa1pHZ2dJR2hrSk54Y1ZBa2dVSHg4VS9iZ1ZGd0pmL2VVQjAvNTBBWXp2blozdm5aMEFCZ0FpQUhJRDNnTWhBQXNBS2dBMkFGVUFZUUI3QUFBQkZBWWpJaVkxTkRZek1oWUhEZ0VqSWlZbklnWUhGQllWRkFZSEhnRXhGVEkyUHdFK0FUYzFNQ1luSlJRR0l5SW1OVFEyTXpJV0J6UTJOUzRCSXc0Qkl5SW1KdzRCQnhVd0ZoOEJIZ0VYTlQ0Qk55NEJOUVVVQmlNaUpqVTBOak15RmdjT0FTTWlKaWNpQmdjVk1CWWZBUjRCUHdFK0FUYzFNQ1luQTNWRk1URkZSVEV4UlRVUElSRVJJUThFQ2djQkd4ZHpKaHc2SGhFU0pCSW9kdjQzUlRFeFJVVXhNVVVnQVFZS0JnOGdFaEVoRHhlQ0JTZ2lFQms2SVFSdUp4Y2JBU0JGTURGRlJURXdSVGtPSGhBUkhnNE5rZ1VvSXhBeWkwNFFFaVFTS0hrQ3JERkZSVEV3UlVXM0J3Z0lCd0VCQWdNQ0lUa1VEb0FmQ1FvR0J4SUxhWGtGaHpGRlJURXdSVVhBQWdRQkFRRUhDQWdIQVNwVGFSVU5CUWdNQWg5T09RWVVPaUVITVVWRk1UQkZSY0lHQndjR0pWbHBGUXdHRUF3WkJnY1NDMmw3QXdBQUJBQXlBTEFEemdMT0FFNEFXZ0JvQUhRQUFBRXVBU2N1QVNNSElnWUhKekFtSnk0Qk1TRXdKZ2NPQVRFSE5DWWpKeUlHQnc0QkJ3WVdPd0VPQVFjVUJoMEJIQUV4RlJRV093RXlOajBCSVJVVUZqc0JNalkxRVR3Qkp5NEJKek0rQVNjRklpWTFORFl6TWhZVkZBWW5OVGN3TmpjaEhnRXhId0VWSVFVaUpqVTBOak15RmhVVUJnUE9BUVFCQkFnSlB3a0tBWVFKQ1FnTy9wUU9DUVVJaGd3SVBRa0lCQUVFQVFRUUNDWU5EUU1DREFpTUNRd0IvQXdKakFnTUFnSU9EU1lJRUFUOCtSb2hJeGdaSWlJMGpnUURBWFVEQkdvbS9WOENsQm9oSXhnWklpTUNKd2NJQ2dnTUNRUUZmUWNFQXdFQkJRUUZmd2NDQ1F3SUNnZ0hDZ29SSkE4Q0F3SUhDQXpwQ0F3TUNDUWtDQXdNQ0FFQ0FnVUNEeU1QQWdzSzJTUWJHeVVsR3hza3NDS0lBd0VCQTJRaEpiQWtHeHNsSlJzYkpBQUFBQUFNQUNNQUdBUGZBM1FBR3dBNEFGVUFjZ0NQQUt3QXlRRG1BUU1CSUFFOUFWb0FBQ1VoSWlZbkxnRTlBVFEyTno0Qk15RXlGaGNlQVIwQkZBWUhEZ0VsSWdZSERnRWRBUlFXRng0Qk15RXlOamMrQVQwQk5DWW5MZ0VqSVNVaElpWW5MZ0U5QVRRMk56NEJNeUV5RmhjZUFSMEJGQVlIRGdFakpTb0JCdzRCSFFFY0FSY2VBVE1oTWpZM1BnRTlBVFFtSnlZaUl5RWxJU0ltSnk0QlBRRTBOamMrQVRNaE1oWVhIZ0VkQVJRR0J3NEJJeVVpQmdjT0FSMEJGQllYSGdFeklUSTJOejRCUFFFMEppY3VBU01oQXlNaUppY3VBVDBCTkRZM1BnRTdBVElXRng0QkhRRVVCZ2NPQVNNbklnWUhCaFFkQVJ3QkZ4NEJPd0V5TmpjK0FUMEJOQ1luTGdFckFUY2pJaVluTGdFOUFUUTJOejRCT3dFeUZoY2VBUjBCRkFZSERnRWpKeW9CQnc0QkhRRWNBUmNlQVRzQk1qWTNQZ0U5QVRRbUp5WWlLd0UzSXlJbUp5NEJQUUUwTmpjK0FUc0JNaFlYSGdFZEFSUUdCdzRCSXljaUJnY0dGQjBCSEFFWEhnRTdBVEkyTno0QlBRRTBKaWN1QVNzQkE1ZitDQThhQ2dvTEN3b0xHUThCK0E0YUNnc0xDd3NLR3YzNkFnSUNBUUVCQVFJQ0FnSDRBUU1CQWdFQkFnRURBZjRJQWZqK0NBOGFDZ29MQ3dvTEdROEIrQTRhQ3dvTEN3c0tHZzcrQ0FJQ0FnRUJBZ0lDQWdINEFRTUJBZ0VCQVFJREFmNElBZmorQ0E4YUNnb0xDd29MR1E4QitBNGFDd29MQ3dzS0dnNytDQUlDQWdFQkFRRUNBZ0lCK0FJQ0FRSUJBUUVDQXdIK0NOaGNEeG9LQ2dzTENnc1pEMXdPR2dvTEN3c0xDaG9PWEFJQ0FnSUNBZ0lDWEFFREFRSUJBUUlCQXdGY1hGd1BHZ29LQ3dzS0Nob1BYQTRhQ3dvTEN3c0tHZzVjQWdJQ0FRRUNBZ0lDWEFFREFRSUJBUUVDQXdGY1hGd1BHZ29LQ3dzS0Nob1BYQTRhQ3dvTEN3c0tHZzVjQWdJQ0FnSUNBZ0pjQWdJQkFnRUJBUUlEQVZ3WUNnc0tHZzVRRGhvS0N3c0xDd29hRGxBT0dnb0xDcDhCQWdFREFWQUJBd0VDQVFFQ0FRTUJVQUVEQVFJQm53c0tDeGtQVHc4YUNnb0xDd29LR2c5UER4a0xDZ3VmQWdJQ0FrOENBZ0lCQVFFQkFnSUNUd0lDQWdLZ0N3b0tHZzVRRGhvTENnc0xDd29aRDFBT0dnb0xDcDhCQVFJREFWQUJBd0VDQVFFQ0FnSUJVQUlDQVFJQi9PUUtDd29hRGxBT0dnc0tDd3NMQ2hvT1VBNGFDZ3NLbndFQ0FRTUJVQUVEQVFJQkFRSUJBd0ZRQVFNQkFnR2ZDd29MR1E5UER4b0tDZ3NMQ2dvYUQwOFBHUXNLQzU4Q0FnSUNUd0lDQWdFQkFRRUNBZ0pQQWdJQ0FxQUxDZ29hRGxBUEdRc0tDd3NMQ2hvT1VBNGFDZ3NLbndFQkFnSUNVQUVDQWdJQkFRSUNBZ0ZRQVFNQkFnRUFBQTRBZy8vOUEzVURuQUFnQUdRQWZRQ09BUFlCVGdGZUFXNEJoZ0dlQWNFQjVBSVhBa29BQURjME5qc0JNalk5QVRRMk15RXlGaDBCRkJZN0FUSVdIUUVVQmlNaElpWTlBVEV6TkRZN0FUSTJQUUUwTmpNaE1oWWRBUlFXT3dFeUZoMEJGQVlqSVNJbVBRRWpGUlFXTXlFeU5qMEJOQ1lyQVNJbVBRRTBKaU1oSWdZZEFSUUdLd0VpQmhVekFUWXlId0VlQVI4QkZnWWpJU29CSXlFaUpqOEJQZ0UvQVJjbUlnOEJCaFl6SVRJMkx3RXVBUzhCSnhjK0FUTXlGaDhCSGdFZkFqRXpJekU3QVNjVk15Y1hOU01YTlRBR0p5RXFBU01oS2dFNUFRY3pOUWN4TXpFak16OENQZ0UvQVNjSERnRVBBUTRCQnc0QkZSUVdNeDRCTXlFNkFUTWhNalkzTWpZMU5DWW5MZ0V2QVM0Qkx3RXVBU01pQmdjWEZ6Y3VBU01pQmc4QkRnRUhGQVlWRkJZekhnRXpJVEkyTnpJMk5UUW1KeTRCTHdFdUFTOEJCeGNlQVI4Q01UTWpNVHNCSnhVekp4Y25NUmNuTUFZaklTSW1PUUVITXljSE1Uc0JJek0vQWo0Qk16SVdGemNCTXpJV0ZSRVVCaXNCSWlZMUVUUTJJVE15RmhVUkZBWXJBU0ltTlJFME5pRTZBVE15RmhVY0FSVVVCaU1xQVNNaUpqVThBVFUwTmpNNkFUTXlGaFVjQVJVVUJpTXFBU01pSmpVOEFUVTBOaUVWTXpJV0ZSRVVCaXNCSWlZMUVUUTJNelVpQmhVUkZCWTdBVEkyTlJFMEppc0JCUlV6TWhZVkVSUUdLd0VpSmpVUk5EWXpOU0lHRlJFVUZqc0JNalkxRVRRbUt3RUZGVG9CTXpJV0ZSd0JGUlFHSXlvQkl5SW1OVHdCTlRRMk16VWlCaFVjQVJVVUZqTTZBVE15TmpVOEFUVTBKaU1xQVNNWEZUb0JNeklXRlJ3QkZSUUdJeW9CSXlJbU5Ud0JOVFEyTXpVaUJoVWNBUlVVRmpNNkFUTXlOalU4QVRVMEppTXFBU09GQkFNbEF3VUVBd0o0QXdVRUF5WUNCUVVDL1I4REJBRURBeVVFQlFRQ0FuZ0RBd1VFSmdJREF3TDlId01EQXdVRUF1RURCUVVESmdJRUJRUDlod1FGQXdNbEJBVUNBV3NGRGdXVEJRNEZsQVVDQnY3R0JoQUcvc1lHQVFXVEJRNEZreGdGRGdYYUJRRUdBY2dHQVFSQkJRNEZnaGdEQVFVREF3VUNrd1VPQlpNREFRRUJBUUlDQWdFQkFRSUMvc1lHRUFiK3hnRUNBUUVCQVFFQkFRS1RCUTRGbEFXVUJBNEZsQUVDQVFFQkF3RUNBd0lCT2dZUUJnRTZBZ01DQVFNQkFRRUNBWlFGRFFXVUF3Y0VCQWNEQWhnQ0F3Y0VCQWNEMndFQ0FRSURBZ0VEQWdISUFnTUNBUU1CQVFFQ0FVRUZEZ1dDQklJRkRRVkJBd0VCQVFFQ0FnSUJBUUVCQVFMK09BRUNBUUlCQVFFQkFnRUJBdHNCQlFNREJRSUMvdmNvQndvS0J5Z0hDZ29CMmljSENnb0hKd2dLQ3Y3UkNoTUtCd3NMQndvVENnY0xDNklLRkFrSUNnb0lDUlFLQndvSy90QW9CUWdJQlNnRkNBZ0ZDUXdNQ1NnSkRBd0pLQUhUSndVSUNBVW5CZ2dJQmdrTkRRa25DUTBOQ1NmK3lRb1RDZ1lJQ0FZS0V3b0dDQWdHQ1EwTkNRb1RDZ2tORFFrS0V3cWJDaFFKQmdnSUJna1VDZ1VJQ0FVSkRBd0pDaFFKQ1EwTkNRa1VDa1FEQkFVRERRTUZCUU1OQXdVRUF6NERCQVFEUGdNREJRUU5Bd01EQXcwRUJRTURQZ0lEQXdJK1BnTUdCZ00rQkFVREF3MEVCUVVFRFFNREJRUURVQVFFWkFRSkJHUUVCUVVFWkFRSkJHUWxBd09WQkFVRkF5MERDZ05aSlFNQkFnSUJaUU1LQTJVQ0FnSUNBUUVCQVFFQkFnSUNBUUZsQXdvRFpRZGxBd29EWlFFQ0FRRUNBZ0lEQVFFQkFRTUNBZ0lCQVFJQlpRTUtBMlVDQWdJQ0JDVURBZ0lDQXBVQkFnRUJBZ0lDQXdFQkFRRURBZ0lDQVFFQ0FTd0VDUU5aQmxrRUNRTXRBZ0lDQWdFQkFRRUJBUUlDQWdFQmxnRUJBUUVEL3M4TEIvNjdDQW9LQ0FGRkJ3c0xCLzY3Q0FvS0NBRkZCd3NMQjFhWlZnZ0tDZ2hXbVZZSEN3c0hWcGxXQ0FvS0NGYVpWZ2NMQkFnRy9yc0dDQWdHQVVVR0NBZ05DZjY3Q1EwTkNRRkZDUTBFQkFnRy9yc0dDQWdHQVVVR0NBZ05DZjY3Q1EwTkNRRkZDUTBFQkFnR1ZwbFdCZ2dJQmxhWlZnWUlDQTBKVnBsV0NRME5DVmFaVmdrTkJBUUlCbGFaVmdZSUNBWldtVllHQ0FnTkNWYVpWZ2tORFFsV21WWUpEUUFBQUFJQVBRQXdBOE1ESHdBT0FCMEFBQUVVRGdJSE5UNEJQUUVqRVNFUklSUU9BZ2MxUGdFOUFTTVJJUkVEd3pKWmUwcFJUOE1CYy8zdE1sbDdTVkJQd3dGekFheFhoMkEzQjVvUWRWY2ZBVnIralZlSFlEY0htaEIxVng4Qld2Nk5BQUlBTWYvcUE4OERsZ0JVQUdBQUFBRTFKeTRCSnpFbU5qOEJKd2NPQVNjeExnRXZBU01IRGdFSE1RWW1Md0VIRng0QkJ6Z0JNUTRCRHdFVkZ4NEJGekVXQmc4QkZ6YytBUmN4SGdFZkFUTTNQZ0UzT0FFeE5oWWZBVGNuTGdFM01UNEJQd0VGSWlZMU5EWXpNaFlWRkFZRHowTVVIUWdJQVFrZldFRVNLaE1USEFjWWZCZ0hIQk1US1JOQVdSOEpBUWdJSGhORFF4TWVDQWdCQ1I5WlFCTXBFeE1jQnhoOEdBY2RFeE1vRTBGWUh3a0JDQWdlRTBQK01VWmtaRVpHWkdRQmdYNFlCeDBURXlvVFFWb2ZDUUVJQ0I0VFJVVVRIZ2dJQVFrZldrRVRLaE1USFFZWmZoa0hIQk1US2hOQldoOEpBUWdJSGhORlJCUWVDQWdCQ1I5YVFSTXFFeE1jQnhsdFpVZEhaV1ZIUjJVQUFBY0FNUUR6QTg4Q2pRQUhBQThBR0FBZ0FDc0Fod0NTQUFBQkZ3NEJCeWMrQVFjWERnRUhKejRCQlFjdUFTYzNIZ0VYSndjdUFTYzNIZ0VuSGdFWEJ5NEJKejRCTndFd0xnSW5EZ014Sno0RE55NEJKekVIRGdFbkl5NEJQd0VPQVFjdUFTYzNIZ0VYTno0Qkh3RWVBUThCSGdFWFBnRTNKeVkyUHdFMkZoOEJQZ0UzRnc0QkJ5NEJKeGNXQmdjakJpWXZBUTRCQng0REZ3Y1RKejRCTng0QkZ3NEJCd09HTGdZTUJqQUhEQ293QmcwSE1BY04vWFl3QncwR01BWU5CekV3Qmd3R0xnY01SQWNPQmk0QkF3RUdEQVlETmlwYmttaG9rbHNxVUR0dVpWd3BNVzQrQmdJSUF3RUVBZ0lRQXdRQ0N4UUxNUVFKQkFZQ0NBTUJCQUlDQmhTQ2FtcUNGQVlDQWdRQkF3Z0NCZ1FKQkRFTEZBc0NCQU1RQWdJRUFRTUlBZ1krYmpFcFhHVnVPMUJMTGdZT0J3WU1CZ0VEQVFKdkhnUUlBeDRFQnhnZkF3Y0VId01IQ2g4RUJ3TWZCQWNER3g0RENBUWVCQWNwQkFrRUhnRUNBUXNWQy81bUNCdzFMUzAxSEFnUkVpVWtJeEVXTXg0TEF3SUNBZ2dESEFRSUJBVUtCU0FEQkFJTEJBSUNBUUlIQkFzTFFpMHRRZ3NMQkFjQ0FRSUNCQXNDQkFNZ0JRb0ZCQWdFSEFNSUFnSUNBd3NlTXhZUkl5UWxFaEVCYXg0RUNRUUxGUXNCQWdFQUFBQUVBQnovMndQcEE2Z0FHZ0FpQUM4QVNBQUFBVEllQWhVVURnSWpJaTRDTlRRd01UUStBak15TURFRE54VXpFU01IRnhjekZUTTFNelVqTlNNVkl4VURJZzRDRlJRZUFqTXlQZ0kxT0FFeExnTWpNUUlDVVkxcVBUMXFqVkZSaldvOVBXbU9VQUhOSFZoYlRqVFNXMXRiVzF0YkJXV3hoRXhNaExGbFpiR0VUUUZNaExGbEEwYzlhbzVSVUk1cVBUMXFqbEFCVVkxcVBmNkNIYnNCT2s1T1ExdGJXMXBhV3dJaVRZU3haR1d4aEUxTmhMRmxaTEdFVFFBQUFBUUFNLy9BQTgwRHdBQVFBQzhBTkFBNUFBQUJJU0lHRlJFVUZqTWhNalkxRVRRbUl3RTBOanNCUEFFMU5EWTdBVElXSFFFek1oWWRBUlFHQnhVaE5TNEJQUUVCSVRVaEZUVWhOU0VWQTRuODdod29LQndERWh3b0tCejlzakFpRndrR3FRY0pGaUl3S2gvKytSOHFBY3o5OGdJTy9mSUNEZ1BBS0J6OGlCd29LQndEZUJ3by90MGlNQWNqRmdZSkNRWkFNQ0t4SUM0RUxDd0VMaUN4L2FncEtYNHBLUUFBQUFZQUFQL0FCQUVEd1FBY0FDQUFOUUE1QUQwQVFRQUFBU0VPQVJVNEFURVJPQUV4RkJZek9BRXhJVGdCTVRJMk54RXVBU2NESVJFaEJ5Y3VBU01pQmdjakFROEJQd0VCUGdFMU5DWW5KeGNISndjbk54YzNKemNYQTd6OGlCd29LQndEZUJ3b0FRRW9IQS84cHdOWmtWMElGZ3dNRlFnQi9xMEhPdXNXQVVVSENRa0l5eXowTEI0bEdta3ZMUFFyQThFQktCejhpQndvS0J3RGVCd29BZnhUQTFud1hRZ0pDQWorckFmck94WUJSUWdWREF3VkNBRXM4eXV4SjE5cEppdjBMQUFOQUVYLzJ3TzdBNmdBRHdBVUFCa0FIZ0FpQUNjQUxBQXdBRFVBT2dBK0FFNEFYZ0FBQVNFaUJoVVJGQll6SVRJMk5SRTBKZ01oRVNFUkFUTVZJelU3QVJVak5Uc0JGU01GTXhVak5Uc0JGU00xT3dFVkl3VXpGU00xT3dFVkl6VTdBUlVqQVRNeUZoMEJGQVlyQVNJbVBRRTBOaUV6TWhZZEFSUUdLd0VpSmowQk5EWURlZjBPR3ljbkd3THlHeWNuRy8wT0F2TDliSXlNMVl5TTNJeU0vaytNak5XTWpOeU1qUDVQakl6VmpJemNqSXorWFZnR0NBZ0dXQVlJQ0FIUVZ3WUlDQVpYQmdrSkEwa2lHUDBIR0NNakdBTDVHQ0w4elFMNS9RY0Nlb3lNakl5TVJZeU1qSXlNUkl5TWpJeU1BMFVJQnJVR0NBZ0d0UVlJQ0FhMUJnZ0lCclVHQ0FBTUFFUC8yUU82QTZrQUR3QVVBQmtBSFFBaUFDY0FLd0F3QURVQU9nQktBRnNBQUFFaElnWVZFUlFXTXlFeU5qVVJOQ1lCSXpVekZUVWpOVE1WTlNNMU14TWpOVE1WTlNNMU14VTFJelV6RXlNMU14VTFJelV6RlRVak5UTVZBVE15RmgwQkZBWXJBU0ltUFFFME5pRXpNaFlkQVJRR0t3RWlKajBCTkRZekEzbjlEaHNwS1JzQzhoc21KdjNiakl5TWpJeU0ySTJOalkyTmpkMk5qWTJOalkzOXpWa0dDQWdHV1FZSUNBSFJXUVlKQ1FaWkJRa0pCUU5HSVJqOUJ4Z2pJeGdDK1JnaC9SdU5qYzZOamRPTi9kS05qYzZOamRPTi9kS05qYzZOamRPTmpRR25DUWEyQmdrSkJyWUdDUWtHdGdZSkNRYTJCZ2tBQUFBSEFFd0FVUVBnQXpVQVBnQjBBSW9Bb0FDeUFNUUExZ0FBSlNJdUFpY3VBU2N1QWpZM1BnRTNQZ0UzTVRZV0Z4NEJGeFVlQVFjT0FRY09BUWNPQVFjT0FRY1VGaGNlQVJjeEhnRVhGZ1lQQVE0QkJ3NEJJeE1PQVFjT0FRY0dGaGNlQVJjZUFqWTNQZ0UzUGdFbkxnRW5MZ0VuTGdFM05EWTNQZ0UzUGdFM1BnRTFOQ1luTGdFbkxnRWpBUlFXTXpBeU1UNEJOelFtSXpnQkl5SUdGU0lVTVRVVUZqTXdNakUrQVRVMEppTTRBVEVtQmhVd0ZCVUZCaFlYT2dFeFBnRTNMZ0VqSWdZVk9BRUhJZ1lWRkRBeEZCWXpQZ0UxTmlZak1DSVRGalkzTURReE5DWW5JZ1lIQmhZekZqSUNCQ2RQVFUwbEl6MFhIQjRER0JrbmRGQkFrRnNkVkN3VEloQVNFUUVCRkJNSEdRNE1IQVFHQkFFRUJBdHlJeTBxQ0FzSEVRRWtaa1ZBZ0Q5ZlZvWThTR2tpS2dVdkZEUWVQb0NEaFVROVdTQUxCUVlISHhnTmt4SVJDZ0VNRWdZWkZBd1lCZ2dKQndjTUdnOG5UQnYrYkNjYkFSc21BU2NiQVJvbkFTY2JBUnNtSnhzYkp3SGZBU1liQVFFYkpnRUJKaHdiSnAwYkp5Z2JHaVlCSmhzQkZ4c29BU2NiR3lZQkFTUWJBUUZSQ2hRZUZCTTFJQ1ZQVVZFblBGc2lHaHNCQVFjTkJoRU1BUTBqRWhNaURRVU9Cd2NRQXdRSEFnRUdCQWNvQ2c0c0V4cy9JUUU3VWhzYUdRS3hBaGdaSGxJMVFZTS9HeTRQSWlRSEZ4b1lTRE1XS0JBUUdBY0VNQkFPR3dvS0hRNEVEZ3dHRHdNRkRRY0dEQVVLRFFRTkJmNVFHeWNCSmhzYkp5VWJBdG9iSndFbkd4c21BU1liQVFHOUd5WUJBU1liR3ljbkd6SW1Hd0VjSlFFbEd4c25BUTBCSmhzQkd5Y0JKaG9iS0FFQUFBQUdBRW9BbHdQWEF6Z0FNZ0JSQUdvQWdBQ1pBSzhBQUFFeUZoY2VBUmNXQmdjT0FRY09BUWNPQVJjZUFSY2VBUmNlQVJjZUFRY09BUWNPQVM0Qkp5NEJKeTRCTno0Qk56NEJOd0U0QVRFVUZqTXlNREUrQVRjNEFURTBKaU00QVRFd0lqRWlCaFVVTUJVMUZCWXpNakF4UGdFM05DWWpPQUV4TUNJeElnWVZIQUV4QlRBVU1SUVdNekF5TXpJMk55NEJJeUlHRlRnQk1RYzRBVEVpQmhVd0ZERVVGak15TmpVd05ERTBKaU13SWpFVE1qQXpNalkxT0FFeE5DWWpJZ1lITUJReEZCWXpBbVVjVlMwU0lBNGJCQndOSFE0TEZRa1RBeFFOSFJFZFBCMFZJd3dYQXhNbWFrSkprSkNOUmlNNkZqWUdNQ3Q1UjBPU1cvNVlLUndCSENnQktSMEJIQ2dwSEFFZEp3RXBIUUVjS0FINEtCd0JBUndvQVFFb0hSMG9waDBvS0IwZEtTa2NBUmtCQVJ3cEtCMGNLUUVvSEFNNEJRNEdFQXNWTnhNSkRnZ0dEUWNPSkJBTEVBWUtEd2dHR0JFZE9oODlWaGtkR1Fjb0pSTXlIMGlkUzBKWUhod1pBdjRlSENrQktCd2RLU2djQVFIbUhDa0JLQjBjS1NnY0FRSEhBUndvS0IwZEtTa2ROQ2tjQVIwb0tCMEJIQ2tCR3ljZEhTa29IQUljS0FBQ0FDRC8zQVBlQTVNQUhRQTZBQUFCQXo0Qk56NEJOejRCTnpZV0Z4WVhGZ1lIRGdFSERnTUhJZ1lIQXdZbUp5NEJKd0lETGdFbkpqWTNOaFlYSGdFWEVoTWVBUmNXQmdjQldZQXZXUzFIajBjZE9Sd3ROZzBwS0FzUUpUVnVPQ2xTVWxNcERSb1FJaGNzREFVSUExbFpBZ01CQmhrY0dpd0pEQlVMUjBjREJBSUNDU01CU1FIK0Jnd0VCUVFIQXhnTEVSa3ZucDRvTXhBWUtRa0dCd1VFQkFZQy9wTUdEQlVLRmd3QlpnRmxCZ3dHSUM0SEJ4d2VMRmdzL3VQKzR3a1VDZ0l4Q0FBQUFBb0FWLy9iQTYwRHFBQklBSUVBbFFDckFNRUF6UURqQU84QkJRRWhBQUFCTGdFbktnRW5OVFFtSnk0Qkl6RWlCZ2NPQVJVR0ZSd0JGVEFVRlNJR0J3NEJCdzRCRlJFVUZoY2VBUjhCRkJZeklUZ0JNVEkyTno0Qkp6d0JNVFU4QVRVK0FUVVJOQ1luQXc0Qkl5RWlKaU11QVQwQk5EVTBOamMrQVRVOEFUVTBOamMrQVRjK0FUTXlGaGNlQVJVVUZSUVhGQlVlQVJjZUFSY1dCaDBCRkFZSEJ3WXFBU1lqUEFFMUZqSXpOeklXTnpFZUFRY0RKZ1lIQmlZbkxnRTFORFkzUGdFWEZoUVZGQVlISVRZV0Z4WTJOelkwTlRRbUp5NEJCdzRCRlJRV0Z4Y1VCaU1pSmpVME5qTXlGZ2MwTURFMEppTWlCaFVVRmpNNEFURTRBVE15TmpVWEZBWWpJaVkxTkRZek1oWUhOREF4TkNZaklnWVZGQll6T0FFeE9BRXhNalkxQnc0Qkl6RWlKaWN1QVRjeE5oWVhIZ0V6TWpZM1BnRVhNUllHQndONUdrUW9Bd3NHSGlFT2hSQVlmQkFuRFFFRkNnWWlSQjRZSEE4aEV6QWNBUXNKQWd3RUNBTUZBd0UrVWhBa0doNUpLUDQ1QkFjRU9rQkFPZ2xLQWhJSEVBZ2VRU0lrU0NNRklRRWRReHNlS2djR0F3Z2Rhd0Y4bzZBa0RCa05zVDZDUUFFREF3OFNnUTBFREFJQkFRTUNFb2dXQVFFQi9qNFNnQTRFREFJQkFnSVNpUlVCQVFJQm9Cc1RFeHNiRXhNYkdnc0pDQXdNQ0FFSUMvZ2JFeE1jR3hRVEd4b01DQWtNREFrSURDSVBOeHNjTmhBTUJnRUNCdzBNTlJ3Y05Rd01DQUVCQmd3Q3lob2VBUUZPRkM0TEJBVUZCQWt4RlNJaUFRSUNBZ0VCQVFNV0h4cENKdjdFTDFRbEZSd0ZQd2dNQkFJR0ZSd0JBZ1lDQmdNUFpVRUJQeXhZSnYzQUlROEJDbGc0cFZKU09GZ0tBUWdCQVQ4V0Rpd0VBZ0lCQXdNRUF3RUVEUTBPTHk4SENBRUhEUTgxSWg5RUg4TXBUQ0dHQVFFRUtBd0JBUUlCRFNnQ0FoVWZGUW9DQndRQkF3RURCUUVORXlzQkFnSUNBd0lmRlFvQ0J3UUJBd0VEQlFFTkV5c0JBZ0lDQXdKUEZSNGVGUlVlSGdJQkNRd01DUWdNQ3dnVEZSNGVGUlVlSGdJQkNRd01DUWdNQ3dqSEN3d01Dd2tSQVFJQ0JnY0tDd1lHQWdJQkVnZ0FBQUFBQlFBYkFESUQ1UU12QUJJQUt3QTZBRXNBVlFBQUFUZ0JNVEkyTlRRbUl5SUdGVGdCTVJRV013TVZKVGNuTGdNSERnRUhEZ0VITGdFbkpnNENCeFVGSVRBR0ZSUVdNU0V3TmpVMEpqRWxJVEkyTlJFMEppTWhJZ1lWRVJRV016Y2lOalVSSVJFVUZqRUJmeHNtSmhzYkppWWIrZ0k1eGdzRk9FMVdKU2xVRmdvVkN3NHVGaGhJUlRZRkEwUDhjQjBkQTVBZEhmeXJBeG9VR1JrVS9PWVVJQ0FVRWdFQkF2TUJBandtR3hzbUpoc2JKdjYvSmdRTUNSWjdmMTBMQzJVbEVpVVRHRGNQRVN0R1NnOGNpd1lZR1FZR0dSZ0dPQlVUQWkwVUh4OFUvZE1URlQ4TkNBSHQvZ2NFQlFBR0FDQUFXZ1BaQXlNQU1BQm9BSFlBaVFDWkFLd0FBQUV1QVNNeElnWUhEZ0lXRng0Qk16b0JNejRCTnpNZUFSY1dNak15TmpjK0FTNEJKeTRCSXlJR0J3NEJJeUltSndFT0FTTWlKaU11QXpFdUFTY2pJZ1lIRGdFSElpTWlKaWN3Smo0Qk56NEJNeklXTVI0Qk93RXlOamMrQVRNeUZoY2VBZ1l4QVRNVkl4VWpOU00xTXpVekZUTUZGQVlqSWlZMU5EWXpNakF4TWhZVk9BRXhKemdCTVJRR0l5SW1OVFEyTXpJV0ZSVTRBVEVVQmlNaUpqVTBOak00QVRFeUZoVUI1UlZUTlVOektDc2tCd29DREZZL0JBY0VEMTVXMDFaZUR3UUhCRDVYREFJS0NDTXJLWEpETkZFV0JnMEhCZ3dGQVprR0loNENCQUlSTVM0Z0J4UUwrd3dUQndobklnUURIeUlGQ2dRZEp5RkxJekZGQ1JVTEtnd1ZDUWs4TVNOTElTY2RBd24rS1FVNVJqbzZSalFCZ3hrU0VSa1pFUUVSR1dvWkVoRVpHUkVTR1JrU0VSa1pFUklaQXV3UEtFcENSNDUyVWd0RVVBRW5aR1VtQVFGUVJBdFJkWTFIUTBZaERRTUVBd0wrRXlBcEFRRW5MU1VJQ1FFS0J3aHdBeWdnUDJaL1FEWW5LUVlJQ0FZSElpYzJRSDltUHdFbVJUbzZSVG82SnhFWkdSRVNHUmtTUHhFWkdSRVNHUmtTZFJJWkdSSVNHUmtTQUFzQUZ3QUNBK2NEaUFBdEFGNEFlQUNKQUxZQXd3RFdBT2tBL3dFVkFTZ0FBQUVqTno0Qk5UZ0JNUzRCSXlJR0R3RW5MZ0VqSWdZVk9BRXhGQllmQVNNT0FRY1JGQll6SVRJMk5SRXVBU2NURkFZaklTSW1OUkUwTmpNaEp5NEJOVGdCTVRRMk16Z0JNVElXSHdFM1BnRXpNaFlWT0FFeEZBWVBBU0V5RmhVUkFTRXdJakVpQmhVNEFURVZGQll6TURJeklUSTJQUUUwSmlNVEZBWWpJU0ltUFFFK0FUTWhNaFlkQVNjbUJqRU9BU3NCSWlZbkxnRUhCaFl4SGdFM1BnRXhQZ0V6T0FFeE16Z0JNVElXRng0QkZ4WTJOeUkySndjVkl4VWpOU00xTXpVekZUTVhJaVkxTkRZek1oWVZPQUV4RkFZak9BRXhOU0ltTlRRMk16SVdGVGdCTVJRR0l6Z0JNUmM0QVRFaUpqVTBOak15RmhVNEFURVVCaU00QVRFbEZBWWpJaVkxTkRZek9BRXhPQUV4TWhZVk9BRXhKelEyTXpJV0ZSUUdJemdCTVNJbU5UZ0JNUU5xcWhjTUR3RTBKaE1oREZoWURDRVRKVFVPREJlcU0wa0JTak1DMWpOS0FVa3pOeDhZL1NvWUhoNFlBVWVHQXdRUENnVUtBNGFHQXdvRkNnOEVBNFlCUnhnZi90TCtoUUV3UkVRdkFRRUJlekJIUnpCV05TVCtnaVF2QVRJa0FYNGtNWUVrVVFRS0JSTUZDZ1FFVGlNaUJ3SVJEeEF4QXdrRmNRVUpBd011RUE4UkF3RUlJN1VjSEJjWEhCeG9DQXNMQ0FnTEN3Z0lDd3NJQ0FzTENEQUlDd3NJQ0FzTENBRlBJQllXSHg4V0ZpQnJIeFlXSHg4V0ZoOEMyUlVNSVJNbE5RNE5WMWNORGpVbUVpRU1GUUZKTS80Zk0wWkdNd0hoTTBrQi9hSVlJQ0FZQWVFWUk0VUVDUVVLRHdRRWhvWUVCQThMQlFrRGhTUVkvaUFCMzBRdzh6QkRRakh6TUVUK2x5UXhMeVA2SXpNMEpQWEtPU0VEQXdNREF4ODZPV2NQRXdJQk5RTURBd1FETWdFQkVoQm1PaDhhSEJ3Y0hSMDhDd2dJQ3dzSUNBczFDd2dJQ3dzSUNBc2REQWdJQ3dzSUNBd1pGaDhmRmhZZ0lCYVRGaDhmRmhZZ0lCWUFBQUFBQXdBYS85TUQ1d09nQUJRQUxBQkRBQUFGSWk0Q05UUStBak15SGdJVkZBNENJeEU0QVRFaURnSVZGQjRDTXpJK0FqVTBMZ0lqRXo0Qk5UUW1Md0VSTkNZaklnWVZFUmNlQVRNeU5qY0NBR1N4aEUxTmhMRmxaTEtFVEUyRXNXVlRrbTAvUDIyU1UxU1NiVDgvYlpKVTNnVUdDZ2lrSGhVVkhjZ0hFQW9MRlFjdFRJU3laR1d4aEUxTmhMRmxaTEtFVEFONFAyMlRVMU9TYlVCQWJaSlRVNU50UC8yU0JoRUpEQlFIaUFFTUZSMGRGZjdFcGdZR0Nna0FBQUFDQUJjQUd3UGxBMWtBQmdBS0FBQVRGeE0zQlJNQkFTY0pBUmU4TmQ4Qko5ZjhNZ0VwQ3dJdi9kd0I2bUwrazlhR0F1NytrZjdpbndGNS9lZ0FBQUFBQlFDNC85MERSZ09xQUNNQU1nQkFBRWtBaGdBQUFUSWVBaFVVQmdjNEFURVVCaU00QVRFaE9BRXhJaVluTGdFMU5ENENNemdCTVJNeUZoVVVCaU1oSWlZMU5EWXpJUlV5RmhVVUJpTWhJaVkxTkRZekZ4UUdLd0VpSmpVekF3NERGUlFXRng0QkZ4UVdGdzRCRlJRV0Z3NEJGUlFXRng0Qk93RXlOamMrQVRVMEppYytBVFUwSmljK0FUVStBVGMrQVRVMExnSW5NUUgvTjJGSUtsc01FQXYrOEFrUEFoZFJLa2hoTjRVTEVCQUwvdllMRUJBTEFRb0xFQkFML3ZZTEVCQUwrU1FpWFNRajZuUkRkMWswSkJRUUd3VUdCUVFFQlFRRUJSOFpDajBvYWlnOUNSb2dCZ1FFQlFRRUJRWUZHeEFVSkRSWWQwUURiU3BJWVRkdFZYWUxFQXNJYzJCdE4yRklLdjJCRHdzTEVCQUxDdzlaRGdzTEN3c0xDdzVTRmlFaEZnTm5BVE5aZDBORVZpTWRPeThLRkFrSEV3b0xGUWtJRkFzY0xBb2xNREFrQ2kwY0N4UUtDQlFMQ2hNSkNCTUtMenNlSWxaRVJIWlpNd0VBQUFRQTFQL1hBeXdEcGdBZEFDc0FPUUJDQUFBQk1oNENGUlFHQnpnQk1SUUdJemdCTVNFaUppY3VBVFUwUGdJekV6SVdGUlFHSXlFaUpqVTBOak1GTWhZVkZBWWpJU0ltTlRRMk13VVVCaXNCSWlZMUlRSUFQbTVSTDJjT0VRMyt6ZzBRQVJsY0wxSnRQcFlNRWhJTS90UU5FUkVOQVN3TkVSRU4vdFFORVJFTkFSa3FKbWtuS0FFSUE2WXZVVzQrZW1DR0RCSVBCNEZ0ZWo1dVVTLzlNQkVOREJJU0RBMFJaUThNRFEwTkRRd1BYQmtsSlJrQUFBQUVBSmIvM1FOcEE2b0FHd0F6QUZNQVlRQUFBVEllQWhVVUJnY0REZ0VqSWlZbkF5NEJOVFErQWpNNEFURVJNajRDTlRRdUFpTWlEZ0lWRkRBeEhnTXpFVGdCTVNJT0FoVVVGaGNtTWhVVEhnRXpNalkzRXo0Qk5UUXVBaWN4RVNJbU5UUTJNeklXRlJRR0l6RUNBRDl2VXpBWkdQWUJCZ01EQmdINEZoa3dVMjgvS2tzM0lTRTNTeW9xU3pjaEFTQTNTeXBMaEdJNUh4c0JBZllKSHhJU0hncjJHeDQ0WW9STFBWZFhQVDVXVnowRGNUQlRiejh1VlNQK2dRSURBd0lCZ1NOVExqOXZVekQrQWlBNFNpc3FTamdnSURoS0tnRXFTamdnQWpZNFk0TkxObVFxQVFIK2dRNFNFZzRCZnlwak4wdURZemdCL2dGWFBUNVhWejQ5VndBQUFBSUFrLy9aQTJZRHBRQWVBQzRBQUFFNEFURWlEZ0lWRkJZWEpqQXpFeDRCTXpJMk54TStBVFUwTGdJakVTSW1OVFEyTXpJV0ZUZ0JNUlFHSXdIOVM0UmlPUjhiQVFIMkNSOFNFaDRLOWhzZU9HS0VTejFYVnowOVYxYzlBNlU1WW9STE5tUXFBZjZBRGhFUkRnR0FLV1EyUzRSaU9mNENWajQ5VjFjOVBsWUFDUUJMLzlrRHVBT3BBQ2dBTFFBeEFEVUFPUUE5QUVFQVJRQkpBQUFCSVNvQk1TSUdGUndCTVJFY0FURVVGak13TWpNaE1ESXhNalkxTURRMUVUQTBOVFFtSXpBaU1RVXpGU00xQVNFMUlUY2hOU0UzSVRVaE5TRTFJVFVoTlNFMUlUVWhOU0UxSVFONi9SQUJBUmtrSkJrQkFRTHdBUmtrSkJrQi9XZjUrUUdtL2xvQnBwYjl4QUk4QmYzRUFqejl4QUk4L2NRQ1BQN1VBU3orMUFFc0E2a2tHUUVCL0s0QkFSa2tKQmtCQVFOU0FRRVpKSmVhbXYxaUpVSXFRaVZDS2tJbFFpcENKUUFHQUtyLzRnTk5BNThBRmdBOUFFc0FXQUJyQUg0QUFBRWhJZ1lWRVJRV015RXdNak15TmpVME1ERVROQ1lqQXc0Qkp5NEJNUzRCSnlNT0FRY09BUWNHSmljd0pqYzJGakVlQVJjelBnRTNQZ0VYRmdZeEp6TVZJeFVqTlNNMU16VXpGVE1YRkFZaklpWTFORFl6SGdFVkJ4UUdJeUltTlRRMk16Z0JNVElXRlRnQk1UVVVNREVVQmlNaUpqVTBOak00QVRFeUZoVUMzZjVBTGtWRkxnSEFBUUVzUHdOQ0xpVURFaEVSTmdNS0JYc0dDZ01FTWhFUkVnTUlKeVpaQlFvR0ZBWUtCUVJWSmljSTV3RWNIQjBkSEJ1K0RBa0pEQXdKQ1F3MERBa0pEQXdKQ1F3TUNRa01EQWtKREFPZlBpMzlGaXc4UHl3QkF1WXRQdjNGRVJRQ0FUc0VCQUVCQkFRRU53RUNGQkZ3UHo4bkF3UUJBUVFEQkNJL1BuQ1FIQ0VoSEIwZEVna01EQWtJRFFFTUNCc0pEQXdKQ1F3TUNUb0JDQTBOQ0FrTURBa0FBQUFFQUIzLzdRUGdBNHdBTmdCR0FJTUFsZ0FBQVJRR0J3NEJCdzRCQnc0QkJ5TTFORFkzUGdFM1BnRTNQZ0UxTkNZbkxnRWpLZ0VqSWdZSERnRUhKejRCTno0Qk16SVdGeDRCRlFFaUJoVVVGak15TmpVdUFTTTRBVEVuSGdFVkZBWUhEZ0VIRGdFSEZBWVZGQllYQnljdUFUVThBVFUrQVRjK0FUYytBU2N1QVNjbUlnY09BUWNPQVJjSEpqWTNQZ0UzUGdFWEhnRVhBdzRCRlJRV016STJOVFFtSnk0Qkl5SUdCd1BnRGd3Tk9Db2ZKZ2dJQ0FITUJnWUhFZ3dNT2l3YUdnd0xDeUVWQVFFQkZTWU9EeElFMFFjc0pTWjNVRDlsSmpRei9yb3VRa0l1TDBJQlFTL2xBZ01DQXdRYUZROFNBd0VDQW9ZQ0JBVUJCZ1VHR3hZTkNRTUREUW9KRnc0UEZ3WUhBd09PQmdvU0VrYzBLVWdkS1RNTGhCZ2ZMUjhnTFFJQkJ5a2FCUXNHQXA4Wkx4UVZPQ0VaSmhBT0loVU1IQ3dSRWg4TkR6TWxGU2NURWg0S0Nnc1JEZzR1SVJvNlhpTWxKUm9aSTF3Ny9sWkJMeTVDUWk0dlFlUUhFUWtJRVFnUUx4NFdJUXNGQ1FVSUR3Z21DQTBjRUFFQ0FRMFlDd3dzSVJNZURBc1NCUVVFQkJJTURDSVdGeWRHSGg4d0R3d0NDZ3d6SnY2ckNDZ2FJQzB0SUFZTEJSZ2ZBZ0VBQUFBQUFRQVlBRkVEMVFNakFCY0FBQWtCQmlZOUFUQXVBaWNlQXpFMU5EWVhBUjRCQndQVi91SUpEcXpmMUNsWDRNZUtEZ2tCSGdnQkNRR0IvdEFIQnd1Qk1ZTGlzVjFmSndOL0NnY0cvdGtIRWdZQUFBQUFCd0FkQURZRDZRTTRBQTBBSGdCRkFGVUFhQUIwQUljQUFDVVVCakVoTUNZMU5EWXhJVEFXQXhFVUJpTWhJaVkxRVRRMk15RXlGaFVGSmdZeERnRXJBU0ltSnk0QkJ3WVdNUjRCTno0Qk1UNEJOek1lQVJjZUFSY1dOamN3TmljSElnWVZGQll6TWpZMU5DWWpPQUV4TlNJR0ZSUVdNekkyTlRnQk1UUW1JemdCTVFjMUl4VWpGVE1WTXpVek5UY2lCaFVVRmpNeU5qVTRBVEUwSmlNNEFURUQ2UjM4YmgwZEE1SWRLU1VUL09zVEd4c1RBeFVUSmY3Ykoxa0ZDZ1lWQlFzRUJGWW1KZ2NERXhBUk5nUUpCbndGQ2dNRU14QVJFd0lJSms4SkRBd0pDUXdNQ1FrTURBa0pEQXdKa0NFY0hDRWNxUWtORFFrSURRMElWeGtJQ0JrWUNRa0NsLzNTRkJnWUZBSXVFeDhmRThGQUpnTUZCQVFESXo5QWNSRVVBUUU4QkFRQkFRUUVCRGdCQWhVUmNUODNEUWdKRFEwSkNBMDZEQWtKREF3SkNRd2dGeGNoSEJ3aEFRMEpDQTBOQ0FrTkFBVUFIZi9YQThNRHBRQVVBQ29BTlFCUEFIZ0FBQUVWTWhZWEhnRVhGaFFIRGdFSFBnRTNQZ0V6TlRFaUJnY09BVEVlQVRNeVBnSTNOaVluTGdFak1ROEJMZ0VuRGdFeEZqWTNBUTRCQnc0QkJ3NERCeThDUGdNM1BnRTNQZ0UzTnlJT0FnY09BekVHRmpFWEhnRXpPQUV4TWpBeE1ENENOejRESnk0Qkl6Z0JJekVCRUFvUUJ4TWdCUUlPRGw5eEV5b1dCQ1FYSmprSU9sTU5HZ3hPYkVjbkNTSW5NZ3dkRURJekNSRUZNRUJCWlNZQ3ZnTVhIQ0ZmUENOSFFUWVFIeFlERVRVNU5oRVlaVFpBVHhNTUgzQjBaeGNYVEVjMEVDNDRFZzBCQVRCTlhpOUdiVUFRRlFNSUJBRUJHeW9IQlEwY0N3UVRGeFpmQ2g1Y1F3d2tLalVZcmtjQkFTUXhNZzQyUVNRSkM2UTdFaUlRZGpFRkRnNERpQXcwTGpON1FpZEtQekFQSEJVREYwZExSQlViWWk0MU1RWXRTR0pqR3h4aFlFWVNDelFMQlNwSVh6UlBqM0JMQ3dJQkFBQUFBQUVBQUFBQkFBQWxCRXQxWHc4ODlRQUxCQUFBQUFBQTFCcHgwZ0FBQUFEVUduSFMvLzMvd0FRSEE4RUFBQUFJQUFJQUFBQUFBQUFBQVFBQUE4RC93QUFBQkFELy9mLzVCQWNBQVFBQUFBQUFBQUFBQUFBQUFBQUFBTXdFQUFBQUFBQUFBQUFBQUFBQ0FBQUFCQUFBQlFRQUFBQUVBQUFBQkFBQU1BUUFBQXNFQUFBaUJBQUFJQVFBQUFBRUFBQUVCQUFBQUFRQUFBQUVBQUF6QkFBQU13UUFBRXNFQUFBQUJBQUFsQVFBQUFBRUFBQUFCQUFBNmdRQUFDY0VBQUFiQkFBQVZRUUFBQUFFQUFBRkJBQUFYUVFBQUdJRUFBQmlCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFCWUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBVVFFQUFBQUJBQUFBQVFBQUFBRUFBQUNCQUFCQWdRQUFIa0VBQUFBQkFBQUFBUUFBTlVFQUFEVkJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQlVFQUFCZkJBQUFYd1FBQUlrRUFBQ1hCQUFBQndRQUFBY0VBQUFBQkFBQUFBUUFBQUFFQUFDYkJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQURRUUFBQUFFQUFBQUJBQUFHZ1FBQUJzRUFBQUFCQUFBQkFRQUFBQUVBQUFBQkFBQUFBUUFBUlFFQUFBQUJBQUFHZ1FBQUFBRUFBQjBCQUFBQUFRQUFBQUVBQUJaQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFCd1FBQUFBRUFBQUFCQUFBVUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFDS0JBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUlFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFFQkFBQU13UUFBRE1FQUFBekJBQUFGQVFBQUFRRUFBQVRCQUFBQUFRQUFBQUVBQUE2QkFBQVZRUUFBRG9FQUFBNkJBQUFPZ1FBQURvRUFBQTZCQUFBT2dRQUFBQUVBQUFJQkFBQUFnUUFBQUFFQUFBRUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFEQUVBQUJTQkFBQUFBUUFBQUFFQUFCeEJBQUFWQVFBQUFBRUFBQUFCQUFBSWdRQUFCd0VBQUN2QkFELy9RUUFBQUFFQUFBQUJBQUFBd1FBQUNJRUFBQXlCQUFBSXdRQUFJTUVBQUE5QkFBQU1RUUFBREVFQUFBY0JBQUFNd1FBQUFBRUFBQkZCQUFBUXdRQUFFd0VBQUJLQkFBQUlBUUFBRmNFQUFBYkJBQUFJQVFBQUJjRUFBQWFCQUFBRndRQUFMZ0VBQURVQkFBQWxnUUFBSk1FQUFCTEJBQUFxZ1FBQUIwRUFBQVlCQUFBSFFRQUFCMEFBQUFBQUFvQUZBQWVBRm9BdkFEVUFRSUJqZ0hFQWdZQ1dnTEtBeW9EVmdPUUJDQUVrQVRlQlVBRmxBWG9CbVFHckFkY0I0QUh2Z2dZQ0d3SXdna1NDaHdLZmdyU0Mzb01EZ3hLRElBTW5nejBEVUlOZWczOERwUU91aEFjRUpnUkZCSEFFZ0FTUGhKK0Vyd1MraE02RTNvVHVoUXVGS0FWRWhXRUZiZ1Y3QllnRmxRV2NCYU9GcW9XeEJlZUdJNFkwQmpzR1I0Wk9obHdHYm9aOEJvYUdrUWFnQnE4R3k0YnVoeFNIT29kMWg0WUhvNGV0QjlPSUZRZ2xpRUdJV0FoeGlNc0kyNGtGQ1NPSk9RbFppWE9Ka2dueGlncUtJNG8wQ2swS1lZcHdpb0VLb1lxMWlzdUs3b3IrQ3hBTEhZdFBDNElMdnd2M2pFUU1wSXpEak5tTkRnMUNEVitOcFEzSERoU09KWTVMRG1FT2w0N2dqdzBQSVE5a0Q2QVAxNUJBa0pVUS9oRnBFYmtTREpKbWt2Q1RzaFBrbEJBVUxKUkJGRmVVZkJTZUZQK1ZIQlV6bFZxVm5aV3NGY2FXQXBZMWxsK1dlUmFRbHFJV3RSYmdsd2lYZnBnMEdFQVlZcGljR0xPWXlKamhHUUlaSVpsckdaK1p1Sm9XbWpRYWF4ckJtdGthNFJzTkd5UWJSSnRVbTIyYmxodk1tOWNjQVp3cmdBQUFBRUFBQURNQWtzQUZnQUFBQUFBQWdBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT0FLNEFBUUFBQUFBQUFRQUtBQUFBQVFBQUFBQUFBZ0FIQUhzQUFRQUFBQUFBQXdBS0FEOEFBUUFBQUFBQUJBQUtBSkFBQVFBQUFBQUFCUUFMQUI0QUFRQUFBQUFBQmdBS0FGMEFBUUFBQUFBQUNnQWFBSzRBQXdBQkJBa0FBUUFVQUFvQUF3QUJCQWtBQWdBT0FJSUFBd0FCQkFrQUF3QVVBRWtBQXdBQkJBa0FCQUFVQUpvQUF3QUJCQWtBQlFBV0FDa0FBd0FCQkFrQUJnQVVBR2NBQXdBQkJBa0FDZ0EwQU1oc1pXZHZMV2xqYjI1ekFHd0FaUUJuQUc4QUxRQnBBR01BYndCdUFITldaWEp6YVc5dUlERXVNQUJXQUdVQWNnQnpBR2tBYndCdUFDQUFNUUF1QURCc1pXZHZMV2xqYjI1ekFHd0FaUUJuQUc4QUxRQnBBR01BYndCdUFITnNaV2R2TFdsamIyNXpBR3dBWlFCbkFHOEFMUUJwQUdNQWJ3QnVBSE5TWldkMWJHRnlBRklBWlFCbkFIVUFiQUJoQUhKc1pXZHZMV2xqYjI1ekFHd0FaUUJuQUc4QUxRQnBBR01BYndCdUFITkdiMjUwSUdkbGJtVnlZWFJsWkNCaWVTQkpZMjlOYjI5dUxnQkdBRzhBYmdCMEFDQUFad0JsQUc0QVpRQnlBR0VBZEFCbEFHUUFJQUJpQUhrQUlBQkpBR01BYndCTkFHOEFid0J1QUM0QUFBQURBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy9mb250cy9sZWdvLWljb25zLndvZmZcbi8vIG1vZHVsZSBpZCA9IDI0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LEFBRUFBQUFMQUlBQUF3QXdUMU12TWc4U0JyZ0FBQUM4QUFBQVlHTnRZWER1SkpldkFBQUJIQUFBQUhSbllYTndBQUFBRUFBQUFaQUFBQUFJWjJ4NVppeUpZYndBQUFHWUFBRGhYR2hsWVdRTFdDZ2lBQURpOUFBQUFEWm9hR1ZoQjhjRWhnQUE0eXdBQUFBa2FHMTBlQ1lCSEFNQUFPTlFBQUFETUd4dlkyR0M5a3Y4QUFEbWdBQUFBWnB0WVhod0FPTUNUUUFBNkJ3QUFBQWdibUZ0WmFYWXc3a0FBT2c4QUFBQnFuQnZjM1FBQXdBQUFBRHA2QUFBQUNBQUF3UDlBWkFBQlFBQUFwa0N6QUFBQUk4Q21RTE1BQUFCNndBekFRa0FBQUFBQUFBQUFBQUFBQUFBQUFBQkVBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFBRHBrUVBBLzhBQVFBUEFBRUFBQUFBQkFBQUFBQUFBQUFBQUFBQWdBQUFBQUFBREFBQUFBd0FBQUJ3QUFRQURBQUFBSEFBREFBRUFBQUFjQUFRQVdBQUFBQklBRUFBREFBSUFBUUFnNEFqbWwra2w2U2Zwa2YvOS8vOEFBQUFBQUNEZ0FlWUE2UURwSittUi8vMy8vd0FCLytNZ0F4b01GNlFYb3hjNkFBTUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFCQUFILy93QVBBQUVBQUFBQUFBQUFBQUFDQUFBM09RRUFBQUFBQVFBQUFBQUFBQUFBQUFJQUFEYzVBUUFBQUFBQkFBQUFBQUFBQUFBQUFnQUFOemtCQUFBQUFBRUFCZi8xQS9zRGh3QW9BQUFCTlRRbUt3RWlCaDBCSnlZaUJ3RXdCaGNXTmpFUklSRTBOanNCTWhZVkVTRVJNQlkzTmlZeEp3TkRFQkZFRVE2bkNSMEwvaDRLSFIxV0FRUVJFWjBSRWdFRFhSc1pDcmdDbjhjT0V4VU1ZNEFJQ1A2UUtDWWpDZjVLQVNZT0VoTVAvdHdCdFFjbkpTU01BQVVBQVAvQUJBQUR3QUFUQURRQU9BQThBRUFBQUFFaURnSVZGQjRDTXpJK0FqVTBMZ0lETlNNVkxnTW5NelVqUGdNM0ZUTTFIZ01YSXhVekRnTUhHd0VGRnljWEJ6Y25BeVVuQWdCcXU0dFFVSXU3YW1xN2kxQlFpN3MvVmt1RlpVRUliMjhJUVdXRlMxWkxoV1ZCQjI1dUIwRmxoVXMzbC82bHhMWnJ2VklPbHdGYnhBUEFVSXU3YW1xN2kxQlFpN3RxYXJ1TFVQeFlibTRIUVdXRlMxWkxoV1ZCQ0c5dkNFRmxoVXRXUzRWbFFRY0JSd0ZhbU1KNGFsTzlTdjZtbU1JQUFBQUJBQUFBTVFRQUEwOEFEQUFBSlJFak5TRVZJelVoRlNNUklRUUFlLzdObXY3RGV3THNNUUtaaFlXRmhmMW5BQUFCQUREL3dBUE5BOEFBSGdBQUFTTTFOQ1lqSVNJR0ZUQVVGU01pQmhVUkZCWVhGU0UxUGdFMUVUWW1Jd01iT2hFSy9uY01EejFMYW1KRkFrOUhZQUpwU3dNUGxnb1JEd3lVQW1oSy9uUkZad1ZnWUFWa1NBR1BTR2NBQUFVQUN3QjdBL1VDN1FBeUFFQUFUUUJaQUdZQUFBRXVBUTRCTVE0Qkt3RWlKaWN3TGdFR0J3NENGakVlQVRjK0F6RStBVE1oTWhZWE1CNENGeFkyTnpBMkxnRW5CUlVqRlNNMUl6VXpOVE1WTXhVRklpWTFORFl6TWhZVkRnRWpOU0ltTlRRMk16SVdGUTRCRnlJbU5UUTJNeklXRlE0Qkl3T2xNM2RtUXdvZ0RUWU1JUXBEWm5jek15WUVEUWN5TEJaQU95b0pIUXdCUmd3ZENTbzdRQllzTWdjTkJTWXkvZk5OVVUxTlUwMEJMQllnSUJnWElRRWlGeFlnSUJnWElRRWlkUmNoSUJnV0lnSWdGZ0txVXlvUktRY0xDd2NwRVNwVFZLYUVVaTAxQXdJeU96RUtEUTRKTVRzeUFnTTFMVktFcGxSYVMwMU5VMDFQQnFnZ0ZoY2hJUmNXSUpnaEZ4Y2hJQmdYSVZJaUZoY2hJQmdXSWdBQ0FDTC80Z1BlQTU0QUZBQWhBQUFCSWc0Q0ZSUWVBak15UGdJMU5DNENJd01HSmpVUk5EWVhCUllVQndVQ0FHT3Vna3RMZ3E1alk2NkNTMHVDcm1OVkJnc0tCd0U5QndmK3d3T2VTNEt1WTJPdWdrdExncTVqWTY2Q1MvMHdCQVVJQWRJSkJBWHBCQTRGNHdBQ0FDRC8yd1BHQTZRQURnQXFBQUFCSGdFSERnTW5NRFkzUGdFWEFTWU9BZ2NPQXpFR0ZqRVhGall4TUQ0Q056NERKd0ZOTWlZaENpeFNmMTFUT2d0ZE9BSjVHWEYrY0JrWFRFYzBFQlE0RnlRd1RWNHZSMnhCRHhVQkNTVkJOUkEzTXlFSVJxNGlRQ2dDbXcxRFptMGRHMkpmUmhJZ05BOFRLMGhlTkZDUGNFb01BQUFEQUFELy9RUUFBNE1BR2dBdUFEb0FBQUVqTlRRbUl5RWlCaDBCSXlJR0ZSRVVGak1oTWpZMUVUUW1Jd0VpTGdJMU5ENENNekllQWhVVURnSW5JaVkxTkRZek1oWVZGQVlEeHJRL0xQNnlMRCsxRnlJaUZ3T05HQ0lpR1A0Nk1WZEJKaVpCVnpFeFYwRW1Ka0ZYTVR4VlZUdzhWVlVDNXl3c1JFUXNMQ0VYL1lZWElTRVhBbm9YSWYyY0prRlhNVEZYUVNZbVFWY3hNVmRCSmw1VlBEeFZWVHc4VlFBQUFBQURBQVQvd0FQOEE4QUFQQUJFQUVzQUFBRW5JejRCTVNFd0ZoY2pCeFFHSGdFWEhnRVhGUjRCRlJRR0J6QUdGUTRCQnc0Qk1TRXdKaWN1QVNjMEpqRXVBVFUwTmpjMVBnRTNQZ0ltTlFVekhnRVhMZ0UzQVQ0Qk56TVdCZ1A4QkxrQ0F2MTZBZ0s1QkFndGZvUXJaQkFIQ1FrSEJ3NGRFQzBlQVlZZUxSQWREZ2NIQ1FrSEVHUXJoSDR0Q1B4RGhRY2RHWlV4QkFMQUdSMEhoUVF4QTFrYkl5a3BJeHNDVG55YlRWSStEZ0VIZGdzTEV3Y0ZBUWdZRHk0Mk5pNFBHQWdCQlFjVEN3dDJCd0VPUGxKTm0zeE9BaVZ1V1Y1OWFqNysyMTVaYmo1cUFBUUFBUC9zQkFNRGZBQVdBQ29BTndCREFBQUJJeEVVQmlNaEZSUVdNeUVYTXpVek1qWTFFUzRCSXdNaElnWVZFUlFXT3dFVk16Y2hNalkxRVRRbUFTTTFORFkzRlE0QkhRRXpGVE1qTlRRMk54VU9BUjBCTXdQR2hSTVAvcW9LRWdGTFZRbzZFaWdDS1JMaC9WSVNKU1VTUFNseEFkY1BKeVQrWG5BNE9Cd0pKZUp1T0RZZEswZ0NUUDdvRWdheEVDUkxTeUlTQWE0UEpBRXdHeEwrSEJJWGRIUVpFQUhrRWh2K2hYUXhOZ010QlNFWEJIQjBNVFlETFFVaEZ3UUFBQU1BQVAvQUJBQUR3QUFQQUJNQUZ3QUFBU00xSVNJR0ZSRVVGak1oRVRNbk53TWhFU0VGSVJVaEJBQ0ovTTBjS0NnY0F6T0ppWW52L2J3Q1JQNU5BU0wrM2dNM2lTZ2MvSWdjS0FKbWlZajg3d00wcTRrQUFBQUVBRFAvd0FQTkE4QUFFQUFVQUJnQUpBQUFBU0VpQmhVUkZCWXpJVEkyTlJFMEppTURJVFVoTlNFMUlUVWhFVE0xTXhVek5UTVZNd09KL080Y0tDZ2NBeEljS0NnY2d2M3lBZzc5OGdJTy9mWTlwRTZkUGdQQUtCejhpQndvS0J3RGVCd28vSjBwVWlsdEFWVkZSVVZGQUFBQUFBUUFNLy9BQTgwRHdBQVFBRmNBWEFCaEFBQUJJU0lHRlJFVUZqTWhNalkxRVRRbUl3VStBVE0rQVRNZUFSY2VBUmNlQVJjZUFUY3dNakUrQVRNeUZoVVVCaU1pSmljeERnRUhEZ0VIRGdFSERnRWpMZ0VqSWlZM05EWTNQZ0UzUGdFbkxnRW5KZ1luSWlZM0FTRTFJUlUxSVRVaEZRT0ovTzRjS0NnY0F4SWNLQ2djL1hNRURBa1NUd2NNRVFjR0NnVUZEUWNKY2dRQkRTMGNLRGs1S0JncERoNDVIUVVKQlFvUEJ3c2RFeFl1Rmd3UUFRNEtEQmdNSFJBTUJoMExEd2tQRGc4R0Fndjk4Z0lPL2ZJQ0RnUEFLQno4aUJ3b0tCd0RlQndvOHdnSkFnTUJEUWtIRHdjR0NBSUVBUUVYSERrb0tUZ1JFUUlCQWdFR0F3Y1ZDZzROQVFFUkRBb09BZ0lHQmc0NUdRd1RBd01CQVJZTi9ZRXpNMzR6TXdBQUFBb0FTLy9YQTdnRHB3QW9BQ3dBTUFBMUFEb0FQZ0JDQUVjQVRBQlJBQUFCSVRBaU1TSUdGVEFVRlJFd0ZERVVGak02QVRFaE1qQXpNalkxTURReEVUQTBNVFFtSXpBaU1STWhFU0VCSVJVaE5TRVZJVFUzSVJVaE5UVWhGU0VWSVJVaEFTRVZJVFUxSVJVaE5TRXpGU00xQTNuOUVRRWFKQ1FaQVFFQzd3RUJHU1FrR2dFQy9SSUM3djFtQWFiK1dnSTQvY2dGQWpmOXlRSTMvY2tDTS8zTkFSQUJKLzdaQVNmKzJmN3IrZmtEcHlRYUFRSDhyd0VhSkNRYUFRTlNBUm9rL0hJRFRQMHpLcEVtSnRNcUttY2xzeVVCWkNVbGJDb3FuNThBQUFBQUNBQUEvOEFFQUFQQUFBTUFCd0FZQUJ3QUlRQW1BQ29BTGdBQUFTTTFNeWtCRlNFVEVSUUdJeUVpSmpVUk5EWXpJVElXRlFjaEVTRUJJeFV6TlNrQkZTRTFCU01WTXlVaEZTRUJWV1ptQWJ6K3F3RlY3eWdjL0lnY0tDZ2NBM2djS0ZYOHFnTlcvYXBtWmdHOC9xc0JWZjVFWm1ZQnZQNnJBVlVDV21abUFTTDhpQndvS0J3RGVCd29LQndSL0tvQjNtWm1abWJOWm1abUFBQUFBZ0NVLzhBRGJBUEFBRE1BUUFBQUFSUUdCdzRCQnc0QkJ3NEJCeU0xTkRZM1BnRTNQZ0UzUGdFMU5DWW5MZ0VqSWdZSERnRUhKejRCTno0Qk16SVdGeDRCRlFFaUJoVVVGak15TmpVMEppTURiQkFQRDBBeEl5MEpDUW9CNndjSEJ4WU9Ea0l6SGg0TkRRMGxHUnNzRVJFVkJmRUlNeXNzaWx4SWRTdzhPLzZITmt4TU5qWk1URFlDcnhzMUdocEFKaHd0RWhBb0dBNGdOQk1VSkJBUVBDb1pMUllWSVF3TURCSVJFRFVtSGtKdEtTb3JIaDRvYWtQK0ZFdzFOa3hNTmpWTUFBSUFBUC9BQkFBRHdBQVBBRHNBQUFFeUZoMEJGQVlqSVNJbVBRRTBOak1CTGdNbkxnRUhKZ1lIRGdNSEJoWXpPZ0V6SEFFVkZCWXpNaUl6TWpZMVBBRTFPZ0V6TWpZbkE5d1BGUlVQL0VnUEZSVVBBdmNoUVVKQklRVUtCZ1lMQkNGQlFrRWhEQXdWSEg0YkVnMDhGRHdORWh0K0hCVU1EQVBBRlE5QkR4VVZEMEVQRmYyckowOVBUaWdGQlFFQkJRVW9UazlQSnc0bGQyeDNEQklTREhkc2R5VU9BQUFBQUFJQUFQL0FCQUFEd0FBUUFEd0FBQmNpSmowQk5EWXpJVElXSFFFVUJpTWhFeDRERng0Qk54WTJOejRETnpZbUl5b0JJendCTlRRbUl5SXlJeUlHRlJ3QkZTb0JJeUlHRnlRUEZSVVBBN2dQRlJVUC9FakJJVUZDUVNFRkNnWUdDZ1VoUVVKQklRd01GUngrR3hJTlBCUThEUkliZmh3VkRBeEFGUTlCRHhVVkQwRVBGUUpWSjA5UFRpZ0ZCUUVCQlFVb1RrOVBKdzRsZDJ4M0RCSVNESGRzZHlVT0FBQUFBQVVBNnYvQUF4WUR3QUFRQUI4QUt3QXdBRmdBQUFFaElnWVZFUlFXTXlFeU5qVVJOQ1lqQnpNeUZoVVVCaXNCSWlZMU5EWXpFeUltTlRRMk16SVdGUlFHTnlFUklSRUJPZ0V6UEFFMU5EWXpNaUl6TWhZVkhBRVZPZ0V6TWhZSERnRUhEZ0VuQmlZbkxnRW5Kall6QXNUK2VDSXdNQ0lCaUNJd01DTHZXd1VGQlFWYkJRVUZCUzRSRnhjUkVCY1h4ZjVRQWJEK3d3b3hDd2NFR0FnWUJBY0xNUW9KQkFRYU1ob0NCQUlDQkFJWk14a0ZCUWdEd0RBaS9LUWlNREFpQTF3aU1Fc0dCQVFHQmdRRUJ2eDZGeEVRR0JnUUVSZDdBcXo5VkFGV0xpb3VCUVlHQlM0cUxnNEdIajBmQWdJQkFRSUNIejBlQmc0QUFRQW4vOEFEMlFQQUFEZ0FBQUUxQlJFVUJqRU9BUlVVRmpNd01qRTRBVEV5TmpjK0FUVThBVEVSSlJFVUJqRU9BUlVVRmpNeU1ERXlNREV5TmpjK0FUVTBKakVSTVFQWS9VQlZRVnRlUWdFeFVTQWhJUUdZVlVCYlhVSUJBVEJTSUNBaUFRTXNsTi8rUmlJSEFWeEJRMTBkSFI1TUxEQ1dBUjZIL3BzaUJnSmNRVUplSGgwZFRDMHZsZ0ZuQUFBQUJnQWIvOEFENVFQQUFCY0FJd0FxQURFQWRRQjZBQUFCSWdZVkZCWVhNQlF4Rng0Qk16STJQd0UrQVRVMEppTVJJaVkxTkRZek1oWVZGQVlCRnpBeU15b0JOd2N3SWlNNkFRRW5KZ1lIQmhZZkFSRW5OVEFtSXlJR01SVUhFVGMrQVNjdUFROEJKU1lHQnc0QkZSRVVGaGNGRmpJekZqSXpPZ0UzT2dFM0pRVXlGak15TmpjK0FUVVJOQ1luQVNjUkZ4RUNsMDl3RUE2Q0JSRUpDUkFGZ2c4UGIwOGhMUzBoSUM0dS9xMENBZ0VDQWhZQ0FnRUJBd0pSUFE0YUJRUU1EaEhGRFNBaERNY1lEZ29FQkJvUE4vN2ZDQkVIQndjT0RBRXFBUUlCQWdRQkFnTUNBUU1CQVNBQklRSUdBZ1lMQlFjSERnejlmZERRQThCd1R4czBGd0hLQndrSkI4b1hOUnRQY1A3ekxpQWhMUzBoSUM3OUR3RUJBUUxERVFRUERnNGVCQWY5NURyNEdSbjRQUUljQ2dRZkRnOE9CQkJUQWdNRkJROEovWVFNRkFOVkFRRUJBVkpUQVFRREJSQUlBbjBNRXdUOW9qa0NGRHY5N2dBQUFBSUFWUUFWQTZzRGF3QVBBQk1BQUFFaElnWVZFUlFXTXlFeU5qVVJOQ1lESVJFaEEzRDlJQmdqSXhnQzRCZ2pJeUw5TkFMTUEyc2pHUDBnR0NNakdBTGdHQ1A4N3dMTUFBRUFBQUExQkFBRFN3QWxBQUFKQVE0Qkl5SW1Kd0V1QVRVME5qOEJQZ0V6TWhZZkFRRStBVE15Rmg4QkhnRVZGQVlITVFQdi9hOEpGUXdNRlFqK3hnZ0pDUWhSQ0JVTURCVUp2d0hYQ1JVTURCVUlVUWdKQ1FnQ2wvMnZDUWdJQ1FFNUNSVU1EQlFKVUFrSkNRbS9BZGNKQ0FnSlVBa1ZEQXdVQ1FBQ0FBVUFDQVFIQTNnQUpBQTRBQUFCUGdFMU5DWXZBUzRCSXlJR0J3RW5MZ0VqSWdZUEFRNEJGUlFXRndFZUFUTXlOamNCQXhFaEVTRTNJU0lHRlJFVUZqTWhNalkxRVFjRCtBZ0hCd2hEQ0JFS0N4RUkvbktpQnhJS0NoSUhSQWNJQ0FjQkNRY1NDZ29TQndIMTR2MDBBbHhFL1ZZWUl5TVlBdUFZSTBVQzN3Z1JDZ29TQjBRSENBZ0gvbktpQndnSUIwUUhFZ29LRWdmKzl3Y0lDQWNCOWY2bS9zY0N6VVFpR2YwaEdDTWpHQUdHUkFBRkFGMy93QU9qQThBQUN3QVBBQjBBS3dBNUFBQUJGU0UxTXpJMk5UTVVGak1YRVNFUkZ6UW1JeUlHRlJFVUZqTXlOalVUTkNZaklnWVZFUlFXTXpJMk5STTBKaU1pQmhVUkZCWXpNalkxQTZQOHV1d2RLZUlwSGIvOUZPUVdEeEFWRlJBUEZyY1dEdzhXRmc4UEZyY1ZFQThXRmc4UUZRTjZZMk1wSFIwcHJ2ejBBd3liRUJVVkVQNG9FQllXRUFIWUVCVVZFUDRvRUJZV0VBSFlFQlVWRVA0b0VCWVdFQUFEQUdML3dBT2VBOEFBSEFBb0FEd0FBQk1SRkJZeklUSTJOUkUwSmljMU5DNENLd0VpRGdJZEFRNEJGU1VoTlRRMk93RXlGaDBCTVFVME5qTXlGaFVVQmdjV0JqRWpNQ1kzTGdFMVlrY3lBa295Uno4dUtrbGlOMG8zWWtrcUxqOENZZjU2YTB3WVRHdiszRGtvS0RvZ0h3d1lMaGdNSHg4QnFQNlNNMGRITXdGdUwwWUZramRpU1NvcVNXSTNrZ1ZHTDNwNVRHdHJUSG53S1RrNUtTRTRDQ2hHUmlnSU9DRUFBQUFBQWdCaS84QURuZ1BBQUNVQU9BQUFBVDRCT3dFeUZoMEJJUTRCRlJFVUZqTWhNalkxRVRRbUp6VTBMZ0lyQVNJT0FoVXpFeFlHTVNNd0pqY3VBVFUwTmpNeUZoVVdCZ0UrQ1dkR0dFeHIvZ3d1UDBjeUFrb3lSejh1S2tsaU4wbzNZa2txYitVTUdDNFlEQjhnT2lnb09RRWdBckpEWFd0TWVRVkdMLzZTTTBkSE13RnVMMFlGa2pkaVNTb3JTV00zL2g4b1JrWW9DRGNpS1RrNUtTRTRBQVFBQUFBVkJBQURhd0JTQUY4QXNnQytBQUFCTlNjdUFTY3hKalEvQVNjSERnRW5NUzRCTHdFakJ3NEJCekVHSmk4QkJ4Y2VBUWM0QVRFT0FROEJGUmNlQVJjeEZnWVBBUmMzUGdFWE1SNEJId0V6Tno0Qk56RTJGaDhCTnljdUFUY3hQZ0UvQVFVaUpqVTBOak15RmhVVUJpTUZOU2N1QVNjeEpqWS9BU2NIRGdFbk1TNEJMd0VqQnc0QkJ6RUdKaThCQnhjV0ZBY3hEZ0VQQVJVWEhnRVhPQUV4RmhRUEFSYzNOaklYTVI0Qkh3RXpOejRCTnpFMk1oOEJOeWN1QVRjeFBnRS9BUWNpSmpVME5qTXlGaFVVQmdMQk13OFdCZ1lIR0VNeURoOE9EeFVGRTE4U0JSWU9EeDhPTVVNWEJ3RUdCaGNQTXpNUEZ3WUdBUWNYUXpFT0h3OE9GZ1VTWHhJR0ZROE9IdzR5UXhnR0FRWUdGZzh6L3FBMlRFdzJOVXhNTlFLZkd3Z01Bd1FCQkF3a0dnY1JDQWNNQXdrekNRTU1Cd2dSQnhva0RBUURBd3dJR3hzSURBTURCQXdrR2djUkNBY01Bd2t6Q1FNTUJ3Z1FDQm9rREFRQkJBTU1DQnU3SFNnb0hSd29LQUhWWUJNRkZnNFBJQTR5UkJnR0FRWUdGdzgwTkE4WEJnWUJCaGhFTWc0Z0R3NFdCUk5nRXdVV0RnOGdEakpFR0FjQkJ3WVdEelF6RHhjSEJnRUhHRVF5RHg4UERoWUdFbE5OTmpaTlRUWTJUY2d6Q2dNTENBZ1JCeHNrRFFNQkF3UU1DQnNiQ0F3RUF3RUREU1FiQnhFSUNBc0RDak1LQXdzSUNCRUhHeVFNQkFNRERBZ2NIQWdNQXdNRERTUWFDQkVJQnd3RENpd29IUjBwS1IwZEtBQUFBQUFDQUFEL3dBUUFBOEFBTHdCSUFBQUJPZ0V6UEFNMU5EWXpNaUl6TWhZVkhBTVZPZ0V6TWhZSERnTUhEZ0VqSWlZbkxnTW5Kall6SlNFVklSRWhFU0UxSVNJR0ZSRVVGak1oTWpZMUVUUW1Jd0VqRjJzWER3bzBFalFLRHhkckZ4SUxDeHM0TnpjY0JBa0ZCUWtFSERjM09Cc0xDeElDbFA3aUFSYjhvZ0VWL3VNZUt5c2VBMjRmS2lvZkFkY3llSHQ0TWdvUUVBb3llSHQ0TWg4TUlrSkRRaUlFQkFRRUlrSkRRaUlNSDloUS9iSUNUbEFxSHYyaUhpc3JIZ0plSGlvQUFBQUFCQUFBLy9JRUFBT09BQU1BR3dBZkFEUUFBQUVWSVRVQk1qWTNQZ0UxTkNZbkxnRWpJZ1lIRGdFVkZCWVhIZ0VETlNFVkFUSVdGeDRCRlJFakZTRTFJeEUwTmpjK0FUTWhBelQ5bUFLYUN4TUhDQWdJQ0FjVEN3c1NCd2NIQndjSEVvLythQUl5SHpjV0Z4Zk0vWmpNRnhjWE5oOEN6QU9PemMzK01nY0hDQklLQ3hNSUNBY0hDQWdUQ3dvU0NBY0gvcHIvL3dJeUZ4WVhOaUQremMzTkFUTWdOaGNXRndBQUF3QUEvOEFFQUFQQUFCa0FVd0IzQUFBQk5DWW5MZ0VqSWdZSERnRVZGQllYSGdFek1qWTNQZ0UxTVFFVUJnY09BU01pSmk4QkRnRWpJaVluTGdFbkxnRW5MZ0UxTkRZM1BnRTNQZ0UzUGdFek1oWVhIZ0VYSGdFWEhnRVZGQVlIRng0QkZURUJJelUwSmlzQklnWWRBU01pQmgwQkZCWTdBUlVVRmpzQk1qWTlBVE15TmowQk5DWUN4U2tvS0dJNU9XRW9LU2dvS1NoaE9UbGlLQ2dwQVRzTUN3d2NFQkFjQzlNM2UwUXNWQ2dvUlI0ZExoRVJFUkVSRVM0ZEhrVW9LRlFzTEZRcEtFVWRIUzRSRVJJbkp0TU1DLzQvWndnRk5BVUhad1VIQndWbkJ3VTBCUWhuQlFjSEFnODVZU2tvS0Nnb0tXRTVPV0lvS1Nnb0tTbGhPZjRBRUJ3TUN3d01DOU1tSmhFUkVTNGRIVVVwS0ZRc0xGUW9LRVVlSFM0UkVSRVJFUkV1SFI1RktDaFVMRVI3TjlNTEhCQUNKbWNGQndjRlp3Y0ZOQVVJWmdZSEJ3Wm1DQVUwQlFjQUFBQUFBd0FBLzhBRUFBUEFBQmtBVXdCa0FBQUJOQ1luTGdFaklnWUhEZ0VWRkJZWEhnRXpNalkzUGdFMU1RRVVCZ2NPQVNNaUppOEJEZ0VqSWlZbkxnRW5MZ0VuTGdFMU5EWTNQZ0UzUGdFM1BnRXpNaFlYSGdFWEhnRVhIZ0VWRkFZSEZ4NEJGVEVCSWdZZEFSUVdNeUV5TmowQk5DWWpJUUxGS1Nnb1lqazVZU2dwS0NncEtHRTVPV0lvS0NrQk93d0xEQndRRUJ3TDB6ZDdSQ3hVS0NoRkhoMHVFUkVSRVJFUkxoMGVSU2dvVkN3c1ZDa29SUjBkTGhFUkVpY20wd3dML1NRRkJ3Y0ZBUnNGQndjRi91VUNEemxoS1Nnb0tDZ3BZVGs1WWlncEtDZ3BLV0U1L2dBUUhBd0xEQXdMMHlZbUVSRVJMaDBkUlNrb1ZDd3NWQ2dvUlI0ZExoRVJFUkVSRVM0ZEhrVW9LRlFzUkhzMzB3c2NFQUltQndVMEJRZ0lCVFFGQndBQUFBQUJBRmdBR0FPb0EyZ0FKQUFBSlNjM05qUXZBU1lHRHdFbkppSVBBUVlVSHdFSEJoUWZBUll5UHdFWEZqSS9BVFkwSndPbzgvTU1ESHdNSVF6ejh3d2hESHdNRFBQekRBeDdEQ0lNOC9NTUlReDhEQXpOOC9JTUlneDhEQUVNOHZNTURId01JUXp6OHd3aURIc01EUFB6REF4OERDRU1BQUFCQUFEL3dBUUFBOEFBSkFBQUFTRVJOQ1lyQVNJR0ZSRWhJZ1lkQVJRV015RVJGQlk3QVRJMk5SRWhNalk5QVRRbUl3UFgvcWtZRWE0UkdQNnBFUmdZRVFGWEdCR3VFUmdCVnhFWUdCRUNRQUZYRVJnWUVmNnBHQkd1RVJqK3FSRVlHQkVCVnhnUnJoRVlBQUFCQUFBQlFBUUFBa0FBRUFBQUFUSVdIUUVVQmlNaElpWTlBVFEyTXlFRDF4RVlHQkg4VWhFWUdCRURyZ0pBR0JHdUVSZ1lFYTRSR0FBQUFBQUNBQUQvd0FRQUE4QUFFd0E0QUFBQklnNENGUlFlQWpNeVBnSTFOQzRDRXdjR0lpOEJCd1lpTHdFbU5EOEJKeVkwUHdFMk1oOEJOell5SHdFV0ZBOEJGeFlVQndJQWFydUxVRkNMdTJwcXU0dFFVSXU3ZmtNSEVnZUZoUWNTQjBNSEI0V0ZCd2REQnhJSGhZVUhFZ2REQndlRmhRY0hBOEJRaTd0cWFydUxVRkNMdTJwcXU0dFEvVnREQndlRmhRY0hRd2NTQjRXRkJ4SUhRd2NIaFlVSEIwTUhFZ2VGaFFjU0J3QUFBZ0FBLzhBRUFBUEFBQlFBT1FBQUFTSU9BaFVVSGdJek1qNENOVFF1QWlNQkZBWXJBUlVVQmlzQklpWTlBU01pSmowQk5EWTdBVFUwTmpzQk1oWWRBVE15RmgwQkFnQnF1NHRRVUl1N2FtcTdpMUJRaTd0cUFSRU5DYmNOQ1Z3SkRiY0pEUTBKdHcwSlhBa050d2tOQThCUWk3dHFhcnVMVUZDTHUycHF1NHRRL2RJSkRiY0pEUTBKdHcwSlhRa010d2tORFFtM0RBbGRBQUFBQWdBQS84QUVBQVBBQUJRQUpRQUFBU0lPQWhVVUhnSXpNajRDTlRRdUFpTUJGQVlqSVNJbVBRRTBOak1oTWhZZEFRSUFhcnVMVUZDTHUycHF1NHRRVUl1N2FnRVJEUW4rQ2drTkRRa0I5Z2tOQThCUmk3cHFhcnVMVUZDTHUycHF1b3RSL2RJSkRRd0tYQWtOREFwY0FBTUFBQUJqQkFBREhRQVlBREVBV2dBQUFUSVdGeDRCRlJRR0J3NEJJeUltSnk0Qk5UUTJOejRCTXhFeU5qYytBVFUwSmljdUFTTWlCZ2NPQVJVVUZoY2VBVE1STWg0Q0Z4NERGdzREQnc0REl5SXVBaWN1QXljK0F6YytBek1DQUJ3eEZSVVVGQlVWTVJ3Y01SVVZGQlFWRlRFY01GSWlJeUlpSXlKU01EQlNJaU1pSWlNaVVqQXJVazVLSXlJOE1pa1BEeWt5UENJalNrNVNLeXRTVGtvaklqd3lLUThQS1RJOElpTktUbElyQWtzVUZSVXhIQnd4RlJVVUZCVVZNUndjTVJVVkZQNk1JaU1pVWpBd1VpTWlJaUlpSTFJd01GSWlJeUlDUmd3WUpCZ1lPRDlISnlkSFB6Z1lHQ1FZREF3WUpCZ1lPRDlISnlkSFB6Z1lHQ1FZREFBQUJBQUFBQVlFQUFONkFBa0FKQUJGQUdVQUFBRXpNaFlYSGdFZEFTY0hEZ0VWRkJZWEhnRXpNalkzSnc0Qkl5SW1KeTRCTlRRMk55Y0JOd0VITGdFbkxnRW5EZ0VqSWk0Q0p5NERKejRCTnk0Qkp5NEJKekVGSWdZSEp6NEJNekllQWhjZUF4Y09BUWNuUGdFMU5DWW5MZ0VqTVFIN0Jod3lGQlVWa3NrTkRpTWlJMUl3R1RNYlNBa1BCeHd4RlJVVkF3SkkvdjQ3QXprN0JTSWRIUzBQTDJVM0sxSk9TaU1qUERJcER4dFlQQTBsRnhnYkF3SFJGaW9WWkNwZE1pdFNUa29pSXpzeUtROGFVRFdJQ1FraklpSlRNQUpqRlJVVk1Sd0psU1ViTXhrd1V5SWlJdzBPU0FNQ0ZSVVVNaHdHRUFsSUFRRTcvTWM3QlNJY0hTd1BGQk1NR0NRWUdEZEFSeWRFY3pBTkpoZ1lHd04rQ1FsbEVCQU1HQ1FZR0RnL1J5ZEJiaTZJRlNvV01GSWpJaU1BQUFJQlJQL0FBcndEd0FBS0FCY0FBQ1V6RVNNMUlSRXpGU0UxRXpJV0ZSUUdJeUltTlRRMk13RkVaV1VCRTJYK2lMUXhSa1l4TWtaR01rc0JrNHY5NG91TEEzVklNek5JU0RNelNBQUpBQUFBTGdRQUExSUFIQUE0QUZVQWNRQ05BS29BeGdEaUFQNEFBQ1VWRkFZSERnRXJBU0ltSnk0QlBRRTBOamMrQVRzQk1oWVhIZ0VWRVJVVUJnY09BU3NCSWlZbkxnRTlBVFEyTno0Qk93RXlGaGNlQVFFVkZBWUhEZ0VyQVNJbUp5NEJQUUUwTmpjK0FUc0JNaFlYSGdFVkFSVVVCZ2NPQVNzQklpWW5MZ0U5QVRRMk56NEJPd0V5RmhjZUFRRVZGQVlIRGdFckFTSW1KeTRCUFFFME5qYytBVHNCTWhZWEhnRUJGUlFHQnc0Qkt3RWlKaWN1QVQwQk5EWTNQZ0U3QVRJV0Z4NEJGUUVWRkFZSERnRXJBU0ltSnk0QlBRRTBOamMrQVRzQk1oWVhIZ0VCRlJRR0J3NEJLd0VpSmljdUFUMEJORFkzUGdFN0FUSVdGeDRCRVJVVUJnY09BU3NCSWlZbkxnRTlBVFEyTno0Qk93RXlGaGNlQVFFa0J3a0lFd3UzREJNSUNBZ0lDQWdURExjTEZBY0pCd2NKQ0JNTHR3d1RDQWdJQ0FnSUV3eTNDeFFIQ1FjQmJnZ0lDQk1MdUFzVENBZ0lDQWdJRXd1NEN4TUlDQWora2djSkJ4UUx0d3dUQ0FnSUNBZ0lFd3kzQ3hRSENRY0JiZ2dJQ0JNTHVBc1RDQWdJQ0FnSUV3dTRDeE1JQ0FnQmJnZ0lDQk1NdHdzVUJ3a0hCd2tIRkF1M0RCTUlDQWora2dnSUNCTUx1QXNUQ0FnSUNBZ0lFd3U0Q3hNSUNBZ0JiZ2dJQ0JNTXR3c1VCd2tIQndrSEZBdTNEQk1JQ0FnSUNBZ1RETGNMRkFjSkJ3Y0pCeFFMdHd3VENBZ0kwbTBNRXdnSUNBZ0lDQk1NYlF3VENBZ0lDQWdJRXd3QkpXNExGQWdJQ0FnSUNCUUxiZ3NVQ0FnSUNBZ0lGUDdRYlF3VENBZ0lDQWdJRXd4dERCTUlDQWdJQ0FnVERBSkpiUXdUQ0FnSUNBZ0lFd3h0REJNSUNBZ0lDQWdUL3RCdUN4UUlDQWdJQ0FnVUMyNExGQWdJQ0FnSUNCVCswRzBNRXdnSUNBZ0lDQk1NYlF3VENBZ0lDQWdJRXd3Q1NXME1Fd2dJQ0FnSUNCTU1iUXdUQ0FnSUNBZ0lFLzdRYmdzVUNBZ0lDQWdJRkF0dUN4UUlDQWdJQ0FnVUFSbHREQk1JQ0FnSUNBZ1RERzBNRXdnSUNBZ0lDQk1BQUFBREFBQUFGUVFBQTJzQUd3QTRBRlFBQUNVVkZBWUhEZ0VqSVNJbUp5NEJQUUUwTmpjK0FUTWhNaFlYSGdFUkZSUUdCdzRCSXlFaUppY3VBVDBCTkRZM1BnRXpJVElXRng0QkZSRVZGQVlIRGdFaklTSW1KeTRCUFFFME5qYytBVE1oTWhZWEhnRUVBQVlIQmc4Si9GWUpEd1lIQmdZSEJnOEpBNm9KRHdZSEJnWUhCZzhKL0ZZSkR3WUhCZ1lIQmc4SkE2b0pEd1lIQmdZSEJnOEovRllKRHdZSEJnWUhCZzhKQTZvSkR3WUhCcFZWQ1E4R0JnY0hCZ1lQQ1ZVSkR3WUhCZ1lIQmc4QlRWWUlEd2NHQmdZR0J3OElWZ2dQQndZR0JnWUhEd2dCVlZVSkR3WUhCZ1lIQmc4SlZRa1BCZ1lIQndZR0R3QUFBQUlBQVAvQUJBQUR3QUFaQUZNQUFBRTBKaWN1QVNNaUJnY09BUlVVRmhjZUFUTXlOamMrQVRVeEFSUUdCdzRCSXlJbUx3RU9BU01pSmljdUFTY3VBU2N1QVRVME5qYytBVGMrQVRjK0FUTXlGaGNlQVJjZUFSY2VBUlVVQmdjWEhnRVZNUUxGS1Nnb1lqazVZU2dwS0NncEtHRTVPV0lvS0NrQk93d0xEQndRRUJ3TDB6ZDdSQ3hVS0NoRkhoMHVFUkVSRVJFUkxoMGVSU2dvVkN3c1ZDa29SUjBkTGhFUkVTWW0wd3dMQWc4NVlTa29LQ2dvS1dFNU9XSW9LQ2twS0NoaU9mNEFFQndNQ3d3TUM5TW1KaEVSRVM0ZEhVVXBLRlFzTEZRb0tFVWVIUzRSRVJFUkVSRXVIUjVGS0NoVUxFUjdOOU1MSEJBQUNRQUMvK01FQUFPZEFEMEFRUUJHQUVvQVRnQlNBRmNBWndCNkFBQWxJeUUzSVJNaEx3SXhJaVlqSnk0Qkl5SUdCd1lXSHdFVEJ4VXpEZ0VWRkJZek1qWTFOQ1luTXc0QkZSUVdNekkyTlRRbUp6c0JQZ0UxTkNZakF6TUhJeFV6QnlNMUp6TVZJeFV6RlNNQk14VWpGeFVqSnpNRElpWTFORFl6TWhZWEhnRVZGQVlqSVNJbU5UUTJOejRCTXpJV0Z4NEJGUlFHSXdPRUFmMmJHd0pSZHZ6UEdRVVZBZ0lCWndJRkF3MFVBd1VQRDFhQUxSQURCRVF3TDBRRUErVUVBME13TUVRRUJCa0JEeFlXRDVDbEpJRjNKVkw4dkx5OHZQN3p6YXFxZlNPZ2R4RVhGeEVJRGdZRkJoY1FBYjBRR0FZR0JnNElDQThGQmdZWEVjcEhBZWhvRlFZQkhnRUJEd3dQR3dVWi9lZDdLQWtVQ2pCRVJEQUtGQWtKRkFvd1JFUXdDaFFKQVJZUEVCWUIwbmRBZG5hM2QwQjJBUzEzUUhaMi9rb1hFUkFYQmdVR0RnZ1JGeGNSQ0E0R0JRWUdCUVlPQ0JFWEFBQUJBUUwvd0FPSEE4QUFKQUFBQVJRR0J3RU9BU01pSmk4QkxnRTFORFkzQ1FFdUFUVTBOajhCUGdFek1oWVhBUjRCRlFPSERBeitVd3dlRVJFZURESU1EQXdNQVQvK3dRd01EQXd5REIwU0VoME1BYTBNREFIQUVSNE4vbFFNREF3TU1nd2VFUklkRFFFL0FUOE5IUklSSFEweERBME5EUDVVREI0UkFBQUFBQUVBZWYvQUF2NER3QUFrQUFBVE5EWTNBVDRCTXpJV0h3RWVBUlVVQmdjSkFSNEJGUlFHRHdFT0FTTWlKaWNCTGdFMWVRd01BYTBNSGhFUkhnd3lEQXdNRFA3QkFUOE1EQXdNTWd3ZEVoSWREUDVUREF3QndCRWVEUUdzREF3TURESU1IaEVTSFF6K3dQN0JEQjRTRVI0TU1Rd05EUXdCckF3ZUVRQUJBQUFBd2dRQUEwY0FKQUFBQVRJV0Z3RWVBUlVVQmc4QkRnRWpJaVluQ1FFT0FTTWlKaThCTGdFMU5EWTNBVDRCTXdJQUVSNE5BYXdNREF3TU1nd2VFUklkRGY3Qi9zRU5IUklSSFEweERBME5EQUdzREI0UkEwY01EUDVUREI0UkVSNE1NZ3dNREF3QlAvN0JEQXdNRERJTUhSSVNIUXdCclF3TUFBQUFBQUVBQUFBNUJBQUN2Z0FqQUFBbElpWW5BUzRCTlRRMlB3RStBVE15RmhjSkFUNEJNeklXSHdFZUFSVVVCZ2NCRGdFQ0FCRWVEZjVVREF3TURESU1IaEVTSFEwQlB3RS9EUjBTRVI0TU1Rd05EUXorVkF3ZU9Rd01BYTBNSGhFUkhnd3lEQXdNRFA3QkFUOE1EQXdNTWd3ZEVoSWREUDVUREF3QUFBQUJBTlgvd0FNckE4QUFKUUFBTnpRMk53a0JMZ0UxTkRZL0FUNEJNeklXRndFZUFSVVVCZ2NCRGdFaklpWXZBUzRCTlRIVkJnVUJrLzV0QlFZR0JUTUZEQWNHREFVQjNnVUdCZ1grSWdVTUJnY01CVE1GQmhVSERBVUJrd0dUQlF3SEJ3c0ZOQVVGQlFYK0lnWUxCd2NMQnY0aUJRVUZCVFFGREFZQUFRRFYvOEFES3dQQUFDVUFBQUVVQmdjSkFSNEJGUlFHRHdFT0FTTWlKaWNCTGdFMU5EWTNBVDRCTXpJV0h3RWVBUlV4QXlzRkJ2NXRBWk1HQlFVR013VU1CZ2NNQmY0aUJRWUdCUUhlQlF3SEJnd0ZNd1lGQTJzSERBWCtiZjV0QlF3SEJnd0ZOQVVGQlFVQjNnWUxCd2NNQlFIZUJRVUZCVFFGQ3djQUFBQUJBQUFBbFFRQUF1c0FKUUFBSlNJbUp3a0JEZ0VqSWlZdkFTNEJOVFEyTndFK0FUTXlGaGNCSGdFVkZBWVBBUTRCSXpFRHF3Y01CZjV0L20wRkRBY0dEQVUwQlFVRkJRSGVCZ3NIQndzR0FkNEZCUVVGTkFVTUJwVUdCUUdUL20wRkJnWUZNd1VNQndZTUJRSGVCUVlHQmY0aUJRd0dCd3dGTXdVR0FBQUFBQUVBQUFDVkJBQUM2d0FsQUFBVE1oWVhDUUUrQVRNeUZoOEJIZ0VWRkFZSEFRNEJJeUltSndFdUFUVTBOajhCUGdFek1WVUhEQVVCa3dHVEJRd0hCZ3dGTkFVRkJRWCtJZ1lMQndjTEJ2NGlCUVVGQlRRRkN3Y0M2d1lGL20wQmt3VUdCZ1V6QlF3SEJnd0YvaUlGQmdZRkFkNEZEQVlIREFVekJRWUFBQUFBQWdBQS84QUVBQVBBQUNVQVNnQUFBUWNPQVJVVUZoOEJCdzRCRlJRV0h3RWVBVE15TmpjQlBnRTFOQ1luQVM0Qkl5SUdCekVCTkRZM1BnRTNQZ0V6TWhZWEhnRVhIZ0VWRkFZSERnRUhEZ0VqSWlZbkxnRW5MZ0UxQWFKRUJnY0hCczNOQmdjSEJrUUdEd2tKRHdZQkx3WUdCZ2IrMFFZUENRa1BCdjVlSWlNaVhUczdnRVpHZ0RzN1hTSWpJaUlqSWwwN080QkdSb0E3TzEwaUl5SUREVVFIRHdnSkR3Yk56UVlQQ1FnUEIwUUdCZ1lHQVM4R0R3a0pEd1lCTHdZR0JnYitzMGFBT3p0ZElpTWlJaU1pWFRzN2dFWkdnRHM3WFNJaklpSWpJbDA3TzRCR0FBQUFBQUlBQVAvQUJBQUR3QUFrQUVnQUFDVTNQZ0UxTkNZdkFUYytBVFUwSmk4QkxnRWpJZ1lIQVE0QkZSUVdGd0VlQVRNeU5qY0JGQVlIRGdFSERnRWpJaVluTGdFbkxnRTFORFkzUGdFM1BnRXpNaFlYSGdFWEhnRUNYa1FHQndjR3pjMEdCd2NHUkFZUENRa1BCdjdSQmdZR0JnRXZCZzhKQ1E4R0FhSWlJeUpkT3p1QVJrYUFPenRkSWlNaUlpTWlYVHM3Z0VaR2dEczdYU0lqSW5ORUJ3OElDUThHemMwR0R3a0lEd2RFQmdZR0J2N1JCZzhKQ1E4Ry90RUdCZ1lHQVUxR2dEczdYU0lqSWlJaklsMDdPNEJHUm9BN08xMGlJeUlpSXlKZE96dUFBQUFBQUFJQUFQL0FCQUFEd0FBbEFFb0FBQk1YSGdFek1qWS9BUmNlQVRNeU5qOEJQZ0UxTkNZbkFTNEJJeUlHQndFT0FSVVVGaGN4QVNJbUp5NEJKeTRCTlRRMk56NEJOejRCTXpJV0Z4NEJGeDRCRlJRR0J3NEJCdzRCSTdORUJ3OElDUThHemMwR0R3a0lEd2RFQmdZR0J2N1JCZzhKQ1E4Ry90RUdCZ1lHQVUxR2dEczdYU0lqSWlJaklsMDdPNEJHUm9BN08xMGlJeUlpSXlKZE96dUFSZ0ZpUkFZSEJ3Yk56UVlIQndaRUJnOEpDUThHQVM4R0JnWUcvdEVHRHdrSkR3YitYaUlqSWwwN080QkdSb0E3TzEwaUl5SWlJeUpkT3p1QVJrYUFPenRkSWlNaUFBSUFBUC9BQkFBRHdBQWxBRWtBQUFFbkxnRWpJZ1lQQVNjdUFTTWlCZzhCRGdFVkZCWVhBUjRCTXpJMk53RStBVFUwSmljeEFUSVdGeDRCRng0QkZSUUdCdzRCQnc0Qkl5SW1KeTRCSnk0Qk5UUTJOejRCTno0QkEwMUVCdzhJQ1E4R3pjMEdEd2tJRHdkRUJnWUdCZ0V2Qmc4SkNROEdBUzhHQmdZRy9yTkdnRHM3WFNJaklpSWpJbDA3TzRCR1JvQTdPMTBpSXlJaUl5SmRPenVBQWg1RUJnY0hCczNOQmdjSEJrUUdEd2tKRHdiKzBRWUdCZ1lCTHdZUENRa1BCZ0dpSWlNaVhUczdnRVpHZ0RzN1hTSWpJaUlqSWwwN080QkdSb0E3TzEwaUl5SUFBQUVBQUFBZkErc0RZUUFlQUFBbEFUWTBKd0VtSWdjR0ZCOEJJU0lHRlJRV015RUhEZ0VWRkJZWEZqSTNBbjBCYmhVVi9wSVdQQllWRmZIOVF4NHJLeDRDdmZFS0N3c0tGandXSHdGdEZqd1dBVzBXRmhVOUZmRXJIaDRyOFFzYkRnNGJDaFlXQUFBQUFRQVZBQjhFQUFOaEFCOEFBQWtCQmhRWEFSWXlOelkwTHdFaE1qWTFOQ1lqSVRjK0FUVTBKaWNtSWdjeEFZUCtraFVWQVc0V1BCWVZGZkVDdlI0ckt4NzlRL0VLQ3dzS0Zqd1dBMkgra3hZOEZ2NlRGaFlWUFJYeEt4NGVLL0VMR3c0T0d3b1dGZ0FCQUYvL3dBT2lBNnNBSHdBQUNRRW1JZ2NCQmhRWEZqSS9BUkVVRmpNeU5qVVJGeDRCTXpJMk56WTBKekVEb2Y2VEZqd1cvcE1XRmhVOUZmRXJIaDRyOFFzYkRnNGJDeFVXQWowQmJoVVYvcElXUEJZVkZmSDlReDRyS3g0Q3ZmRUtDd3NLRmp3V0FBRUFYLy9WQTZFRHdBQWZBQUFUQVJZeU53RTJOQ2NtSWc4QkVUUW1JeUlHRlJFbkxnRWpJZ1lIQmhRWE1WOEJiUlk4RmdGdEZoWVZQUlh4S3g0ZUsvRUxHdzRPR3dvV0ZnRkQvcElWRlFGdUZqd1dGUlh4QXIwZUt5c2UvVVB4Q2dzTENoWThGZ0FBQVFDSi84Y0RhUU81QUF3QUFCY0dKalVSTkRZWEFSWUdCd0d3RHhnWER3SzZEd0VQL1VnNUN3c1JBOUFSQ3d2K0dRc2RDdjRuQUFBQkFKZi94d04zQTdrQURBQUFBVFlXRlJFVUJpY0JKalkzQVFOUkRoZ1hELzFHRHdFUEFya0R1UXNMRWZ3d0VRb0tBZWNMSFFvQjJRQUFBQUFCQUFjQVZ3UDVBemNBREFBQUV5WTJNeUV5RmdjQkJpWW5BUWNMQ3hFRDBCRUxDLzRaQ3gwSy9pY0RFUThYRncvOVJnOEJEd0s1QUFFQUJ3QkpBL2tES1FBTEFBQWxGZ1lqSVNJbU53RTJGaGNEK1FzTEVmd3dFUXNMQWVjTEhRcHdEeGdYRHdLNkR3RVBBQUFCQUFEL3dBUUFBOEFBbUFBQUFTY3VBU01pQmc4QkRnRVZGQllmQVNFUkZ4NEJNekkyUHdFK0FUVTBKaThCTGdFaklnWVBBUTRCRlJRV0h3RWVBVE15Tmo4QkVTRTNQZ0UxTkNZdkFTNEJJeUlHRHdFT0FSVVVGaDhCSGdFek1qWS9BVDRCTlRRbUx3RWhFU2N1QVNNaUJnOEJEZ0VWRkJZZkFSNEJNekkyUHdFK0FUVTBKaThCTGdFaklnWVBBUkVoQnc0QkZSUVdId0VlQVRNeU5qOEJQZ0UxTkNZbkEvYW9CUXdIQndzRkZBUUZCUVJWL3RCVUJRc0hCd3dGRXdVRkJRV3BCUXNIQnd3RXFRVUZCUVVVQkF3SEJ3c0ZWUDdFVlFRRkJRUVVCUXdHQnd3RnFBVUZCUVdvQlF3SEJ3c0ZGQVFGQlFSVUFUdFVCUXNIQnd3RkV3VUZCUVdvQlF3SEJ3c0ZxUVVGQlFVVUJBd0hCd3NGVkFFd1ZRUUZCUVFVQlF3R0J3d0ZxQVVGQlFVQjFxa0ZCUVVGRkFRTUJ3Y01CVlFCTjFRRkJRVUZFd1VNQndjTEJha0ZCUVVGcVFVTEJ3Y01CUk1GQlFVRlZQN0pWUVFNQndjTUJSTUZCUVVGcVFVTUJ3WU1CYWtGQlFVRkZBUU1Cd2NMQmxUK3pGUUZCUVVGRXdVTUJ3Y0xCYWtGQlFVRnFRVUxCd2NNQlJNRkJRVUZWQUUwVlFRTUJ3Y01CUk1GQlFVRnFRVU1Cd1lNQlFBQUFnQUEvOEFFQUFQQUFCTUFyQUFBQVNJT0FoVVVIZ0l6TWo0Q05UUXVBaE1PQVNNaUppOEJMZ0UxTkRZL0FTTVZOejRCTXpJV0h3RWVBUlVVQmc4QkRnRWpJaVl2QVM0Qk5UUTJQd0UrQVRNeUZoOEJOU01YSGdFVkZBWVBBUTRCSXlJbUx3RXVBVFUwTmo4QlBnRXpNaFlmQVI0QkZSUUdEd0V6TlFjT0FTTWlKaThCTGdFMU5EWS9BVDRCTXpJV0h3RWVBUlVVQmc4QkRnRWpJaVl2QVJVekp5NEJOVFEyUHdFK0FUTXlGaDhCSGdFVkZBWVBBUUlBYXJ1TFVGQ0x1MnBxdTR0UVVJdTdvQU1KQlFZSkF3OEVBd01FUWZNOUJBVUdCUWtERHdRRUJBU0FCQWtGQlFrRWdRTUVBd1FPQkFrRkJRY0VQZkpBQkFNREJBOERDUVlGQ1FPQkJBTURCSUVEQ1FVR0NBUVBCQVFFQkVEeVBRUUdCUVVKQkE0RUJBUUVnQVFKQlFVSkJJQUVCQVFERHdRSUJRVUhCRDN4UHdRREF3UVBBd2tHQlFrRGdRUURBd1NCQThCUmk3cHFhcnVMVUZDTHUycHF1b3RSL1cwRUJBUUVEZ1FJQlFVSEJEM3hRQVFEQXdRUEF3a0dCUWtFZ0FRRUJBU0FCQWtGQmdnRUR3UURBd1JBOFR3RUJnVUZDUU1RQXdRRUE0RUVDUVVGQ1FTQUJBUUVBdzhFQ0FVRkJ3UTk4VUFFQkFRRURnUUpCUVlJQklBRUJBUUVnQVFJQmdVSkJBNEVCQVFFUVBFOEJBWUZCUWtFRGdRRUJBU0FCQWdHQlFrRWdBQUFBUUFBLzlvRUFBT21BQ29BQUFFSExnTWpJZzRDRlJRZUFqTTFJaTRDTlRRK0FqTXlGaGNIRGdFWEJSWTJOeE0ySmdjRHZGUWlWV050T1dXeGhVMUpnckpxUTNaWE16SlhkRU5DZUMxYUh3UWNBU2NjTEFRakF5Z2ZBdzRtTEVjeEdreUVzbVJsc1lSTXBETlhkVU5EZFZjek15MHBEakFUMEJRVUlnRmtJaHdPQUFBQUFRQ2IvOGNEVndPNUFBd0FBQmNHSmpVUk5EWVhBUllVQndIQURoY1hEZ0tYRGcvOWFqa0xDeEVEMEJFS0N2NFpDeDBLL2ljQUFBQUNBQUQvd0FRQUE4QUFEd0FnQUFBRkZBWWpJU0ltTlJFME5qTWhNaFlWSVRRbUl5RWlCaFVSRkJZeklUSTJOUkVCalJzUy9zMFNHeHNTQVRNU0d3SnpHeEwrelJNYUdoTUJNeEliRWhNYkd4TURwQk1iR3hNVEd4c1QvRndUR3hzVEE2UUFBUUFBLzhBRUFBUEFBQThBQUFVVUJpTWhJaVkxRVRRMk15RXlGaFVFQUNBWC9HNFhJQ0FYQTVJWElBa1hJQ0FYQTVJWElDQVhBQUFDQUFEL3dBUUFBOEFBRXdBZ0FBQUJJZzRDRlJRZUFqTXlQZ0kxTkM0Q0F3WW1OUkUwTmhjRkZoUUhCUUlBYXJ1TFVGQ0x1MnBxdTR0UVVJdTd4UWNNREFjQlZBY0gvcXdEd0ZDTHUycHF1NHRRVUl1N2FtcTdpMUQ4L1FVRkNRSDBDUVVGK2dVUEJmTUFBQUFEQUFEL3dBUUFBOEFBRXdBakFETUFBQUVpRGdJVkZCNENNekkrQWpVMExnSURGQVlyQVNJbU5SRTBOanNCTWhZVkV4UUdLd0VpSmpVUk5EWTdBVElXRlFJQWFydUxVRkNMdTJwcXU0cFJVWXE3bFFvSGNnY0tDZ2R5QndycUNnZHlCd29LQjNJSENnUEFVSXU3YW1xN2kxQlFpN3RxYXJ1TFVQMVNCd2tKQndGY0J3a0pCLzZrQndrSkJ3RmNCd2tKQndBQUFnQUEvOEFFQUFQQUFCTUFJd0FBQVNJT0FoVVVIZ0l6TWo0Q05UUXVBaE1VQmlNaElpWTFFVFEyTXlFeUZoVUNBR3E3aTFCUWk3dHFhcnFMVVZHTHVrME1DUDY2Q0F3TUNBRkdDQXdEd0ZDTHUycHF1b3RSVVl1NmFtcTdpMUQ5WFFnTURBZ0JSZ2dNREFnQUFRQUEvK1VEOHdPYUFCWUFBQWtCSmdZZEFTVW1CaFVSRkJZM0pSVVVGamNCTmpRbkEvUDlrUTBXL3NFTkZSVU9BVDRXRFFKdURnMEIwUUhKQ2drUjJ1b0tDUkg4YkJBS0NlVFRFQW9KQWIwS0d3b0FBUUFOLytZRUFBT2JBQllBQUFFRk5UUW1Cd0VHRkJjQkZqWTlBUVVXTmpVUk5DWUhBOTMrd2hZTi9aSU9EUUp2RFJZQlB3MFZGUTREbStUVEVBb0ova01KSEFyK053b0pFZHJxQ2drUkE1UVFDZ2tBQVFBQS8vVUVBQU9LQUNRQUFBRWpJZ1lWRVFFbUJoMEJKU1lHRlJFVUZqY2xGUlFXTndFUkZCWTdBVEkyTlJFMEppTUQzVDBPRmYzNkRSWCt6QXdWRlEwQk14VU5BZ1lWRGowUEZCUVBBNGtVRC82bkFYMEtDUkRUNGdvSkVQeUtEd29KM2MwUENna0JjLzZ5RHhRVUR3Tk1EeFFBQUFBQUFRQUEvL1lFQUFPTEFDUUFBQUVGTlRRbUJ3RVJOQ1lyQVNJR0ZSRVVGanNCTWpZMUVRRVdOajBCQlJZMk5SRTBKZ2NEM3Y3TkZRMzkraFVPUFE4VUZBODlEaFVDQmcwVkFUUU1GUlVOQTR2ZHpROEtDZjZOQVU0UEZCUVAvTFFQRkJRUEFWbitnd29KRU5QaUNna1FBM1lQQ2drQUFBQUFCQUFhQUhBRDVnTW1BQkFBSndBN0FGTUFBQk1WRkJZek9BRXhNeEVqSWdZVk9BRXhKUkV3RkRFVUJpTWlKaThCRVRjK0FUTXlGaFV3RkRFWEhnRVZGQVlIRnhZeU56NEJOVFFtSnk0QkJ6Y2VBUlVVQmdjWEZqSTNQZ00xTkM0Q0p5WWlCeG9tR29hR0dpWUNTQmNRQmdzRS9mMEZDZ1lRRjFBZElTRWRJd2tqQ1IwaUloMElJd2xMTVRrNU1pVUpJd2taS0J3UERod29HUWtqQ1FJOTVSc21BV2NtRzhEOW5BRVJGd01Ea1FHSGtnTURGeEVCblJ4TkxDdE5IU01KQ1NaZU5EUmVKZ2tCQ2tzeWhVeE1oVElsQ1FvZVJFdFFLeXBRUzBRZUNRa0FBQUFBQXdBYkFISUQ1UU1vQUJZQUxRQnBBQUFURlRnQk1SUVdNemdCTVRNUkl6Z0JNU0lHRlRnQk1TVVJPQUVWRkFZaklpWXZBUkUzUGdFek1oWVZNQlF4QVI0QkZSUUdEd0VPQVNNaUppOEJCdzRCSXlJbUx3RXVBVFUwTmo4Qkp5NEJOVFEyUHdFK0FUTXlGaDhCTno0Qk16SVdId0VlQVJVVUJnOEJHeVliaG9ZYkpnSkpGeEVGQ3dUOS9RUUxCUkVYQVh3Q0F3TUNJUUlGQXdRRkFrZEhBZ1lEQXdZQ0lRSUNBZ0pIUndJQ0FnSWhBZ1lEQXdZQ1IwY0NCUVFEQlFJaEFnTURBa2NDUCtVYkpnRm5KaHZBL1pzQkVCY0RBcElCaDVJREF4Z1FBZjZHQWdVREJBVUNJUUlEQXdKSFJ3SURBd0loQWdVRUF3VUNSMGNEQlFNREJnSWhBZ01EQWtkSEFnTURBaUVDQmdNREJRTkhBQUFBQUFRQUFQL0FCQUFEd0FBV0FDMEFSQUJiQUFBQkpqUS9BU2NtTmpjbE5oWUhBdzRCTHdFSEJpSXZBUUVISnlZaUR3RUdGQjhCQndZV0Z3VVdOaWNETGdFSEpTWWlEd0VuSmdZSEF3WVdOeVUrQVM4Qk56WTBMd0VUTnpZbUp5VW1CaGNUSGdFL0FSY1dNajhCTmpRdkFRSmlBd04xUlFVRUJ3RlpCd2tCT1FFS0JVTjBCQW9EalFGV1JYUUVDZ09OQXdOMVF3VUVCd0ZWQndrQk5RRUtCZjFaQXdvRWRFTUZDZ0U1QVFrSEFWa0hCQVZGZFFNRGpSbERCUVFIL3FzSENRRTFBUW9GUlhRRUNnT05Bd04xQXE4RENnUjBSQVlKQWpRQkNRZityQWNFQmtKMEJBU00vbjVGZFFNRGpRTUtBM1ZDQlFvQk9RRUpCd0ZZQndRRk13UUVkRUlHQkFmK3JBY0pBVFVCQ1FaRWRBUUtBNHdCMUVNRkNnRTVBUWdJL3FnSEJBVkVkQU1EakFRS0EzUUFBQUFFQUFUL3d3UDlBN3dBRmdBdEFFUUFXd0FBQVJNK0FSOEJOell5SHdFV0ZBOEJGeFlHQndVR0pqY1RIZ0UvQVJjV01qOEJOalF2QVRjMkppY2xKZ1lYRXlVWEZqSS9BUmNXTmpjVE5pWUhCUTRCSHdFSEJoUVhFeGNIQmhZWEJSWTJKd011QVE4Qkp5WWlEd0VHRkJjQ1h6a0JDZ1ZEZEFRSkJJMERBM1ZGQlFRSC9xY0lDQUUwQVFvRlJYUUVDZ09OQXdOMVF3VUVCLzZyQndrQk5mMXhqQVFKQkhSREJRb0JPUUVJQ1A2bkJ3UUZSWFFFQkFOMFFnWUVCd0ZWQndrQk5RRUtCVVYwQkFrRWpBUUVBaTRCVkFnREJVSjBBd09NQkFvRGRFVUZDZ0UxQVFrSC9jc0hCQVZGZFFNRGpRTUtBM1ZDQlFvQk9RRUlDUDZvWEl3REEzUkNCUVFIQVZRSENRRTFBUW9GUlhRRENnUUN5blJDQlFvQk9RRUlDQUZZQndRRlJYUUVCSXdEQ2dRQUFBQUFBd0FBQUNZRCt3TmFBQzBBYmdDZ0FBQVROVFEyT3dFeUZoY2VBUmNlQVJjZUFRY09BUWNPQVFjT0FRY09BU01pSmljdUFTY3VBU2N1QVNzQklpWTFCVDRCTno0Qk54VVVGajhCTmpRdkFTWUdIUUVPQVFjT0FRY09BUWNPQVFjT0FRY09BUWNPQVNzQklnWWRBUlFXT3dFeU5qYytBVGMrQVRjK0FUYytBVGNYSmdZZEFTNEJKeTRCSnk0Qkp5NEJJeUlHQnc0QkJ3NEJCdzRCQndZV0Z4NEJGeDRCRng0QkZ4VVVGajhCTmpRdkFRQUlCZkVhTWhjV0p4RUtFZ2tEQVFNS0Vna0lFUWdDQXdFQ0JRTUVCUUlLRWdrTEZBa0tGQXZ4QlFnQ3NRb1RDUWNPQndrRitRWUYrZ1VKSERZWEZpWVFIVEFXRUI4UEZpc1ZDaE1JQ1JFSzhRVUlDQVh5SGprWkZTWVJIVEFXRUI0UEZ5c1VVQVVKQ1JBSkNSTUxDUk1KQWdZREF3VUNBZ01CQ0JFSUNSSUtBd0VEQ0JNS0VTY1dGUzRZQ1FYNkJRWDZBbHFEQmdjTENRb2JEd2dUQ1FRSkJBMGFEUTBaRFFJRkFnTURBd0lNRlFrS0RnVUZCUWdGTFFrTUJBTURBV2tHQkFTeUJBc0V0d1FFQm1vQkRnd0xIUThjUHlFWUx4Y2hPQkVKRFFRREJBZ0Znd1lIRHd3TEhSQWJRQ0FZTUJZaE9CS0xCQVFHYVFFRkJBVU9DZ2tWREFJREF3TUNCUUlOR1EwTkdnMEVDUU1LRXdnUEd3a0pDd0ZwQndRRXNnUUxCTGNBQUFFQUFQL2FCQUFEcGdBcUFBQVRGejRETXpJZUFoVVVEZ0lqTlRJK0FqVTBMZ0lqSWdZSEZ4NEJCd1VHSmljREpqWVhSRlFpVldOdE9XV3hoVTFKZ3JKcVEzWlhNekpYZEVOQ2VDMWFId1FjL3RrY0xBUWpBeWdmQXc0bUxFY3hHa3lFc1dWbHNZUk1wRE5YZFVORGRWY3pNeTBwRGpBVDBCUVVJZ0ZrSWh3T0FBQUFBQUlBQVAvQUJBQUR3QUFsQUVzQUFDVU9BeU1pTGdJbkJ3WW1OeE0rQVJjRkZnWVBBUjRCTXpJK0FqYytBUmNlQVFjVEJ5NERJeUlPQWdjR0ZoY1dOamMrQXpNeUZoY0hEZ0VYQlJZMk54TTJKZ2NEdFNWZmIzdEJOR1ZlVmlSVEhpY0RJZ1FyR3dFaEd3UWZUaTFxT0N4VlRVRVpFMEliSEEwU0NWTWtWbDVsTkVGN2IxOGxFZ3djSEVJVEdVRk5WU3c0YWkxT0h3UWJBU0ViS3dRaUF5Y2VvelZWT2g4VUtEa2tKUTRiSVFGZElSTVR5eE12RGlNZ0loVXBPaVFjREJJU1Foc0NxU1VsT0NnVUh6cFVOaHRCRXhJTUhDVTVLUlVpSUNNT0xoVExFeE1oQVYwaEd3NEFBQUFBQVFFVS84QUM3QVBBQUJ3QUFBRWpGVE1STXhFek55TXdORFUwTmpNNkFURTFNQ0lqSWdZVkhBRXhBWDlyYTg2UUQ1OFNIaGhYZkJKMGF3SnhyLzMrQWdTdFNSb2VHN05rWVZRMkFBUUFBUC9BQkFBRHdBQUxBRU1BV2dCdEFBQUJJeFVqTlNNMU16VXpGVE1CRkE0Q0l5SXVBalUwTmpjK0FUY3VBVFUwTmpjT0FTTWlMZ0kxTkRZM1BnRXpJUWNqSGdFVkZBWUhEZ0VWRkJZZkFSNEJGUU0rQVRVMExnSWpJZ1lIRGdFVkZCNENNekkyTnhNMEppY21JaU1pQmdjT0FSVVVGak15TmpVRUFJZEZob1pGaC82S0wxeUhWMHB0UnlNdFBEK1hMZzhhQ0FZTUZnbzJWRG9lSWl3NmlUY0JIRmhSRjBaSEt3MFpHQXN4TFVYSUdBb1ZLMEVxR3pRUUVnd1VLa0FzR1RNUWJVZE5DQTBLQ2xzcUYxNkNiV0ptQWJlSGgwS0hoLzdGTDF0SUxDQTJSaVVrWENNbkZBTVNLaDhSRnd3QkFTUThTeWN2WkNVd0Z6WVRVVTFLVXlFTkh4WVdHZ2ttSlZGR0FYd1hOUklsVmtveUZSUVZOeG9pVTBreEdSRCtVRE5JTmdFSERnZzdSMGhjVXo0QUFBQUFCUUFhLzlZRDVnT2pBRUFBZmdDWkFLa0F2QUFBRXhFME5qVStBVGMrQVRjK0FUYytBVE1oTWhZekhnRVhIZ0VYSGdFWEhnRVZFUlFHRlE0QkJ3NEJCdzRCQnc0QkJ5RXVBU011QVNjdUFTY3VBU2N1QVRVbEl6d0JOUzRCSnk0Qkp5NEJKeTRCSXlZaUJ3NEJCdzRCQnc0QkJ3NEJGUVlVRng0QkZ4NEJGeDRCRng0Qk14WTJOekkyTno0Qk56NEJOVDRCTnlNVURnSWpJaTRDTlRRK0FqTXdNakV5SGdJVk9BRXhCekkyTlRRbUl5SXdNU0lHRlJRV0Z3RTZBVE15RmhVVUJpTXFBU011QVRVME5qY2FBUUVFQnhCSk95QkVJd2NQQ0FGQUFnVUNIRGtiUGxvWkRnc0JBUUVCQVFRSEVFazdJRVFpQ0E4SS9zQUNCUUljT1JzK1doa09Dd0VCQVFOMUFRRUNBd01WRWhsREpTdFdLeXRWS3h3NkhCd3lGQjRiQWdNQ0FRRUJBd01DRmhFWlF5VXJWaXNyVlNzZlB4ODFSdzRFQmdJQkFaVW5SRnMwTkZ0RUp5ZEVXelFCTTF0RUovcENZRjVDQVVOZlhrTUJBd0VCQVJnaUloZ0JBUUVYSVNFWEFSMEJRQUlGQWh3NUd6NWFHUTRMQVFFQkFRRUVCeEJKT3lCRUlnZ1BDUDdBQWdVQ0hUZ2JQbG9hRFFzQkFRRUJBUUVCQkFjUVNUc2dSQ0lJRHdpZ0hqMGVIVGtkSERJVUhoc0NBd0lCQVFFREF3SVdFUmxESlN0V0t5dFZLeHc2SEJ3eUZCNGJBZ01DQVFFQkF3VUlQalFRSXhNeFl6RTBXMFFuSjBSYk5EUmJSQ2NuUkZzMG9sOUJSR0JmUTBOZUFRSGdJaGtZSWdFaUZ4Z2lBUUFEQUFEL3dBUUFBOEFBQ3dBUEFETUFBQk1VQmlNaUpqVTBOak15RmdNakVUTUJJeEV6TUR3Q05UUTJNeklXRlJ3RE1UTXdQQUkxTkM0Q0l5SUdNVFV4K2trME5FbEpORFJKRXRUVUFWTEx5MEUvT3puU0pVSmJOMnhoQTBJMFNrbzBORXBLL3ZYOVZRS3IvVlZTYzNvb1IxRlBTU1Y2ZEZSVWY1bEVSV1pESVhCY0FBQUJBSFQvd3dPTUE4QUFVQUFBQVNJT0FoVVVGaGNXTmpjK0FUYzJKaWN1QVRVMFBnSXpNaDRDRlJRT0FpTWlKamMrQVRVMEppTWlCaFVVRmpFd0RnSUhCaFlYRkJZM1BnRTNQZ0V4SGdFek1qNENOVFF1QWlNQ0dHbWRhalE2UGdvUkFnTUhBd0lEQ0JJVktVdHJRenRiUGlFYk1VVXFMam9MRGlZbktDOURFeFFiR0FRUkRnRUxBd1JURXdVa0VGQXdSM1ZUTGpWaGlsUUR3RVJxZ3o1TWZCa0VDQXNISUFnTERBb1ZPQ1k0WmswdklqMVNNVDl5VlRKQ0x6aHdLU1EwVjBFcU0xZHZhUkpIa0FrRkFnUUdkVVlUamgwc1BXeVVWa0Y2WGpnQUFBRUFBQUFnQkFBRFlBQTVBQUFCRGdFSFBnRTNEZ0VITGdFaklnNENGeTRESnc0QkhnRVhMZ0VuQmhZWERnRW5IZ0VYRGdNbkhnTXpNajRDSno0Qk53UUFIRDBnSVRBTUgwTWtIRkF0TTFVNUZ3dEJlMjVnSnhRTEVTd2pHakFWQWw5TUZ6QVlGR3RGSVVwUFV5b2pURkZXTEpMam1Vd0ZIelVWQXY0TkVRTVRQQ1VTR2djZUpDeElYVEVESWpsT01DUlBTME1ZQVE0TFNYZ1BCZ01GUGxJQ0dpVVdCd1VXSXhnTmNMUGZieFkzSUFBQUFBRUFBQUFqQkFBRFhRQkhBQUFCSGdFVkhBRUhEZ01IRGdNaklpWXZBaTRCSXlJR0J5Yy9BVDRCTnpJMk16SVdGeDRCRng0QkZ4NEJNekkyTno0Qk56UTJOVFFtSXlJR0J6NERNem9CTXdOclNrc0JBUncwVFRJMFlWaFFKUzFMSGlvcUZ6RWJCU2dpTVV0TE1rc2FCQWNETmtJTkNBd0ZCQWdFRVNZVkR6RWdJQ0lEQVNNakVTWVVFalZGVmpNREJnTURYUUpVVXdVTUJTTlRYMnc5UDE4L0lFMU9qWTVNVFJZWE9qOCtLQ3NEQVUxTkxFY2JIQ1lMU0Vrdkx6RklGd1VKQkNBZkJ3YzNWRGdjQUFzQVdmL0FBNmNEd0FBUEFCZ0FJUUE4QUZVQWhBQ1NBTUlBMGdEc0FRZ0FBQ1UxTkNZaklnWUhGUjRCTXpJMk5URTNNelUwSmlNaUJoVWxGU01SSXhFak5UTVhFU00xRGdFaklpWW5MZ0U5QVRNVkhBRVhGQll6TWpZM05UTVhGUlFHQnc0Qkl5SW1KeFVqRVRNVlBnRXpNaFlYSGdFVkZ4VWNBUWNPQVFjT0FTTWlKaWN1QVQwQk5EWTNQZ0V6TWhZWEhnRWRBU01WRkJZek1qWTNNRFEzUEFFOUFUTUJGUlFHSXlJbVBRRTBOak15RmdFMEppY3VBU2N1QVNjdUFTTWlCZ2NPQVFjT0FRY09BUlVVRmhjZUFSY2VBUmNlQVRNeU5qYytBVGMrQVRjK0FRRTNJd2NuSXhjd0ZoY2VBUmNWTXpVWE5UUW1KeTRCSXlJR0J3NEJIUUVVRmhjZUFUTXlOamMrQVJjekVTTVZEZ0VqSWlZblBBRTlBU01WRkJZWEhnRXpNalkzRlRFQ2RBc0xCd3dHQmd3SEN3dU9NdzBOREEzK1NEMDVQTEtiTkE4ZERnMFFBd01DTXdFR0JRZ1FDRFRDQXdJRkZCQU9HZ3cwTkF3YURoQVVCUUlEd1FFQkJnVUtIeFFVSUFzSUNBZ0lDeDRVRkI0S0NBaG1EUTBKREFJQk5QNmxEQTBNREF3TURRd0JtZ2NIQkJFTURSMFJOSjlxYXA0MEVSNE1EUkFFQ0FjSENBUVFEUXdkRVRTZmFtcWVOUkVkREEwUUJBZ0gvYnRGT1Nnb1BCSUpDUTBTQkRuZkNBa0xIaE1USGdzSUNBZ0lDeDRURXg0TENRaUxORFFJRVFjR0JnRTBBZ01FRUEwT0hSQ0FlUlFUQmdhdEJnWVRFbDRiRXhRVUU3STIvcnNCUlRaaC91WWVFUkVMQ2djVUQ5L1FDUW9CQlFZTUROZFZjUlFjQ0JBUUVBOGJBWHQ4RUE4UUVBZ2RGR1FHREJBR0NBOEhFQThPRHdvaUZtUVdJUXNPRHc4T0N5RVdPeklVRXdvS0F3SURCZ1FRQW50NEZCUVVGSGdVRkJUOXgwUmtJQkVjREFzTkFnWUdCZ1lDRFFzTUhCRWhaVUpFWkNBUkhBc01EUUlHQmdZR0FnME1DeHdSSUdRQ09lU1dsalViR2lnOUZadWJQbVFXSWdzT0R3OE9DeUlXWkJjaEN3OE9EZzhLSWtZQkhkb01EQWNHQVFvSjBlRVBGUWNLQ2hFUkh3QUFBZ0FBLzhBRUFBUEFBQk1BTVFBQUFTSU9BaFVVSGdJek1qNENOVFF1QWhNd0lpTWlCaFVjQVRFekJ5TVJJeEVqTlRNd05EVTBOak02QVRFVk1RSUFhcnVMVUZDTHUycHF1NHRRVUl1N0lqUVBFUXRmQ1ZaOFFFQkJSUXRLQThCUWk3dHFhcnFMVVZHTHVtcHF1NHRRL3NnUUV3OHNaLzdLQVRScElETTZQR3NBQUFBQUJRQUEvOEFFQUFQQUFCSUFKZ0JZQUdVQWVBQUFBUTRCSXlJbU5UUTJOejRCTXpJV0ZSUUdCd1VVRGdJaklpNENOVFErQWpNeUhnSUJOQ1l2QVM0Qk5UUTJOejRCTlRRbUp6TTNJeUlHQnc0QkZSUVdNekkyTnc0QkZSUVdGdzRCQnc0QkZSUVdNekkyTlRjak5TTVZJeFV6RlRNMU16VUZJaVlqSWdZSERnRVZGQll6TWpZMU5DWW5BZDBLSHc4MU1nZ0tDaUFRTXpRR0RnSWpVSXU3YW1xN2kxQlFpN3RxYXJ1TFVQNVZLUndkQnc0T0NCb3JLZzR4TmFzaFV5TWJGRWRCQmc0SEJBVVFDUnhiSmlRYlZWbHFjTjVSS2xGUktsSCtrZ1VJQmdZM0dRNDVUMEk3UFNvdkFnb0tEMmNwRUNFTkRBMXFLd3NnRGtwcXVvdFJVWXU2YW1xN2kxQlFpN3YrK3lreEZ4WUdFQTBPRWdnVU1pMHVNUXNoRGgwV1BSd3ZVQUVCQnc0TEVob0xBZ3dYRlRnV0xVZGdPcjFTVWlkU1VpZHlBUVVJQlNRckt6Y3hKaDhySVFBRkFBRC93QVFBQThBQUN3QWpBRE1BUndCWUFBQUJORFl6TWhZVkZBWWpJaVlsRkFZaklpWTFORFkzSXhVVUZqTWhNalk5QVNNZUFSVTNJeUlHSFFFVUZqc0JNalk5QVRRbUJSUU9BaU1pTGdJMU5ENENNekllQWljMEppTWhJZ1lWRVJRV015RXlOalVSQVpjOUxDcytQU3dzUFFFUllrWkdZZ01ETUF3SkFYb0pEREFEQXhVL0NRd01DVDhKREF3Qk9sQ0x1MnBxdTR0UVVJdTdhbXE3aTFEdkpScitYQm9sSlJvQnBCb2xBY0FzUFQwc0t6NCtLMFppWWtZTEZRcm5DUXdNQ2VjS0ZRdlNEQWsvQ1F3TUNUOEpETkpxdW90UlVZdTZhbXE3aTFCUWk3dG9HaVVsR3Y1Y0dpVWxHZ0drQUFBQUJBQUEvOEFFQUFQQUFCTUFGd0FqQUQ0QUFBRWlEZ0lWRkI0Q016SStBalUwTGdJQkl4RXpKeUltTlRRMk16SVdGUlFHQVNNd05EVTBKaU1pQmhVY0FURWpFVE1WTURZek1oWVZIQUV4QWdCcXU0dFFVSXU3YW1xN2kxQlFpN3YvQUhCd09Cd25KeHdiSnljQnhIQWVJQ0VqYkd3ME9qbExBOEJRaTd0cWFycUxVVkdMdW1wcXU0dFEvTzhCYkRBbkhCd25KeHdjSi81a21DY25LeXdtS3BVQmJERThSMHBKblFBQUFBSUFBUC9BQkFBRHdBQVRBRjRBQUFFaURnSVZGQjRDTXpJK0FqVTBMZ0lESWlZbk1BWUhEZ0VIQmlZMUxnRTNQZ014TUNZMU5EWXpNaFlWRkFZSEJoWXpNalkxTkNZaklnWVZGQllYSGdFSERnRUhEZ0VuTGdFMU5ENENNekllQWhVVURnSWpBZ0JxdTR0UVVJdTdhbXE2aTFGUWk3czZIVEVKRmdNTE1nTUNCZ0VJQ2dJUEVBd0xLQndaRnhjSUJ5TWNNajVNUjFGZURRc0ZBUUVDQkFJQkNnWWxKQ0EvWHo4elV6c2dIREpIS2dQQVVJdTdhbXE3aTFCUWk3dHFhcnVMVVAxM0doSldEQ2xIQkFJQkF3WldLd3MvUXpRZkdTZzBIeFlaUXlJY0tIQk1PMDFuUXhjaURBWUhCd1VUQkFjRkF3OUtMaVpQUUNraU9Va25OVmxCSkFBQUFnQUEvOEFFQUFQQUFCTUFRd0FBQVNJT0FoVVVIZ0l6TWo0Q05UUXVBaE1XRGdJaklpWW5GalkzTGdFbkZqWTNMZ0UzSGdFekxnRTNIZ0VYSmpZek1oWVhQZ0UzRGdFSFBnRTNEZ0VIQWdCcXU0dFFVSXU3YW1xN2kxQlFpN3VBQXl4WWdsUXpYaWd3WFNZb1Bnc09IQXdyTmdFTUd3OG9GUmd0Z0V3T1NUb2FMaEFWSmhJSEhCSVNJeEFNSHhFRHdGQ0x1MnBxdW90UlVZdTZhbXE3aTFEK2VFQ0FaMEFkR1FVWkhnRXZKQU1DQXdsRktnY0lHMTBwTjBNRU9Gd1ZFUVFQQ2hVaURBTUpCeElmRFFBQUFBSUFBUC9BQkFBRHdBQVRBRlVBQUFFaURnSVZGQjRDTXpJK0FqVTBMZ0lURGdFSERnRWpJaVl2QWk0Qkl5SUdCeWMvQVQ0Qk56STJNeklXRng0QkZ4NEJGeDRCTXpJMk56NEJOendCTlRRbUl5SUdCejRCTXpvQk14NEJGUndCRlFJQWFydUxVRkNMdTJwcXU0dFFVSXU3eVFJL1BEOXFLeHd0RWhrWkRoMFFCQmNWSFMwdEhpMFFBZ1FDSUNnSUJBY0RBd1VDQ3hZTkNSMFVFeFFDRlJRTEZ3d1dVejRDQXdJc0xRUEFVSXU3YW1xN2kxQlFpN3RxYXJ1TFVQNkZLbkpKVEV3dkxsVlZMaTRPRFNNbEpSZ2FBZ0V1TGhzcUVSQVhCeXNzSEIwZEt3NERCUU1URXdVRVEwTUJNeklEQndNQUFBQU1BQUQvd0FRQUE4QUFEZ0FZQUNFQVBRQldBSVlBbEFERkFOVUE3d0VLQVI0QUFBRTFOQ1lqSWdZSEZSNEJNekkyTlRjek5UUW1JeUlHSFFFbEZTTVZJelVqTlRNWEZTTTFEZ0VqSWlZbkxnRTlBVE1WSEFFekZCWXpNalkzTlRNeEZ4VVVCZ2NPQVNNaUppY1ZJelV6RlQ0Qk16SVdGeDRCRlJjVkhBRUhGQVlIRGdFaklpWW5MZ0U5QVRRMk56NEJNeklXRng0QkhRRWpGUlFXTXpJMk56QTBOVFkwUFFFekZRTVZGQVlqSWlZOUFUUTJNeklXRXpRbUp5NEJKeTRCSnk0Qkl5SUdCdzRCQnc0QkJ3NEJGUlFXRng0QkZ4NEJGeDRCTXpJMk56NEJOejRCTno0Qk5RRTNJd2NuSXhjd0ZoY2VBUmNWTXpVWE5UUW1KeTRCSXlJR0J3NEJIUUVVRmhjZUFUTXlOamMrQVJjek5TTVZEZ0VqSWlZMUlqUTlBU01WRkJZWEhnRXpNalkzRlFVVURnSWpJaTRDTlRRK0FqTXlIZ0lDUmdjSEJBY0VCQWNFQndkVkhnY0lDQWYrK0NVaUpHdGRId2tTQ0FnS0FnRUJIZ0VEQkFRS0JSOTBBUUlEREFrSkR3Z2ZId2NRQ1FrTUF3SUJkQUVFQXdZU0RRd1NCd1VGQlFRSEV3c01FZ1lGQlQwSUJ3WUhBUUVmMEFnSEJ3Z0lCd2NJOWdRRkFnb0lCeElLSDE5QVAxOGdDaElIQ0FvQ0JBVUZCQUlLQ0FjU0NoOWdQejlnSHdvU0J3Z0pBd1FGL3FNcUl4Y1pKQXNHQlFnTEFpS0dCUVVIRWdzTUVnWUZCUVVGQmhJTUN4SUhCUVZUSHg4RkNRVURCQUVmQWdFRENRZ0lFZ2tCaGxDTHUycHF1NHRRVUl1N2FtcTdpMUFCQUVrTERBUURhQVFEQ3dzNUR3d01EQXdQZXlIRHd5RTdxUklLQ3djR0JBMElobndHQmdRREJ3ZUJNME1NRVFVS0Nnb0pFT1JMQ1FvS0NnVVJERHdFQmdvRUJRa0VDUW9KQ1FZVURqc09GQVlKQ1FrSkJoUU9JeDRNQ3dZR0FnRUJCQU1LQVFGOVNBd01EQXhJREF3TS9xc3BQQk1LRVFjSENBRURCQVFEQVFnSEJ4RUtGRHdvS1R3VENoRUhCd2dCQkFNREJBRUlCd2NSQ2hNOEtRRXNpVnBhSUJBUUZ5VU5YRndsUEE0VUJna0pDUWtHRkE0OERSUUhDUWtKQ1FZVUthdURCd2dFQkFZR2ZvZ0lEUVFHQndzS0VrNXF1b3RSVVl1NmFtcTdpMUJRaTdzQUFBSUFBUC9BQkFBRHJ3QTJBRWNBQUFFWEVUQUdJeW9ESXlJbUp5WTJOVFFtTlRRMk5UUW1OVFEyTlRRbU5UUTJNeUV1QVNjdUFUYytBUmNlQXhjZUF4Y0ZJeUlHRlJFVUZqc0JNalkzRXpZbUl3TE5TWTVSS0haM2FSMFhLZzhRRVRRWU1TWW1NQndCTFFNckVSVWJHeUZaRFFjU0ZoY01GajA4TXcwQklvOElEZzRJTVFnUEFsWUJDUWtCZ3pqK3Zra2dJaUVwQmdZdEh4OGREQXdXS3lvWUJ3Z2NMeTRqTDA0dkwyd2dKeE1ZREQ1SlJSSWlaV0pPQ3hVUENQNTlDQXdNQ0FHRkNBMEFBZ0FBLzlFRUFBUEFBRFlBUndBQUFTY1JNRFl6T2dNek1oWVhGZ1lWRkJZVkZBWVZGQllWRkFZVkZCWVZGQVlqSVI0QkZ4NEJCdzRCSnk0REp5NERKeVV6TWpZMUVUUW1Ld0VpQmdjREJoWXpBVE5KamxFb2RuZHBIUmNxRHhBUk5CZ3hKaVl3SFA3VEF5c1JGUnNiSVZrTkJ4SVdGd3dXUFR3ekRmN2Vqd2dPRGdneENBOENWZ0VKQ1FIOU9BRkNTU0FpSWlnR0JpMGZIeDBNREJZcktoZ0lCeHd2TGlRdVRpOHZiQ0FuRXhnTVBrbEZFaUpsWWs0TEZROElBWU1JREF3SS9uc0lEUUFFQUFBQUNnUUFBM3dBR2dBZkFDUUFLQUFBQVNFaUJoVVJGQlk3QVJVVUZqYytBekVoTWpZMUVUUW1Jd1VoRlNFMUFTRTFJUlVsSVRVaEE3ejhpQndvS0J4bkhRMEJORHd4QWtVY0tDZ2MvTzhDSXYzZUFabitad0daQVJIOVZnS3FBM3dvSGYzZUhDaTVFQVlJQWo1S1BTZ2NBaUlkS0t0RVJQNnJSRVNJUkFBQUFBQUJBQUQvK2dRQUEyNEFQZ0FBQVNJR0J3NEJCdzRCQnc0QkJ5NEJKeTRCSnk0Qkp5NEJJeUlHQnc0QkZSUVdGeDRCRng0QkZ4NEJGeDRCRndFZUFUTXlOamNCUGdFMU5DWW5MZ0VqQXZJU0l4SVNJeEFQSFFvS0dBc0tGUTBLSFJBUEl4SVNKQkpBWlNRbUpRWUlCeEFIQ0JRS0NoQUZCUWNGQVdZRkN3Z0lDd1VCWmtNL0pDUWVaVU1EYmdZSUJSSUxDaFFIQ2hJS0NoUUlDaEVLQ3hBSEJnZ2tKQ05qUXhJb0ZCVWpEUThiREEwVUJRVUdBLzZrQlFVRkJRRlpRNEJBUUdNakpDUUFBQUVBQi8vQUEvWUR2UUF5QUFBQkxnRXZBaTRCSnpFakRnRVBBZzRCQndZV0h3RURCaFlYSGdFN0FUSTJQd0VYSGdFN0FUNEJOejRCSndNM1BnRW5BL1lJSWhmOWRBb2pGd29WSWdweC9CY2xCUWdORDdrdEFnOFNDaGtOQ2dnUENPSGhDQlFORGdvVUJ4SVNCU3k0Q2dzSEFqNFhIZ1VtN3hRWkF3TVpGTzhtQWlFWEZ5c1F1Lzd5RnlzTkNnb0ZCWDkvQlFVREJnZ05LeGNCRGI4UUxoUUFBQUFBQXdBQUFFZ0VBQU0zQUE4QUV3QWZBQUFCSVNJR0ZSRVVGak1oTWpZMUVUUW1Cd2tCSVFFUkFSNEJNekkyTndFUklRTzgvSWdjS0NnY0EzZ2NLQ2h4L3BuK21RTE8vTzRCalFZUUNBZ1FCZ0dOL0tvRE55Y2MvWmdjS0NnY0FtZ2NKMVgrbWdGbS9id0NFUDV6QmdZR0JnR00vZkVBQUFBQUFnQUFBQ2dEK1FPREFCTUFLd0FBSlJVaEVUTTNJeUlHRlJFVUZqTWhNalk5QVFjQkF5WUdIUUV3RGdJSFBnTXhGUlFXUHdFMk5DY0M3LzJJYUhmcUxUOC9MUUtOTFQ5MkFRcnlCd3lSdkxNalNiMnBkQXdIOFFnSDYwMEJpM2MvTGY1ZkxEOC9MTTUyQVpnQkFBVUZDVzRwYmIrVlRsQWlBbXNKQmdiNUJROEdBQUFBQWdCUUFCQURzQU53QUNZQVVRQUFBVDRCTno0QkhnRVhCeTRCQnc0QkR3RUdGQmNXTWo4QkhnRTNCdzRCSWlZbkxnRTBOajhCQVFjMkZoYzNOaklYRmhRUEFRWWlKeTRCSndjZUFSY2VBUmNXTmpjK0FUOEJQZ0UwSmljdUFTSUdCd0VJRGg4UkxtWmhWUjVnRkZ3ekV5UVB1Q29xS25jcE9TZFJLWDBvWldsbEtTZ29LQ2k0QVNSOUtWRW5PU2wzS2lvcXVDcDNLUW9RQldBSUVBb2FRU2N4WmkwUkh3NjRLQ2dvS0NobWFXVW9Ba3dPRndrYURCYzZMV0F2TUF3RUV3KzRLbllxS2lvNUR3MERmU2dvS0NncFpXbGxLTGdCSkgwRERRODVLU2txZHltNEtpb0pHQXRmREJRS0dpWUpEQTRZQ1JnT3R5bGxhV1VvS1Nnb0tBQUFBQUFFQUFEL3dBUUFBOEFBQ2dBT0FDSUFNd0FBQVRjUklSRVhIZ0V6TWpZVElSYzNCUlFPQWlNaUxnSTFORDRDTXpJZUFpYzBKaU1oSWdZVkVSUVdNeUV5TmpVUkFndnUvZ0R1QXdvRkJRbkovbExYMXdFd1VJdTdhbXE3aTFCUWk3dHFhcnVMVU5RWUVmM3JFQmdZRUFJVkVSZ0JXdTMreEFFODdRUUVCQUVSMTllbmFydUxVRkNMdTJwcXU0dFFVSXU3U0JFWEZ4SCtqaEVYRnhFQmNnQUFBd0FBLzhBRUFBUEFBQk1BSmdBK0FBQUJJZzRDRlJRZUFqTXlQZ0kxTkM0Q0V4UUdJeUVpSmowQk5EWTdBUWNqRlNFMU56Y0hCaVk5QVRBT0FnYytBekUxTkRZZkFSWVVCd0lBYXJ1TFVGQ0x1MnBxdTR0UVVJdTdiQ1liL25rYkppWWJqRWMvQVh0SFdaRUVDRVZsY2l3VmJIQlhCd1dSQkFRRHdGQ0x1MnBxdTR0UVVJdTdhbXE3aTFEOVBSb21KaHI3R2laSDdTNUhuNVlEQXdaQUFSUXdMMWx6UVJsQ0JRTURtZ01KQXdBREFBRC93QVFBQThBQUV3QTBBRnNBQUFFaURnSVZGQjRDTXpJK0FqVTBMZ0lEQmlJbkpqUS9BVDRCTnpZV0Z3Y3VBUWNPQVE4QkJoUVhGakkvQVI0Qk53Y0JCdzRCQnc0Qkp5NEJKeTRCSnpjZUFSY1dNajhCTmpRbkppSVBBUzRCQnpjMk1oY1dGQWNDQUdxN2kxQlFpN3RxYXJ1TFVGQ0x1NE10Z1M0dExXa0hFZ2sxZGlJM0N6VWNDeFVJYUJnWUdFTVlJQll1RjBjQkRtZ0lFZ2thT2h3V0pRNEdDUVEyQXdrRkdFTVlhQmdZR0VNWUlCVXZGMGN0Z1M0dExRUEFVWXU2YW1xN2kxQlFpN3RxYXJxTFVmMEZMaTR0Z1M1b0NBMEZIUnd6TmhvYkJnTUxDR2dZUXhnWEZ5QUlCd0pIQVExb0NBMEZEZ2dIQlJVUEJnc0hOZ2NOQlJnWWFCaERGeGdZSUFrSEFrY3VMaTZBTGdBQUFRQUEvOEFFQUFQQUFDb0FBQUVPQVNNaUppY3VBVFUwTmpjMkxnSWpJZzRDTVJRZUFoY2VBek13UGdJMU5DNENCd0x2TXlJME0yWXpORlZWTkJrbVRWb1pHa1pBTFRCTllqSXlrWnFTTTBCTlFFSmFXeG9CV2pSVlZUUXpaak0wSWpNYVcxcENRRTFBTTVLYWtUSXlZazB3TFVCR0dobGFUU1laQUFRQWl2L0FBM1lEd0FBTkFCY0FJd0F2QUFBQkl6VTBKaU1pQmgwQkl3TWhBeVUwTmpNeUZoMEJJVFVESWlZMU5EWXpNaFlWRkFZaElpWTFORFl6TWhZVkZBWURWcUZxUzB0cW9TQUM3Q0QrRzFRN08xVCs0aElXSGg0V0ZSNGVBUzRXSGg0V0ZSNGVBcTFlUzJwcVMxNzlFd0x0WGp0VFV6dGVYdjczSGhVVkhoNFZGUjRlRlJVZUhoVVZIZ0FBQUFFQUFBQklCQUFET0FBZ0FBQUJKeTRCSnpVakRnRWpJaVluSXhVT0FROEJGemNlQVJVUklSRTBOamNYTnljRHFWb1FKaFI2RUVvdUwwb1BlaFlwRUxLaVNBSUNBaWtDQVVTaVZ3S21hQklWQWdFcE5UVXBBUUVWRTg1OVV3VU5CLzVMQWJVR0N3VlBmV1VBQUFjQUFQL2tCQUFEbkFBbkFFOEFYd0J3QUgwQWlRQ05BQUFCSXpjK0FUVTBKaU1pQmc4Qkp5NEJJeUlHRlJRV0h3RWpJZ1lWRVJRV015RXlOalVSTkNZakV4UUdJeUVpSmpVUk5EWXpJU2N1QVRVME5qTXlGaDhCTno0Qk16SVdGUlFHRHdFaE1oWVZFUUVoSWdZVkVSUVdNeUV5TmpVUk5DWVRGQVlqSVNJbU5SRTBOak1oTWhZVkVUY3lGaFVVQmlNaUpqVTBOak1uTkRZek1oWVZGQVlqSWlZRkZ3YzFBMzZ5R0EwUE9DZ1RJdzFkWEEwakV5ZzREdzBZc2pkTVREY0MrelpNVERZNklCcjlCUm9pSWhvQldJMEVCQkFMQlFvRGpZMEVDZ1VMRUFRRWpRRllHaUQrdy81d01rbEpNZ0dRTTBoSUtUb2wvbTBtTURVbEFaTW1OWUFYSVNFWEdDRWhHRGdnR0JjaElSY1lJUDVjaFlVQzVCY05JaE1vTnc4TlhGd05EemduRXlJTkYwODIvZ2MyVEV3MkFmazJULzJDR2lBZ0dnSDVHaU9PQXdvR0N3OEVCSTJOQkFRUEN3WUtBNDRqR3Y0SEFmbElNLzhBTTBoSU13RUFNMGorZ3lVMU1pVUJCeVUxTmliKy91TWhGeGdoSVJnWElXSVhJU0VYRnlFaFFXdHIxZ0FBQUFjQUFQL2tCQUFEbkFBbkFFOEFZQUJ3QUh3QWlBQ1ZBQUFCSXpjK0FUVTBKaU1pQmc4Qkp5NEJJeUlHRlJRV0h3RWpJZ1lWRVJRV015RXlOalVSTkNZakV4UUdJeUVpSmpVUk5EWXpJU2N1QVRVME5qTXlGaDhCTno0Qk16SVdGUlFHRHdFaE1oWVZFUUVoSWdZVkVSUVdNeUV5TmpVUk5DWWpFeFFHSXlFaUpqVVJORFl6SVRJV0ZSY1VCaU1pSmpVME5qTXlGaWMwTmpNeUZoVVVCaU1pSmdVekZTTTFNelV6RlRNMU14VURmcklZRFE4NEtCTWpEVnhkRFNNVEtEY09EUml5TmsxTk5nTDdOa3hNTmpvZ0d2MEZHaUVoR2dGWWpRUUVFQXNGQ2dTTmpRTUtCUXNRQkFTTkFWZ2FJUDdEL25BeVNFZ3lBWkF6U0VnelhEb2wvbTBsTVRVbUFaSW1OYmdoRnhjaElSY1hJWEFoRnhjaElSY1hJZjdyRmRjVVNCOUhBdVFYRFNJVEtEY09EbDFkRFE4NEp4TWlEUmRQTnY0SE5reE1OZ0g1TmsvOWdob2dJQm9CK1JvampnTUtCZ3NQQkFTTmpRUUVEd3NHQ2dPT0l4citCd0g1U0RQL0FETklTRE1CQUROSS9vTWxOVElsQVFjbE5UWW1WeGdoSVJnWElTR0RGeUVoRnhjaElXbWFtaFFVRkJRQUFBY0FBUC9rQkFBRG5BQW5BRThBWUFCeEFIMEFpUUM1QUFBQkl6YytBVFUwSmlNaUJnOEJKeTRCSXlJR0ZSUVdId0VqSWdZVkVSUVdNeUV5TmpVUk5DWWpFeFFHSXlFaUpqVVJORFl6SVNjdUFUVTBOak15Rmg4Qk56NEJNeklXRlJRR0R3RWhNaFlWRVFFaElnWVZFUlFXTXlFeU5qVVJOQ1lqRXhRR0l5RWlKalVSTkRZeklUSVdGUkUzRkFZaklpWTFORFl6TWhZbk5EWXpNaFlWRkFZaklpWUhNQlFWRkFZSERnRXJBU0ltTlRRMk16QTJQUUVIRlRBVUZSUUdCdzRCSXpFNEFURWlKalUwTmpNd05qMEJOeFVEZnJJWURRODRLQk1qRFZ4ZERTTVRLRGdQRFJpeU5rMU5OZ0w3Tmt4TU5qb2dHdjBGR2lFaEdnRllqUVFFRUFzRkNnU05qUU1LQlF3UEJBU05BVmdhSVA3RC9uQXlTRWd5QVpBelNFZ3pYRG9sL20wbE1UVW1BWkltTmJnaEZ4Y2hJUmNYSVhBaEZ4Y2hJUmNYSWVrS0NRZ1hEUUVTR2hrU0dIRUpDUWtXRGhJYUdSSVh3d0xrRncwaUV5ZzNEZzVkWFEwUE9DY1RJZzBYVHpiK0J6Wk1URFlCK1RaUC9ZSWFJQ0FhQWZrYUk0NERDZ1VMRUFRRWpZMEVCQThMQmdvRWpTTWEvZ2NCK1Vnei93QXpTRWd6QVFBelNQNkRKVFV5SlFFSEpUVTJKdjcrcWhjaElSY1lJU0dERnlFaEZ4Y2hJYW9xRFF3VkNRZ0lHaElTR2dJSll5VlBLZzBNRlFnSUNCa1RFaGtDQ25vOWl3QUFCd0FBLytRRUFBT2NBQ2NBVHdCZ0FIRUFmUUNKQUtnQUFBRWpOejRCTlRRbUl5SUdEd0VuTGdFaklnWVZGQllmQVNNaUJoVVJGQll6SVRJMk5SRTBKaU1URkFZaklTSW1OUkUwTmpNaEp5NEJOVFEyTXpJV0h3RTNQZ0V6TWhZVkZBWVBBU0V5RmhVUkFTRWlCaFVSRkJZeklUSTJOUkUwSmlNVEZBWWpJU0ltTlJFME5qTWhNaFlWRVRjVUJpTWlKalUwTmpNeUZpYzBOak15RmhVVUJpTWlKZ2NWRkFZSEZTTTFMZ0U5QVRRMk93RXdOREUwTmpzQk1oWWRBVE15RmhVRGZySVlEUTg0S0JNakRWeGREU01US0RnUERSaXlOazFOTmdMN05reE1Oam9nR3YwRkdpRWhHZ0ZZalFRRUVBc0ZDZ1NOalFNS0JRd1BCQVNOQVZnYUlQN0QvbkF5U0VneUFaQXpTRWd6WERvbC9tMGxNVFVtQVpJbU5iZ2hGeGNoSVJjWElYQWhGeGNoSVJjWElmWVpFcFlTR1JzVUR3UURZd01FRHhNYkF1UVhEU0lUS0RjUERWeGNEUTg0SnhNaURSZFBOdjRITmt4TU5nSDVOay85Z2hvZ0lCb0IrUm9qamdNS0Jnc1BCQVNOalFRRUR3c0dDZ09PSXhyK0J3SDVTRFAvQUROSVNETUJBRE5JL29NbE5USWxBUWNsTlRZbS92NnJHQ0VoR0JjaElZTVhJU0VYRnlFaGdtZ1RHZ0VhR2dFYUUyZ1RHeWNEQkFRREp4c1RBQUFMQUFELzVBUUFBNXdBSmdCT0FGOEFjQUI5QUlrQXFBQ3NBTUVBMHdEb0FBQUJJemMrQVRVMEppTWlCZzhCSnk0Qkl5SUdGUlFXSHdFaklnWVZFUlFXTXlFeU5qVVJOQ1lURkFZaklTSW1OUkUwTmpNaEp5NEJOVFEyTXpJV0h3RTNQZ0V6TWhZVkZBWVBBU0V5RmhVUkFTRWlCaFVSRkJZeklUSTJOUkUwSmlNVEZBWWpJU0ltTlJFME5qTWhNaFlWRVRjVUJpTWlKalUwTmpNeUZoVW5ORFl6TWhZVkZBWWpJaVlGTXhVT0FTTWlKalUwTmpNeUZoOEJJelV1QVNNaUJoVVVGak15TmpjeE56TVZJemN6RlNNMURnRWpJaVk5QVRNVkZCWXpNalk5QVRjaUJnYzFJeFV6TlI0Qk16STJOVFFtSXhjak5UUTJNVE0xTkRZeE16SVdIUUV6TWhZZEFRTitzaGdORHpnb0V5SU9YRjBOSXhNb053NE5HTEkyVFUwMkF2czJURXdFSUJyOUJSb2hJUm9CV0kwRUJCQUxCUW9FalkwRENnVU1Ed1FFalFGWUdpRCt3LzV3TWtoSU1nR1FNMGhJTTF3NkpmNXRKVEUxSmdHU0pqVzRJUmNYSVNFWEZ5RndJUmNYSVNFWEZ5SCtEQ1lHSWhnZEp5Y2RHQ0VHQVNZRERna09FeE1PQ0E4RE5DTWpnaU1oQmhFSkdCMGpDQkFMRFhvTEV3Y2tJZ2dVQ3hvbEpSb2FNUUlIQWhzQkFRY0JBUUxrRncwaUV5ZzNEdzFkWFEwUE9DY1RJZzBYVHpiK0J6Wk1URFlCK1RaUC9ZSWFJQ0FhQWZrYUk0NERDZ1lMRHdRRWpZMEVCQThMQmdvRWpTTWEvZ2NCK1Vnei93QXpTRWd6QVFBelNQNkRKVFV5SlFFSEpUVTJKdjcrcWhjaElSY1lJU0VZbXhjaElSY1hJU0hjQVJZYUtCMGVLQmtYQVFFR0NoWVFEeFVKQjVDK2hZVUxCd1lnR2sxTkJSUU9DMDBDQndkRnZnMEhDQ2djSFNobU9RRUJDQUVCQVFFSUFRRTVBQUFUQUFBQVFBUUFBMEFBSGdBaUFEWUFTQUJkQUcwQWZRQ05BSjBBclFDOUFNMEEwZ0RpQVBJQkFnRVNBU0lCTWdBQUFUTUhEZ0VqSWlZMU5EWXpNaFlYRlNNbkxnRWpJZ1lWRkJZek1qWTNOUmN6RVNNWEZBWWpJaVk5QVNNVkZCWXpNalkzRlRNMUl3VVVCaU1pSmljVkl4RXpGVDRCTXpJV0ZTYzBKaXNCTlRRbUt3RWlCaDBCSXlJR0hRRXpOUk1SRkFZaklTSW1OUkUwTmpNaE1oWUJOQ1lyQVNJR0hRRVVGanNCTWpZMU5UUW1Ld0VpQmgwQkZCWTdBVEkyTlRVMEppc0JJZ1lkQVJRV093RXlOalUxTkNZckFTSUdIUUVVRmpzQk1qWTFOVFFtS3dFaUJoMEJGQlk3QVRJMk5UVTBKaXNCSWdZZEFSUVdPd0V5TmpVQkVTRVJJVGMwSmlzQklnWWRBUlFXT3dFeU5qVTFOQ1lyQVNJR0hRRVVGanNCTWpZMU5UUW1Ld0VpQmgwQkZCWTdBVEkyTlRVMEppc0JJZ1lkQVJRV093RXlOalUxTkNZckFTSUdIUUVVRmpzQk1qWTFOVFFtS3dFaUJoMEJGQlk3QVRJMk5RRS9OUUVITUNNcE9EZ3BJakFJTkFFRUZBMFRHeHNUREJVRlNqRXh1Qk1QR0FrektTSU5Gd2t3TWdFSE5DWVFIQXN3TWdzYkR5WTBOUUVCQ3dJQkpRSUJDZ0VDUmUxTE4vMEVOa3hNTmdMOE4wdjhYQXdJRlFnTURBZ1ZDQXdNQ0JVSURBd0lGUWdNREFnVkNBd01DQlVJREF3SUZRZ01EQWdWQ0F3TUNCVUlEQXdJRlFnTURBZ1ZDQXdNQ0JVSURBTXAvUFlEQ2x3TUNCUUpEQXdKRkFnTURBZ1VDUXdNQ1JRSURBd0lGQWtNREFrVUNBd01DQlFKREF3SkZBZ01EQWdVQ1F3TUNSUUlEQXdJRkFrTURBa1VDQXdCZkFFZ0pEZ3FLamtrSVFFQkNBNGVGeFVmRFFvQlFRRU93QThVSFFadGJTUXVDZ2tQdTEwcE9Rd0tFZ0VPWWdrTE9Ta2hBZ0VMQVFJQ0FRc0JBbEJRQVFMK0JqWk1URFlCK2pWUFQvM1VDQXdNQ0JRSkRBd0pld2dNREFnVkNRc0xDWHNJREF3SUZBa01EQWw2Q1F3TUNSUUpEQXdKZXdnTURBZ1ZDQXdNQ0hzSkRBd0pGQWtNREFuOXpRS0UvWHhIQ0F3TUNCUUpEQXdKZXdnTURBZ1ZDUXNMQ1hzSURBd0lGQWtNREFsNkNRd01DUlFKREF3SmV3Z01EQWdWQ0F3TUNIc0pEQXdKRkFrTURBa0FDQUFDLzhBRUFBUEFBQ1lBS2dBdUFESUFOd0E5QUVJQVRRQUFBU0VsUGdFdkFTNEJKeTRCSXlJR0l3VU9BUjhCSGdFeEJoUVZFUlFXTXlFeU5qVVJOQ1lqQnlNM015RUhJemNqQnlNMUpTYzNGd2NsQnljM0Z5TUZOeGNISndFaElpWTFFU0VSRkFZakE3TCthZ0YzSHlNR0ZnTVJEUWtXQ3dRSUJQemdJQ01IRmdJTkJVQTZBdFk2VkM0Z2Q2RmhvUDYzWUtsaHAyRXVBU3FLbzRxakFlV2dpYWVDQWZ6S0hZcU9HUU1hL1VJT0pnTTVPUTRDWjFRR05oNXREeG9JQmdjQm53WTBIbThIQlFnVUMvNHRPVnBhT1FIVEh5S3RYRnhjWEZ5TFd5RmFJbVFoV2lGV05BZGNIblA5UENNZkFVWCt1eUFpQUFBRUFBQUFKZ1FBQTFvQUpBQXZBRG9BUGdBQUFTTTFOQ1lyQVNJR0hRRWpOVFFtS3dFaUJoMEJJeUlHRlJFVUZqTWhNalkxRVRRbUl5VTBOanNCTWhZZEFTTTFJVFEyT3dFeUZoMEJJelVCSVJFaEE4MUlLQnZuR3l3b0t4dm5HeWxJRlI0ZUZRT2FGaDBkRnY2UEF3THNBZ1AyL2xJREF1d0NBL1lEQ3Z5UUEzQUMxRU1iS0NnYlEwTWJLQ2diUXhrVy9iUVZIaDRWQWt3V0dUb0JBd0lDWTJNQkF3SUNZMlA5WUFJZkFBQUFBQU1BQVAvQUEvNER3QUJHQUlJQW1RQUFBUzRCS3dFaUJnY3VBeWN1QVNjdUFTY3VBU01pQmdjR0ZoY2VBUmNqSWdZVkZCWVhEZ0VWRkJZWERnRVZGQllYQmhZWEhnRXpJVEkyTng0Qk93RXlOamNUTmlZbkFTTU9BU01xQXlNaUppY21OalUwSmpVME5qVTBKalUwTmpVMEpqVTBOak1oTGdFbkxnRTNQZ0V6TWhZWEhnRVhIZ01YSGdFeE14RVRBdzRCS3dFaUpqVXdQQUkxTkRZek9nRXpNaFlIQSt3TkpoWjZEaHNORERZNUx3UUlGZ2NLRFFjT05TSW5UaHNpQXlRRUNnV1ZRazRIQmdZSEVBc0RBeGdOQWdVTEdFa3JBV0F5VFJzUU1Sb3BKelVIU1FRSkRmNzdNQkZDTVNKa1oxa1pFeVFPRFE0c0ZDa2dJQ2tZQVFFREpBOFNGeGNTTHhNTEVRUUxKeE1VT0RVb0F3SUtMY3BLQVEwSEtRMFRDd29HY0E4SENBRUJveEFUQndjV1ZWaEhCd3hHRnlJb0RSb2RKaUFvZDFBTUZnaFBRQlFoRFF3ZkV4d29EZ2tWRFIwdEVCRXFHREkySHhJVkhEUWVBVU1WS1JEK29ROG9JQndjSmdVRkpob2FHQW9LRWlRa0VnY0dGeWNuR3lGTEtDZGdHaFVWQndjVmtoNGRWMVJCQmdZUy9zc0JKUDY3Qnc4VEIySjNad1VLQXdvSEFBTUFBUC9BQS80RHdBQkZBSUVBbUFBQUFRTXVBU3NCSWdZSExnRWpJU0lHQnc0QkZ3NEJGUlFXRnc0QkZSUVdGdzRCRlJRV093RU9BUWNPQVJjZUFUTXlOamMrQVRjK0FUYytBemNlQVRzQk1qWTNQZ0VGSXpBR0J3NERCdzRCQnc0Qkl5SW1KeVkyTno0Qk55RWlKalUwTmpVMEpqVTBOalUwSmpVME5qVTBKamMrQVRNNkF6TXlGaGN6RVRNcUFTTWlKalU4QXpFME5qc0JNaFlYRXhZR0l3UCtTUWMxSnlrYU1SQWJUVEwrb0N0SkdBc0ZBZzBZQXdNTEVBY0dCZ2RPUXBVRkNnUWtBeUliVGljaU5RNEhEUW9IRmdnRUx6azJEQTBiRG5vV0pnME5DZjdsTFFvQ0F5YzJPQlFUSndzRUVRc1RMeElYRnhJUEpBUCsveGdwSUNBcUZTMFBEUTRrRXhsYVptUWpNRUlTTDd3UGNBWUtDeE1OS1FjTkFVb0JDQWNDS3dGREhqUWNGUklmTmpJWUtoRVFMUjBORlFrT0tCd1RId3dOSVJSQVR3Z1dERkIzS0NBbUhSb05LQ0lYUmd3SFIxaFZGZ2NIRXhBUUtROFNCZ1pCVkZjZEhwSVZCd2NWRlJwZ0p5aExJUnNuSnhjR0J4SWtKQklLQ2hjYkdpWUZCU1ljSENBb0QvN0xBd29GWjNkaUJ4TVBCLzY3QndvQUFBQUFCZ0FBLzlzRUFBT2xBQVFBQ1FBT0FDNEFTd0JRQUFBVElSVWhOVFVoTlNFVk5TRTFJUlVUSWlZMUVUUTJNeUV5RmhVUkZBWWpJUTRCQnc0QkJ3NEJLd0VpSmowQk15Y2VBVHNCSEFFVk16NEJOeUV5TmpjK0FUVVJOQ1lqSVNJR0ZSRVhFeUUxSVJXd0FSMys0d0hUL2kwQ29QMWdEMVZxYWxVQ2dsVnFhbFgraEFzWEN4RWpFUXNnRWh3aExoUnVCRG93T3h3aVJpSUJvU2s0Q2dJQ1BEUDlmak04QVY4Q29QMWdBWEVpSWxVaUl1OGlJdjNHWkZVQnQxWmtaRmIrVTFadENSNE9GU2dVRGd3c0lWT3ZMekVpV3lJcVV5SW9KQWdTQ2dHeE56TXpOLzVQRUFFVUlpSUFBQUFKQUFELzRnUUFBNTRBTndCWkFITUFkd0I3QUlBQWhRQ29BTXNBQUFFUk5DWWpJU0lHRlJFVUZqc0JIZ0VYSGdFWEhnRTdBVEkyUFFFekZSUVdPd0VWRkJZN0FUSTJOejRCTno0Qk93RXlOajBCTkNZbkJSd0JGU011QVNjaklpWW5MZ0UxRVRRMk15RXlGaFVSRkFZVkhBRVZEZ0VqSVFVVUJpc0JEZ0VISXp3Qk5TTWlKajBCTXpJMk56TXlGaDBCQVNFVklSVXpGU01GSVJVaE5UVWhGU0UxTnk0Qk5UUTJOejRCTno0Qk16SVdGeFlVQnc0QkJ3NEJCeDRCRlJRR0t3RWlKaWNqTGdFMU5EWTNQZ0UzUGdFek1oWVhGZ1lIRGdFSERnRUhIZ0VWRkFZak1TSW1Kd09hWUUzOXYwMWZYMDBpQ2hVS0R5QVBDeHdRR1I0cUtVVTRDQzBlRFJBZENnZ1JDUU1HQTBnNFNEZ3UvZXNaSHo4ZVJDVXlDUUlDTmk0Q1FTODJBUVExSy82WUFqTWZHV29SSVJFUVVCb2NzRGhFQmhFWkgvNDBBUUQvQU9IaC9zSUJwUDVjQWo3OXdwZ0pDZ2dIQnhjT0ZCQUZCUWdEQmdJQkJRVVBGUVVUR2hzVEFRNFhDcElLQ1FjSUJ4WVBFeEVFQlFnRUJnRUNBUVFGRUJRRkVoc2JGQTRZQ1FHcEFVNU5XbHBOL24xTll3Y2NEQk1rRWd3TUtCNUtFamRIQ0I0c0Rnd0tGUXNEQzBjM2ZERkRCNTBmVWg4blNoOGtJQWdQQ1FHSE1TNHVNZjU1QXdVQ0FRSUJLaXhhR2h3WEpCY1hMQThjR2pzOU5CWWFmQUpISGwwZjJCNGVmQjhmYXdrV0RRNGFDd3NVQ1F3R0JBTUhDd1FDQXdVTEV3Y0JHeE1USEFrSUNSWU5EaG9MQ3hRSkRBWUVBd2NMQkFJREJRc1RCd0ViRXhNY0NRZ0FCZ0FBLy8wRUFBT0RBQk1BS0FBMUFFOEFYQUJoQUFBQk5DNENJeUlPQWhVVUhnSXpNajRDQnlJdUFqVTBQZ0l6TWg0Q0ZSUU9BaU0xSWlZMU5EWXpNaFlWRkFZakFUVTBKaU1oSWdZZEFTTWlCaFVSRkJZeklUSTJOUkUwSmlNbE5EWXpJVElXSFFFaE1EUTFBUkVoRVNFQzd5WkJWekV4VjBFbUprRlhNVEZYUVNidktrczRJU0U0U3lvcVN6Z2dJRGhMS2paTlRUWTJUVTAyQVE4K0xQNjJMRDYzR0NJaUdBT01HQ0lpR1AyS0JnVUJTZ1FDL3FYKy9nTmsvSndCY2pGWFFTWW1RVmN4TVZkQkppWkJWNXdnT0VzcUswbzRJU0U0U2lzcVN6Z2dTMHcyTmsxTk5qWk1BZmNzTEVSRUxDd2hGLzJHRnlFaEZ3SjZGeUZCQkFrRUJYSlZHZjBqQWs3OXNnQUFBQUFHQUFUL3dBUDhBOEFBVWdDUEFLa0F0QURPQU5rQUFBRW5MZ0VyQVR3Qk1UWW1KeTRCSXlFaUJnY09BUmN3RkJVaklnWVBBUTRCSGdFWEhnRVhNQllWSGdFVkRnRUhEZ0VIQmhZWEhnRXpJVEkyTno0Qkp5NEJKeTRCSnpRMk56QTJNVDRCTno0Q0ppY0JEZ0VITVE0QkZSUVdGekFXRng0QkZ4NEJNU0V3TmpjK0FUYytBVEUrQVRVMEppY3hMZ0VuTGdJMk5UY3pMZ0V4SVRBR0J6TVhGQllPQVFjVEl5SUdGUTRCQnc0QkJ3WVdGeDRCTXpJMk56NEJKeTRCSXdjK0FUYytBVGN6RmdZSEpTNEJKelFtS3dFaUJnY0dGaGNlQVRNeU5qYytBU2N1QVNjbk14NEJGeDRCRnk0Qk53UDhBd01mRkd3QkNBZ0lGQXY5dmdzVUNBZ0lBV3dVSHdNREF3RXdkblFoVEJjQ0F3UVBIQTB0SVFJRkJBY0lHQTBCWEEwWUNBY0VCUUloTFEwY0R3UURBaGRNSW5OMk1BRUQvc0ltVnhBSUJ3Z0hCUUVNR2c0cEd2NmtHaWtPR2d3QkJRY0lCd2dSVmlkMmNDZ0hBNllDQWdKQ0FnS21Bd2NvY0hmVGR3WUtCQkFOQkFzR0FRUUVBZ1VDQXdVRGhqRUVBUWtIamdFREFnd1FCVmdDSmx2K0ZBMFFCQW9HZHdjSkFRUXhoZ01GQXdJRkFnUUVBUVlMQkpsWkJCQU1BZ01DWENZQ0F6b1ZGUmtJQkFzVUNBZ0lCd2dJRmdzQ0NSa1ZGaEJaZVk5R09qd1BBUUVRTXc0S0dBMHRPZ1lOSEF3TERnNExEQndNQmpvdURSZ0tEVFFSQVE4OE8wYU9lbGtRL25GSk53MEdhZ29LRVFZRUFRZ1dEaWt4TVNrT0ZnY0JCUVlSQ2dsckJnMDNTVWFKYmtVQ0Z5RWhJU0VYQVVadWlVWUJkZ2tIUjBncUR5UVdCUXNEQVFFQ0FuQmxQZ2NKNXdZS0JTaEhRU2RPVUI0cVNFY0hDUWtIUG1Wd0FnSUJBUU1MQlJZa0Q2ZEJSeWdGQ3dWUVRpY0FBQVVBTS8vQUE4MER3QUFRQUJRQUdBQWNBQ29BQUFFaElnWVZFUlFXTXlFeU5qVVJOQ1lqRVNFUklRRWhGU0UxSVJVaEpTRVJNelV6RlRNMU14VXpFU01EaWZ6dUhDZ29IQU1TSENnb0hQenVBeEw5Y0FJTy9mSUNEdjN5QVlEK2dEK2pUNTQvamdQQUtCejhpQndvS0J3RGVCd28vRVFEZVAwTUtxVXFsUUZWUlVWRlJmNnJBQUFGQURQL3dBUE5BOEFBRUFBVUFCZ0FIQUJqQUFBQklTSUdGUkVVRmpNaE1qWTFFVFFtSXhFaEVTRUJJUlVoTlNFVklRRVVCaU1pSmljakRnRUhJZ1lIRGdFSERnRW5JaVlqSWlZM05EWTNQZ0UzUGdFbkxnRW5KaUlqSWlZM1BnRTNQZ0V6SGdFWEhnRVhIZ0VYSGdFM01ESTFQZ0V6TWhZVkE0bjg3aHdvS0J3REVod29LQno4N2dNUy9YQUNEdjN5QWc3OThnSU9PU2tYS2cwQkhUa2VCUWtFQ3c4SEN4MFNGeTRYQ3hBQkRnb01HQXdlRUEwR0hRc1BDUThPRHdZRURBa1NUd2NNRWdjRkNnWUVEUWNKY2dVQkRDNGJLVGtEd0NnYy9JZ2NLQ2djQTNnY0tQeEVBM2o5RENxbEtnRnVLVG9TRWdJQ0FnWURDQlVLRHcwQkFSSUxDaEFCQWdZR0R6b1pEQlFDQXhjTkNBa0JBUU1CRFFrSEVBY0dCd01EQWdFQkZoMDZLUUFBQUFBRkFEUC93QVBOQThBQUVBQVVBQmdBSEFBN0FBQUJJU0lHRlJFVUZqTWhNalkxRVRRbUl4RWhFU0VCSVJVaE5TRVZJUUVWRkFZSEZTRTFMZ0U5QVRRMk93RThBVFUwTmpzQk1oWWRBVE15RmhVRGlmenVIQ2dvSEFNU0hDZ29IUHp1QXhMOWNBSU8vZklDRHYzeUFkb3FIdjc2SHlvd0loWUpCcWtHQ1JZaU1BUEFLQno4aUJ3b0tCd0RlQndvL0VRRGVQME1LcVVxQWFpd0lDNEVLeXNFTGlDd0lqQUhJeFlHQ1FrR1FEQWlBQVVBRlAvQUErZ0R3QUF0QUVRQVlBQjVBSklBQUJNZUF6TXlOamMrQVRjZUFSOEJIZ0V6TWpZL0FUWW1Md0V1QVNjK0FTY3VBeU1pQmdjT0F4Y0ZOejRCTXpJV0h3RWVBUThCRGdFaklpWXZBUzRCTndFK0FUTXlIZ0lYRmdZSERnRUhEZ0VqSWk0Q0p5WStBamNIRGdFWEhnRXpNalkzUGdFM1BnRW5MZ0VqSWdZSERnRUhGejRCTno0Qk16SVdGeFlHQnc0QkJ3NEJJeUltSnlZMk54UVNSRmhxT1I0N0hBY09CZ0VRRGZrTklCRVVKQTFaR2dRYytRc2REeGNERlJORFdXbzVIam9kUldrOENoZ0NLRmtFREFZRkNnVDVDUUVJV1FRTUJnVUtCUGtKQVFqK3lSZ3dHQzlYU1RjUEZBY2FHbFk0RnpFWUwxZEpOdzhVQ1RGV09Xb1RCUTRZZEVnVEpSSXFRaFFVQlE4WGRVZ1RKQklyUWhRWkVUb21EeUVRUDJjVURRUVNFVG9sRUNFUVAyWVZEUVVSQWRrNFcwRWpDZ29EQlFNU0lRM29EQTBSRG1VZVR4cm9Dd3dDUFlFL04xdEJKQW9LR1dKL2tVaTlaUVVGQkFUb0NSa0paUVVGQkFUb0NSa0pBbElJQ1I0MVN5MDZkelkyVHhRSUNSMDJTeTA3ZUdoUkZMZ3FXeXhGVmdjR0R6MHBLbHNyUmxVR0JnODlLUTBsTlEwR0JVczlKbEFsSkRVTkJnWk1QU1pRSkFBUUFBVC80UVAvQTU4QU9nQjNBSHNBZ0FDRUFJZ0FqQUNRQUpRQW1BQ2RBS0lBcHdDc0FMd0F6d0FBQVM0Qkl5RW5MZ0V2QVNvQkl5Y3VBU01pQmdjR0ZoY3lNREVYRXdjT0FSVVhGQllYSGdFek1qWTNNeDRCTXpJMk56NEJOVFFtSnhNMkppY0RJUWNoTWhZVkZBWXJBUjRCRlJRR0l5SW1OVFEyTnlNZUFSVVVCaU1pSmpVME5qY2pKemNESnk0Qk56NEJNeklXTXg4QkZqSVhOUjhDSVFNVEl4VXpKelV6QnlNWEl4VXpKelV6QndNakZUTW5JelV6RnlNVk15Y2pOVE1uTlNNWE15Y1ZJeWN6QXpNMUl4YzNJeWN6RlFjME5qTXlGaGNlQVJVVUJpTWlKalVoTkRZM1BnRXpNaFlYSGdFVkZBWWpJaVkxQS9ZSEZBdjlWeEVERWd3ZEFRRUJXUVlPQnlBMENRc21KUUVvWVNFQ0FRRUVCQU5mUWoxYkNrQUtXejFBWFFjV0d4RU9iZ0lFQjZMOS9CY0NGZzRTRWc0V0F3TTdLU283QkFQSUF3UTdLaWs3QXdNT0FTZHVUQTBNQXdRUkN3SUZBZ1pVQVFFQ0VnUVdBc2RuRjZLQ2JYSVZYV1I1V2tWSkZXKzJ0aFdMaXhXMnRoV0xpOGJGSDZZVmdCV1ZhbitlSDJwWkZXNS9GUTRIRFFVRkJSUVBEaFVCaEFVRkJRMEhCd3dGQlFVVURnOFVBdjRKQ2tVTUV3TUpHZ0lDSng4bFJ3d0wvbVJjQkFnRk5nY05Ca0ZiVFRvNlRWVS9EQzBiRlNVTkFjVUxGZ2orSERBVURRMFVDQklKS1RzN0tRa1NDQWdTQ1NrN095a0pFZ2dqYXdIVEZnUVhEUXNOQVFJWUFRRUJCaEpiL2tvQmVJTVZXRmc2Z3hWWVdBRVdneFZZa29NVldEdURnMjFZV1A3cmc0TVZXRmozRHhRRkJRVU5CdzRVRkE0SERRVUZCUVVGQlEwSERoUVVEZ0FBQUFnQUV3QTFBK0FETmdBTkFCMEFJUUJJQUZVQWFBQjdBSTRBQUNVVUJqRWhNQ1kxTkRZeElUQVdBeUVpQmhVUkZCWXpJVEkyTlJFMkpnTWhFU0VISmdZeERnRXJBU0ltSnk0QkJ3WVdNUjRCTno0Qk1UNEJPd0V5RmhjZUFSY1dOamN3TmljSEZTTVZJelVqTlRNMU14VXpGeUltTlRRMk16SVdGVGdCTVJRR0l6Z0JNVFVpSmpVME5qTXlGaFU0QVRFVUJpTTRBVEVYSWlZMU5EWXpNaFlWT0FFeEZBWWpPQUV4QStBZS9HOGVIZ09SSGxuODVCTWRIUk1ESEJRYkFSd20vUWdDK09Bbld3UUxCUlVHQ3dRRlZTY25DQU1URVJFMkJBa0dmUVVLQkFNekVSRVRBZ2dteXh3Y0lTRWNISFlKREF3SkNRd01DUWtNREFrSkRBd0pOUWtNREFrSkRBd0pWaGtJQ0JrWUNBZ0N5QjRVL2RJVEdSa1RBaTRVSHYyMkFnU3ZRQ1VEQkFRREF5SS9RSEVSRlFJQlBBTUZCUU1FT0FFQ0ZCRnlQeUllSEJ3aEhCeEREQWtKREF3SkNRdzZEUWdKREF3SkNBMGZEQWtKREF3SkNRd0FCQUFBQUNZRUFBTmFBQk1BSkFBd0FEUUFBQ1VoSWlZMUVUUTJNeUV5RmgwQkl6VWhFU0VWQVJFVUJpc0JJaVkxRVRRMk93RXlGaFVETkNZaklnWVZGQll6TWpZVElSRWhBbXI5eXhZZkh4WURSQllmU1B6aUFpSUJsaDhXNEJZbkp4YmdGaCtQRGdrS0RnNEtDUTVtL3dBQkFLd2VGUUpIRlI4ZkZYUmcvZUZIQVkvK0pCVWtKQlVCM0JVZUhoWCtNUW9PRGdvSkRnNEI0djVjQUFBQUFBa0FBUC9oQS9vRG53Qk5BRklBaFFDU0FKNEFxZ0MyQUxvQXh3QUFBUzRCSXlJR0J5NEJKeTRCSXlJbUp6VTBKaXNCSWdZVkVSUVdPd0V5TmpVUkhnRXpNaFlYSGdFWExnRWpNU0lHQnc0Q0ZoY2VBVE02QVRjeU5qY3pIZ0VYT2dFek1qWTNQZ0V1QVNjQkl4RXpFU1VPQVNNcUFTTXVBVEV1QVNzQklnWUhNQVlIS2dFaklpWW5NQ1kzUGdFek1oWXhIZ0U3QVRJMk56QTJNeklXRnhZR01TVXpGU01WSXpVak5UTTFNeFVGRkFZaklpWTFORFl6TWhZbkZBWWpJaVkxTkRZek1oWVZGQVlqSWlZMU5EWXpNaFlCTXhFakF6UTJNeklXRlJRR0l5SW1OUVBJRzB3dElqY09BaFllRkRZaFdHb1dJeGJwRmh3Y0Z1a1dJeUJyVFJzcEVCY1RBZzQ0SXkxTUd4MFlCUWNDQnpvcUFnVURDajQ2alRvK0NnTUZBaW82Q0FFSEJSZ2QvVVRFeEFLeEJCWVZBUUlDRjBrRUR3ZW5CdzhFU1JjQkF3RVZGZ1FLTkJZeUZ5RXVCUkFHSFFZUUJTOGdGek1WTkFyK3hnTW5MaWNuTGdFbUVRc01FUkVNQ3hGSEVRc01FUkVNQ3hFUkN3d1JFUXdMRWYxZEhoNHRJUmNZSVNFWUZ5RUJaU3d2RlFrZlZTSVdGMk1tZ1JVYkd4WDhwaFllSGhZQ29pbElFUklhU2g0Skd6RXNNRjlPTndjdU5nRWFRME1hQVRZdEJ6WlBYaS8reEFNdS9OSXVGUnNDVUFVSEJ3VlFBaHNWbVZVa0doc0VCZ1lFR3hva1ZabkVMaVltTGljbkdRd1JFUXdNRUJBZURCRVJEQXdRRUZzTEVSRUxEQkVSQVd6K0NBSjVHQ0VoR0JjaElSY0FBQUFBQ3dBNi84QUR4Z1BBQUE4QUh3QXNBRGdBUlFCU0FHOEFrQUNVQUprQXFRQUFBU1lHQndZbUp5WTJOejRCRnhZR0J5RTJGaGNXTmpjMkppY3VBUWNHRmhjWEZBWWpJaVkxTkRZek1oWVZKelFtSXlJR0ZSUVdNekkyRnhRR0l5SW1OVFEyTXpJV0ZTYzBKaU1pQmhVVUZqTXlOalVIRGdFak9RRWlKaWN1QVRVeE5oWVhIZ0V6TWpZM1BnRVhNeFFHQndFUkZBWUhGU0UxTGdFMUVUUStBanNCTlRRMk15RXlGaDBCTXpJZUFoVWxJVFVoQVNFVklUVVROQ1lqSVNJR0ZSRVVGak1oTWpZMUF0RVFlQTBEQ3dJQ0FRUVJmeFFCQVFMK1hoQjREUU1MQWdJQkJCQi9GUUVCQXBVWkVoSVpHUklTR1JnTENBZ0xDd2dJQytZWkVoSVpHUklTR1JnTENBZ0xDd2dJQ3g4UE1ob2FNdzRMQlFJR0RBd3hHaG94REFzSEFRRUZDd0ZyVjBIOXBFRlhIelpJS2hNaUdRRmlHU0lVS1VnMkgvMlNBVkQrc0FHVC9pb0IxcHBPTnYzK05rNU9OZ0lDTms0QjloMFRDZ0lIQXdRSUFnd1JKd01IQWgwVENnSUhBd1FJQWd3Ukp3TUhBa2tVSEJ3VUV4d2NFeElIQ3dzSENBb0tDaFFjSEJRVEhCd1RFZ2NMQ3djSUNnb0l1Z29MQ3dvSUVBRUNBUVlHQ2dvR0JnRUNBUkFJQVUvK2pVWnJFR0JnRUd0R0FYTXBTVFlmYWhraUlobHFIelpKS2FhQy9MNDVPUUliTjAxTk4vNkxOazVPTmdBQUN3QlYvOTREcXdPaUFCd0FJZ0FvQURrQVJnQlNBRjhBYXdCN0FJc0FvZ0FBQVNNMU5DWWpJU0lHSFFFaklnWVZFUlFXRnhVaE5UNEJOUkUwSmlNaE5TRVZJVFVCRlNFMUlSVTNGQVlqSVNJbU5SRTBOak1oTWhZVkVTVWlCaFVVRmpNeU5qVTBKaU1WSWlZMU5EWXpNaFlWRkFZM0lnWVZGQll6TWpZMU5DWWpGU0ltTlRRMk16SVdGUlFHSndZbUZ5WTJOVEV3TmpjeEhnRUhNVGNtTmpjeEhnRTVBUlFXQnpZR0p6RUhQZ0VYTVRJV0Z4WVVCd1ltSnlJR0J3NEJOVDRCTndMd0VpRVcvcklXSVJKTmJsSTlBamc5VW01Ti9uSUJQUDdFQVhyK1NBRzRqMGd6L2lBelNFZ3pBZUF6U1A0MUVSY1hFUkFZR0JBSUNnb0lCd29LdVJBWUdCQVJGeGNSQndvS0J3Z0tDcUZQUEFFQkFaRU1CUVllZmgwR0JReVFBUUVCUEU5OEJpMFhFQ0lIQndNREdTRWhIUVlHRGdJR0JnTUhZeGNoSVJkamJrMytvME5rRDF0YkQyUkRBVjFOYmx0N0lQMHNGVFVndkROSlNUTUJYVEpKU1RMK28rd2FFaE1hR2hNU0dpd0tCd2NLQ2djSENpd2FFaE1hR2hNU0dpd0tCd2NLQ2djSENqNFFFUUlDQmdJSUhBRWxCd0VISmdFZEN3SUdBUUVRRXRrR0RRRUpEZzBFQWdJVEFROERBZ0VDQlE0R0FBQUFFQUE2LzhBRHhnUEFBQ0FBSlFBckFEd0FUQUJjQUdrQWRRQ0NBSTRBclFEMkFRSUJFZ0VpQVM0QUFBRWpOVFFtSXlFaUJoMEJJeUlPQWhVUkZCWVhGU0UxUGdFMUVUUXVBaU1oTlNFVklRRVZJVFVoRlRjVUJpTWhJaVkxRVRRMk15RXlGaFVSQVRZV0Z4NEJCdzRCSnk0QkJ5NEJOd1VtQmdjR0ppY21OamMrQVJjV0JnY0ZJZ1lWRkJZek1qWTFOQ1lqRlNJbU5UUTJNeklXRlJRR055SUdGUlFXTXpJMk5UUW1JeFVpSmpVME5qTXlGaFVVQmdjeEpnWUhEZ0VqSWlZbkxnRUhNUVlXRng0Qk16a0RNalkzUGdFbk55SXdJekFtQnpBR0l5SW1NU1lHTVNJR0l5Y1ZGeDRCTVRJV0Z4NEJGeDRCRng0Qk56NEJOejRCTno0Qk16SVdGeDRCRng0QkZ4WTJOejRCTno0Qk56NEJNekEyUHdFMUJ3VWlKalUwTmpNZUFSVVVCaGNPQVFjT0FTY3VBVEUyTWhjZUFRY1hCaVluTGdFbkpqWTNOaklYTUFZSE53WW1OVFEyTnpJV0ZSUUdBdjhUSWhuK25oa2lFeXBJTmg5WFFRSmNRVmNmTmtncS9sa0JVUDZ3QVpMK0xBSFVtVTAzL2dJM1RFdzNBZjgyVGYyckZIOFJBd0VDQVF3RERYY1JBUUVCQWFNUmR3MERDd0lDQVFNUmZ4UUJBUUgreUJJWkdSSVNHUmtTQ0FzTENBZ0xDOFlTR1JrU0Voa1pFZ2dMQ3dnSUN3c0ZBUWNNQ3pFYUdqRUxEQWNCQVFVTER6TVpHaklQQ3dVQnBnRUJuR1lKQXdNSlpwd0JBZ0Z4YndFQ0NRY0JBZzBGQlJJVEV5a1JFU1lLQ2hnREJBY0VCQWNFQXhnS0NpWVJFU2tURXhJRkJRMENBUWNKQWdGdmMvM3lCZ2NJQlFZSENNME9JQW9LTmlFaEJBTk9DUXRqQ3ZFaE5nb0tJQTRLWXdzSlRnUUZJVG9HQ0FjR0JRZ0hBeHRxR1NJaUdXb2ZOa2dxL28xR2F4QmdZQkJyUmdGektrZzJIMkdDL1NFWE9TTEdOazFOTmdGek4weE1OLzZOQVRNb0VRMENDQU1FQmdJSkZCMENCZ01MSFJRSkFnWUVBd2dDRFJFb0F3WUNMUnNVRkJzYkZCUWJMd3NIQndzTEJ3Y0xMeHNVRkJzYkZCUWJMd3NIQndzTEJ3Y0xqZ0lDQmdVS0NnVUdBZ0lCRUFnS0N3c0tDQkFCNHdnZ0F3TWdDQUVkS3hrQ0FSRUlCelFORFJJRkJRTUJBaFVRRHpFSUNBTURDQWd4RHhBVkFnRURCUVVTRFEwMEJ3Z1JBUUVhS3h3YUF3SUJBZ0VEQVFJQ0xqWWdCQVFEQ2d0b0hnRUJFeVZYQ2dNRUJDQTJKUk1CQVI1b0M0WUJBZ0lCQXdFQ0FRSURBQUFBQ1FBNi84QUR4Z1BBQUNBQUpRQXJBRHdBandDeEFMNEE0QUR0QUFBQkl6VTBKaU1oSWdZZEFTTWlEZ0lWRVJRV0Z4VWhOVDRCTlJFMExnSWpJVFVoRlNFQkZTRTFJUlUzRkFZaklTSW1OUkUwTmpNaE1oWVZFU1VHSmdjT0FTY3VBVGMwTmpFK0FUYytBUmNXQmc4Qkp6QW1KeVlHQndZV0Z4WTJOellXRng0Qk16STJOejRCRng0Qk56NEJKeTRCQnc0Qk1RY25MZ0UzTmhZWEhnRVhNQlFWRmdZSEJpWW5KZ1luRXlZR0J3NEJKeUlHRng0Qk14WTJOdzRCRlJRV016STJOVFFtSno0QkZ6NEJKd2NVQmlNaUpqVTBOak15RmhVbkJpWW5MZ0VIQmhZWE5oWVhEZ0VWRkJZek1qWTFOQ1luSGdFM01qWTNOaVlqQnlJbU5UUTJNeklXRlJRR0l3TUFGQ0laL3A0WkloTXFTRFlmVjBFQ1hFRlhIelpJS2Y1WUFWRCtzQUdTL2l3QjFKbE5OdjRCTjB4TU53SC9OazMrZmpkUkd4Y2tIaDhRQkFFREZCSVZHZ1VGQWdJQ0Fnd0lBeG9FQkFrTUdrQWREaDRMQmlBYkdpRUdDeDBPSFVFWkRRZ0VCUmtFQ0FzQ0FnSUNCQVVhRlJJVkJBVVBIeDBsRnh0UU44VUxPaHdWR1JNREF3RUNDZ1lDREFnRkJSa1NFUm9VRHhvekNBSURCRXdMQndnTEN3Z0hDNTBTR1JVZE9Rc0VBd0lJTXhvUEZCb1JFaGtGQlFnTUFnWUtBZ0VEQkVNSUN3c0lDQXNMQ0FNYmFoa2lJaGxxSHpaSUt2Nk5SbXNRWUdBUWEwWUJjeXBJTmg5aGd2MGhGemdoeGpaTlRUWUJjemRNVERmK2pRd1pHd1lFQ1F3TVB4OEJBaEVkREE4SEJ3Y1hDQTRERlFNQkVoQUxHQXdZTlFZREJnRUJGeGdCQWdZREJUUVlEQmdNRHhJQkF4VUVEZ2tYQmdnSERnd2RFUUlCSHo0T0RBZ0VCUndZQVJjV0ZSRU5CZ0VMQkFVR0FRRUJCZzhKRkJzYkZCRWFBeEFkSVFNVENVY0lDZ29JQndzTEJ5VUJCZzBSRlJZSkV3TWhIUkFER2hFVUd4c1VDUThHQVFFQkJnVUVDemNLQ0FjTEN3Y0lDZ0FBQUF3QU92L0FBOFlEd0FBZ0FDVUFLd0E4QUVnQVZBQmdBR3dBZkFDTUFPc0JLd0FBQVNNMU5DWWpJU0lHSFFFaklnNENGUkVVRmhjVklUVStBVFVSTkM0Q0l5RTFJUlVoQVJVaE5TRVZOeFFHSXlFaUpqVVJORFl6SVRJV0ZSRWxJZ1lWRkJZek1qWTFOQ1lISWlZMU5EWXpNaFlWRkFZM0lnWVZGQll6TWpZMU5DWUhJaVkxTkRZek1oWVZGQVlsUGdFWEhnRUhEZ0VuSmdZSExnRTNKUzRCQndZbUp5WTJOellXRnhZR0J4Y3VBU011QVNjbUJoY2VBUmNPQVFjT0FTTXFBU011QVNjd0lqRW5QZ0UzTmlZSERnRUhLZ0VIRGdFVkhBRVZIZ0VYRmpZM01pWTFNaFl6SGdFWEhnRVhIZ0V6TWpZM1BnRTNQZ0UzUGdFM0ZBWVhGQlkzUGdFM1BBRTFOQ1luQnc0Qkl5SW1KeTRCSnpRMk54WTJOeW9CSXk0Qkp5NEJOUjRCRnhZeU16STJOekkyTXh3QkJ4UUdCeFFHQnc0QkJ3NEJCeW9CSXg0Qk54NEJGdzRCQndNQUZDSVovcDRaSWhNcVNEWWZWMEVDWEVGWEh6WklLZjVZQVZEK3NBR1MvaXdCMUpsTk52NEJOMHhNTndIL05rMytHQkVaR1JFU0dCZ1NCd3NMQndnTEM4SVNHQmdTRVJrWkVRZ0xDd2dJQ2dyKzJBdDBFUVFDQVFFSkF3MXVDZ0lDQVFGMERHNE5Bd2tDQVFNREVYUU5BUUlCR1FJREFnY1RCd0lJQlFJSEF3a1VDeGcySFFNR0FqRlpJZ0VHQXdVQkJnZ0RCeE1HQWdRQ0FnSUJDZ2tDQWdFQkFnRUdBd0VDQVFJS0VoUlVKeTVIRVE4TUJBSUNBZ0lGQWdJQkF3RUtDZ0VDQTB3UFF5a3RTQTBDQkFFRUFoVW5FQUlHQXhreEJnWUJHMG9uQ2hVS0dqVVpCQWtFQVFFQkFRRUJBZ0lFS2hjQ0FnRU1JaEVDQWdFQ0JRTURHMm9aSWlJWmFoODJTQ3IralVackVHQmdFR3RHQVhNcVNEWWZZWUw5SVJjNEljWTJUVTAyQVhNM1RFdzMvbzM2R3hRVEd4c1RGQnN2Q3djSEN3c0hCd3N2R3hRVEd4c1RGQnN2Q3djSEN3c0hCd3M3TEJrSkFRZ0RCQWtDQnhVaUFRWUVGQ0lQQmdJSUJBUUhBZ2dUTEFNR0FySUJBUUVEQlFJSkJnTUVBUU1FQWdRREFRd0hBZ0VEQVFZS0FnUUNBUUVCQXdJQkFnRURGUVVCQVFFR0JBSUhEZ2NZTHhBUURnNE5DeTBiQnc4SEFRRUJCQVlCQVFFQkJCVURBUUlCQVFRQmZRc05EZ3dCQkFJSUNRSUJBUU1DQ1FzTEdnWUdDUUVCQkFVQ0FRUUNBd2NEQXdVQ0JBY0RCd2dCQWdJQkFnY0VCUWNDQUFBQUFBMEFPdi9BQThZRHdBQWdBQ1VBS3dBOEFFa0FWUUI2QUljQW5RQ2tBTWNCQkFFN0FBQUJJelUwSmlNaElnWWRBU01pRGdJVkVSUVdGeFVoTlQ0Qk5SRTBMZ0lqSVRVaEZTRUJGU0UxSVJVM0ZBWWpJU0ltTlJFME5qTWhNaFlWRVNVaUJoVVVGak15TmpVMEppTVZJaVkxTkRZek1oWVZGQVlsSmdZSERnRUhEZ0VYSGdFM01qWTNEZ0VWRkJZek1qWTFOQ1luUGdFM1BnRVhQZ0VuQnhRR0l5SW1OVFEyTXpJV0ZTY1VCaWN1QVNjdUFRY21ORGMyRmhjZUFSY2VBUWNEUGdFeE1CWTNKUTRCQnlJbUp5WVdGeFFHRlNvQk1SVVVCaGNlQVJjZUFUNEJOelltSnpFK0FRY0hPZ0V6SGdFVk1EWTNQZ0UzSGdFeE1EWTNQZ0UzRmhReE1EWTNQZ0UzTWhZWEhBRVZEZ0VqSWlZblBBRTFQZ0UzSGdFWEhnRXhNQ1kzT2dFekJ5WTBNVEFHQnlJbU5TWTBOeDRCTXpJMk54UVdGUllHQnc0QkJ5NEJNVEFVQnc0Qkl5NEJNVEFVQndZaUl5NEJNUlFHQnlvQkl3TUFGQ0laL3A0WkloTXFTRFlmVjBFQ1hFRlhIelpJS2Y1WUFWRCtzQUdTL2l3QjFKbE5OdjRCTjB4TU53SC9OazMrRmhFWkdSRVNHUmtTQndzTEJ3Z0xDd0V2Q3pzZEZoa1RCQU1CQWdzRkFnZ0ZCUVVaRVJJWkZROEJBd0VjT0FrQ0F3UlhDd2dIREF3SENBdWlDd1lHSkJZYUx3MEJCUTB3R2hZYUV3UUdBWDBGQndVTEFUdzJnRE1lS1JrU0JRa0RBZ2dEQWdFTEFncGljRjRGREFJQ0VBc1Y2UVVOQmdJRkJRUU1HQXdFQVFVRURSa05CZ2NGQ0E4SUJBVUJOSGt6RlNVT0FRTURDUk1MQkFZQkJBWU1CeWdCQkFNVUdnUUJEeXNiTVhRMEFRRUVBd1lZRUFNRkJBd2NEZ01GQlF3WkRBUURCQUlPR3d3REcyb1pJaUlaYWg4MlNDcitqVVpyRUdCZ0VHdEdBWE1xU0RZZllZTDlJUmM0SWNZMlRVMDJBWE0zVEV3My9vMzdIQk1VR3hzVUV4d3ZDZ2dIQ3dzSENBcDdFU2tZRVFNRkFRd0RCQU1DQVFFSER3a1VHeHNVRVJvREFRSUJGVFVkQXhJSGFRZ0tDZ2dIQ3dzSExBVUZBUUVKRUJJakdRTVBCZzRXRWc4SkF3RUxCUDdRQWg0Y0FZMFlFd0VFQkFRTUJnb2RBd01CSkF3R0JBRUNBZ1FLQ2hSS0VRc1dDVDhEQ2dnUUJnRUNBZ1lRRVFjQ0JBTUZFaFVHQWdVQ0NBUUhFQWNPQ1FFQkJRc0dBd2tEQVFJQkJnOFBCbEFHQ3dvR0F3RUdFZ1lCQWdnTUF3a0ZCUWtDQkFVQ0J3NFJCUUlDQnc0UkJRRUdEQVlKQkFBQUFBQU1BRHIvd0FQR0E4QUFJQUFsQUNzQVBBQkpBRlVBWWdCdUFJUUFtZ0M5QU9vQUFBRWpOVFFtSXlFaUJoMEJJeUlPQWhVUkZCWVhGU0UxUGdFMUVUUXVBaU1oTlNFVklRRVZJVFVoRlRjVUJpTWhJaVkxRVRRMk15RXlGaFVSSlNJR0ZSUVdNekkyTlRRbUl4VWlKalUwTmpNeUZoVVVCamNpQmhVVUZqTXlOalUwSmlNVklpWTFORFl6TWhZVkZBWW5EZ0VqSWlZbkxnRUhMZ0UzTmhZWEhnRVhNaFlITno0Qk56NEJGeFlHQnlZR0J3NEJJeUltSnlZMk14OEJEZ0VqSWlZbk55WUdNVGNjQVRFVUZoY2VBUlUrQVRjK0FUVXdORFVYTUNZSEZ4UUdCeFEyQnc0QkJ3NEJNVEFtSnk0Qkp6UVdOUzRCTlM0Qk5SNEJNekU2QVRNNkFUTXhNalkzRkFZSEF3QVVJaG4rbmhraUV5cElOaDlYUVFKY1FWY2ZOa2dwL2xnQlVQNndBWkwrTEFIVW1VMDIvZ0UzVEV3M0FmODJUZjRYRWhrWkVoRVpHUkVJQ3dzSUJ3c0x4UkVaR1JFU0dSa1NCd3NMQndnTEM1RUNDZ1VGSUJRY05Ra0NBUUVMT2h3VkpBa0RBZ0pKQ1NRVkhEb0xBUUVDQ1RVYkZDRUZCUW9DQWdJRFR3Y01SaW9xUmd3SEdRVUdDaG9ZVVFGUUdCb0tCZ1VaQXg4Qkd3RURCd1lTVUZBU0JnY0RHZ0VmQVFFUVFDWUJBZ0VCQWdFbVFCQUJBUU1iYWhraUlobHFIelpJS3Y2TlJtc1FZR0FRYTBZQmN5cElOaDloZ3YwaEZ6Z2h4alpOVFRZQmN6ZE1URGYramZvYkZCUWJHeFFVR3k4TEJ3Y0xDd2NIQ3k4YkZCUWJHeFFVR3k4TEJ3Y0xDd2NIQzBnREJnUUdDQkFOQWdjREZRWUtDQWNCQ1FRTkFRY0lDZ1lWQXdjQ0RSQUlCZ1FHQXdRSnd3WURDUWtEQmdNZUJRRUJEelVNQ1FJQkFRSUpERFVQQVFFRkhnTXhCZ2NDQlFNQ0NBY0RCd01EQndNSENBSURCUUlIQmdZTUJBSUpDUUlFREFZQUFBQUFEQUE2LzhBRHhnUEFBQ0FBSlFBckFEd0FTQUJVQUdBQWJBQjhBSXdBeWdEbUFBQUJJelUwSmlNaElnWWRBU01pRGdJVkVSUVdGeFVoTlQ0Qk5SRTBMZ0lqSVRVaEZTRUJGU0UxSVJVM0ZBWWpJU0ltTlJFME5qTWhNaFlWRVNVaUJoVVVGak15TmpVMEpnY2lKalUwTmpNeUZoVVVCamNpQmhVVUZqTXlOalUwSmdjaUpqVTBOak15RmhVVUJpVStBUmNlQVFjT0FTY21CZ2N1QVRjbExnRUhCaVluSmpZM05oWVhGZ1lIRnk0Qkp6NEJOeklVRlI0Qk56NEJOUzRCQnlJR0Z4NEJGdzRCQnc0QkJ3WW1KeUlHQndZV0Z4NEJOek0rQVRjZUFSY2VBVE15TmpjK0FUYzJOQ2NIRGdFSEJpWW5MZ0VuUGdFM0hnRVhOQ1luUGdFM0hnRVhGaFFIQXdBVUlobituaGtpRXlwSU5oOVhRUUpjUVZjZk5rZ3AvbGdCVVA2d0FaTCtMQUhVbVUwMi9nRTNURXczQWY4MlRmNFdFUmtaRVJJWkdSSUhDd3NIQ0FzTHhoSVpHUklSR2hvUkNBc0xDQWdMRFA3VEVtOFBBd0lDQWdvRERHa09BUUVCQVhJS2F3d0RDUUVCQXdNUWNRc0JBZ0pOQ0NNWkJnc0VBUUVHQkFRRkF4Z1JBZ0VDQkFjRENpNFRHVGNURWhzTEJ3d0JBZ29HQmlJT0FSSWpFUXdSQ0FzYUZRVUxCUkVjQndjSEVnWVZEUlFXRGdjUENnVVNDd3dkRHgwTUF3c0hGaDRIQkFVREcyb1pJaUlaYWg4MlNDcitqVVpyRUdCZ0VHdEdBWE1xU0RZZllZTDlJUmM0SWNZMlRVMDJBWE0zVEV3My9vMzdIQk1VSEJ3VUV4d3ZDZ2dIQ3dzSENBb3ZIQk1VSEJ3VUV4d3ZDZ2dIQ3dzSENBcEFMQk1JQVFnREJBa0JCZzhoQVFZRUVTUU9DQUlKQkFRSUFnb1NMd1FHQXQwU0ZRZ0lEZ2NDQVFRRkFRRUdCQkVLQVFRQkFRUUREaXNPRVJrQ0FnSUJBUU1HQkFJQ0NBSUNDZ2dJRnd3UUhBRURCaHNTRUNBTk5ROFZCUWNURlFvVkNBWUxBUUlPRHhVVUF3VU9BUWNSRGdrWERBQUFBQUFTQUFEL3dBUUFBOEFBUkFCUkFGOEFZd0JuQUhnQWd3Q1FBSjBBcVFDMkFNTUEwQURjQU9rQTlRRUxBUThBQUFFaklnWWRBUTRCQnc0QkhRRVVGaGNlQVJjVkZCWTdBUlFHTVNFd05EVXpNalk5QVQ0Qk56NEJOejRCUFFFMEppY3VBU2N1QVNjMU5DWXJBVFUwSmlNaElnWWRBUU1qSWlZMVBBRTFORFk3QVJVQk1oWVZIQUVWSVR3Qk5UUTJNd01WSXpVQklUVWhFeEVVQmlNaElpWTFFVFEyTXlFeUZoVVRGQVlyQVRVek1oWWRBVGNVQmlzQk5UTXlGaFVjQVJVbE5DWWpJZ1lWRkJZek1qWTFCeUltTlRRMk16SVdGUlFHSlNJR0ZSUVdNekkyTlRRbUl4VWlKalUwTmpNeUZoVVVCaU0xSWdZVkZCWXpNalkxTkNZakZTSW1OVFEyTXpJV0ZSUUdKU0lHRlJRV016STJOVFFtSXhVaUpqVTBOak15RmhVVUJnVWpJZ1lIRGdFZkFSNEJPd0V5Tmo4Qk5qUW5MZ0VISXljekFSZGtMRGdQRkFVU0ZSZ1dCUkVMT0N3TUFRS0VEQ3c0QlFnRUJnWURHUlVTRmdJSkNBVUpCVG9xWkNrOS92TW5PYnNOQndNREJ3MENMQXdNL3NBTUNPc2lBcFQrQ3dIMWNRc0wvVlVMREF3TEFxc0xDeTREQ1JZWENBTWlCQWNNREFjRS9odEdNVEZHUmpFeFJuY3JQVDByS3owOUFSWXhSa1l4TVVaR01TczlQU3NyUFQwcklqRXhJaUl4TVNJSkRRMEpDUTBOL3JZaU1URWlJakF3SWdrT0Rna0pEUTBCQ3VjREJRSUNBUUVXQVFZRXZRUUdBUlVCQWdJRklhc013d001T1N4d0NCZ1FEQ2NaaUJ3cUNnc1FCbVF0T1JsTVJDRTVMV01DQndNR0N3VU1MUmVIRnlvTkNCRUlCUWNEYnlvN0xSbEJOQ1l0L2hvREJ5SklJUWdFb1FJb0NRZ0dQeDBjUWdRRkRQNm44dkw5NDBVQjcvNUxEUW9LRFFKS0RRb09DZjV1Q1FQeUF3bmFJZ2dEb1FNSklVY2lsakpGUlRJeFJrWXhhRDByS3owOUt5czkzMFV5TVVWRk1USkYzandyS3owOUt5czh1akFqSWpBd0lpTXdSd3dKQ1EwTkNRa01SekFqSWpBd0lpTXdSd3dKQ1EwTkNRa004QUlEQWdZRE9BUUVCQVE1QXdVQ0F3STVJZ0FPQUFnQUN3UDRBM1VBUndCWEFHTUFlUUNKQUpVQXF3RHBBUXNCR3dFbEFVOEJYd0dCQUFBQkZnWUhEZ0VqQmlZbkxnRW5EZ0VIRGdFbklpWW5MZ0UzUGdFWE1oWVhIZ0V6UGdFM0p5NEJOVFEyTno0Qk16QXlNVG9CTXpJV0ZSUUdEd0VlQVJjeU5qYytBVE0yRmhjM0JpWW5MZ0VuTkRZM05oWVhIZ0VISnpJMk5UUW1JeUlHRlJRV056UW1JeUlHQno0Qk16SVdGUlFHQnpJV016STJKd1VPQVNjbU5qYytBUmNlQVJVT0FRY25OQ1lqSWdZVkZCWXpNalkzTGdFaklnWVZCaFl6TWpZekxnRTFORFl6TWhZWEJTNEJKeTRCTno0Qk16SVdGeDRCRno0Qk56NEJNeklXRno0Qk56NEJNeklXRnhZR0J3NEJEd0VPQXdjT0FRY1ZJVFV1QVNjdUFTY3VBUzhCTng0QkZ6NEJOeUltSnk0Qk56NEJGeDRCRno0Qk55NEJKeTRCSXlJR0J3WVdGemMrQVRjdUFTY2lCZ2NHRmhjZUFUY0JNRFExSndjY0FURWhFeTRESnk0Qkl6RWlCZ2NPQVFjNEFURU9Bd2NlQXhjZUFSYzNGejRCTno0RE56YytBU2N1QVNNaUJnY2VBUmN5TmpjM0xnRWpJZ1lIRGdFSEhnRVhQZ0V6TmhZWEZnWUhEZ0VqSGdFWFBnRTNQZ0VuQW1jREJBWUVFZ29EQndNSkhRb0xIUWtEQmdRS0VRVUZCQUlCQkFNQ0JnTUVDd2NRSUFNQkpTZ1FEUXNmRUFFQkFRRWlPUzBwQVFNaER3Y01Bd01HQXdJRUFZb25QQndkRHdFUk1DWkJEdzROSm1VSkN3c0pDQXNMUXgwVkRSVUhCaEVKRXhvWUVnSUVBUlVkQWY3T0hEd25KdzRORUVFbU1CRUJEeDBIREFnSUN3c0lDQXdNQmhZTkZCMEJIUlVCQkFFUkdCb1NDaEFHL3VjTk1oWVdIeEVQVWpnS0ZBc0tGQWdRS0JrbllEaGFqQ29JRkFvTEZBbzRVZzhSSHhZV01nMElCaGdkSVE0TklnLytVUWNPQ0FrdEhBNFZCUWdnQXdVQ0F3WUVDaFFJRFFjSEJoZ1BCdzhIQlEwSEN4b1FCZzBIR2pBTUZtWU9IQUlHQXdRTkJna01CQVFEQndjUkJ3SFhrS1FCTktRQkNoUWVGaUIyVHpGVUlSb25EQkVaRVFrQ0JSWWJIUXdVSXdXbW1BMG1Dd2daR3hnR0tBZ0VCQU1NQ1FZT0JRTUdBZ2NSQmwwTU1Cb0hEUVlSR3dzSURRWUhFQWdQRndZR0J3NElGQW9FQmdJQ0JnUU9aaFlCUndVTEJnWUlBUUVCQXhBTkRSQURBUUVCQ0FZR0N3VURBd0VGQmdnR0FSWUdLQWMrRFFnTkJBVUZGQThPUVFNb0JoWUJCZ2dHQlFFREE0Z1BKaEVRR0JJTE93NE1JaFVXWmc5UkN3Y0lDd3NJQndzRkZoOE5EQWNKSFJRVUhBRUJJQmN1RVNZUEQyWVdGU0lNRGpzTEVoZ1FPd2dMQ3dnSEN3c1dEQTBmRmhjZ0FRRWNGQlFkQ1FlQUJoMGFHVlE5UEVNQ0F3SURBaEViQ3hFU0xpd0NBd0lEQWtNOFBWUVpHaDBHQkNwYVVENFBEUmNHWjNJRERRWUdNVTRuVlNrRVBnSURBUkFtRlFjR0Nod1BEeEFCQVFVRUVTQU9BUVVFQVFJZ0sxSkNDRm9MRmdzRUJRRUlDUWtPQlFVRkFmM3lMQlVEQkJVckFZQU1TVmxZR3lNbUR3OExIaE1iVEV0Q0VTMVpTelFJRFE4Q0NRZ0VEZ3NJTWtkVkxKQUZFQWtKQ1FjRkN4Y0xCQVZBS3lBQ0FRUUZBUThqRWdVR0FSRVBFQjBLQmdjVEpBOENCQUlJUWxJQUFBQVdBQUwvMXdQOEE2a0FQQUJmQUtjQXVBRFpBT29BL1FFRUFROEJId0V2QVRzQlNBRllBV2NCZEFHQUFZMEJtUUhqQWdVQ0dBQUFBUzRCSnpVMkppOEJMZ0VqS2dFakxnRW5OUzRCSXpFcUFROEJEZ0VIRGdFWEZCWVZEZ0VmQVI0Qkh3STNIZ0VYRHdFRlB3RStBVDhCTmlZbkF3WWlJeUltSnlVdUFTY3VBVDhCUGdFek1oWVhCUjRCRng0QkR3RXdCaFVPQVFjbEJpWXZBVHdCTlQ0Qk56NEJOeVUyRmg4QktnRWpJZ1lQQVM0Qkl5SUdCdzRCQnc0QkR3RUdJaWNpSmlNT0FRY0dGaGNlQVRNeU5qYytBVGMrQVQ4Qk5oWVhIZ0V6RHdFM01DWUhEZ0V4UGdFM05oWVhNVElXTVNjT0FURXVBVFUrQVRzQk1oWXpGakkvQVQ0Qk56NEJOellXRnh3QkJ6QUdCeVV5RmpNWEhnRVBBU2MxUGdFM1BnRXpKVDRCUHdFeU5qTXlGaDhCQlM0Qkp5WTJOeE1uTVRjSE1RY1hOeDRCRndVNEFURUhKUUVpSmpVK0FUYzJNaGNlQVFjT0FRYzNKalkzUGdFWEhnRTNGZ1lIQmlZbkZ4WW1KeVlHQnlJMk56WVdCeVkyRng0QkJ3WW1CdzRCTlFVV0JpTXVBUWNpSmpVME5qYzJGaGNuTGdFM05qSVhIZ0VIRGdFbkxnRVhCaFlYRmpZM05pWW5KZ1lITnc0Qkp5NEJOejRCRng0QkZ4WTJOelltSnlZR0J3WVdGemNlQVFjT0FTY3VBVGMrQVJjaUJoY2VBUmNPQVFjR0ppYzRBVEU0QVRFdUFTY3VBU2MrQVRjeU5DY21CZ2NHRmhjV05qY3dOamNlQVJjVUJnY09BUmNlQVI4QkZqWTNQZ0UzRkJZVkZCWXpNalkxTmlZbkJ5NEJKemdCRlM0Qkp6QW1NUzRCT1FJME5oY3dOaWN3RmhjeEZCWXhNQVluTndZbUp5NEJKeVkyTng0QkZ6QVdOdzRCQndQaUN4OFNDUzRweGdVS0JRRUNBUkpJTGdZNUpRUUlBOGdVSWd3TUNnTUJNemNKSVFjOEtnRUx3UWdWRGdNTUFkVU5BeXMrQ2lzSURoU2tBd1lEQlFnRi9zOFFIQWtLQmdNdkJpOGVCQWtGQVRFUUhBa0tCZ1F1QVFrbUYvMlFJemtHSXdFVkVnY1FDQUUwSXprRkVBRURBaWxBQ0FNRkRnb0RCd1FHREFZSkV3a0dDQlVLQmcwR0dROEVCUUVHQXdrSUF3VURDeEFIQ2hRUkVRc1hEQVlNQmdyU3pDc2FGU1FNSFE0ZElnVUJBa1FvTGdJQ0F3Z0hBd1VLQlFzWENBY0tGUW9HQ3dVSUN3VUJMaWdCS0FFREFzVU1EUU1NL2dJR0JBTVFDdjR4QkFrR3h3RURBUW9SQVFmKy93RURBZ0VEQXlvSHh3cTI5QWNGQ2dZQk1RYit1ZjduQWdJakxnUUJDUUlDQXdFRk95R2NBZ0VDQWdrQkJqZ2pBUUVDSUVRSVhnUVFEaGtMQ0FrT0Nnb296d0VqREFzVkNRZ1FGZ3dMQW1ZQkF3RURTQW9DQlFJRERFd0Mrd0VCQVE1UkN3SUJBUUlIQWdoTkJRTU5EQXdVQXdJTURBd1VBeXNCQ0FZRkJnRUJDUVVHQlhJTEZRSUREUXNNRlFJRERRd0xCUVlCQVFrRkJRWUJBUWtaQWdFQ0FnTUNBZ1lESGpNWEZ5VU9EQWtGQXdZREFRRUxFZ01CQWdNQ0JRRUJBUUVEQXdFQkFnRUdCaU1mQVVrNUJBTUdBZ0VEQXdNRUFROExoUXNRQlFNR0FnRUZCUzRSQVFRckRnRWpIV0VIT0E4UVBnUURBd0VPTGhzK0hBRUxCZ0lMRWgwS0FpbEdDU2tCQVNvM0NBRW1NQUVmQXhVUkVDY1RBUUVCR21jODBEQktFZ1ZJSGhFZURSRkZZa29PRUVZdnppUkdILzVtQVFFQlFBTVREZzhoRU40ZEpnRUJRQU1URGc4aEVONENBUmNoQjlvR0tpTGdBZ01DRnlrT0JRWUJNQVlxSTJVMEtBc0dDQUVCQVFVQ0JBY0JBUUVCQVFFZERoRWFCd1FHQVFFQ0NBTUZDQU1EQVFFQkFRSXhJV1FFQlFRTUV3b0RCUXNJQVI0R0JRRUhBd1FEQVFFQkFRSUhCQUlGQVFJQ0JnSURBUW9HMUFFcEF4UU1PVFlCQ2hzVENnMlZCQVlCSHdFT0N5a3BDUlFOQmdzRi9jb3NIeTRkamlnQ0JBRkFKa1VCOUFRQ0JpWUpBZ0VCQlFJTUp3RTlBZ1VDQWdNQ0NCWUZBUVVCQ1JNS1pBME5CQVlTQVJvRUJRb3hFUllDQVJVQ0FnNE9CeElPbFFNRUdCb0RCd0lEQkFFREhSOHNBUVFDSFFnQ0JRTUNCQUVIQVZRTkZnSUREdzBORmdJRER3MERCUVVCQVFrRkJBWUJBUWxLQWc4TkRCWURBZzhOREJZRE53RUlCUVVHQVFJSUJRVUZVQUlCQVFRQkFRRUJCd0lGQlE0R0JnVUVBUUlCQWdFREF3c0RCQUVCQWdNQ0FRTUZBd0VFQWdvaUV4SWdCZ0VPV3c0QkJBSUJBd0VEQkFNREN3b0NhQU1HQkFFQ0JBSUJCUWNEQnhJRUF3Y1NBUUVNQnlzSENBTURFZ3dJRVFRSEVBWUhBd2tUQlFBQUFBQUNBQUFBQ1FRQUEzY0FSUUNGQUFBQk5DWW5MZ0VuTGdFbkxnRW5MZ0VqSWdZSERnRUhEZ0VIRGdFSERnRWpJaVluTGdFbkxnRW5MZ0VuTGdFaklnWUhEZ0VIRGdFSERnRUhEZ0VWRkJZWENRRStBVFV4TXhRR0J3RU9BU01pSmljQkxnRW5MZ0VuTGdFbkxnRW5MZ0UxTkRZM1BnRXpNaFlYSGdFWEhnRVhIZ0VYUGdFM1BnRTNQZ0UzUGdFek1oWVhIZ0VWTlFPM0JnWUhEd29KR0EwT0d3ME5IQThQSUJFUklBNFBHQXNLRVFjRkRna0pEZ1VIRVFvTEdBOE9JQkVSSUE4UEhBME5HdzROR0FrS0R3Y0dCalUyQVV3QlN6WTJTVUZDL3B3RkRRY0hEUVgrbXdNSUJRVVBDd3NUQ1FrUEJ3WUhKQ1VrWkVBU0pCSVRJaEFRR3d3TEZnb0tGZ3NNR3hBUUloTVNKQkpBWkNRbEpBSnNGeWdTRWh3S0N4RUhCZ2tDQWdNSUJ3Y1NDd3NWQ1FvU0NBWUdCZ1lJRWdvSkZRc0xFZ2NIQ0FNQ0Fna0dCeEVMQ2h3U0VTa1hNR1kxL3NBQlB6Wm1NRUNBUXY2cUJnVUZCZ0ZYQXdjRkJoSU9EUndPRHlJVkZDY1RQMk1qSXlRR0JnY1FDd29VQ1FrVEN3c1RDUWtVQ2dzUUJ3WUdKQ01qWXo4QkFBSUFCUC9BQS93RHdBQTNBSFlBQUFFdUFTOENMZ0VuS3dFSERnRVBBZzRCQndZV0h3RURCaFlYSGdFN0FUYytBVDhCRng0Qk93RTNPd0UrQVRjK0FTY0ROejRCSndFZUFSY1RCVElXRnhZR0R3RVRGQVlIRGdFaklqQXhJaVlqSlFVR0lnY3dJakV3SmpFaUppY3VBVFVUSnk0Qk56NEJNeVVUUGdFM01ESXhNekFXRndQOEJ5UVgvbklLSlJVQ0NnUVZJd2x4L2hnakJ3Y0xFTG9zQkJFU0Nob09CQVlJRGdmaTR3Z1ZDd0lFQWdJTEZBZ1NFUVFzdWc4TEIvNExBZ0lCZ2dFaUJBWUJBUUlDMGpJREF3RUVBUUVDQkFIKy9QNzlBUU1CQVFFQ0JBRUVBakhTQWdJQkFRWUVBU0tCQWdZREFRRUZBZ0kvRmg4RUp2TVVHUUlCQWhrVThpY0VIeFlYTEJHOS92TVhLZzRJQ1FFQkJBUjlmQVVHQVFJSUJ3MHJGZ0VPdmhBdEZnRTdBUU1DL3V3c0JnUUVDQUxYL3RFRkJ3SUNBUUdQandFQkFRRUJBZ2dFQVMvWEF3Z0VBd1l0QVJRREJBRUJBUUFBQUFRQUFQL0FCQUFEd0FBUUFCUUFLQUJRQUFBQklTSUdGUkVVRmpNaE1qWTFFVFFtSXdNaEVTRW5GU00xSVJFekZTTWlKalVSTkRZeklUSVdGUU02QVRNOEFUVTBOak15SWpNeUZoVWNBUlU2QVRNeUZnY09BUWNPQVNjR0ppY3VBU2NtTmpNRHd2Mk5HU1VsR1FKekdTVWxHUkQ5clFKVDVVdjl5WUtSR1NNakdRSlZHU1BlRUVvUUN3Y2tEU1FIQ3hCS0VBd0lDQ1pOSmdNR0F3UUdBeVpOSmdnSURBTWFKeHY5S3h3bkp4d0MxUnNuL1BrQ3RiZ2lFLzFyVHlVYUFyUWJKU1ViL2UxR1AwWUhDd3NIUmo5R0ZRa3VYQzhEQXdFQkF3TXZYQzRKRlFBQUFBUUFBUC9BQkFBRHdBQVFBQlVBS1FBMkFBQVhJVEkyTlJFMEppTWhJZ1lWRVJRV016Y1JJUkVoQXhFME5qTWhNaFlkQVNNMUlSRXpGU01pSmpVRkJpWTFFVFEySHdFV0ZBOEI2UUxVSENjbkhQMHNIQ2NuSEE4Q3R2MUsrQ1ViQXJNYkpVLzlheE1pR3lVQjh3UUhCd1RIQkFUSFFDVVpBbk1aSlNVWi9ZMFpKVTRDVS8ydEFTRUNWUmtqSXhtUmd2M0pTeU1aandNREJRRWxCUU1Ea2dNSkE0NEFCQUFBLzhBRUFBUEFBQk1BSkFBd0FEd0FBQk1STkRZeklUSVdIUUVqTlNFUk14VWpJaVkxQVJFVUJpTWhJaVkxRVRRMk15RXlGaFVISVJFK0FSNEJGeDRCTnhFRE1qWTFOQ1lqSWdZVkZCWUFKUnNDc3hzbFQvMXJFeUliSlFRQUp4ejlMQnduSnh3QzFCd25VdjFLSEZWZ1lTZFVtMjdKTUVORE1DOUVSQUV2QWxVWkl5TVprWUw5eVVzakdRRkIvWTRaSlNVWkFuSWFKU1VhRC82VUxDZ0JKeUZJRUFFQnVQN0ZRekF2UTBNdk1FTUFDQUFBLzhBRUFBUEFBQXNBR0FBbEFERUFQUUJKQUZVQVlnQUFBUlFHSXlJbU5UUTJNeklXQXlJR0ZSUVdNekkyTlRRbUl3RWlKalUwTmpNeUZoVVVCaU1sTkNZaklnWVZGQll6TWpZVEZoUUhCaUluSmpRM05qSUJCaFFYRmpJM05qUW5KaUlUQmlJbkpqUTNOaklYRmhRQkppSUhCaFFYRmpJM05qUW5Bbm84S3lvOFBDb3JQR2NqTWpJakpESXlKQUd0R3lVbEd4b21KaHI5RFR3cUt6dzhLeW84WUI0ZUhsVWVIaDRlVlFIOUZ4Y1hQeGNXRmhjL1JBOHJEdzhQRHlzUEQvMjNIbFVlSGg0ZVZSNGVIZ05aS2p3OEtpczhQUHpuTWlRak1qSWpKRElCRENZYUd5WW1HeG9tUUNzOFBDc3FQRHdCbWg1VkhoNGVIMVFlSC8yQUZrQVhGaFlYUUJZWEFkNFBEdzhxRHc4UER5citEaDRlSGxVZUhoNGVWUjRBQUFRQU1BQUVBOTREZndBVkFDc0FRQUJXQUFBbEFTNEJJeUlHQndFT0FSY2VBVE1oTWpZM05pWW5CeUVpSmljbU5qY0JQZ0V6TWhZWEFSNEJCdzRCSXlVekV6UTJOVFFtSnk0Qkl5SUdCdzRCRlJ3QkZSTU9BUlVVRmhjZUFUTXlOamMrQVRVMEppY3VBUWNEMVA2bkZUNGhKRHdVL3FRVkJCSVBReWtDdFNsREVnOEZGSFQ5U3hVZUJ3Z0VDZ0ZaQ2gwTUVCa0xBVmdMQkFnRkhSVCtqeXdjQXdZSUJ4RU5EUlFGQndZTkJ3WUdCd2dVQ2dvVUJ3Z0dCZ2dTS1JEZkFsVWtKeWNrL2Fza1VCOGZLU2tmSDFBa2RBY05EUjhTQWxVU0V4TVMvYWNTR3cwTkI2b0JRUWdPQWdvVUNBY0dCZ2NJRlF3RERRWCtwd2NVQ2dvVUNBY0dCZ2NJRkFvS0ZBY05BeEFBQUFBQUJnQlMvODREdUFPMkFEd0FTQUNHQU1jQTB3RVJBQUFCTGdFaklnWUhEZ0VIRlJRV0Z6SVdNem9CTXc0QkJ3NEJIUUVlQVJjT0FSVVVGak15TmpVMEppYytBVGMxTkRZMU1EWTNQZ0UzUGdFMU5DWW5BeUltTlRRMk16SVdGUlFHRXc0QkJ3NEJCdzRCQnpBR0J3WW1NVFUwTmpjK0FUYytBVGMrQVRVMEppY3VBU01pQmdjT0FRY3dCaWN1QVRFK0FUYytBVE15RmhjZUFSVVVCZ2NGTGdFbkxnRWpJZ1lIRGdFUEFSVUdGaGNPQVFjVkJ4VVVGaFVPQVFjR0ZoY2VBUmNlQVRNeU5qYzJOQ2MrQVQ4Qk5UQTBNVDRCTno0Qk56NEJOelltSndNT0FTY3VBVGMrQVJjZUFUY09BUWNPQVFjT0FRY09BUWN3QmljdUFURTFQZ0UzUGdFM1BnRTNQZ0UzTmlZbkxnRW5KZ1lIRGdFSE1BWW5MZ0V4UGdFM1BnRVhIZ0VYSGdFSEFrOG5YanRLZENZa0xRZ2xYUW9RQ0FVSEJRVUhCUVVDQWd3S0VCSlpRRUJhRkJJTEN3SUVEeG9tTUEwUER6UTEwU1F4TVNRa01qTEJDaW9oRng0RkJRWURGREF4SGdFREJRc0lDaW9oRkJFSkNBVVlEeEllQ2dvUEFpQTJPQk1GSXh3ZFd6MHhUUndtS0FvS0FUTVVQU1lWS0JJWkt4VWVMaEFEQXdoRENBb0RBd01LRUFVRkJRc01KQmNJRHdncFFRb0ZCUVVHQXdNREN3b2NLZzhRRkFVTkVCL0NCU2dVRlJZRkJTZ1VGeGFnQXdzS0NDSVhFaFVGQlFvQ0ZCd2ZEUUlKQmdVTEJ3Z2dHUkFRQWdNQkJRSVBDZ29VQ0FjUEJSZ2ZIZ2NLSHhRVk95UWNLaEFYREFnRGd4a2FKeVFrWERrR0MxSU5CQW9VQ3hJdEdTWUlGd29VTHh4QVdscEFIRFVWQ2hnS0Rnb0xBeFFWSERNWEdqTWFQV1VrL1RveEpDUXhNU1FrTVFHN0Vpa2FFaDhNQ3hrUUl3SUZLZ3NVSXcwTkdBc0tLQndRSGhBTUdBZ0ZCUXNOQ2lBYUhBZ0hJaXRIR1IwZEZCUWFSeXNTSXhEVEZ5TUtCUVVLQ2hJMEpBUURCVTBmQ2hrUUJ3ME9CUWNGQ2hvUEZ5NFhGUjBGQWdFeUpoQWlEd1VMQlFNSEF3TUZBd3dYREJBakVpbFFKUDZQRkJjR0JTY1VGUllGQlNYT0NoUUlCeFFLQ0F3SUJROEtFQVVHSUFjTkV3VUlDd1VGRUFvRkR3c0hEd1VGQ1FNREFRVUdFUThKREEwV0dTUUtEUUVLQ0JrUEZTNFpBQUFBQXdBQUFDWUVBQU5hQUFzQUdBQk1BQUFCTlNFVkl6VWhGU01SSVJFQklpWTFORFl6TWhZVkZBWWpFdzRCQnc0QkJ3NEJNU00xTkRZM1BnRTNQZ0UzUGdFMU5DWW5MZ0VqSWdZSERnRUhKejRCTno0Qk16SVdGeDRCRlJZR0J3T2Evc3pNL3N4bUJBRDkrUndvS0J3Y0tDZ2N0UWdqR1JJWkJRVUZsaElDQXhNRkNDWWFEeE1HQndnUkRRMFpDZ2NMQW44R0doY1hTREFuUFJjZkh3SUlDQUxSaVltSmlmMVZBcXY5anlrY0hDZ29IQndwQVZJTUl4VVBGZ3NISWdjU0d3b0tGQWNJSVJVTkdBc0tFd1VGQ0FrSUJ4MFNFU1E0RkJjV0VBOFVPU1FQR3hBQUJBQUFBQ1lFQUFOYUFBc0FGd0F6QUQ4QUFBRTFJUlVqTlNFVkl4RWhFUVUwTmpNeUZoVVVCaU1pSmdFeEZDWW5MZ0VqSWdZSERnRW5NU1kyTno0Qk16RXlGaGNlQVJVUklpWTFORFl6TWhZVkZBWURtdjdNelA3TVpnUUEvUDB3SWlFd01DRWtMZ0hRQ3hjVld6RXdYQlFYREFNQ0RSUWNYakV3V3h3VUJDRXhNU0VoTVRFQzBZbUppWW45VlFLcjZDUTFOU1FrTlRQK3d3TURDZ29WRWcwS0F3TURHUTBVRGc0VUR4Y0RBUW8xSkNRMU5TUW1Nd0FBQUFBQ0FIRUFQZ09KQXo0QVhRQnZBQUFCRGdFUEFRNEJGUlFXTXpJMk56NEJOVFFtSnk0Qkl5SU9BaFVVSGdJek1qWTNQZ0UzRnc0QkJ3NEJJeUltSnk0Qk5UUTJOejRETXpJZUFoVVVCZ2NPQVNNaUppY3VBVFVPQVNNaUpqVTBQZ0l6TWhZWE56TTFBejRCTlRRbUl5SUdCdzRCRlJRV016NEJBdUVGRVFVM0FnRUxEUTBkRENJbU5qQWZVVEZHZFZRdUswNXRReVJHSGhvckhqY2tLeUl1WFRCZmtUWXpNemMySDBaU1hEVk9nbDQxTFNra1ZTNGFKd29EQkJvM0prTk5JenRRTFNZckVncG10UkFUSFJjWkxoRVFFeG9hR1MwQ2tBMUFEOFlJREFjS0RnNEtHVnN6UFdZY0VoUXNVRzVEUUdoS0tRb0xCeFFVVGhVVUNnMFBORFl4aVUxU2pUVWZMaDhQTDFWMFJUNXdLU1FrRXc4RkNnMGRHbHBOT1dOS0t4Y2NId1ArOWg5TEh4d2hJaDhmUng4a0pBTWtBQUFHQUZULzJnT3BBNk1BQlFBTEFCRUFGd0RFQU1rQUFDVWpGek0xSnlFSEZUTTNJeEV6SnlNVkZ5VUhNeFUzTlFNOEFUVTBKaWN1QVNjdUFUVThBVFU4QXpVME5qYytBVGMrQVRVOEFUVThBVFVtSWlNcUFTTWlCZ2NPQVFjT0FTTXFBU01xQVNNaUppY3VBU2N1QVNNcUFTTXFBUWNVQmhVY0FSVVVGaGNlQVJjZUFSVWNBUlVjQXhVVUJnY09BUWNPQVJVY0FSVVVGaGNlQVJjZUFUTTZBVGN5RmhjZUFSY2VBUlVHRkJVVUZoY2VBUmNlQVJjMk1EYytBVGMrQVRVOEFUVTBOamMrQVRjMk1qTTZBVE15TmpjK0FUYytBVFVuQnljUklRTjJrVE9STS8wVU5wRTJrWkV6bERZQ2pqYVVNNElCQWdRSkJRSUNBZ0lFQ0FRREFnSURBU0pFSWdNRUFnUUxCQU1FQkFVTEJqSmxNZ01HQWdVS0JBSUVBeU5ISXdFREFRRUNBUVlLQlFJQ0FnRUZDd1VDQWdJQkVpVVNBUU1DQmdzRkJnZ0RCRmtHQWdJQkFnSVFJQkFCQWdFQkFSRWhFUUlCQVFFR1hRVUJCQUVIRGdjQ0JBSVNKQklCQW8yWm1nRXpZVDZJTnpTTFBnTUJRWXMyd1VHQU5vdjlaU05HSXdJREFnUUlCQUlGQXdRSEJBSTNRemtFQXdNQ0JBZ0VBZ1VFSUVJZ0FnTUNBUUlDQlFvRkFnSUNBd1VKQlFJQ0FRRUJBU0ZFSVFJRUFRVUxCUUlGQXdZTEJRRTFRRGdFQVFJQkJRc0ZBZ1FDSWtRaUFnUUJFeVVTQVFJQkF3UUZXUVVDQlFNSERBY0RCQUlSSUJBQkFnRUJBUkVpRVFJREF3Y1BCd0lEQVFaZEJRSUNBUk1rRXdFREFrU2NuQUV6QUFBQUFBTUFBUC9BQkFBRHdBQVRBQm9BSmdBQUFTSU9BaFVVSGdJek1qNENOVFF1QWdNak5RY25Oek1CRlNNMUl6VXpOVE1WTXhVQ0FHcTdpMUJRaTd0cWFydUxVRkNMdTk1MEprUm1lQUZxZUhkM2VIY0R3RkNMdTJwcXU0dFFVSXU3YW1xN2kxRDlPdlltWjJiKzJuZDNlSGQzZUFBQUJRQUFBQzBFQUFNK0FBTUFCd0ExQURvQVB3QUFBU0VSSVFFaEVTRUJMZ0UzTmhZWEhnRUhNeVkyTno0QkZ4WUdCekFHTVRNK0FTY3VBUWNPQVFjdUFTY21CZ2NHRmhjek1DWXhCU01SSVJFRklSRWhFUUkzQWNuK04vM0pBWlArYlFFd1FDc0lCMDB4TGpvRmhRVTZMaTVOQ2dnclFBTm1IQmNLRDRCSUtVQVNFa0FwU29FUENoWVphZ01COHVzQnlmMjEva3NCa3dFNy92SUJEdjd5QW93YU1CSVNCeFVVSENrcEhoSVZCQklTTVJrSEtTNGFKaEVjRWkwYUdqQVNIQkVwRnk0cEJ3Zis4d0VOQS83MkFRb0FBQUFHQUNJQUt3UGVBMGdBR3dBNUFGVUFjUUNQQUtzQUFDVVZGQVlIRGdFaklTSW1KeTRCUFFFME5qYytBVE1oTWhZWEhnRVJGUlFHQnc0Qkl5RWlKaWN1QVQwQk5EWTNQZ0V6SVRJV0Z4NEJGVEVSRlJRR0J3NEJJeUVpSmljdUFUMEJORFkzUGdFeklUSVdGeDRCQVJVVUJnY09BU3NCSWlZbkxnRTlBVFEyTno0Qk93RXlGaGNlQVJFVkZBWUhEZ0VyQVNJbUp5NEJQUUUwTmpjK0FUc0JNaFlYSGdFVk1SRVZGQVlIRGdFckFTSW1KeTRCUFFFME5qYytBVHNCTWhZWEhnRUQzZ1lHQmc0SS9aa0lEZ1lHQmdZR0JnNElBbWNJRGdZR0JnWUdCZzRJL1prSURnWUdCZ1lHQmc0SUFtY0lEZ1lHQmdZR0JnNEkvWmtJRGdZR0JnWUdCZzRJQW1jSURnWUdCdnp3QmdZR0RnaGNDQTRHQmdZR0JnWU9DRndJRGdZR0JnWUdCZzRJWEFnT0JnWUdCZ1lHRGdoY0NBNEdCZ1lHQmdZT0NGd0lEZ1lHQmdZR0JnNElYQWdPQmdZR28xQUlEZ1lHQmdZR0JnNElVQWdPQmdZR0JnWUdEZ0UyVHdnT0JnWUdCZ1lHRGdoUENBNEdCZ1lHQmdZT0NBRS9VQWdPQmdZR0JnWUdEZ2hRQ0E0R0JnWUdCZ1lPL1h0UUNBNEdCZ1lHQmdZT0NGQUlEZ1lHQmdZR0JnNEJOazhJRGdZR0JnWUdCZzRJVHdnT0JnWUdCZ1lHRGdnQlAxQUlEZ1lHQmdZR0JnNElVQWdPQmdZR0JnWUdEZ0FBQUFBSEFCei8rQVBrQTRZQVRBQlJBRjRBYXdCM0FJUUFsQUFBQVM0Qkl5SUdCeTRCSnk0Qkl5SW1KelUwSmlzQklnWVZFUlFXT3dFeU5qVVJIZ0V6TWhZWEhnRVhMZ0VqSWdZSERnSVdGeDRCTXpJMk16NEJOek1lQVJjeUZqTXlOamMrQVM0Qkp3RWpFVE1SQXlJbU5UUTJNeklXRlJRR0l3RVZJeFVqTlNNMU16VXpGUmNYSWlZMU5EWXpNaFlWRGdFbklpWTFORFl6TWhZVkRnRWpGeUltTlRRMk16SVdGVGdCTVJRR0l3TzBHVWtxR2pJV0FoVWRFeklnVTJVVkloWGVGUm9hRmQ0V0lSOWxTUmtuRHhjUkFnMDFJaXBKR1J3V0JRWUNCemNvQWdVQ0NqczNoamM3Q2dNRkFpYzNDQUVHQkJjYy9Sb2dJQlFXSHg4V0ZpQWdGZ0hKSmlvbUppb21rd3NRRUFzTUVBRVBEQXNRRUFzTUVBRVFDMFFMRUJBTEN4QVFDd0ZwS2kwUERoMVJJUlVWWHlSNkZSZ1lGZnpSRlIwZEZRS0FKa1VRRVJsR0hRa1pMaXN0V2tzMEJpd3pBUUVXUTBNV0FRRXpLd2N6UzFrdC93QUI0LzRkQWlvZkZoWWdJQllXSC82TUtTRWhLaVVsQVZJUUN3c1FFQXNMRUVvUURBc1FFQXNNRUNnUURBc1FFQXNNRUFBQUFBQUhBSy8vM0FOUUE1NEFGZ0FhQUVFQVRnQmhBSFFBaHdBQUFTRWlCaFVSRkJZeklUZ0JNekkyTlRRd05STTBKaU1USVJFaEF5WUdNUTRCS3dFaUppY3VBUWNHRmpFZUFUYytBVEUrQVRzQk1oWVhIZ0VYRmpZM01EWW5CeFVqRlNNMUl6VXpOVE1WTXhjaUpqVTBOak15RmhVNEFURVVCaU00QVRFMUlpWTFORFl6TWhZVk9BRXhGQVlqT0FFeEZ5SW1OVFEyTXpJV0ZUZ0JNUlFHSXpnQk1RTGcva0F1UTBNdUFjQUJMRUFEUWk0cy9lVUNHMjhuV1FRTEJSVUdDZ1VFVlNZbkNBTVNFUkUyQXdvR2V3VUtCQU16RUJFVEFnZ214aDBnSFIwZ0hYSUlEUTBJQ1F3TUNRZ05EUWdKREF3Sk5BZ05EUWdKREF3SkE1NUFMZjBXTEQ5QUxBRUJBdWN0UVB6bkFwcis3RDhtQXdRRUF3TWpQejl3RVJNQkFUc0VCUVVFQkRjQkFSUVFjRDhoSFJ3Y0lSd2NSQXdKQ1F3TUNRa01PZ3dJQ1F3TUNRZ01Id3dKQ0F3TUNBa01BQUFELy8zL3dBUUFBOEFBRndBb0FFQUFBQUVuTnk4QkJ5Y0hKdzhCRndjWEJ4OEJOeGMzRno4Qkp3RXpGUlFHQnc0Qkt3RWlKaWN1QVQwQkV3NEJJeUltSnk0Qk5UUTJOejRCTXpJV0Z4NEJGUlFHQkFCbUw1SWprbWR3a0RPWkhuQm1NSk1pazJaeGp6Q2FILzVCVlFFQ0F3SUNPZ01GQWdNRVRnY1JDZ29RQ0FnR0JnZ0lFQW9LRVFjSUJnWUJwWENRTDVvZmNXWXZraU9TWjNDUUw1b2ZjV1l2a2lPU0FWbHhGQ1VTRWpVekZCSWxGSEgraVFZSUJnZ0ZFZ3NLRXdVRkNBVUlCUk1LQ3hBQUFBQUVBQUFBQkFRQUEzd0FFQUFnQURFQVFnQUFBVFEyTXlFeUZoMEJGQVlqSVNJbVBRRWhORFl6SVRJV0hRRVVCaU1oSWlZMUFUUTJNeUV5RmgwQkZBWWpJU0ltUFFFaE5EWXpJVElXSFFFVUJpTWhJaVk5QVFKWktCd0JIeHdvS0J6KzRSd28vYWNvSEFFZkhDZ29IUDdoSENnQ1dTZ2NBUjhjS0NnYy91RWNLUDJuS0J3Qkh4d29LQnorNFJ3b0F6Y2RLQ2dkMmh3b0tCemFIU2dvSGRvY0tDZ2Mvc2tkS0NnZDNSMG9LQjNkSFNnb0hkMGRLQ2dkM1FBQUFBTUFBQUFtQkFBRFdnQWlBQ29BTHdBQUpTRTFJVEkyTlJFMEppTWhJZ1lWRVJRV015RVZJVEFHRlJRV01TRXdOalUySmpFQklSRWhNRHdDRnlFUklSRUQ1ZjVqQVdNVUlpSVUvTFVWS1NjWEFWeitZeDhmQThJZkF4Nzhwd0x2L1JGRUFtZjltV3NpT2hRQ1N4VWZIeFg5dFJRNklna1pHZ2tKR2h3R0FxcjkzcXZOcWtUK1pnR2FBQUFBQmdBREFERUQvUU5UQUEwQUhnQWlBQ2NBTEFBeEFBQWxJVEFHRlJRV01TRXdOalUwSmlVaE1qWTFFVFFtSXlFaUJoVVJGQll6RXlFUklSTWhFU0VSQlRNVkl6VTFNeFVqTlFQZS9FUWZId084SHgvOGdnTkFGUnNiRmZ6QUZSOGZGUlFER1B6b1NBR1cvbW9CNGFlbnA2ZDFDUmthQ0FnYUdRazNGeFVDU0JRZkh4VDl1QlVYQWwvOTVRSFQvblFCak8rZG5lK2RuUUFHQUNJQWNnUGVBeUVBQ3dBcUFEWUFWUUJoQUhzQUFBRVVCaU1pSmpVME5qTXlGZ2NPQVNNaUppY2lCZ2NVRmhVVUJnY2VBVEVWTWpZL0FUNEJOelV3SmljbEZBWWpJaVkxTkRZek1oWUhORFkxTGdFakRnRWpJaVluRGdFSEZUQVdId0VlQVJjMVBnRTNMZ0UxQlJRR0l5SW1OVFEyTXpJV0J3NEJJeUltSnlJR0J4VXdGaDhCSGdFL0FUNEJOelV3SmljRGRVVXhNVVZGTVRGRk5ROGhFUkVoRHdRS0J3RWJGM01tSERvZUVSSWtFaWgyL2pkRk1URkZSVEV4UlNBQkJnb0dEeUFTRVNFUEY0SUZLQ0lRR1RvaEJHNG5GeHNCSUVVd01VVkZNVEJGT1E0ZUVCRWVEZzJTQlNnakVES0xUaEFTSkJJb2VRS3NNVVZGTVRCRlJiY0hDQWdIQVFFQ0F3SWhPUlFPZ0I4SkNnWUhFZ3RwZVFXSE1VVkZNVEJGUmNBQ0JBRUJBUWNJQ0FjQktsTnBGUTBGQ0F3Q0gwNDVCaFE2SVFjeFJVVXhNRVZGd2dZSEJ3WWxXV2tWREFZUURCa0dCeElMYVhzREFBQUVBRElBc0FQT0FzNEFUZ0JhQUdnQWRBQUFBUzRCSnk0Qkl3Y2lCZ2NuTUNZbkxnRXhJVEFtQnc0Qk1RYzBKaU1uSWdZSERnRUhCaFk3QVE0QkJ4UUdIUUVjQVRFVkZCWTdBVEkyUFFFaEZSUVdPd0V5TmpVUlBBRW5MZ0VuTXo0Qkp3VWlKalUwTmpNeUZoVVVCaWMxTnpBMk55RWVBVEVmQVJVaEJTSW1OVFEyTXpJV0ZSUUdBODRCQkFFRUNBay9DUW9CaEFrSkNBNytsQTRKQlFpR0RBZzlDUWdFQVFRQkJCQUlKZzBOQXdJTUNJd0pEQUg4REFtTUNBd0NBZzROSmdnUUJQejVHaUVqR0JraUlqU09CQU1CZFFNRWFpYjlYd0tVR2lFakdCa2lJd0luQndnS0NBd0pCQVY5QndRREFRRUZCQVYvQndJSkRBZ0tDQWNLQ2hFa0R3SURBZ2NJRE9rSURBd0lKQ1FJREF3SUFRSUNCUUlQSXc4Q0N3clpKQnNiSlNVYkd5U3dJb2dEQVFFRFpDRWxzQ1FiR3lVbEd4c2tBQUFBQUF3QUl3QVlBOThEZEFBYkFEZ0FWUUJ5QUk4QXJBREpBT1lCQXdFZ0FUMEJXZ0FBSlNFaUppY3VBVDBCTkRZM1BnRXpJVElXRng0QkhRRVVCZ2NPQVNVaUJnY09BUjBCRkJZWEhnRXpJVEkyTno0QlBRRTBKaWN1QVNNaEpTRWlKaWN1QVQwQk5EWTNQZ0V6SVRJV0Z4NEJIUUVVQmdjT0FTTWxLZ0VIRGdFZEFSd0JGeDRCTXlFeU5qYytBVDBCTkNZbkppSWpJU1VoSWlZbkxnRTlBVFEyTno0Qk15RXlGaGNlQVIwQkZBWUhEZ0VqSlNJR0J3NEJIUUVVRmhjZUFUTWhNalkzUGdFOUFUUW1KeTRCSXlFREl5SW1KeTRCUFFFME5qYytBVHNCTWhZWEhnRWRBUlFHQnc0Qkl5Y2lCZ2NHRkIwQkhBRVhIZ0U3QVRJMk56NEJQUUUwSmljdUFTc0JOeU1pSmljdUFUMEJORFkzUGdFN0FUSVdGeDRCSFFFVUJnY09BU01uS2dFSERnRWRBUndCRng0Qk93RXlOamMrQVQwQk5DWW5KaUlyQVRjaklpWW5MZ0U5QVRRMk56NEJPd0V5RmhjZUFSMEJGQVlIRGdFakp5SUdCd1lVSFFFY0FSY2VBVHNCTWpZM1BnRTlBVFFtSnk0Qkt3RURsLzRJRHhvS0Nnc0xDZ3NaRHdINERob0tDd3NMQ3dvYS9mb0NBZ0lCQVFFQkFnSUNBZmdCQXdFQ0FRRUNBUU1CL2dnQitQNElEeG9LQ2dzTENnc1pEd0g0RGhvTENnc0xDd29hRHY0SUFnSUNBUUVDQWdJQ0FmZ0JBd0VDQVFFQkFnTUIvZ2dCK1A0SUR4b0tDZ3NMQ2dzWkR3SDREaG9MQ2dzTEN3b2FEdjRJQWdJQ0FRRUJBUUlDQWdINEFnSUJBZ0VCQVFJREFmNEkyRndQR2dvS0N3c0tDeGtQWEE0YUNnc0xDd3NLR2c1Y0FnSUNBZ0lDQWdKY0FRTUJBZ0VCQWdFREFWeGNYQThhQ2dvTEN3b0tHZzljRGhvTENnc0xDd29hRGx3Q0FnSUJBUUlDQWdKY0FRTUJBZ0VCQVFJREFWeGNYQThhQ2dvTEN3b0tHZzljRGhvTENnc0xDd29hRGx3Q0FnSUNBZ0lDQWx3Q0FnRUNBUUVCQWdNQlhCZ0tDd29hRGxBT0dnb0xDd3NMQ2hvT1VBNGFDZ3NLbndFQ0FRTUJVQUVEQVFJQkFRSUJBd0ZRQVFNQkFnR2ZDd29MR1E5UER4b0tDZ3NMQ2dvYUQwOFBHUXNLQzU4Q0FnSUNUd0lDQWdFQkFRRUNBZ0pQQWdJQ0FxQUxDZ29hRGxBT0dnc0tDd3NMQ2hrUFVBNGFDZ3NLbndFQkFnTUJVQUVEQVFJQkFRSUNBZ0ZRQWdJQkFnSDg1QW9MQ2hvT1VBNGFDd29MQ3dzS0dnNVFEaG9LQ3dxZkFRSUJBd0ZRQVFNQkFnRUJBZ0VEQVZBQkF3RUNBWjhMQ2dzWkQwOFBHZ29LQ3dzS0Nob1BUdzhaQ3dvTG53SUNBZ0pQQWdJQ0FRRUJBUUlDQWs4Q0FnSUNvQXNLQ2hvT1VBOFpDd29MQ3dzS0dnNVFEaG9LQ3dxZkFRRUNBZ0pRQVFJQ0FnRUJBZ0lDQVZBQkF3RUNBUUFBRGdDRC8vMERkUU9jQUNBQVpBQjlBSTRBOWdGT0FWNEJiZ0dHQVo0QndRSGtBaGNDU2dBQU56UTJPd0V5TmowQk5EWXpJVElXSFFFVUZqc0JNaFlkQVJRR0l5RWlKajBCTVRNME5qc0JNalk5QVRRMk15RXlGaDBCRkJZN0FUSVdIUUVVQmlNaElpWTlBU01WRkJZeklUSTJQUUUwSmlzQklpWTlBVFFtSXlFaUJoMEJGQVlyQVNJR0ZUTUJOaklmQVI0Qkh3RVdCaU1oS2dFaklTSW1Qd0UrQVQ4QkZ5WWlEd0VHRmpNaE1qWXZBUzRCTHdFbkZ6NEJNeklXSHdFZUFSOENNVE1qTVRzQkp4VXpKeGMxSXhjMU1BWW5JU29CSXlFcUFUa0JCek0xQnpFek1TTXpQd0krQVQ4Qkp3Y09BUThCRGdFSERnRVZGQll6SGdFeklUb0JNeUV5TmpjeU5qVTBKaWN1QVM4QkxnRXZBUzRCSXlJR0J4Y1hOeTRCSXlJR0R3RU9BUWNVQmhVVUZqTWVBVE1oTWpZM01qWTFOQ1luTGdFdkFTNEJMd0VIRng0Qkh3SXhNeU14T3dFbkZUTW5GeWN4Rnljd0JpTWhJaVk1QVFjekp3Y3hPd0VqTXo4Q1BnRXpNaFlYTndFek1oWVZFUlFHS3dFaUpqVVJORFloTXpJV0ZSRVVCaXNCSWlZMUVUUTJJVG9CTXpJV0ZSd0JGUlFHSXlvQkl5SW1OVHdCTlRRMk16b0JNeklXRlJ3QkZSUUdJeW9CSXlJbU5Ud0JOVFEySVJVek1oWVZFUlFHS3dFaUpqVVJORFl6TlNJR0ZSRVVGanNCTWpZMUVUUW1Ld0VGRlRNeUZoVVJGQVlyQVNJbU5SRTBOak0xSWdZVkVSUVdPd0V5TmpVUk5DWXJBUVVWT2dFek1oWVZIQUVWRkFZaktnRWpJaVkxUEFFMU5EWXpOU0lHRlJ3QkZSUVdNem9CTXpJMk5Ud0JOVFFtSXlvQkl4Y1ZPZ0V6TWhZVkhBRVZGQVlqS2dFaklpWTFQQUUxTkRZek5TSUdGUndCRlJRV016b0JNekkyTlR3Qk5UUW1JeW9CSTRVRUF5VURCUVFEQW5nREJRUURKZ0lGQlFMOUh3TUVBUU1ESlFRRkJBSUNlQU1EQlFRbUFnTURBdjBmQXdNREJRUUM0UU1GQlFNbUFnUUZBLzJIQkFVREF5VUVCUUlCYXdVT0JaTUZEZ1dVQlFJRy9zWUdFQWIreGdZQkJaTUZEZ1dUR0FVT0Jkb0ZBUVlCeUFZQkJFRUZEZ1dDR0FNQkJRTURCUUtUQlE0Rmt3TUJBUUVCQWdJQ0FRRUJBZ0wreGdZUUJ2N0dBUUlCQVFFQkFRRUJBcE1GRGdXVUJaUUVEZ1dVQVFJQkFRRURBUUlEQWdFNkJoQUdBVG9DQXdJQkF3RUJBUUlCbEFVTkJaUURCd1FFQndNQ0dBSURCd1FFQndQYkFRSUJBZ01DQVFNQ0FjZ0NBd0lCQXdFQkFRSUJRUVVPQllJRWdnVU5CVUVEQVFFQkFRSUNBZ0VCQVFFQkF2NDRBUUlCQWdFQkFRRUNBUUVDMndFRkF3TUZBZ0wrOXlnSENnb0hLQWNLQ2dIYUp3Y0tDZ2NuQ0FvSy90RUtFd29IQ3dzSENoTUtCd3NMb2dvVUNRZ0tDZ2dKRkFvSENnciswQ2dGQ0FnRktBVUlDQVVKREF3SktBa01EQWtvQWRNbkJRZ0lCU2NHQ0FnR0NRME5DU2NKRFEwSkovN0pDaE1LQmdnSUJnb1RDZ1lJQ0FZSkRRMEpDaE1LQ1EwTkNRb1RDcHNLRkFrR0NBZ0dDUlFLQlFnSUJRa01EQWtLRkFrSkRRMEpDUlFLUkFNRUJRTU5Bd1VGQXcwREJRUURQZ01FQkFNK0F3TUZCQTBEQXdNRERRUUZBd00rQWdNREFqNCtBd1lHQXo0RUJRTUREUVFGQlFRTkF3TUZCQU5RQkFSa0JBa0VaQVFGQlFSa0JBa0VaQ1VEQTVVRUJRVURMUU1LQTFrbEF3RUNBZ0ZsQXdvRFpRSUNBZ0lCQVFFQkFRRUNBZ0lCQVdVRENnTmxCMlVEQ2dObEFRSUJBUUlDQWdNQkFRRUJBd0lDQWdFQkFnRmxBd29EWlFJQ0FnSUVKUU1DQWdJQ2xRRUNBUUVDQWdJREFRRUJBUU1DQWdJQkFRSUJMQVFKQTFrR1dRUUpBeTBDQWdJQ0FRRUJBUUVCQWdJQ0FRR1dBUUVCQVFQK3p3c0gvcnNJQ2dvSUFVVUhDd3NIL3JzSUNnb0lBVVVIQ3dzSFZwbFdDQW9LQ0ZhWlZnY0xDd2RXbVZZSUNnb0lWcGxXQndzRUNBYit1d1lJQ0FZQlJRWUlDQTBKL3JzSkRRMEpBVVVKRFFRRUNBYit1d1lJQ0FZQlJRWUlDQTBKL3JzSkRRMEpBVVVKRFFRRUNBWldtVllHQ0FnR1ZwbFdCZ2dJRFFsV21WWUpEUTBKVnBsV0NRMEVCQWdHVnBsV0JnZ0lCbGFaVmdZSUNBMEpWcGxXQ1EwTkNWYVpWZ2tOQUFBQUFnQTlBREFEd3dNZkFBNEFIUUFBQVJRT0FnYzFQZ0U5QVNNUklSRWhGQTRDQnpVK0FUMEJJeEVoRVFQRE1sbDdTbEZQd3dGei9lMHlXWHRKVUUvREFYTUJyRmVIWURjSG1oQjFWeDhCV3Y2TlY0ZGdOd2VhRUhWWEh3RmEvbzBBQWdBeC8rb0R6d09XQUZRQVlBQUFBVFVuTGdFbk1TWTJQd0VuQnc0Qkp6RXVBUzhCSXdjT0FRY3hCaVl2QVFjWEhnRUhPQUV4RGdFUEFSVVhIZ0VYTVJZR0R3RVhOejRCRnpFZUFSOEJNemMrQVRjNEFURTJGaDhCTnljdUFUY3hQZ0UvQVFVaUpqVTBOak15RmhVVUJnUFBReFFkQ0FnQkNSOVlRUklxRXhNY0J4aDhHQWNjRXhNcEUwQlpId2tCQ0FnZUUwTkRFeDRJQ0FFSkgxbEFFeWtURXh3SEdId1lCeDBURXlnVFFWZ2ZDUUVJQ0I0VFEvNHhSbVJrUmtaa1pBR0JmaGdISFJNVEtoTkJXaDhKQVFnSUhoTkZSUk1lQ0FnQkNSOWFRUk1xRXhNZEJobCtHUWNjRXhNcUUwRmFId2tCQ0FnZUUwVkVGQjRJQ0FFSkgxcEJFeW9URXh3SEdXMWxSMGRsWlVkSFpRQUFCd0F4QVBNRHp3S05BQWNBRHdBWUFDQUFLd0NIQUpJQUFBRVhEZ0VISno0QkJ4Y09BUWNuUGdFRkJ5NEJKemNlQVJjbkJ5NEJKemNlQVNjZUFSY0hMZ0VuUGdFM0FUQXVBaWNPQXpFblBnTTNMZ0VuTVFjT0FTY2pMZ0UvQVE0QkJ5NEJKemNlQVJjM1BnRWZBUjRCRHdFZUFSYytBVGNuSmpZL0FUWVdId0UrQVRjWERnRUhMZ0VuRnhZR0J5TUdKaThCRGdFSEhnTVhCeE1uUGdFM0hnRVhEZ0VIQTRZdUJnd0dNQWNNS2pBR0RRY3dCdzM5ZGpBSERRWXdCZzBITVRBR0RBWXVCd3hFQnc0R0xnRURBUVlNQmdNMktsdVNhR2lTV3lwUU8yNWxYQ2t4Ymo0R0FnZ0RBUVFDQWhBREJBSUxGQXN4QkFrRUJnSUlBd0VFQWdJR0ZJSnFhb0lVQmdJQ0JBRURDQUlHQkFrRU1Rc1VDd0lFQXhBQ0FnUUJBd2dDQmo1dU1TbGNaVzQ3VUVzdUJnNEhCZ3dHQVFNQkFtOGVCQWdESGdRSEdCOERCd1FmQXdjS0h3UUhBeDhFQndNYkhnTUlCQjRFQnlrRUNRUWVBUUlCQ3hVTC9tWUlIRFV0TFRVY0NCRVNKU1FqRVJZekhnc0RBZ0lDQ0FNY0JBZ0VCUW9GSUFNRUFnc0VBZ0lCQWdjRUN3dENMUzFDQ3dzRUJ3SUJBZ0lFQ3dJRUF5QUZDZ1VFQ0FRY0F3Z0NBZ0lEQ3g0ekZoRWpKQ1VTRVFGckhnUUpCQXNWQ3dFQ0FRQUFBQVFBSFAvYkEra0RxQUFhQUNJQUx3QklBQUFCTWg0Q0ZSUU9BaU1pTGdJMU5EQXhORDRDTXpJd01RTTNGVE1SSXdjWEZ6TVZNelV6TlNNMUl4VWpGUU1pRGdJVkZCNENNekkrQWpVNEFURXVBeU14QWdKUmpXbzlQV3FOVVZHTmFqMDlhWTVRQWMwZFdGdE9OTkpiVzF0Ylcxc0ZaYkdFVEV5RXNXVmxzWVJOQVV5RXNXVURSejFxamxGUWptbzlQV3FPVUFGUmpXbzkvb0lkdXdFNlRrNURXMXRiV2xwYkFpSk5oTEZrWmJHRVRVMkVzV1Zrc1lSTkFBQUFCQUF6LzhBRHpRUEFBQkFBTHdBMEFEa0FBQUVoSWdZVkVSUVdNeUV5TmpVUk5DWWpBVFEyT3dFOEFUVTBOanNCTWhZZEFUTXlGaDBCRkFZSEZTRTFMZ0U5QVFFaE5TRVZOU0UxSVJVRGlmenVIQ2dvSEFNU0hDZ29IUDJ5TUNJWENRYXBCd2tXSWpBcUgvNzVIeW9CelAzeUFnNzk4Z0lPQThBb0hQeUlIQ2dvSEFONEhDaiszU0l3QnlNV0Jna0pCa0F3SXJFZ0xnUXNMQVF1SUxIOXFDa3BmaWtwQUFBQUJnQUEvOEFFQVFQQkFCd0FJQUExQURrQVBRQkJBQUFCSVE0QkZUZ0JNUkU0QVRFVUZqTTRBVEVoT0FFeE1qWTNFUzRCSndNaEVTRUhKeTRCSXlJR0J5TUJEd0UvQVFFK0FUVTBKaWNuRndjbkJ5YzNGemNuTnhjRHZQeUlIQ2dvSEFONEhDZ0JBU2djRC95bkExbVJYUWdXREF3VkNBSCtyUWM2NnhZQlJRY0pDUWpMTFBRc0hpVWFhUzhzOUNzRHdRRW9IUHlJSENnb0hBTjRIQ2dCL0ZNRFdmQmRDQWtJQ1A2c0IrczdGZ0ZGQ0JVTURCVUlBU3p6SzdFblgya21LL1FzQUEwQVJmL2JBN3NEcUFBUEFCUUFHUUFlQUNJQUp3QXNBREFBTlFBNkFENEFUZ0JlQUFBQklTSUdGUkVVRmpNaE1qWTFFVFFtQXlFUklSRUJNeFVqTlRzQkZTTTFPd0VWSXdVekZTTTFPd0VWSXpVN0FSVWpCVE1WSXpVN0FSVWpOVHNCRlNNQk16SVdIUUVVQmlzQklpWTlBVFEySVRNeUZoMEJGQVlyQVNJbVBRRTBOZ041L1E0Ykp5Y2JBdkliSnljYi9RNEM4djFzakl6VmpJemNqSXorVDR5TTFZeU0zSXlNL2srTWpOV01qTnlNalA1ZFdBWUlDQVpZQmdnSUFkQlhCZ2dJQmxjR0NRa0RTU0lZL1FjWUl5TVlBdmtZSXZ6TkF2bjlCd0o2akl5TWpJeEZqSXlNakl4RWpJeU1qSXdEUlFnR3RRWUlDQWExQmdnSUJyVUdDQWdHdFFZSUFBd0FRLy9aQTdvRHFRQVBBQlFBR1FBZEFDSUFKd0FyQURBQU5RQTZBRW9BV3dBQUFTRWlCaFVSRkJZeklUSTJOUkUwSmdFak5UTVZOU00xTXhVMUl6VXpFeU0xTXhVMUl6VXpGVFVqTlRNVEl6VXpGVFVqTlRNVk5TTTFNeFVCTXpJV0hRRVVCaXNCSWlZOUFUUTJJVE15RmgwQkZBWXJBU0ltUFFFME5qTURlZjBPR3lrcEd3THlHeVltL2R1TWpJeU1qSXpZalkyTmpZMk4zWTJOalkyTmpmM05XUVlJQ0FaWkJnZ0lBZEZaQmdrSkJsa0ZDUWtGQTBZaEdQMEhHQ01qR0FMNUdDSDlHNDJOem8yTjA0MzkwbzJOem8yTjA0MzkwbzJOem8yTjA0Mk5BYWNKQnJZR0NRa0d0Z1lKQ1FhMkJna0pCcllHQ1FBQUFBY0FUQUJSQStBRE5RQStBSFFBaWdDZ0FMSUF4QURXQUFBbElpNENKeTRCSnk0Q05qYytBVGMrQVRjeE5oWVhIZ0VYRlI0QkJ3NEJCdzRCQnc0QkJ3NEJCeFFXRng0QkZ6RWVBUmNXQmc4QkRnRUhEZ0VqRXc0QkJ3NEJCd1lXRng0QkZ4NENOamMrQVRjK0FTY3VBU2N1QVNjdUFUYzBOamMrQVRjK0FUYytBVFUwSmljdUFTY3VBU01CRkJZek1ESXhQZ0UzTkNZak9BRWpJZ1lWSWhReE5SUVdNekF5TVQ0Qk5UUW1JemdCTVNZR0ZUQVVGUVVHRmhjNkFURStBVGN1QVNNaUJoVTRBUWNpQmhVVU1ERVVGak0rQVRVMkppTXdJaE1XTmpjd05ERTBKaWNpQmdjR0ZqTVdNZ0lFSjA5TlRTVWpQUmNjSGdNWUdTZDBVRUNRV3gxVUxCTWlFQklSQVFFVUV3Y1pEZ3djQkFZRUFRUUVDM0lqTFNvSUN3Y1JBU1JtUlVDQVAxOVdoanhJYVNJcUJTOFVOQjQrZ0lPRlJEMVpJQXNGQmdjZkdBMlRFaEVLQVF3U0Joa1VEQmdHQ0FrSEJ3d2FEeWRNRy81c0p4c0JHeVlCSnhzQkdpY0JKeHNCR3lZbkd4c25BZDhCSmhzQkFSc21BUUVtSEJzbW5Sc25LQnNhSmdFbUd3RVhHeWdCSnhzYkpnRUJKQnNCQVZFS0ZCNFVFelVnSlU5UlVTYzhXeUlhR3dFQkJ3MEdFUXdCRFNNU0V5SU5CUTRIQnhBREJBY0NBUVlFQnlnS0Rpd1RHejhoQVR0U0d4b1pBckVDR0JrZVVqVkJnejhiTGc4aUpBY1hHaGhJTXhZb0VCQVlCd1F3RUE0YkNnb2REZ1FPREFZUEF3VU5Cd1lNQlFvTkJBMEYvbEFiSndFbUd4c25KUnNDMmhzbkFTY2JHeVlCSmhzQkFiMGJKZ0VCSmhzYkp5Y2JNaVliQVJ3bEFTVWJHeWNCRFFFbUd3RWJKd0VtR2hzb0FRQUFBQVlBU2dDWEE5Y0RPQUF5QUZFQWFnQ0FBSmtBcndBQUFUSVdGeDRCRnhZR0J3NEJCdzRCQnc0QkZ4NEJGeDRCRng0QkZ4NEJCdzRCQnc0QkxnRW5MZ0VuTGdFM1BnRTNQZ0UzQVRnQk1SUVdNekl3TVQ0Qk56Z0JNVFFtSXpnQk1UQWlNU0lHRlJRd0ZUVVVGak15TURFK0FUYzBKaU00QVRFd0lqRWlCaFVjQVRFRk1CUXhGQll6TURJek1qWTNMZ0VqSWdZVk9BRXhCemdCTVNJR0ZUQVVNUlFXTXpJMk5UQTBNVFFtSXpBaU1STXlNRE15TmpVNEFURTBKaU1pQmdjd0ZERVVGak1DWlJ4VkxSSWdEaHNFSEEwZERnc1ZDUk1ERkEwZEVSMDhIUlVqREJjREV5WnFRa21Ra0kxR0l6b1dOZ1l3SzNsSFE1SmIvbGdwSEFFY0tBRXBIUUVjS0NrY0FSMG5BU2tkQVJ3b0FmZ29IQUVCSENnQkFTZ2RIU2ltSFNnb0hSMHBLUndCR1FFQkhDa29IUndwQVNnY0F6Z0ZEZ1lRQ3hVM0V3a09DQVlOQnc0a0VBc1FCZ29QQ0FZWUVSMDZIejFXR1IwWkJ5Z2xFeklmU0oxTFFsZ2VIQmtDL2g0Y0tRRW9IQjBwS0J3QkFlWWNLUUVvSFJ3cEtCd0JBY2NCSENnb0hSMHBLUjAwS1J3QkhTZ29IUUVjS1FFYkp4MGRLU2djQWh3b0FBSUFJUC9jQTk0RGt3QWRBRG9BQUFFRFBnRTNQZ0UzUGdFM05oWVhGaGNXQmdjT0FRY09Bd2NpQmdjREJpWW5MZ0VuQWdNdUFTY21OamMyRmhjZUFSY1NFeDRCRnhZR0J3RlpnQzlaTFVlUFJ4MDVIQzAyRFNrb0N4QWxOVzQ0S1ZKU1V5a05HaEFpRnl3TUJRZ0RXVmtDQXdFR0dSd2FMQWtNRlF0SFJ3TUVBZ0lKSXdGSkFmNEdEQVFGQkFjREdBc1JHUytlbmlnekVCZ3BDUVlIQlFRRUJnTCtrd1lNRlFvV0RBRm1BV1VHREFZZ0xnY0hIQjRzV0N6KzQvN2pDUlFLQWpFSUFBQUFDZ0JYLzlzRHJRT29BRWdBZ1FDVkFLc0F3UUROQU9NQTd3RUZBU0VBQUFFdUFTY3FBU2MxTkNZbkxnRWpNU0lHQnc0QkZRWVZIQUVWTUJRVklnWUhEZ0VIRGdFVkVSUVdGeDRCSHdFVUZqTWhPQUV4TWpZM1BnRW5QQUV4TlR3Qk5UNEJOUkUwSmljRERnRWpJU0ltSXk0QlBRRTBOVFEyTno0Qk5Ud0JOVFEyTno0Qk56NEJNeklXRng0QkZSUVZGQmNVRlI0QkZ4NEJGeFlHSFFFVUJnY0hCaW9CSmlNOEFUVVdNak0zTWhZM01SNEJCd01tQmdjR0ppY3VBVFUwTmpjK0FSY1dGQlVVQmdjaE5oWVhGalkzTmpRMU5DWW5MZ0VIRGdFVkZCWVhGeFFHSXlJbU5UUTJNeklXQnpRd01UUW1JeUlHRlJRV016Z0JNVGdCTXpJMk5SY1VCaU1pSmpVME5qTXlGZ2MwTURFMEppTWlCaFVVRmpNNEFURTRBVEV5TmpVSERnRWpNU0ltSnk0Qk56RTJGaGNlQVRNeU5qYytBUmN4RmdZSEEza2FSQ2dEQ3dZZUlRNkZFQmg4RUNjTkFRVUtCaUpFSGhnY0R5RVRNQndCQ3drQ0RBUUlBd1VEQVQ1U0VDUWFIa2tvL2prRUJ3UTZRRUE2Q1VvQ0VnY1FDQjVCSWlSSUl3VWhBUjFER3g0cUJ3WURDQjFyQVh5am9DUU1HUTJ4UG9KQUFRTUREeEtCRFFRTUFnRUJBd0lTaUJZQkFRSCtQaEtBRGdRTUFnRUNBaEtKRlFFQkFnR2dHeE1UR3hzVEV4c2FDd2tJREF3SUFRZ0wrQnNURXh3YkZCTWJHZ3dJQ1F3TUNRZ01JZzgzR3h3MkVBd0dBUUlIRFF3MUhCdzFEQXdJQVFFR0RBTEtHaDRCQVU0VUxnc0VCUVVFQ1RFVklpSUJBZ0lDQVFFQkF4WWZHa0ltL3NRdlZDVVZIQVUvQ0F3RUFnWVZIQUVDQmdJR0F3OWxRUUUvTEZnbS9jQWhEd0VLV0RpbFVsSTRXQW9CQ0FFQlB4WU9MQVFDQWdFREF3UURBUVFORFE0dkx3Y0lBUWNORHpVaUgwUWZ3eWxNSVlZQkFRUW9EQUVCQWdFTktBSUNGUjhWQ2dJSEJBRURBUU1GQVEwVEt3RUNBZ0lEQWg4VkNnSUhCQUVEQVFNRkFRMFRLd0VDQWdJREFrOFZIaDRWRlI0ZUFnRUpEQXdKQ0F3TENCTVZIaDRWRlI0ZUFnRUpEQXdKQ0F3TENNY0xEQXdMQ1JFQkFnSUdCd29MQmdZQ0FnRVNDQUFBQUFBRkFCc0FNZ1BsQXk4QUVnQXJBRG9BU3dCVkFBQUJPQUV4TWpZMU5DWWpJZ1lWT0FFeEZCWXpBeFVsTnljdUF3Y09BUWNPQVFjdUFTY21EZ0lIRlFVaE1BWVZGQll4SVRBMk5UUW1NU1VoTWpZMUVUUW1JeUVpQmhVUkZCWXpOeUkyTlJFaEVSUVdNUUYvR3lZbUd4c21KaHY2QWpuR0N3VTRUVllsS1ZRV0NoVUxEaTRXR0VoRk5nVURRL3h3SFIwRGtCMGQvS3NER2hRWkdSVDg1aFFnSUJRU0FRRUM4d0VDUENZYkd5WW1HeHNtL3I4bUJBd0pGbnQvWFFzTFpTVVNKUk1ZTnc4UkswWktEeHlMQmhnWkJnWVpHQVk0RlJNQ0xSUWZIeFQ5MHhNVlB3MElBZTMrQndRRkFBWUFJQUJhQTlrREl3QXdBR2dBZGdDSkFKa0FyQUFBQVM0Qkl6RWlCZ2NPQWhZWEhnRXpPZ0V6UGdFM014NEJGeFl5TXpJMk56NEJMZ0VuTGdFaklnWUhEZ0VqSWlZbkFRNEJJeUltSXk0RE1TNEJKeU1pQmdjT0FRY2lJeUltSnpBbVBnRTNQZ0V6TWhZeEhnRTdBVEkyTno0Qk16SVdGeDRDQmpFQk14VWpGU00xSXpVek5UTVZNd1VVQmlNaUpqVTBOak15TURFeUZoVTRBVEVuT0FFeEZBWWpJaVkxTkRZek1oWVZGVGdCTVJRR0l5SW1OVFEyTXpnQk1USVdGUUhsRlZNMVEzTW9LeVFIQ2dJTVZqOEVCd1FQWGxiVFZsNFBCQWNFUGxjTUFnb0lJeXNwY2tNMFVSWUdEUWNHREFVQm1RWWlIZ0lFQWhFeExpQUhGQXY3REJNSENHY2lCQU1mSWdVS0JCMG5JVXNqTVVVSkZRc3FEQlVKQ1R3eEkwc2hKeDBEQ2Y0cEJUbEdPanBHTkFHREdSSVJHUmtSQVJFWmFoa1NFUmtaRVJJWkdSSVJHUmtSRWhrQzdBOG9Ta0pIam5aU0MwUlFBU2RrWlNZQkFWQkVDMUYxalVkRFJpRU5Bd1FEQXY0VElDa0JBU2N0SlFnSkFRb0hDSEFES0NBL1puOUFOaWNwQmdnSUJnY2lKelpBZjJZL0FTWkZPanBGT2pvbkVSa1pFUklaR1JJL0VSa1pFUklaR1JKMUVoa1pFaElaR1JJQUN3QVhBQUlENXdPSUFDMEFYZ0I0QUlrQXRnRERBTllBNlFEL0FSVUJLQUFBQVNNM1BnRTFPQUV4TGdFaklnWVBBU2N1QVNNaUJoVTRBVEVVRmg4Qkl3NEJCeEVVRmpNaE1qWTFFUzRCSnhNVUJpTWhJaVkxRVRRMk15RW5MZ0UxT0FFeE5EWXpPQUV4TWhZZkFUYytBVE15RmhVNEFURVVCZzhCSVRJV0ZSRUJJVEFpTVNJR0ZUZ0JNUlVVRmpNd01qTWhNalk5QVRRbUl4TVVCaU1oSWlZOUFUNEJNeUV5RmgwQkp5WUdNUTRCS3dFaUppY3VBUWNHRmpFZUFUYytBVEUrQVRNNEFURXpPQUV4TWhZWEhnRVhGalkzSWpZbkJ4VWpGU00xSXpVek5UTVZNeGNpSmpVME5qTXlGaFU0QVRFVUJpTTRBVEUxSWlZMU5EWXpNaFlWT0FFeEZBWWpPQUV4RnpnQk1TSW1OVFEyTXpJV0ZUZ0JNUlFHSXpnQk1TVVVCaU1pSmpVME5qTTRBVEU0QVRFeUZoVTRBVEVuTkRZek1oWVZGQVlqT0FFeElpWTFPQUV4QTJxcUZ3d1BBVFFtRXlFTVdGZ01JUk1sTlE0TUY2b3pTUUZLTXdMV00wb0JTVE0zSHhqOUtoZ2VIaGdCUjRZREJBOEtCUW9EaG9ZRENnVUtEd1FEaGdGSEdCLyswdjZGQVRCRVJDOEJBUUY3TUVkSE1GWTFKUDZDSkM4Qk1pUUJmaVF4Z1NSUkJBb0ZFd1VLQkFST0l5SUhBaEVQRURFRENRVnhCUWtEQXk0UUR4RURBUWdqdFJ3Y0Z4Y2NIR2dJQ3dzSUNBc0xDQWdMQ3dnSUN3c0lNQWdMQ3dnSUN3c0lBVThnRmhZZkh4WVdJR3NmRmhZZkh4WVdId0xaRlF3aEV5VTFEZzFYVncwT05TWVNJUXdWQVVrei9oOHpSa1l6QWVFelNRSDlvaGdnSUJnQjRSZ2poUVFKQlFvUEJBU0doZ1FFRHdzRkNRT0ZKQmorSUFIZlJERHpNRU5DTWZNd1JQNlhKREV2SS9vak16UWs5Y281SVFNREF3TURIem81Wnc4VEFnRTFBd01EQkFNeUFRRVNFR1k2SHhvY0hCd2RIVHdMQ0FnTEN3Z0lDelVMQ0FnTEN3Z0lDeDBNQ0FnTEN3Z0lEQmtXSHg4V0ZpQWdGcE1XSHg4V0ZpQWdGZ0FBQUFBREFCci8wd1BuQTZBQUZBQXNBRU1BQUFVaUxnSTFORDRDTXpJZUFoVVVEZ0lqRVRnQk1TSU9BaFVVSGdJek1qNENOVFF1QWlNVFBnRTFOQ1l2QVJFMEppTWlCaFVSRng0Qk16STJOd0lBWkxHRVRVMkVzV1Zrc29STVRZU3haVk9TYlQ4L2JaSlRWSkp0UHo5dGtsVGVCUVlLQ0tRZUZSVWR5QWNRQ2dzVkJ5MU1oTEprWmJHRVRVMkVzV1Zrc29STUEzZy9iWk5UVTVKdFFFQnRrbE5UazIwLy9aSUdFUWtNRkFlSUFRd1ZIUjBWL3NTbUJnWUtDUUFBQUFJQUZ3QWJBK1VEV1FBR0FBb0FBQk1YRXpjRkV3RUJKd2tCRjd3MTN3RW4xL3d5QVNrTEFpLzkzQUhxWXY2VDFvWUM3djZSL3VLZkFYbjk2QUFBQUFBRkFMai8zUU5HQTZvQUl3QXlBRUFBU1FDR0FBQUJNaDRDRlJRR0J6Z0JNUlFHSXpnQk1TRTRBVEVpSmljdUFUVTBQZ0l6T0FFeEV6SVdGUlFHSXlFaUpqVTBOak1oRlRJV0ZSUUdJeUVpSmpVME5qTVhGQVlyQVNJbU5UTUREZ01WRkJZWEhnRVhGQllYRGdFVkZCWVhEZ0VWRkJZWEhnRTdBVEkyTno0Qk5UUW1KejRCTlRRbUp6NEJOVDRCTno0Qk5UUXVBaWN4QWY4M1lVZ3FXd3dRQy83d0NROENGMUVxU0dFM2hRc1FFQXYrOWdzUUVBc0JDZ3NRRUF2Kzlnc1FFQXY1SkNKZEpDUHFkRU4zV1RRa0ZCQWJCUVlGQkFRRkJBUUZIeGtLUFNocUtEMEpHaUFHQkFRRkJBUUZCZ1ViRUJRa05GaDNSQU50S2toaE4yMVZkZ3NRQ3doellHMDNZVWdxL1lFUEN3c1FFQXNMRDFrT0N3c0xDd3NMRGxJV0lTRVdBMmNCTTFsM1EwUldJeDA3THdvVUNRY1RDZ3NWQ1FnVUN4d3NDaVV3TUNRS0xSd0xGQW9JRkFzS0V3a0lFd292T3g0aVZrUkVkbGt6QVFBQUJBRFUvOWNETEFPbUFCMEFLd0E1QUVJQUFBRXlIZ0lWRkFZSE9BRXhGQVlqT0FFeElTSW1KeTRCTlRRK0FqTVRNaFlWRkFZaklTSW1OVFEyTXdVeUZoVVVCaU1oSWlZMU5EWXpCUlFHS3dFaUpqVWhBZ0ErYmxFdlp3NFJEZjdPRFJBQkdWd3ZVbTArbGd3U0VneisxQTBSRVEwQkxBMFJFUTMrMUEwUkVRMEJHU29tYVNjb0FRZ0RwaTlSYmo1NllJWU1FZzhIZ1cxNlBtNVJMLzB3RVEwTUVoSU1EUkZsRHd3TkRRME5EQTljR1NVbEdRQUFBQVFBbHYvZEEya0RxZ0FiQURNQVV3QmhBQUFCTWg0Q0ZSUUdCd01PQVNNaUppY0RMZ0UxTkQ0Q016Z0JNUkV5UGdJMU5DNENJeUlPQWhVVU1ERWVBek1ST0FFeElnNENGUlFXRnlZeUZSTWVBVE15TmpjVFBnRTFOQzRDSnpFUklpWTFORFl6TWhZVkZBWWpNUUlBUDI5VE1Ca1k5Z0VHQXdNR0FmZ1dHVEJUYno4cVN6Y2hJVGRMS2lwTE55RUJJRGRMS2t1RVlqa2ZHd0VCOWdrZkVoSWVDdlliSGpoaWhFczlWMWM5UGxaWFBRTnhNRk52UHk1VkkvNkJBZ01EQWdHQkkxTXVQMjlUTVA0Q0lEaEtLeXBLT0NBZ09Fb3FBU3BLT0NBQ05qaGpnMHMyWkNvQkFmNkJEaElTRGdGL0ttTTNTNE5qT0FIK0FWYzlQbGRYUGoxWEFBQUFBZ0NULzlrRFpnT2xBQjRBTGdBQUFUZ0JNU0lPQWhVVUZoY21NRE1USGdFek1qWTNFejRCTlRRdUFpTVJJaVkxTkRZek1oWVZPQUV4RkFZakFmMUxoR0k1SHhzQkFmWUpIeElTSGdyMkd4NDRZb1JMUFZkWFBUMVhWejBEcFRsaWhFczJaQ29CL29BT0VSRU9BWUFwWkRaTGhHSTUvZ0pXUGoxWFZ6MCtWZ0FKQUV2LzJRTzRBNmtBS0FBdEFERUFOUUE1QUQwQVFRQkZBRWtBQUFFaEtnRXhJZ1lWSEFFeEVSd0JNUlFXTXpBeU15RXdNakV5TmpVd05EVVJNRFExTkNZak1DSXhCVE1WSXpVQklUVWhOeUUxSVRjaE5TRTFJVFVoTlNFMUlUVWhOU0UxSVRVaEEzcjlFQUVCR1NRa0dRRUJBdkFCR1NRa0dRSDlaL241QWFiK1dnR21sdjNFQWp3Ri9jUUNQUDNFQWp6OXhBSTgvdFFCTFA3VUFTd0RxU1FaQVFIOHJnRUJHU1FrR1FFQkExSUJBUmtrbDVxYS9XSWxRaXBDSlVJcVFpVkNLa0lsQUFZQXF2L2lBMDBEbndBV0FEMEFTd0JZQUdzQWZnQUFBU0VpQmhVUkZCWXpJVEF5TXpJMk5UUXdNUk0wSmlNRERnRW5MZ0V4TGdFbkl3NEJCdzRCQndZbUp6QW1OellXTVI0QkZ6TStBVGMrQVJjV0JqRW5NeFVqRlNNMUl6VXpOVE1WTXhjVUJpTWlKalUwTmpNZUFSVUhGQVlqSWlZMU5EWXpPQUV4TWhZVk9BRXhOUlF3TVJRR0l5SW1OVFEyTXpnQk1USVdGUUxkL2tBdVJVVXVBY0FCQVN3L0EwSXVKUU1TRVJFMkF3b0Zld1lLQXdReUVSRVNBd2duSmxrRkNnWVVCZ29GQkZVbUp3am5BUndjSFIwY0c3NE1DUWtNREFrSkREUU1DUWtNREFrSkRBd0pDUXdNQ1FrTUE1OCtMZjBXTER3L0xBRUM1aTArL2NVUkZBSUJPd1FFQVFFRUJBUTNBUUlVRVhBL1B5Y0RCQUVCQkFNRUlqOCtjSkFjSVNFY0hSMFNDUXdNQ1FnTkFRd0lHd2tNREFrSkRBd0pPZ0VJRFEwSUNRd01DUUFBQUFRQUhmL3RBK0FEakFBMkFFWUFnd0NXQUFBQkZBWUhEZ0VIRGdFSERnRUhJelUwTmpjK0FUYytBVGMrQVRVMEppY3VBU01xQVNNaUJnY09BUWNuUGdFM1BnRXpNaFlYSGdFVkFTSUdGUlFXTXpJMk5TNEJJemdCTVNjZUFSVVVCZ2NPQVFjT0FRY1VCaFVVRmhjSEp5NEJOVHdCTlQ0Qk56NEJOejRCSnk0Qkp5WWlCdzRCQnc0QkZ3Y21OamMrQVRjK0FSY2VBUmNERGdFVkZCWXpNalkxTkNZbkxnRWpJZ1lIQStBT0RBMDRLaDhtQ0FnSUFjd0dCZ2NTREF3NkxCb2FEQXNMSVJVQkFRRVZKZzRQRWdUUkJ5d2xKbmRRUDJVbU5EUCt1aTVDUWk0dlFnRkJMK1VDQXdJREJCb1ZEeElEQVFJQ2hnSUVCUUVHQlFZYkZnMEpBd01OQ2drWERnOFhCZ2NEQTQ0R0NoSVNSelFwU0IwcE13dUVHQjh0SHlBdEFnRUhLUm9GQ3dZQ254a3ZGQlU0SVJrbUVBNGlGUXdjTEJFU0h3MFBNeVVWSnhNU0hnb0tDeEVPRGk0aEdqcGVJeVVsR2hralhEditWa0V2TGtKQ0xpOUI1QWNSQ1FnUkNCQXZIaFloQ3dVSkJRZ1BDQ1lJRFJ3UUFRSUJEUmdMREN3aEV4NE1DeElGQlFRRUVnd01JaFlYSjBZZUh6QVBEQUlLRERNbS9xc0lLQm9nTFMwZ0Jnc0ZHQjhDQVFBQUFBQUJBQmdBVVFQVkF5TUFGd0FBQ1FFR0pqMEJNQzRDSng0RE1UVTBOaGNCSGdFSEE5WCs0Z2tPck4vVUtWZmd4NG9PQ1FFZUNBRUpBWUgrMEFjSEM0RXhndUt4WFY4bkEzOEtCd2IrMlFjU0JnQUFBQUFIQUIwQU5nUHBBemdBRFFBZUFFVUFWUUJvQUhRQWh3QUFKUlFHTVNFd0pqVTBOakVoTUJZREVSUUdJeUVpSmpVUk5EWXpJVElXRlFVbUJqRU9BU3NCSWlZbkxnRUhCaFl4SGdFM1BnRXhQZ0UzTXg0QkZ4NEJGeFkyTnpBMkp3Y2lCaFVVRmpNeU5qVTBKaU00QVRFMUlnWVZGQll6TWpZMU9BRXhOQ1lqT0FFeEJ6VWpGU01WTXhVek5UTTFOeUlHRlJRV016STJOVGdCTVRRbUl6Z0JNUVBwSGZ4dUhSMERraDBwSlJQODZ4TWJHeE1ERlJNbC90c25XUVVLQmhVRkN3UUVWaVltQndNVEVCRTJCQWtHZkFVS0F3UXpFQkVUQWdnbVR3a01EQWtKREF3SkNRd01DUWtNREFtUUlSd2NJUnlwQ1EwTkNRZ05EUWhYR1FnSUdSZ0pDUUtYL2RJVUdCZ1VBaTRUSHg4VHdVQW1Bd1VFQkFNalAwQnhFUlFCQVR3RUJBRUJCQVFFT0FFQ0ZSRnhQemNOQ0FrTkRRa0lEVG9NQ1FrTURBa0pEQ0FYRnlFY0hDRUJEUWtJRFEwSUNRMEFCUUFkLzljRHd3T2xBQlFBS2dBMUFFOEFlQUFBQVJVeUZoY2VBUmNXRkFjT0FRYytBVGMrQVRNMU1TSUdCdzRCTVI0Qk16SStBamMySmljdUFTTXhEd0V1QVNjT0FURVdOamNCRGdFSERnRUhEZ01ITHdJK0F6YytBVGMrQVRjM0lnNENCdzRETVFZV01SY2VBVE00QVRFeU1ERXdQZ0kzUGdNbkxnRWpPQUVqTVFFUUNoQUhFeUFGQWc0T1gzRVRLaFlFSkJjbU9RZzZVdzBhREU1c1J5Y0pJaWN5REIwUU1qTUpFUVV3UUVGbEpnSytBeGNjSVY4OEkwZEJOaEFmRmdNUk5UazJFUmhsTmtCUEV3d2ZjSFJuRnhkTVJ6UVFMamdTRFFFQk1FMWVMMFp0UUJBVkF3Z0VBUUViS2djRkRSd0xCQk1YRmw4S0hseEREQ1FxTlJpdVJ3RUJKREV5RGpaQkpBa0xwRHNTSWhCMk1RVU9EZ09JRERRdU0zdENKMG8vTUE4Y0ZRTVhSMHRFRlJ0aUxqVXhCaTFJWW1NYkhHRmdSaElMTkFzRktraGZORStQY0VzTEFnRUFBQUFBQVFBQUFBRUFBQ1VFUzNWZkR6ejFBQXNFQUFBQUFBRFVHbkhTQUFBQUFOUWFjZEwvL2YvQUJBY0R3UUFBQUFnQUFnQUFBQUFBQUFBQkFBQUR3UC9BQUFBRUFQLzkvL2tFQndBQkFBQUFBQUFBQUFBQUFBQUFBQUFBekFRQUFBQUFBQUFBQUFBQUFBSUFBQUFFQUFBRkJBQUFBQVFBQUFBRUFBQXdCQUFBQ3dRQUFDSUVBQUFnQkFBQUFBUUFBQVFFQUFBQUJBQUFBQVFBQURNRUFBQXpCQUFBU3dRQUFBQUVBQUNVQkFBQUFBUUFBQUFFQUFEcUJBQUFKd1FBQUJzRUFBQlZCQUFBQUFRQUFBVUVBQUJkQkFBQVlnUUFBR0lFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFGZ0VBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFCUkFRQUFBQUVBQUFBQkFBQUFBUUFBQUlFQUFFQ0JBQUFlUVFBQUFBRUFBQUFCQUFBMVFRQUFOVUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBRlFRQUFGOEVBQUJmQkFBQWlRUUFBSmNFQUFBSEJBQUFCd1FBQUFBRUFBQUFCQUFBQUFRQUFKc0VBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQU5CQUFBQUFRQUFBQUVBQUFhQkFBQUd3UUFBQUFFQUFBRUJBQUFBQVFBQUFBRUFBQUFCQUFCRkFRQUFBQUVBQUFhQkFBQUFBUUFBSFFFQUFBQUJBQUFBQVFBQUZrRUFBQUFCQUFBQUFRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFBQUVBQUFIQkFBQUFBUUFBQUFFQUFCUUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFRQUFJb0VBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQWdRQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFBQVFBQUFRRUFBQXpCQUFBTXdRQUFETUVBQUFVQkFBQUJBUUFBQk1FQUFBQUJBQUFBQVFBQURvRUFBQlZCQUFBT2dRQUFEb0VBQUE2QkFBQU9nUUFBRG9FQUFBNkJBQUFBQVFBQUFnRUFBQUNCQUFBQUFRQUFBUUVBQUFBQkFBQUFBUUFBQUFFQUFBQUJBQUFNQVFBQUZJRUFBQUFCQUFBQUFRQUFIRUVBQUJVQkFBQUFBUUFBQUFFQUFBaUJBQUFIQVFBQUs4RUFQLzlCQUFBQUFRQUFBQUVBQUFEQkFBQUlnUUFBRElFQUFBakJBQUFnd1FBQUQwRUFBQXhCQUFBTVFRQUFCd0VBQUF6QkFBQUFBUUFBRVVFQUFCREJBQUFUQVFBQUVvRUFBQWdCQUFBVndRQUFCc0VBQUFnQkFBQUZ3UUFBQm9FQUFBWEJBQUF1QVFBQU5RRUFBQ1dCQUFBa3dRQUFFc0VBQUNxQkFBQUhRUUFBQmdFQUFBZEJBQUFIUUFBQUFBQUNnQVVBQjRBV2dDOEFOUUJBZ0dPQWNRQ0JnSmFBc29ES2dOV0E1QUVJQVNRQk40RlFBV1VCZWdHWkFhc0Ixd0hnQWUrQ0JnSWJBakNDUklLSEFwK0N0SUxlZ3dPREVvTWdBeWVEUFFOUWcxNkRmd09sQTY2RUJ3UW1CRVVFY0FTQUJJK0VuNFN2Qkw2RXpvVGVoTzZGQzRVb0JVU0ZZUVZ1QlhzRmlBV1ZCWndGbzRXcWhiRUY1NFlqaGpRR093WkhoazZHWEFadWhud0dob2FSQnFBR3J3YkxodTZIRkljNmgzV0hoZ2VqaDYwSDA0Z1ZDQ1dJUVloWUNIR0l5d2piaVFVSkk0azVDVm1KYzRtU0NmR0tDb29qaWpRS1RRcGhpbkNLZ1FxaGlyV0t5NHJ1aXY0TEVBc2RpMDhMZ2d1L0MvZU1SQXlrak1PTTJZME9EVUlOWDQybERjY09GSTRsamtzT1lRNlhqdUNQRFE4aEQyUVBvQS9Ya0VDUWxSRCtFV2tSdVJJTWttYVM4Sk95RStTVUVCUXNsRUVVVjVSOEZKNFUvNVVjRlRPVldwV2RsYXdWeHBZQ2xqV1dYNVo1RnBDV29oYTFGdUNYQ0pkK21EUVlRQmhpbUp3WXM1akltT0VaQWhraG1Xc1puNW00bWhhYU5CcHJHc0dhMlJyaEd3MGJKQnRFbTFTYmJadVdHOHliMXh3Qm5DdUFBQUFBUUFBQU13Q1N3QVdBQUFBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNEFyZ0FCQUFBQUFBQUJBQW9BQUFBQkFBQUFBQUFDQUFjQWV3QUJBQUFBQUFBREFBb0FQd0FCQUFBQUFBQUVBQW9Ba0FBQkFBQUFBQUFGQUFzQUhnQUJBQUFBQUFBR0FBb0FYUUFCQUFBQUFBQUtBQm9BcmdBREFBRUVDUUFCQUJRQUNnQURBQUVFQ1FBQ0FBNEFnZ0FEQUFFRUNRQURBQlFBU1FBREFBRUVDUUFFQUJRQW1nQURBQUVFQ1FBRkFCWUFLUUFEQUFFRUNRQUdBQlFBWndBREFBRUVDUUFLQURRQXlHeGxaMjh0YVdOdmJuTUFiQUJsQUdjQWJ3QXRBR2tBWXdCdkFHNEFjMVpsY25OcGIyNGdNUzR3QUZZQVpRQnlBSE1BYVFCdkFHNEFJQUF4QUM0QU1HeGxaMjh0YVdOdmJuTUFiQUJsQUdjQWJ3QXRBR2tBWXdCdkFHNEFjMnhsWjI4dGFXTnZibk1BYkFCbEFHY0Fid0F0QUdrQVl3QnZBRzRBYzFKbFozVnNZWElBVWdCbEFHY0FkUUJzQUdFQWNteGxaMjh0YVdOdmJuTUFiQUJsQUdjQWJ3QXRBR2tBWXdCdkFHNEFjMFp2Ym5RZ1oyVnVaWEpoZEdWa0lHSjVJRWxqYjAxdmIyNHVBRVlBYndCdUFIUUFJQUJuQUdVQWJnQmxBSElBWVFCMEFHVUFaQUFnQUdJQWVRQWdBRWtBWXdCdkFFMEFid0J2QUc0QUxnQUFBQU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBPVwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zdHlsZXMvZm9udHMvbGVnby1pY29ucy50dGZcbi8vIG1vZHVsZSBpZCA9IDI0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJhc3NldHMvbGVnby1pY29ucy5zdmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy9mb250cy9sZWdvLWljb25zLnN2Z1xuLy8gbW9kdWxlIGlkID0gMjQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmFwcGxpY2F0aW9uL2ZvbnQtd29mZjtiYXNlNjQsZDA5R1JnQUJBQUFBQUcwTUFCRUFBQUFBdVNRQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJHUmxSTkFBQUJnQUFBQUJ3QUFBQWNhZ1h4ZGtkRVJVWUFBQUdjQUFBQUhRQUFBQjRBSndEdVQxTXZNZ0FBQWJ3QUFBQlRBQUFBWUVteVFoUmpiV0Z3QUFBQ0VBQUFBWUVBQUFIUzVibENBbU4yZENBQUFBT1VBQUFBS2dBQUFDb050QWUxWm5CbmJRQUFBOEFBQUFHeEFBQUNaVk8wTDZkbllYTndBQUFGZEFBQUFBZ0FBQUFJQUFBQUVHZHNlV1lBQUFWOEFBQmVjQUFBcE16TklTK0thR1ZoWkFBQVkrd0FBQUEyQUFBQU52c1FpSzFvYUdWaEFBQmtKQUFBQUI4QUFBQWtFZG9GMW1odGRIZ0FBR1JFQUFBQ2Z3QUFBNkRXM1NzOWJHOWpZUUFBWnNRQUFBSEhBQUFCMGhLQTZlcHRZWGh3QUFCb2pBQUFBQ0FBQUFBZ0FnUUJpbTVoYldVQUFHaXNBQUFCMXdBQUJKWlA4cDFsY0c5emRBQUFhb1FBQUFIbUFBQUN5Sm1TL0Exd2NtVndBQUJzYkFBQUFKWUFBQURXYmNFdlZYZGxZbVlBQUcwRUFBQUFCZ0FBQUFZcHhGaCtBQUFBQVFBQUFBRFVVYlZxQUFBQUFNRVFZY2dBQUFBQTFLUGFRM2phWTJCa1lHRGdBV0l4SUdaaVlBVEM1MERNQXVZeEFBQU5pd0VXQUFBQWVOcGpZR1pXWTV6QXdNckF3anFMMVppQmdWRWFRak5mWkVoalltQmdBR0VJV01EQW9PL0F3T0FGNDN2NEtDZ3dPREFvL0daaVMvdVh4c0RBdlk2bERpZzhHU1RIdW9hakRFZ3BNREFDQUJhckRFY0FlTnBqWUdCZ1pvQmdHUVpHQmhBNEErUXhndmtzREJ1QXRBYURBcERGd1ZESDhKOHhtTEdDNlJqVEhRVXVCUkVGS1FVNUJTVUZOUVY5QlN1RmVJVTFpa3FxZjM0ei9mOFAxS0hBc0lBeENLcVNRVUZBUVVKQkJxclNFcTZTOGYvLy80Ly9IL3BmOE4vbjcvKy9yeDRjZjNEb3dmNEgreDdzZnJEandZWUh5eDgwUHpDL2YraldTOWFuVUZjUkJSalpHT0RLR1ptQUJCTzZBcUJYV1ZqWjJEazR1Ymg1ZVBuNEJRU0ZoRVZFeGNRbEpLV2taV1RsNUJVVWxaUlZWTlhVTlRTMXRIVjA5ZlFOREkyTVRVek56QzBzcmF4dGJPM3NIUnlkbkYxYzNkdzlQTDI4Zlh6OS9BTUNnNEpEUXNQQ0l5S2pvbU5pNCtJVEVobmEyanU3SjgrWXQzalJrbVZMbDY5Y3ZXck4ydlhyTm16Y3ZIWEx0aDNiOSt6ZXU0K2hLQ1UxODI3RndvTHNKMlZaREIyekdJb1pHTkxMd2E3THFXRllzYXN4T1EvRXpxMjlsOVRVT3YzUTRhdlhidDIrZm1Nbnc4RWpESThmUEh6Mm5LSHk1aDJHbHA3bTNxNytDUlA3cGs1am1ESm43bXlHbzhjS2dacXFnQmdBaDBXSWZBQUFBQUFFQS9BRml3QjRBS1lBTkFCTEFGb0FhUUNJQUpZQXBBQVBBR2tBV2dCcEFGWUFmUUJsQUVRRkVRQUFlTnBkVWJ0T1cwRVEzUTBQQTRIRTJDQTUyaFN6bVpER2U2RUZDY1RWaldKa080WGxDR2szY3BHTGNRRWZRSUZFRGRxdkdhQ2hwRWliQmlFWFNIeENQaUVTTTJ1SW9qUTdPN056enBrelM4cVJxbmZwYTg5VDV5U1F3dDBHelRiOVRraTFzd0QzcE92cmpZeTBnd2RhYkdiMHluWDcvZ3NHbTlHVU8yb0E1VDF2S1E4WlRUdUJXclNuL3RIOENvYjcvQi96T3hpME5OUDAxRG9KNlNFRTVwdHhTNFB2R2MyNnl3LzZndFhoWWpBd3BKaW00aTQvcGxMK3R6VG5hc3V3dFpIUnZJTXpFZm5KTkVCVGEyMEVtdjdVSWRYemNSUkxrTXVtc1RhWW1MTCtKQlBCaGNsMFZWTzF6UGphd1YyeXMraGdneXJOZ1FmWXcxWjVEQjRPRHlZVTByY2t5aXdORWZaaXE4UUlFWk1jQ2pubDNNbitwRUQ1U0JMR3ZFbEtPK09HdFFiR2tkZkFvRFpQcy84OG0wMXRieDNDK0ZrY3dYZS9HVXM2K01pRzJoZ1JZanRpS1lBSlJFSkdWZm1HR3MrOUxBYmtVdnZQUUpTQTVmR1BmNTBJdE83WVJEeVh0WFVPTVZZSWVuN2IzUExMaXJ0V3VjNkxRbmR2cW1xbzBpbk4rMTdPdnNjRG5oNEx3MEZqd1p2UCsvNUtnZm84TEs0MGFBNEVRM28zZXYraXRlcUlxN3dYUHJJbjA3K3hXZ0FBQUFBQkFBSC8vd0FQZU5xa3ZROThXK1YxTi80ODkxN2RLOG5TL2FQL2x1MXJXYklsLzlFZkkxbFNuRnlTa0JxYTJpYUVOQTJnUWtwcFN1TTBwWXd5OERMR1VnWk9SaW5qWmVBeXhuZ1pTMWpLYUhzbGk1UXh4dEpBV1grTXRzeGpYc3A0V2NJb0wrYk5TN09NVWY1WTErODV6NVZEQWdsMG4xOC94SklsMVg2ZTg1dy8zKzg1NXprbUhCa2hoTnZpK0J6aGlVU3lWVXB5UmswUy9QODNYeFVkTHhrMW5vT25wTXJqeXc1OHVTYUpnUVdqUnZIMWd0YWw5WFJwWFNOY3pPcW05MWhiSFo5Nzc2OUdoSjhTK0pIa1FVTG9GbWVJT0lsQ0xpQTFpWkNCbXBzakE5UlVjeWFacXd0ZUVoSUc2ZzcyWVBMNUdZOUFuQU5WbDNmZWRPV3FIdTk4VmFNRFZZOUw4MVVsYm5pWVZOMFNQT1c4dzhPRFo1V0h5cUZ3VUV6RS9WcFlreExKQnl1YjNYcTZJbTlUZGVNNncrZzFscThYbnVRdk50NTdNTkNQYTduZElYUGQwbkxpSW42eW1zQ215RURkQjc5T0dLaDU0UG1NMDhjN1lXRUJ0akJZVVR1c3lLRlczYkFBVlo2dkJ1a0FxVHA5bXM5VTRaZjdpNlZDUHN3TjBIalpWd2dGUllVbTRyZTd1OWRIMHJxZWZVV3ZHT095S2h0aUxWc3hyQjJqVkE5RkhuaExKVXdtUStRUEhacllRczRoWXpSUGFpNzQzYWEvVVBPaGJNSVV2b1R3V1N0OE1ZdTU2Z3JuZksyNHdqMHdzN3A0bG11Z3RxS0lUMWNNdStCTjFjekU1alN6VUtpT09PZXBPWjR6amJucUdubmU5T2JOTmVwTWRrMVdIcWdYdkNRTEd5bmtUS2xRejdKdlVLN3dnYW9ESGh5NW1tTU4va2dIZ1I4Skw2NmxBNmFhcjdhQjZFUFJmTDdXdGhiZmJZdkF1NjM1NnZud2JpbjYrSUdyMzVraXdRRzNiSVpVTTNoQXFLcnF1dzdUZCtCeHg0VUhodkVOZkQwTXIwZjVkN21hR294bXMxbGE4d1hEOEdpdWp0THFHZ2Njb3pnNFBGeGRhMmkrbWQ2K2dYTzd3M0M4bVNMSXQzL1lYS0hWdWdiS3cvQitlRVR6N2VkNEdqdDc5VnI0Q0VpK0hDN2tpK1ZVYVFYTkIvMkYwdG1VTDRlbGNEa2NsSUx3VGpuc2tNTGlBTTNSaEQ4bEpZSUJLUkZQNFQvUWxrSzVtQklkU1VkZ0JTMFgrWVFZSERLbWQrMVY5SEJJMXhWaldqY01SYThieDVUTXprOFoxZ3VLRWt6cGlxTG8rc1JZSnFNckUvVzFnMk8vOVF0ZC83SlZNN2l2WktiaHphZjRtWXhTcVJ3eE10WTkvajZkVHVtWlhZdEt4dEIzTGVxWmljbkpDU1ZERm5XbHNzNVRWOFo2RTVuSnArQTNLY1l4WGFlandSTHFBMDl1Z1M5Ym5MOVBCa2tKOVBJcFVzc3dUUUMxcU9yU2ZNMkh1dG1XOGFGdW5vTzZDY2RibFVBaHovTE96MmdTbUVzOTRDV2I0SXdsdGVxaUEvV3lUSFQ0cnF4V0RmaXVtNzAzMDlwdHdBZmI3TGZhY3ZWVzlxeTZCcFQ3TERDcEd1L3hvYlFER3B5R29PYUhRTlNtUzZ1SDljNVlBWitYZmRXTzNQQ3dhV2d6OFZSL21oMVdXMGJ6MVRsWGZIZ1Zma0xYYXA3ODBEQmFwdCszZ29iRkRob3FGTGxFcWpoVTVzdWhEcW9XQkREVG9aNkVGRlRESkJoUWFEQVVGdUZvK0c1L3VKQktTUGgvZytNY1NpVnU2UzZCM0ZmZWtydGxZdGRZWm15QzdsRXkxbzhONVFoWlBES202QjJkeXJsQjY4Y1Q4RlRYajV6VnArOWQxTGthbFRNcnRrM09Ldnp3M3N4WWhWcTZQMnBZbDI2eFhzNzg5RFpGc2Y3Z0R1dWQvdzBIVXJtU0g1R29mRC8vVm1WYXQ3akdNNGx2WlBiL0c1ekRYY1RESFhRK1JqemdINkxraTZRbW8yVTZDbVpycmhwMHpadStIQVhKb1hObzhaSWNpTEZGcmZJZ1B3bE1wUjBlV3dqb3RGY0dJZkhhZnBlaStnTEJWaFNNNUt1R3d1aTdncTJnM0hUWTlHbW1DLzFYMGVjZktoZUNIQjhQU255NUVBNUlTV28vM1BYbWN4dmllMTZMNVhVamE0eXZwRTRqYll5dWpHL2dMblZFNzFqWisvNU5DeTgvM3U4TWdaUHJEcjFUaDRkNHdOYWwyNmhiT0Z2eUU1MzBrQXk1ajlSRVZLTTByTDQ5ViszazU4MUlyaG9TNTAxL25wclpuTW5OVmQzZ0JOeHF0UjgyNEFUWDRWU3JDanlOeXZPMXFJS1dId1hMcnlsUmZLcG9yb0ZxRHQ1MWMzRHdZaXplaTNwZzltdG0zN0RwOUptZVlWUFJURC9zdExNZGRrcUd6WWoyS09mV1BLMXgvRnpJVi9VRlFEcHB6ZXhGSlNGRkhweG9LS2p5QVg4aDd4OUtGY0d5bVJtclhZbDR1VkJNSmVLZ0U0VVN2QlcvamNxVHlkK3ZUMVl5bTF0MlRlNnFUQ2pIckV1bmQ4M3VVdlJVSVpNb2Q3V05MYU5icUZ6bjNoeXJqenhySGJBMmJMU08wcWxpajRFMmJCaDdyZk1uSjhmcXdyV1dOa0RQZm1FNXlvdVM5Y0lDZFl0SElTYjBrNXFBRWNFbEVKY0FwdVpHNmRSRkZnYXFMYkJwRVRZTjUwWmc1VVBNNTNOU1luMzNVTy95N1RHM28zL2xjanFxRzlhdE1mdm5GaGJmNWI3bHpJQW05Ukxicy9NczZySGdVbldCZEYwRVJlcHlnRWd4c21CRVVVRVpBaElmVkdrbkxXTmtpeFdPNmJzeWRJV1NtVlRDWDdSK0l2eHlsdjdqWHFYL1ZldWVweHB2TnI2bjZHT0tzb3Z0QTNSM3BmUVlSTmtJcVhGTEFkWXpWeFh0RUdxdk9oOG1HaHBrU1N1cWRMMnh5VWRIcjMwc2ZjeDZTRnEvdXZkd1k3azExSGhHenRib05vUGV3YjFLaUFBUjZ0djh6V0tXcEVDYmhzZ3cyVUpxRHJTS2xnSTFsK2ZNenJsNjFFdGF3UmFpcWlsRE1FTFR3SERUa3F2TDlyTXl2RnBWdmZNMXRZd2JWb093NFJVZ3puSW5lSnJZV2ZraXFFWlZiUUVYRkk2MGd2ZUFsYmJSWXFwVUR1ZkJtL3NMSVhRa2dVN0svQVU2OW1TcW5BVG5IcWRKZi81c2VDeUh3SnVuRXFBN3hjVFlzVEYrV09ucVY1WjlhNnl6dzZobndKZTdMbFE2TzVRTUtFSFVlblBzV0VWUGZkUFZyU3VaRENvR2R3NjNQTE5yWGI4eVFSYWxrUjk4QWVPQUhsODJkdXlwTVdsa1l2eHV4ZnF4UXJkVzlNbkttQTd4Z1oxdGhZYjRPNFhYU0RzNUg2STNCR3kwTFo2ZnI3WHp1TU4yTUJocWR1Uk14eHdHMnByRHN4UmVxenBpR1loOE5WZHJGTGRhNWNGT2FxcS96ZmFheFNHTVM3aDFLUmdvOUlTREFVZlFqenYySlJ5VmVtVlVEcFFNT1UzVHVyWFBDRVQxclpGZTZ4bStPNjJyMDVYMXZYcDlFcENIM0IrWHJVdkgxOUw5T2x2clBaWkJKNmxKV2tnSG9hYUhlUy9KUy95QXVleUhxdGRXRGw4eFZTN2FnT2FlclhLNmZlV0dLMlRkMmtxLy8vaWVyRHk2TUFjLzYrdThoeC9rZnc0SXNZMEFicWp5RW9BT1p3NWpEdXpFd1h3YjdxS25FQTRLMHRlNVc4Qm5YL1dmL1BBWVJNK01ZZHZGTS9EbFd2SUVFZEhlSEdBWGRVNUE2RWROaWEyTjk1SUlMTXFKUDVKYitwR3JLSE9LejZ6T3JsNi9ldXZHamNzRzIvRm4zVUlrN2cvRWNmRFhXVnNycWVsZGNzK2JUblhQTWp6eUxVdjJlNHJqdmVVWFQ4RFJ6dXFaa0VFZjVYOHdrZEVYRGphZTJLWGJXSTFiUE1vOUlONEwvaUZBY3FUbWhCVlhQVHpzTzhnTTJTMHo1NGtlMHdFUk9RU1BpaHQramNUY1JKSHI2ZmFyamtUTXI2SXFxemtxOHYyOVZLZnh6ZFlMc3ZWMjcwUDZvZVFlNC9GZTd2NXhQclorZFdQendrMjM4MnNic3cveS9mU2REWHAvNHpEdUU3QTV2VTk4RG15N1NHb3Q2RXZva29ITGMzVVhzNythN0VJdGs3MmdaWWlZWFRJaTVoWm1UbjZJS2FCUWZ0QW5LWjRxRDQya3M0WmVUMWRLM2FyNGZkMm9WT3J2UDVaV2IweW1LMGZaR1NVWDMrTnVGUGVSSUNEVW1uZkpkOVUwZURZVDhES01IR0p5OXR0b01neS96NCt4VDFaUXB3TmVWSEJKdG5XNjVDdUhOSTR2WVZ4enBJb2tGZWVsZURMOXdKckowVzMzUDZLbXJlMlROTDE3a3krYkZHNTduUTRLU2V1NWhUZXNpMzBIc3ZVcFhYWjhQMlpkcXNPYUROTEsxY1E0U1pLcmJmOVdqYm5uNFJDcW9uUGU3SUhBbk1xWmJYUDFzTzF6RW5renJOYUpEZUZKRHI2cGRnQVVFbXk5RU5TcW56S09VZTJGUjRGZ01HdVJOUmFrL0pvWmhFM0VlbUEvT3JIQkRQajZBRitJYVNwTkZoTmduVVNEZ0FTQVA1a2laOU5VTWM2amRocFh2emcyTVVZV0xXMU02ZWpNME9zbkRvNW45TTRPS2l2YjI1UktScmlRL21Qa3dvcTF3enB1UFd6dGNaOHpJaWswUXM5YWRzR3hqRFJDZi9hTUFSamxPTGlsRmp3REE4N2dZb21ET0w2WjFDSjRCdHlTMiszTW1SMHNNT0ZlUkFiNXpMWjhWWUU0N3N0WFl4aXBPdUFFT0wwZFRnQXdYRlVBWDJNcXZscExJTUtjRGhlQnR5V1gwandnb0RFUzRLK3lDazk0clJDU2dndy9KNHQrS2VVekl2bmVibDNPam1ZcmNiZXVUazZyV1lCY1J1Q1FvWXErMGRIS3dsdlpyTEJwM0hxaHNWbWZmdWpZYUVVMzZFOUNXZjUyMk1PYXhRWHVxUGdhaVpNTGJSeGl4bkpWQlpsS0ltZlNPVE9VcjN0a2NoYnN3c1BPcCtxSEUrbEdGMGtoTkhBUkd6VjBhSFczNEcyTE1jU3B4TUM0dkxCc0gxY1lLdVRCUllvT1VZUEZnM2tGT1FFUUJQaXdrcitZQk9Rd3dxMlp2Slp1MXRkWnEwZGxkWTk2TEYyem5sbW42cGZPWGhlOXQvUTRkd2UvYkZ0ZFYzZmVmcWUxWjdkdTNTTmJkMTI3UjFmbHF3ZnBPdjJWaW0zL280dXZjOWVLMDJBTGNiS0IxQUpMMWxDWE93TzhkNkFxdSt6dDJFSGRkS25WTnRpQUp0c2JhUVBlT2lONkFpSGNpS2FaTWtLakFFamYweEpwdW53VldFeFlER29BZ1h4ZENKSVZHdmREUk10RE5BRDh3NGRIdCtweFR5V3RwNms2ZW5qY3NqenhkRVZQcTFjT3FrSjJHN1hHZDk1bkhYL2Jlb1FlVG02WXRkcHYwcWs4VHV1VDZ6eldqbkU0ZzhqaW05eXpqdnRBajM2UDFJSzRlb2xiK3VLQTBGV05pdk0xRHA3TWRBUTV0R3pRcnRhNXVzOW1CeDQ1bnpkOTZrekk1d2NtR2JaSmVqaUhoZy9QbUs2MWhzRlFncWhoZ0dvbHNCL2ZqTFBGcTdMVDZnakNlNTZ3dlZFTTAzbndBa0dSTHdCUmcvK0F1YWQ4L29RakpTVWpockZOZis2MmJOclFWZmlmMFg1cGI3d1hJdG54N0dSRmVFYzM5SzFwOWJwR1Z0YXpvN1BHNUNpTjhQZWtaVm0zTWU4b0VibnJ4RHJSQUxYSHlYSWJ4MEVvcUxielM0ZURLQVZaa0JMRjdFS2JyV2VrS2tENHJiZW9nWENYelN5SGVsWlJPQU1PZUFtWGlCZjlTWDhnWFBBWEUwTFFIODZYNFVERVVWcVhzOGF4eWZSNWM1T1R0Ni9acGsrcjFuRkR2OWxYT2MraHZybGIxZFhSOGNhYVN3ODlhZTJyYy8wTDFQZkcxZFRhTnZMRSsvZnBCNDF0azBPb1V6MWcyLzhpcm9MVjlwRHZBTXRZc3U1cXdqVnZZOUNPVmxrQTVlcEFXMG15OWJmWjV0NW11NjVnWno1ZmJVRjl5OCswK2xVNEc2K053aURrYWVBSHRGdzFoVm1MTmxDL2NHdEhBaUdXQm03T0RBeWJMVnBONEdYbUNGb3hTTGpVWVRReTB6MXNKbncxRWc0MUdWeFhHSXdxS0dvRlNRdGoyQ2o2NFY5Q1JMd0Z4bFpNRGxCUjZwbW1LOGJHOUF5ZzBJeGhJTVJTOUoxL05qdVpNZjd1YThwWVpWZEZXRS8vRWQ3Nm9lVlFHdnZxUm1VaVF3OVg2dnJlK2hpOVc4L2tYMkkyTnMwRjZGWmhPM0VTbFp4TG1EWkM2SUt0YTB1Wm1EREx4TmdBMDJWN2RSY0RtSWpOZlJoODBkQTRzVVZCdlVPbmhud1RtQ1dFZVh5U25CYXVIRTJyYXozam82UGpnbSt3UDdBUklzK09qUUZmTkdzRWNBMmx4bXE2azcrT2NiOEVZVGpkTzFmWG1GUVJuNE5ZOFRjSURuN3BOMmdnRG5DY1hDS1l4TjhTbEpLbFkzcDZYRldYelJsYnh5dlp5Y2IyUFZ6bFlGWk9HNHVrc1U0T09WN283WTVkbk0yeUdQdE5XdUorTFh3ZGR0d0Qra294bk51N2RYdUoxTnlVRzJPcTZCcHVVbzVTRDRRaEt0R2dGTzlKcHI0NS9UbDZnV0h0VU9qZG1YN3JZTis5M002eHpNNWZLNWtPNjUvR3JPT1p6QkZkZ1gwOVJ6MzhROXhQQUxNcFpKQ2dVYlJJOHlmQW01cGozS0RhNG1YUXlIUm9WU0loZnowRnlpbTBDZW1lNDI0R3NWMTF2SnVia3JQV1ZXOXgrZEh4TElDSlorMEgzTmRHdXBkNzNmRnA0aU5kSUVWL3p2VE4xWjBzS05kOFRrUW9QaGtRU3FCSmVJYlFYUXV3cTRDRVdZSlNjYU9SbWFXWFdIODVNZkhVRWVIblJsSlNqa3p2Z3UxMDlldEd2dnpnWlV4ZkRwSVI3bVpwTitEdkpMbUJzTndkUUlCcVp3dm1ESnRJd096SVYvMUlaL09tWDdVNWJzNk1GdXBCVzN2YTFIcmNWaXQ0VndCb29ERDdZbmpBNzhib0dlN0U2Qm5VYXJIdUhud1c5NWtpbUl5ckU5LzBoVzBqQVI0SUFBQ2dRTXFIeWFnQUw5a1pEYUFvS25nOHhBMmdIZ2ZyMDluK2xWbmpxaTM2N2xmU3p1NUFTZFVoem95bmpjcEt3V2RNMHZaTHQyWkJkK2owSzlkWitwN3A1MzByMjUwakZkcS84Sm9Lbk5LUW05dyt1bGdSdG9zcVlQa2tHU0M3Z1hzZ0dwV0JlQ0Q0cmJXQkZ0VURNVmNiZUk0QWVyNTB6dXlicStyQU5mVStGTDNlNFJvd2RiV2FvQXo4dDhGK003QmZ2UStjb052Vkh1ckJLSlhRYWc2L3h0eERBTjJERjdacXhyU2FGdXBGTWJUNWFxMWRmZmdNZEtWbm9CbkRldkxGUEFKZHdjODVDdmt5NW5TS3hGY2VDZ1B3OUJYS0piL2FBMi8xK0xrOEo5ejczb09OaFVqajJkcTE5STZoQTFkSDQ0WmhyVE9Pcmsxbm5iMmIxNjJNV0RkYVR6NjRqNjUxSjduNEtPL1pvVGV1WExqOU5wMC90UEJpNkpEc3VkcDZTYmg2czg3cFV3dXZoZmJUZG5wOGU2KzF1ckh5SmZvc3ZjMk8yYUhGYS9pNDgxOUlpTVRJcHdqTHBwcWVBdk9zMU94QzBHeEc4MVVuVURPbmpISnh0b0JLeGxuK1E4TWtCc1NGRUJpN1U0MTBzckJROWdFRXpJZERXa0R5UzRtVWxvSjRBTnpmSCs0dWFtVWVvRVpvOUtGZC81L0RjVGZOamtOa2xxMTdBQVVkemxLSVVPbnM1VWx1T2ZDbXIxTGgzZGw3SDdaaWNwcExIMDVQTnQ0UStXaDZwSnZLVDNQTDYvYjVKaGR2NTljNHJ3TjIxUU9NNWs1U2l5N0ZhOU5icVBuUkxjYmhzRG1DKzhoaGVzSjA1S3M5b052SmZJM3J3YTF3UEJ4eGo0cVJHVldkaGJ4Z3pEbFE3N1BqUjE5dVNkTUhZYjg5SEJ4d0s4QkVzMCtyTzF0OGNZMkY3WGdVZEx3OW1jSjhvT1NINTMwREdhYnZZWEI2eFRJZ2xsQ3dVQ3Jud3dFK0NGOVZpaHJ2TCtScGVTZ2hkRkN0UUxSa0tpN3h5VW82UFo0ZWwyKzlibWYzNGFtclM5YlRCNTVKWit2cWsxVFFKNjE3MG5ScmUreWVtaHg1aDQrbjFVbitRSFowaysvZ0RtdTFxaDZ6bnJQY0M4L0lOTTBkbkR4MjAyMVphdER0OUx3UjhiQ1Z0WGxrNytKci9KQ3pEMkxvVjJ4OFhOVkFORm9FaGFBRlhBUHN0S3N1TkFPV3NxdktjTnd5UzduSUVzaElWdEVKMVlNMnpzSHNuWXp4TVRwc0JyU3FLNEttN3pNRk5IaU52UXhxcnRKU0FZSkpJQ0h3bkJiMEZjS0ZraDg0SkdDMFhucjlVNU9WWGRiYm0rc2RqMllxRjIzUHJEdGdmWWYrSjdlYmUvSVl3R1g5SDYxL3NuTFdwWXExVWtuU05ZcVZvOWVEbmpvWFRmNGNKd2N4SUVvKzA4UUJUbHgyQkRDWnlMUVYxczdQWVRMT2pLb3NETG1idWNZb0Q4dnlvWU1DQm9UR0drSGQxZkNRL0Q1d3JJVlFRUUMrSWlLS0tYUzMwU0xYRlE4NksyUDY1UFlyYWJxeFBUUmk3RlVvZjFSZmJoMmJjTkRydVF1NFgreDlhbnF2dGIreHUzSE85QmlWNytNZUlZc1ZldjBzazNkMjhVWHVwODQwNEt2TFNLMEw1ZDBHOHNiU1JVMmxySDdCa0pZd2g2V1NtaXF3VkkvSGhXUUw0L1JGSUdRRXhLcHdJczlqeXByWkJRdG5JSVVqN2JhdHRkRlVxYWdOSllaNlVOUU9maWtQWWo4QmYrcUlaMGNCSmRJOW85WkQ3V21xeTlZKzhLQjNSYW1WdUpPSzNNM2oxNnpoMWs1UGpnZWk2ZXlhUnUrNHJzdXFZVFMyNjN2MlZDaHQyd3Q3Y1M0K3hBZWtGMGszK1F0UzYwYXBlOWcrVVBRQjkzeXRGV3N3UEw3T2lGY0hmdWxrUnRlVE02VzVhZ2pPSUF5N0RFdTR5N0FQdEUwSzQxTkpjT0ZYTjdpVHBGMG5VVGIrNkgreGNrZ2tLNXZ0cXNPTXFOVk81N3Z3dE5vS0Q1M3FURWRudTMrQW40bTBkblJtN2VKSU5ZejVlSmZIYXlmRHdqNHRXUnhhUmJWeWFxZ01PbGRBY1loQlBveHlrWURSUTlDUm5BOXQyeWFyMlczeTlCc2IwdGFyczZwSzA4QmhldGZMRlowcjBWZmovZDBsZzdZZmc1Z2pqeHB5Yi9lYTU2ejk2VkZkai9mcTZzSnQyNllOeHZzZjQ2OXlSb0FyRkFuYmRWVnB4cGFxVTVwbnBTbkdEOENhdkdCTlhtWk5YckFtZERkMkF0TTJrUmpQQWZJditMVGlVSTRPOVFDL0JEamRuYVRYN1g5KzNDcmRQMms4WGEvREFudTd0K2xyWDdYMmNXU1MyOG5kc0FmQVdPTmU2NmJuckJlc2RUUk43eHIvL3ByME5ubDA4dW1GcSs0SEhWejhyOFh2OE9QU1BFUy9wRzN6Wm5mQjVwVmFBY00rUm05U0ZTTklPanJSWDBuK1ZKNlZJb0xBbzdxTEVJbEN3RDY0QVpyeUo4ckZja29JOGdDbWlpMFZmZTJxVHhVVlkvMldETjI2Y25sbXJHTDROd0VUUnp4cmZSV0FiWVp2cS9DL1RVSHYzdjh2cGEyTGYxbnhSLzlzb1cvaDd6TjBScGsrb3JSZjJyaXNra0VaRGkyK1NSK1g3Z011a2lBMWxTbU5qK0U2Z0swdFlBUXM4WUNleHNrU1VTVmNYaEZFSm1xY0ZvYkZET2xieDlQNnR0MlQrdWpxaTd1RnQ3aDJ0VHVpYjdWbUYvWmJxeXM2dzFneENIS0crQVFnVmNQT0xWY0Y1enhtTlZUd0d5MUxhV1pRVkJuOGhpZHZ1akFENjEycVlMWUlIMlRWYko3SmwxWlFCTEtCUkRJbVorUExLbVpjMWJOQXhMcGZtcHFlTlI3aTc1STVlYytleHY2RjlYb1VmbjlpY1lMUFNUMkF2OFpKclEydEE0bGwxUy9PTjVsWGdhVS91VGtzS05RNDUxSmdZdWxQSjhTY21oQ3gwNThDUmhkbjJPYkM0YnlmTDRkQStRdWtDRm91VXZDeElCRSt3UU9jU0JSS3l0aFpMVG9jMEtwaFk4TDZ3NTIvR0h0MFJobFRqSjdQQzFGK09LTmtqaXk4eFUyK2FZemRzZkI4cHZIUGhzSjVHNytyb0x6R0Y5L2dEa3I3U1lCc2JNckw2NXB2Smd5RGJKMHNIOCt4Zkx3SVBvdFRUUjVsSmpWVGVoS3UyZEhDRExMcTlZRitFWlVoSUZOaDhFRGpZYjJTUDZqeXdYQlhPUnpvaWhmSEo0SEZHbGtWUEpVOHJUZGVNSklBK0RmekI0enNiT1BWdzliOTFubXluazd2WnVjNXRQZzQvNVowTWNUOFMwZ3R1eFFGN0twQmJDblkwem1UejFjSDRFUUg3R1JKQkx3UUJ2RUJDdXZwN1dNa3J1b0Y5bVpHZkdZYkxOU1poVlY3NVNnVGJoazFYazJWQUpQNlEzN2d0S21oUWpFVTlHTjVGSWlNeWljNEhtVE5wUkpoVFIyZ1E0YUtpWjdzNkxiUlN2YWdQRnJabHRYVGNrV3ViS3RzQ0QyVVZ0VktWdUMyQW5aNTl2SVJVYkRXM0c3ZHdkK1ZyaGhxOTNudnZyNTFuVWMvbk9WdXBlOVlyeldNTkoyaWIvVytZaDFmV0E5N1hiNDR5ei9wWEVNeTVDWTdqakNGTmNNRjVvaFpUUW9DSG5VQ3YwM0o4elB0UEFGeTIyK0Q5aFFMZ2ZWV08rdUlkU2dlTFlrYk5sUGFqTmpTTjhDS1VUNnpsK0YyZjRMaDlsYmZvNm9XaURielJ5MWRFR3hVclgzQUJuWkFhVFhnSUNtczVZTll3b1VpWHdZWjVZT1M1cGZzMGlRbUxNT0krK0xMZFZrMkROMVk4MlNsUGltUHlySTdQNnFQcTNwN0xMM3NCdXVPa2Q2QXFnTDhXM2NkcmN2ajNIWDFpajZhTmF5WTJhZ2RlOGhSbWgxUHE5TVZhK1g3TnhqMUVaRWU1TitMV2R6c2JtdlFZSmcxQndCd2hYZ0hrUUVMckxTenJsVU5uQzdtbXFvaER6d0pvWHJ5RHBlTkN2d3M5NHhRZ0RCcWlyVzNFSko0ZE1PK3doQnc5ekFBQUFlY3FhOFEwNG9JVThMQjNNVGtMdVd6UGJURGVtSDYxODdNRVhySkJVZC8vQldGL3FyT3I4MWV2K3ZseG16alowOG8zSElyeHYzSTRHNVorSzZDSEhMMTRuR2VTQ1d3bjNieU5WSlRsbkpncHNNMmROOWNOV2czSFFSVjA0TWNYYlBScHBhcmUreG5RYlVhYWFiaTBRbjRBRlJWVlE2T3g2TlZlUVZ3WmdSVFJTNkIxVVNVWmtZSldYYXhIQzRMUVFBeVFRM09JNVVBYU9NdkVBQ2E4ZUJxMExlbjZmTEdxN29hV0paV3N4VUFsTmxYRG91YjFtMHkwbkxzVGV0MWErMzRRV3RmWlhOL1ZuanY2VFdOQjJsczRmQmhteU1NZ0x5ZmxFWkloT1RKNTJ5T1VHMlRscUtkYzM0bUUzSmdPcXlRTTFOenpUUmxkUWh6a3lrUU51Yngya0oyUGlXalBTcHIvcTV1eHA2Y0FKWnpnMHVwUGJ1WUd5UWFlSVlRSmxGRWhjYjVzcS9RWFJ5aVJjeFpBb1RFaWd2YUlCelFBTDFrV3M5VTZPalk4aDFHNysvOTRKeGRSOGFNb1hteWFQMjdybmYrU3NrbzI2YVVIaWZXTS8vMGYzQmYwYm1uNmM4eW1kYUVZdjI3dFZLM0d0YWhQNzVzYk85UlFhZDNqMWs3cGg0ZHBmV01ibDI2bm42VCs0d3hOclp3ZzczMzhHSTM5N2E0QitMSUFKa2lETnFZb1lMdGROQWFxNzJTelI3cFhMM2RQcit1ZkkyMm93SlNnRGdtVlUwUmo3bmZmaFBBVEEvWXBXd1RDNlNVN1NLeVpCZTZubXBQUDlKTHJUV09PVUVBZlZWL0NFKzVGOHQvZ3NaeXZCaUwvUEZpNld3VVdFOGhIK1FjUWRLSmlZNFdtZ2lHd1IvRndUWXgxNTRBV2hITzZHTkdScG1nc3JIcm05Yi9vdHJOeHRnWGZybzNvNHhsNHZmcU9yM0VVUGI5c2JKK1dsaG1WREtUR2QyWXRTNzgrOHpDVHk5VURBT0VmYjJ5YUozUEg5QnA5czB4WTVmMVZadFByTFhtaGM4Ni80SjBrTStTV2p0cXVJQmZ2QXdUZ2pyNDJyMm9EcnBkcExLejFyeGFsVEFEQ2tyZGljb05rSHpHSFFxM00wL2p3OG9lNXd3M2lSTndwa0xNWDJ5aHZoNmdUTUZFTURsQUJkNGZCZ3ROcnZWSDlYeVpYcHlkMWMram15ZUt2Ni8venVpWTlRL2lNY1g2eTRranBiR242SjR4N2swcTh4M0xsUWxER2Z1clJtVGgzakhybjUvV1YrUGFGeTNRNVRjY1R3S2V2ZHpXWkRzZndMNndoaXZNcUpsaWdlVVgzVmpGOFNSWXJyY0hNeVZBOCtkcmJZR2xKaDlFcnRVQVluS0hFdXBrVzBtQXBsZDlPbTZFQjNzc2xSbjBUQVJUQXJCRHJDeEp5UlFlSG5oVGtLK1U1TkwxdWxHaDAybGc5bzhFVkZrZUh4RU5XWmJqdmVQSFJoMjk2YXd1WjNWRFRXZUJIK3ZXU210SFpYelAya0Z3byt1WEdSUmlEWmRXQTNnbXBjWC93NzN1K0JacHhmcEJaQ2x1WTZiVS91Sm5nRFRLQUNrbVE2VTg1ajk5TnZYRnZCMm00bjB0c0JWZWNFVlErNEF0cVpxZFQyT3dVT3lnc0g3TTNmakxxWEsrZ3dKTEtvVS9sY0d5ZW1HajhpL2ZVSXpNNUhlc1o0NElBWHE5cnZ5Zm4xUVVaYXh4SzcrMi9wUlJOOTYveXRhZDBPSUNIeGMza3lBNXIxbnJwMHUxbWxET2RNNWhhYWFtTUJpa2VJRXNPRmxmaFJOcEFwYk9GQ2M0a2hhUU04WGVNcEYxT09VMWZ3anhNd0FpRUs4S29UbkZoWXpLd2ZYUnVqcGV5UjRiUFMrd3pmR3dZZTFyY0FlNUhYVExGQ1ZwWGMrWEd2Y3N6S1VQVXg5YjF3V0xqd29WY1NQRTJqdElyZitFMTlidFhFSTlFZW4zZXdlcUNXR2VoZDFtQmFNbGowVU16UlppMEhiZFdEdUwyZGFkYStMWHFwQWV4cEpHWFhSN1UzMU10cjZhRW1JaEYzQklKSUZaSXlUT3dFd1RyR1pqK3JXWkZuZFB5czYwWTkwakZBYWFFSlpDNEFTTEtWYUc4b0ZMMUlaU3NHay9CaXpBNnRpNGxiaGdURG1yeFZDVWx2ajBVM3BQY1pOZldmUE45YTBHQVBObDkxWXZTOTMzeUdmMUhxZkMxZXJjbTByR21uL2J5czFtOXY0cjc1dklURXhNTEd6bTJzbmlvVGNtNE9TMk4zait5cmJHb3VWMjJ2WG94ZGNYQ2I5T0dnTE9zNExVOUNYYk1XVzd6c2F4R3VlbVpxbkRqekRRNmJHaHEwT0hiMW84Zm1iZkVnRVVqZjQ4SEZoQmZRQmlSVDdvWTBVMFhteWhVb1NldC9sd1doMjhXZGIxeDY3TnV5ZG43OThaaXNqeG8vM1BUSSsvUUkvU0Y4YTVXdHJ5cVdudTFTMXErc0dGcDFYTGZNNFE2SlB4eHJQV2NabmhwZ2Y1bXlTc3BXMG1EQlJXQlloV01jYXpZMTJnVkZGY3RscW91ME5kVVRoVnQ5c3VmWGpCdmtIN0FsNzhZQUNvcWhuTDI3VVBOMUp4eXV2b282Tm80WkxJZ0dLeFVBekgvQWtlVmg5UEFaUUFLOUZDaFc1TVo4SzJ1SzRnQUtIZGRNUGw4dXhENmV4cWQvTHFkRVhWcWVkcE9JNGJ0bHhyTFR5L1ZsWXJqaTNXUGJPelU5enpjdlp0eTduMVBlN1MzWWJ4eE1MYWhSdFUyMlpZL0hYOGdMU1JrV2FlQ3lQUGpCQnRRY2ZVemtSdk41QXdzQ3R6VFJzUk1EZEZWQlE3VmpJNDNtdkRXNktsSEVuTUlROWhxanBBZzRVZU1HY3hrWExFQjdqbEdldjhFZWtZM1pySk5QN1Q0RDREUEdxaWNXdkc0SitrV1dXNm94TUNxejZSVVg3dy9ySE0zZ25GMEtmdE5YWXVIdVAyaU44aklWaXRYVHRqelZRdWNZazhoSE9JYWtqVkZjUkZ5WnE5bEpJZm9MVWpLQ1o2NHJ4ZDh3SVQ3dTQwOUFyOVIyWE0ybTlrRWsrT25YdGg1cGoxaDcvNm9mQ0VvVXpvR2YyOXQrc1Y1WSs3eG14LzNzODlLSXJFQTlKcGx2cnR2Z2JScmczSWpHMHpmZk5oZTBpY2NweVI3VjMvay9kQ0ViMWttUnNkaDdMV1BZMERsdFBnYjZaeDIwY1JCM2ViZUJoODZYQ3pwczhTWkpHbVEyVlFEanhwY0k2VnhkRng0cWJNQ05xdmw4bWUxZkN3UDB2VStFQllUSFNmVFZjQmRTMFVmZjd1a0hHc3NuZHNXcCtNWEdoOVZjbnMrRW9HSkM3ZXJRT0ZObTVwWksyVmYzenIyRWdQOHVuTU5QOWR1aUhEMWpURnpmSFhpZ1p3NWFUZGpWdVZoZm1hekpwb1pJS3BGTm5sWWdRYWFUTkxNQkIwMWNpVE5XQXFJaTlOMFpYTDlKV0hEV1A2MnJoYW1UVzR1VkcrdmZIQ3FLRlNRcDNpNXNhaHRIMldPbkU2b3VRSndOZTl4UFRrcXJ3VElEVnJ6T0U1L0IxS3JxcXlOaFlQV0FLVmJFc29Pd285SWZodHFZU2pLdzdJUW42RnUydGx1MTVYRy91c1o2NGRBWUkwR2lpcGFibloyekxwV01hWjRrMUVBQ21iUW82YWpxV1dGaWVjbW1odm9WeHlTSlBSY1RvNzZYaG4wOUFibHdNZTI3QjRDZmZYd3YrRStCSEQraGZXbUtzUk42d1BNNzQ2TEJRTHRYWEZIWEI0V1VxR0piR0puWWZDdEhYSXJ1eVJxaDVvNWdETG1KTEhyZzhJYmF3QkZ1aGRJdTRQTkF0M2NXMERXZXk3QUU2bi96SWQzYWh5MFE4bkpqSmZ2S0lsbnBtK2F5OVgvWHhGUDdMd1MrWENDQjIxT0xwaUwrOVJaaHUzSW5ZY1hIeVplMW9TUUo5MDh0c24xUzVyVGx4c0J6L1BBQWh6bnNHbGRveGFrR1hIZ240NFVpQWh6b0VQT2pOUU9PMU45eHBza2psZU00VmhNd3lNVzFTWnErMlFzWXJ1Q0VhYVJkb3k4TEVDSWlyQWlWS3lDQkdpV0ZiOTRaSy9yQ2JpZzZQanFxSGV0RGxidjlLeWdINWY1ZFozeTdkZHErKytYWHlzdHpzNzFmRFY3OWxqeVF2QTViTHlwRURlM3kxdm9EZE9VbUtmWVhEeGYzTTNPSFE0aTNPYnVRSVBISUJkb0F2WkxUOTJ2eVFZWVYyMXM4Y1l4R1VzR3ZFT241M1dRQ1dTMVNZTFdBVkFROUFBSm9YempBL0VVOG5na2VtTTlZSnlwRHFZVVk3OXh5VVordGdFM2I4d3B1alBXdjl6MTFPdmoweG5IaHc4dGdQbHZXcHhsbnRDL0IzUXFBVFpibWVVYW1FRTdFb0J5OXNNdEZPeis2UWFOMmFLQmV4RzljN1B0QW9pMEdlM2pZWjZzRE1raXQzem5lRHlNUTFVOVFYQmpibzFVOFYwQWRiQ2lUOFFqTmxpVm51d3N4clQvQmlXaTFJeXdhY1NTRmF3SnA3M2cva0ZWNUhGV2IyamMyTlFqOGRvYnBYWW9paWZuOUhyazJQS3hUc1U0d2k5bklydkZLNlpwWmVNU0dNVDcrVm9Jc3A5UTJuY1N1VnI0OXhkeXJlT3d2NkNnUEZ1RUY0allkS0YzSkxwdnBlM0pWNk44Zk4xZHpTQXBYQTNxbjA4WjRibVRuUVkybWtRcEpRSjNDNkdNQzdDNE1lakxzRWJhREorTjNZanFSb2VqQm5WekJDREpZUnhTejlMVnFxT1JGQmxmZU1GeEJ5c25iQ2tZUWRKME1qODl2WmoxZ3NUdXpJWC9ZbWlURHhsZmkxNlowdThVZzllVStmK0xFY3ZlbXJ0dm94Vit3UGRPajZCV0ozN3lzVFlSdXBRcHNHSEgxaDhqUjhScDhEYi9CYXB4WmZpVzlYUHo1dEt2cDRTNGkxZUpGM1ZGTzQxaGVZaGdCK2EwZUlzL3ZWaCtzNU01S3RCVUxZTzVOWFZIaG43bkZpYmJoQjdrN3JpVE5OU21JenFZRkNzMlZRSWtRRnNBMXZraDRxc28wU2hRV3drMFFvbDdDbDFORk0rY0pqeDFicXVUOHI2TXJyNW1KcFc2OGZTOG9QN1ZOWGFKeHNBMEdWVmY0em5LdnBNTU1KdGRlZDFWWWEzeHExWG8rdGsvYnpMcmRqVU5TRmptaDdPMnB3eXV0RE9QU2Y4TlhpRkZKa2d6R09oVHcwNllmMjVhaGVlWGk5VDBrNWJTVHRWWmphZ3BDeVAwUWZQdzUzWVRhNTVvOWl1Z0ZySlk4dTBZb05Id0pRdGNJWlZCeVp3M0szUmJqdUJBeFI3aUFGNXphOWkvdkpzV2dnVjhxMlVhV3F5ekJ4ZW5KZWl0T01JUk5rSlpYYXNybjlwelY1RnYrYVFVaHd4ZHRTc3p5dnYwcWZwUlpXeHpOaFByRjhzZkt0eG1aNzhmV1dNL29yN3R3bnJVdGQ5R2U3NVhkYktTZlFON3NWbnVCZkY5OEJMWDlYa2lNenplVkJWZ3hCSWd5eWVCRldYWFdic1pQNFBOeHUydXpaazd6eFczeERUeEp2N25lSGRiZTEyMjFuVjA0cEZFUjh6eG1BN2JsTngyVVVSUDNiUEJhVWdrR0JFeUpoSktLb1Eva0lGckx3Vnk1dzdzZ1pZbFM3clczNXlSMGpQcnZOTVB0YnJER0grVGw4dDNqblNuVlludHpaOFdUcTU4TXllOGVsdDNJUG5OYTZiSFJINzE0MktidnY4bGkrK1Rkc2RrNEE1QW5nM3B1VUViVlFLTTM1T2NRNHNkVHlLb0pIZVpvNG5ERHZCL0tnR2RML09DMDYzdjlrY29XTDd2K2J6QjdFRmcxVUtwZmp5aXA0MW5CdXk2ZlBjZW5yNTRMWmU3akc2M0ZocHZXVzlhaDNYczQ3ZURkamtEbXRaWFAvK3czU2R3MDM4Z0gvT0p6VTNsbU9DS09UV0Z0YmFJbUJiVERzeUsvUUY3Yll2RUZzZ05vSW1vVTlvQVVZMTR3bUdvN1lIUUU5SFdwaGxGRHBwSVkvdGlCZ2J0YURhbFN6NjhSSVJpTkhVdDhuNnNmUzIwTWEwdk5YYTk5QXJ4dVhPOUhoNjRhMVptZmR3cjlDZmphYWZYamkwU01ZWDN0cDByek01bXV6T3BtVVdNenlMLzhhOUoxNEltajlsWTNOTVp6TFZjTE80MFlzNUpMeHNNOU9ld25TbTNWTnVDdm1adUNObHR5T1piZXBNdGsyQk41TzJkMHZteks1Q1UxdnFIYllEUnlOeG9NRnpRTE9xQ3NFdXZ0WVlpemp1R0liSVlHdHlLVVNHV0l6RXpzOGc2YUFCV2lnSFJTbEpXWC9DQU1XTWI2TE1lOFpHSkYxWHR1MVJkTVA2UzNwUXFiU3YzR1h0VjZRa09BYUlSa3JHOGV2MmxSMmRleHUzcnFmbkFqQzJCczlXSHJNTzZVWXBxTk5ScGZLMXZzcll4Q1JaTlBnSFdaNzlOZktLOURKZ3JCVk5aQ0N4NktTd0hEc3dkUENCYUNFdEh1QXJYQXNyQzJCWHRJcEh4dGxwTmNUUFoxUHd6R1cvNU1lK3luRmRhQmVIQkVHVzlmSDR1cU82bU14N3JOdmZYbmpZZXFIZXZ0TE8zUUNYZUVCNGo2VEpqMG10NzRUbXlnWFduSTBFbDRWTWFtWnk1c0JjdmNlV2NJODZFKzVKMmRsbGJBVHB6OVZUOWpPQzZpMHNmWXBoRTd3T0VXTjNJR0s2YTJDcEdNdGFyVlM4ZllNZkRlU3FXWGd4MVkrSkg0ZkVjbDhEc0tzKzdKL0E3cHFvcjlyU05vd1Y1cHFNaVhwTXJmUnB2dFZ1aDlTaStRSlJzYTMveFBHQnRSZVFFdWY5WmFERVlQQitBTHljaG5TNHBHRVUxckIvRHM1eDdiaWh5OWV1WHI5Skg2M2N0aXk3T3FySDF1cTcwMFkwWUFBMm5WUmpGeHM2djdBeElJOVg5RmNlb2lTOWNKWDFRdGFnQm5kL3dMcTFzVjhmM1ViMzBQYkc1c2xLWmZUcFVidTJYdWQyT3BMZzUzN1hyZ09hV29HSjFKWm51R1YreWI5RmJYd1g3V1FYUmRwYzZOZE4yaFJmRTRzRVFDWmVMd3Q3cXYyaW5HZitMNENGQzRjTEJPTFZBTFdTYXJnRHMwNlNMRFpUQkNpRk1FdGxZNW9wREZCUFV4SDFhNnh6ME45ckdLcXF6OHExbUtxcTJkRnQ4Z1BkcXE2UHk3TFFXekZDa2NQcVN3ODNObHZISHpLbTlNQkdlb3lUMHhzYVQxcVhHaFdEM21YZncxdWM0L0xDWGFRRjBCNndVUGRTTncxM0V0cnpZQW1ONVVPcUluZ1hqRm1haHlVM25YWXZyWXpVenhHd1U3NXFWOTR2QmJrRTlrUDRtajJjNGhCZGZ0c3lOZm1zckI2dXhMZW9OeWFuNnB6SzNXeHRWeXVOZFhLZTI5QjRpMnVmZlM1UXdqVjFMZnlhby93eDhNSWQ1SGRJVGFSMnBSMXNpQ1VmNlZ5enJRTlQ3UzFZbzdMYi9VeC9BV05wclVWakJ1WjFuVWk1TzV2WlNZMGlRQlhZSmE4V1RMYkxyRlNrVmNVMjNFZWJndWxZTng5c3BtTzFjZ0pERFJCcEZXc2ZlRGtBL0ltR1hYOWFGL0M0Qy83dXZwUzFIeGhFUllIL2pxeklLcE5kRmJxaVRxZXN2d1JpcTFpUFdHdjF2YnNVaGJ2bEVFM1dMN2Vlc09QTWlvWDN1YXJ3SjREMzR1UlNZbE9jR05ZNVlrdmxEUkI4TlhxaWNSUExYRmcwMTVxOUQ5aEVvRVUwMzZPODdGQkN1bzBVYWs3SncwNGpodkEyNEY5S3YrZUxDRjc5cWhRdkprcWEyaVJCaUY3TEFPLzRGVFE5ZG11L01xWlVETVhJNk5mY1Y1OHc5Ti9lRGlUMWNKWit1MEp2b1lwZU1Scm5OaTZ5YmhzY0c2ZlAwM3RweWRMSTRqY0MzTVdaSTQwL0FWdUpFNEU3WDlnTCtMeHNkeTR5bjQ4UWx2SHA4Rnl6RmxMMzJZR2ZkUWVIc1p3b0JlejZ2aCtaVEFjdCtGaU1UM0ZnMk5nMGRqYmw0bmdaUmZuTzNSbERIenVtakJsbC9xRks1TUs5ZE9UckJyeGpIYlJlTzdiWFVNS2h2ZHp6TEpmMUpPaHpTRGdNM0d6VXpsZFVLWEFYR21SNWUzQzB6WEFVWnBIVGJnTmFTa3VDUjJiYXduS1JFZ1lVVUJmVEQzSk1oZkdHNVJDZlVsa1BJTWFTTU5jVlgxTTNabWV6ZEt1dVdxOVFJbSszZnJKbm5UcTBVMDNTL0VNMDhKeXFQL3VpL29EMXNtRzlhdWZaZnJLNFFCK1hDT0REeXduenhuYnZDT3YxN0hBQTYxOXFMbWlkUTlCYjk5c3A5akMyNzlrRmJBUWVZbzZsSjFqZnNZamVRMklkN3FaenVCcjBNNkNJaVpGVnRGQXE4cXU0Y0ZBdFlDNE9TN09pbEtNYUJEMXBtUmh0djExWDgzRXhmWmZxaWFwMVhZaXVGZEszQ3JkM093UHI2RUhaeDIwSENKeVB4YUppWmVFdDQ4VXA0UTE2elI0NjVXR3hKclg0SzI2RHNKRkV5SmZzZldDUFVVMWpxMjlkdWwyRGdwVllkNFNFQ2kycFZZL2QzVjd6TTRqbzk0RzRvMGhla1BJS3JBcW1ZSitkMzhjY29lYUNsM243UmhDN3U2RmlMQWRmZ3RRM2lLM0pLVVBQS0x2MENWM2ZoVXJ5MUkrNW81VnZCUFNKYWVzWDFzdDluRGE5YmNVWHcvcGtabkpoenVhMWF4Yi9uZHNzM0F5WTZpdUUzZVN3WXlUbXFBTllUYXdMak12V0JEL2pJanhvaTU4bEYvMkVOZkd3aTZYZUQ5cGhzWEtQWk4ybDFVUUZFMSttbC9VMFZEbHRLWW5OTUZiQmg2bGRUSWlLVWx4YkV6dzNvN2pXUEtXVTg1MGRtU1BMVjFiNFJzV1liS3ppTm41M01pT05WQmErZGIxSzl5emxCNFdqcElkOHU5bUxvcmt4Mk5xNmdJVU01anE4a1VLQnRValRPV1NDVFZFM080T3h5UXNMeG5hVVloM1JFbDBTK0l6RGxlaG1GU2xmcmFVelpqZDdWaldrVWxFN201S0FjR1IyRDFkNU9JMWFnSDJFRlZjUjJ3YlJPYWFBVDdHTFBUejJXM1ZRanVWWkJtZ3dQZ0JPSlpQUkFSdUJiNWxRTHV2UFZETEp2OW05UXIvMUluMFBkMTJHM3AyWitrN2pHZDVUMXpOampjdGY1WDVFMDBwbGVOM2l3cjNjeFkxL1ZteWJhVmhUM0U4ZGp3QUt6dGpNMkl3V1dFV0toUVdFd0loMlNWVU1nRC9rM0MxcUtNeThOMThDc01ES2k4Z1h3b1RISk9FUUxFMmhTWDc5UzlPWlRDWTlybVNlR2h1enJQNm4vTkd4Q2YyWHl4VERPbmdGOTEvMDZHQW1ZKzBBMW1OWW9sV3p0TEVwU2hvWERpcjJta2gyNFZadWovQTUwazF1SmpVdnFsQUNiQkpMQ0QzTVhjTWhMS2srYjZzKzFudVJ4bXI1V2xCbkJFbGgwUWxMd3dpYlBEbFdjdkpJdUluV2FIdFh3cjVNYkhaaVRXRkc5dnBERE1hN3NJelFoV0NoVHJpQTNtUkdhcGxWY1lCd0VBMFQxQjJVQnkrcURtQWJtVTlMTUxYTDdzcU1HUXJ0TU5pTlAyWENNQ29aSmZURTZrL3ZvZzE2NWZtS2NkbUJpbldjSHFZcktzYUtiUlBXRGtXWmZ2K3Z4ODQ5UlArVWUxMjB3b2F5MUhNNHgwdU9yNUJPck5Dek9odkxVclM3NW1jNlF3SlNwRmpPakxKK1p5d1pkR0gwaFlCa092RFdSd2lVeUsxRWx2cUdzUkVEbGszeHhucFB3YzR4Sm9zRTd6TktpZDRqWDc0Qnp1TXY5VXlSWHBqSmdDNVpmemhMcC9UKy84d0lVejFYYkJJQzM5Q3RoWVYvMWZWcExGVk5kNS9MSjM4NVBVMVliNDZIMnlkOWplVElOYVNXUUx2cGdCalF1WlR3cmZjR0VwaE82UVVEQ3ZTeW1rQVk2ZXJnVXU4NXVpNDNPejgzM2t3OXE5bUdYdXZySHhoZUt0dFdrMzAyaW0xbEw1cUNyeHJKREMrMVNBYUpoQmMydzZ6eEhwNFZ5czBTQW1hL1JFU3lxWVNVS3BKaVBKV2dlNjQ3My9xOVFlT3BwekpISnBVam9KUGxmTmZOU3ViTDM5MmxBN0I0eWlDTDkzNVorQlRkUWI4OHBsdEhmdlNGejAxTWcrT0RMZS9Da0ozNVYrdlBNNU1nQkJBT1JPMHhPdGczZTRLSC9CdndrSE5QejBOTUtYOTZLbUp5ckZmOGt4bUpWSEE0RkVVZmkxK0FqT1Fzci9YdC8xcjRyczFJS0dsZm5PSytMRjBJVnZ0Wm13L2F1UituZTc2ZURzUmFRUHhwM3E2NU9WaHQwR3pQczdxYWd2Y2RReURrTkxBNUpsSVVNaVZJRlV5bnI4cHJ0Z2ZxTG1Jd1NLUnM0TUR4d1JEUVdoRUlRejVZNEtRRXlMWmNCQkd2b2tNSnFaMHMvbFhxV0NiUldqazIvSit1cnhzQTJIWmxsQjh1WkRMME02cHl4TmlieVJ6aDNzLzh6Y2hCU3NaMkdaVnRkNDlaQjZ4blVjakxOaHVHZGMreGpFNTlkMmIweWpRWWoyMEhmK1Q0QStFTzZhdUFVYnZzdTNpbXN3QlJwSmtocUFmc1pvbFE4MTVwT2V6cnBLRnlKeWhEamliaFA0WCtVZDh2QjM3NE8rRTlmeHR5Ty83KytldWY3ZkJjdnNZcHJpT0xlcXQxUEM1bS8wNVVXaGVXZi9xb2kyLzc4N05zM0hobzhhdjBUdkVPTmtka2dMQ2JDeTRiRXM2RVhFaXE3VUVpTms0OE1TMEVmbjhnWENwak1zOWYxb0E3YUljdXFyamFCemJKWDFZNmhzWGVZakZSTEh6Nm5YOHRDay82ZXF3QXkwZU9jRGVJSnV3dFFiNWhXNUJkMG0wL2NXTkt4TzZJN3BOendZaWNPcEhlUjRLd2tpNDcrQUJvamNsNHRwanJPaWxiakduWW9Kc0ZlTE5McXdxQVhLc3hRTFJtd3I0enFxN2lKSUUva1M0V1VrbktFckVGVEh2ei9vQVVQREw5VXBmMWUyVTdmV3gxWHBLaHNzS0RTbm9jekFqc1hMTDZ1Yk90L2c5eXlWYnVQNDdxd3EvUDhvNHdSYlVldHJuejRvdUxWL0x2T0FWZ0d6dWFOUzdXV0NubndDRXo1cU1DK1ZCVnN3UERMdVVSZ2pFaXdqRnZjUkhzMDVtdnVaa3R1V1cwSmZjSld0L1pIQlJRVlgzb09lUWc1cGRENGRZMnZJMkVWL3pndzNiMWppK1dlWTZHYWNyblIxOG9TcHpVNDVDNkpWSXUrVVVwK1dyN2JmeHpZdVA1MnprbmphaHBhM05zSmQxSTU3TFdadEVTa2hzaTEyUzVMYU1CdnArTE5NWnZvcjBqalVQVzQ3NXMyaWRiZTU1NDVMYnI5dmRicng2WXBaZjZQSEMrTzBtU0gzVk1rUlFaeEp2NTdQYTJEeURFV1RrelBWY05nKzNuTVRXWEJqYmtDMGJhN1h4V09lUlBsc3AyVEEyWHdxR3dEejFaU0pWWVlFMkpxVVFTVzN1U2ZqRWM4aGZoK2M3dTY1YTc0OXZhMDluMjlldW11L1hOZzZPYlZvNnZ2Q0VRSFYyMmRsSmRuYjJpV3pYZUd0bDlJS1pQWFhWRkw5MXl4M1BUMUtkbjAyOWNJN3ZiYWNUWWQ5Y2U2L0hicmJkSHI3MTluVnNlZWpNbXk3ejhYTzFoZXU5NUx3WEF4eXkrdlhnZjk2TGpFT21uRWJ1RGg5VW1XZDZ1M3RiYUtYcFpPNU9aeEdQcmNzN1hBeHErWnFxRmFnRFZkNERSZDkzV1ZGMDF3OGpaazE2U1BwRjZDdHZmcVBsYU9NbmFuSUhkMTVLc2tKTmt0YmxrajMyYnBNVUdoaGpLL2ZscTJ1NTdYdldEZHgrMDU4UEVWSk0vVU8zUTNqV1ZBL0ROREJmai9hQW1NVDUyYSt6V2hBajBlWmpNY0x6U2dkM1A5TVF6TmlRbTJjbXdKSUNCcXFzWHpNVGJnaldMVnRTbVpCYzhqV0llckxVTm5vWDdtYk9za2w1TWhkdjlyWHl4cDR5SnZwRGZwNVhDSEMreFFLUlE5aUR4RXVwV3F0aFRLb3VTbTE0aFBEUjBuaTV2bUZxMi9yejd1SDFxZXNkMjdsazVlL3NOdm1tbmIycXJRUWNGWWM4T2J2MW90SmU3ZjNQOURtQTl2ZFNkM1dRZHRtN1FQZG0wNk53VXlhWlZuNlcyLzR3bVE5SHNhSGM2SGRDWjc3b0M0dEU3MHN2c0R0YW01Z3drMW5HT0VOYStVdTdrMWRpQkhMdlM3Wm96dVR6TE8vRDVtb2ZkNnZaQUtLNjVHSFZ3a2VZRmJ4eUpWSlB3eG5XemtiamNSZ01TYjhjcC9ncWQyK3hVeDRjOExIZm1pYS9qYitTc1FTdld2bEs0aGwvTE1taldLNWhyZlpFa0JWMThnRVRCbDVjSjVyQWlnQmNpckIwb0VvSVRkdWF3N29JbEZsS05ZSDJ4RldLUnRsL3dLbHEwM1M0VitiaWVaSXFqVXJBYnZSWnh4Rk1DMXhNdmhndENUeXBjTHFWNnhNZGVwaHVpNTNYVHQxVnJydnNac05QVjJSaEg5bG1QN2FrYjlEN3IzdnUySHJoOTFIclpvaWI5MlUrUzM2ZFQxc0pLL2NtNi9zRDNyUzByM1h1c0o0WW0xZGloOTV5Qi9tMExCMUNtZEx0NEhyOWRrb2xJdkNSUFdCbk1wSVc2UTJBOUs1NDhCUmZXaERSWWZGV1dydFB4RXBOWGM4eEtUM1BveW5ZMldZQU9zUWZSM0xoeFdWN2YxSnd6d0pQNDRwUENSc2NXT0Q4WitENUduMFRPVkppM3dOUStVUHA2aCszYjJaMWZ2QkRyNjJ4MkdaWENBZzRCOEJVRVgwOGN5QU9WQUlVSE1TalpZQ2c1T3JWL0I3ZnhWU3RtM1ZsWjlnbzlObWgxUCtOWlI2K0t2ajBrSDc1dU1LMEdIamgrY1pZN1JGL2ZFN3I1dmJldVdNbHRiRHlYRm03T04vWnY1WlkxSHIrQ3J1N2ZmZkQxa2FIcDdFT1gyelZEQ0xYMEdmNmJySjY4MGo1VEVUTklWYmRqSG54M2xRZSt6ZXNmdEpPeWFuSTlaSWZ0T0I2MDdtYTNTK3laSktjVWtsUHNCdWdIaGVST3M3M1UyZW51V0JYczYrdnZkQnUvOTVuUDZKLzZsQlR1L0FyOTAvUHBTUCtBTW1IZEtpVmIvdlJYZDhHbXBDOVpoK3g0dnBPV2hHM0NnMFFGdlF2WU55RE5ZT0dFcXAzbXdtUFBoMS9ZT2IySnJqT3NIVEs5SzkxdkhleS9sMjc2OEN2Y3p0SHN6cmZsYkxzMU8yb2R6NllQNityVkgzbUZZWnJMd2NBTmZpVnBJVHJCcTRLa1VPV3d6QURzeE10bVViZ1pjV1MxR0lkUUx2RXBmMEs0M04xUFMvVEdseUtEbHdjODFtdmNBK3RWVC90UXZuSGNTUzhkdExIU0J6TXp5TWNNeHVCSkZyNHNsd3cyaDJhSTNMbzBhV0twQTdqWE0xL3JZS1N2YUt1MW5SNEI3TkdLbVZUc0NzK2JBUlVUMFBWT2U4WlRKK3ZLWkdNcFN2aVpWc3ovK1hEU2lKblY5anM5bXRUUjFZdFVxOU5YazJNSmh1NDlkdnJIN05CcWlmUlNHNnV2UVB6TlJ1SThtN3dTREFld044aGZadmNwSkYrNHBQSElmY3ZoRW12UlZHaDIyeVFYZDFvdlRML3RUTDh5dFQ1L2NTWGlUSWNDWWl6cWZIcFNmblpxOU5MZTVORm5yanltUGg5M1hyckJTZCtzODJ2cGh2Y1BOSDcyaEl6ZHg5dVd2Zkc4OC9iai9Yd2xrdFd2ZmUxR0s1czM2WFo2QjgwdjdEdmcyM2R6ZjJ6MHNDM2ZxeDJidUMyT0Y0Z0RvemxyYjhQR0M1RmxTbmt2VHZMQkhrMVM1YkVJNUxEbk9aUWQ1WER5YXBFK21SYWVjMnpmNmhPdlNUS2RsR21TYnVPdVlmbmc1YWdGZGRsRGJoQk9qTHZ3MklLMTA4RjE4WVBpLzhrWllkUmNiR1VMaXBnRnRpKzlZeFpZL3BjdkpOM1JXOTB0ZjdJeVBOS3lLZnI1MzZVL3FuNWRhUDFiM3ZzWGQ5dzF2RXhVN05reTVFWCtGZUUxMGtmdWFhS1QxbHcxREdyUXlrSnZxdzZoTnhGdWRRNWdUZFhzWTNObnFObC9tbUV6ZUdHYWhYL1cvOFZpZUVEREdNNThlekxod3FzREE5VWtrbzRleklqVVhOMTQ1YzhNK0tvNnVxOXFIOFRZV3JBek9jd21XdFZVZisvSGpLbXhnUnZXbGxoVVRaWkxINWxaVTZJbE9mdnlJMDZuTHJ4eXMwRXYxNTJlTXd5d3VVRlBad01CSjZmSDB1UHg4Y21YN0ZrMlBYUXZuUmYrQVU0bjNjd2NhNGhsUWtzelg5ek40OEE1WEROdXI2dzJxNUVyYVJtSE5TMk5JUEhoaGQxNFQ5ZGt2bEplZi8wM1BYSHI1NVZYdnJKYVRyVHpQLzNhSDNHKy8ySGQ5aFBuNTBPZld5VkwzUGVVWit3YVg1SGVUVjhWL293a3liYm1EZldZYU04ZmNjeXpLOGZBQmhJUUR4SjJWNElnenpmSGpOUmR0bC9GbThVSldOaitGcThhYVl2MzJLTXRxbUdORVdoRU9VdVRSekN4U1hxYXN6bXcvUk40WGNCaFR4N3BMaTVOSGlteHlTTVNocS9pK1hjWDFnNTkzL3Bld1IwSWRsS3k5dWFoem1BdzhOZnVVWC9MeWs1KzVnMXZiK2JwM1k5ODN4R0xDODV2LzBsNzcrK0UrTVRyWDlLZDBpNW5PT1JvOWk0ZDRvZzBTQVNJY0l6VDFRV0JlRkQzVHpReHRYelF4RVRLWVRwSmwwV1dXUWZFQ0pYZHk2ekQ4RFBreGJ1NGttQUFjN3ErMlV0SlNMTTdSWmd6U2I0NWw2Zld3aEtMTFM3N2RtRGN0cW9XbGJGdXpCUUYxV2EySER1LzBJZkZCWnN1dFdnemtqT0JvTVAwK2FxeURxSlROYk9kM2RXTXNydHlwV0tKYitaTWZXVTdaUm9PaGptL21FaEtXRFFDMUM3SDFhU2haOVUxVzdicSttNDU0dXVOREhtR1JnYXZpL1lHUnUrLytEaGRWN2ttb0crZGJ1ek85blBxOURiajhodXprMWJOR2hVcWtTM1g5VS9iOFdKMDhVMytjZUZsNEUwNzdjb1JUbkJrNlNEV29LVmpwd3JXWm1vaFZwRUpvVUdHMkw1d1RJTm13MlpuYzRaTEhxZXVlZkVLUmM2dTFXQ3l5TS91U09GVURSVjI3ak9WNGFyVGk4VFdqYmFKVTRhYVJXMi9yNnRjS0VsSURWTkRnR2xGdmptdmdVMXJHSjJteHJUK2hoNVJ4OVBkc2Y2UlpOb3cwbkpKMzNuL0xQY2FmVjUzbHhvN0VSY3VYOGNmRjdpZERXZmRxR3pOMHB2MWg5Zyt0OUpYeUFLM0QrTFhJTUgwT3lmTTR6K2MrOVFjM3drTW92bGdENExpeEtWSUNRRTdMS2FTVy9QckF0RmxlVzU5c2x2ZXZGV09zSi83MXNKYnZBRlJUd1VKSWpTaHpoUHpIcnduSmlDZ3FpMlZIOHBCdS9Ed0ZpczhURFpyRG8zdGN2NG11WmZtOTZqNmc5WmhBMEF0SldmVEd1MTFMQWUwblNBMVNwdWprcnpzRHQ2bm1qa0NsL2ZFbEtZUFRVYzZXNC8xQm41WFg5bmQydUxvVnp0enVjc2F6NFJjNXdUQ3VSMFFJK0owaWw3TS81VEZpR1VZSTZxeVkvNDNDaEF6RUNBQ1MvMFJMRUxZZGNLbFdTOWkvTWxOY1hmNGQxMnUzYVhnMmE3end4ZGV4ZDFEaXdlZEE5YWpVb1IyTEZEaHkxZTRvN0NHamZSaTRTN0hldUlCMUw3SzlvUkE3TmkxSUE5ckVzV2FyRWRreklHNjJJeWdLS3luT2EwSmJ3K0xIanZUWkZjWWNCWWpUWlZ3SE45UU9RL2ZFQW0vMjJpMGMwYmplQ1ZBbjd2Y1NITnBxN0oxZlpvK0xQek1TRG9GNjc3ZG8xWmxmQm5OWGtxdk1aSWhhL2ZVdURYVm4wL1REWnNSejZ3aGc4SlJjU2VjUVR0WlFlNjIrMWdCNGRWNjJYa1lPVk05YWFnSnkrcmp3YmNKT0xnRkQ2ck5ubmF5SEJhZThKSUpZV0FtbkZqdVpGVVUwNTlqMkJ0OExXYU8wMERhejBiZ3JUWkhYcUVuYmNVT3d1cUtEaUNJaWVVc2pBMmpOU1cxbWE2ZThyTG1NWHpvNVAwbmp3V2pwOHhGa2o0OEYybE5NalVVdlMrNUx0Y3BMMXNhSUVadmpKeVY3TmJsek5yTVJWM3VEdlhhTzVXTTN0R3hJakM3UW5XWXZwNXk2YXJHbGpiMytlRzI4aDJOZnpoMTJoai9Xd01EQmV1Y2FKUzdJZjJJOWZ2YXBpL2MybC9RNHRUaGJlT2NUSjZhOENOeEU1Tm5ubHg1UXA1bU5vZjFVM1pSU1owejVYeFRxRE50cWxjZU9FbVEySUNFNlkyaGt5VlY5V09xckJXTEhtR3ROcEEraTZGQUdsdXk0SThWMElmQ0ttRmg5U1M1Q0Nma2tzN3NIZm5kOGE4OVdOVXkxaGR2b01YYkx2SGxVbzRIZk4ybDR2YkdiMFhkWStGbzZkdU5QejlWSXR6cTdiZHp2anVzUC9wN1Z5VzBFWVB4UHVYSE11cldDdExtVU1YTElSWVh5QVpTSmJYMGlWTGl5VUg1cyt6cVZ0NFdoNURIVHBzT0wydEhFOEF2ZDdBZzFJRitPWDlpSGhoZWZiaVFEcGo5K2VweWtGVUcvbVhoMWVVcVU3QlBBWlRlQ0k5NXZBSVdISzVlaUdXNklid0JWa3VYMW1OaC9leXM1cXN2VzJHc3U0Q1ZMRVNzc3c4dFl3TTA2cVNudE9xY1pqdlhtY042OXdkaG5mNkc2bGdHZFZ5eDdlZWYvdEtuajF2OW41YmI5SDY2NVV0L3ZiYS9vNk1kdk9TVlVmbHpBL1RLRTJkUkRFRVlhUFAycmVsYnI3dmFsRzIzeUgxdGJXMUYzNCtLTXYrOTF6eTk2WU5UMy8yZW82dExjSDdyTysycDYwTjgvSmRYQUZLWWtzSWhjZUh1RHludGlsUnEwTG95RXVIVzl0NXYzYTllY05HTnFaemFlY3dUb2Y5R09DNjUrSFBoaUNTeE9TMGJtamVGTzVITjlMam5XYjl3RXpnMXgwbmhLQlllek4zRE1rOE1NUEYremZkRFVRMkVPanBqckZnSEtOVVpUdGc0dTJjSVVHaVNYV2tOU3lyb0lOZEJ3L2xWbE0wd3BIaTlsZlYxY1VuNmhSSFBzczZOcmRsYzYyM1c2L05yejdsODdXVi85YWU1ZjZMY3Q3NDRjTjNJWlQvNGJYcjRMKzcrR1p1NmNvbDFhTnVLU2V1MXoyL04va3BQVzE4VGY3VkM5cGZVVVIzMGpzMFZjVzhuUHRhdFdyRDdnMDBuWTYxbXl4d09ZUk5CczBSV1RoRHhYancycG9xWXRIS0c3RFNOeis4TGgvaFRwb2hnUXpoLzhpaVJXNS9mbzU0MFNLU05OWXUvZitvNGtaMGg0WjNiVHg0bTRtTE41TysrOHNGSWtlWjZXMFJZYi90cDF4djZtUFhHenJqZUUwdmxFUVYrZEwwbkJwL2Nid1BFTXl6NHBPa245TTBtaER5eDVrbFljeHhRZnVYRW1zM09YRFVrek5jNjJUWFlUbXdsWDkwWmRkbE5YYkNYNUVmMmtqMnhseWc2dFU2ZjVudlV3WHNDM1FNbmhycDhlR3RGMXJNVGpxZndjb0ZDL1I5ektwazV2SGNRbUE3Z3ZZTnR4dDVQT3A0dG8vUndZNjUwUDE1S09KcCtkLytIemtrNHgvMS9ZYzhwY2hiZVJqMXhUbmxXbWsvWlpEL0ZRQ01RL1EvdnRJQmRaMkFwVmV4eUJwQmNWNE1obTlxTEgzZVMvT2xLTXgrM1o5L3B5alovL2trN2YrMzBaWjEzeno1cCtvMWduN3ZyQlpBQmRycjNrOUpKVWhoZ0o5enhrWDJubXljODQreEo5alV6OWFjek1KYmorOERFbWk5OGRIOC9aK2svNzlLRy9weDllNlp0M2NhU2hPKysrSUVXNzdRVGhzMjl1SytFdmVpa0YreHU2c1JlYWdNc1ExR29kM2pJYmlSWFEreUErK3dEN3JNUE9NNDJha2J6SiswVk1GdzlhMzhLQW40Uk50NkhCNjUwc2dQL29UY1VhWStsQnM3Q3lvcVlSWjEzc1lzVG9QTXp4Qk5MblZuakFmQVZzVDBYeFBLQllXT0xWSGtvUjRFdGZVUklQM2hqN1RXalJ6M1B0eXlKNlZzM2hSN1dkdzdlcVo5SlV0Y0ZubzA1di85cTkzc2JQNURWMU8zOXorOE1PVDIzTm0zZXNkeDVsUG1wczBtTjFBeTc1N0M2akorM3MrVkpWbnpEWjRNc2JLeGM4bDhsYkFySzEwcE1VS1c4QzNra2R1QWdLUmxpbzJUTmRONHNxZlV1RzVwMzVXcWxMdmJaUHZoc2wxb2ZzR2ZUckFLSmRqRlYwanRab0NscFpuRzRPakFFRWQ0QVNTNHo3SG5XZzlvUEZiK25vek13dkJ3L2xjUkpDNS9nSmo5aG9vMGovakV1ZFA5cFI5MEVMUFhPVC9hcTc2b2ZQd3duOUFqbXZIcUJoOWx6bEFiSWJjMWJ0ajRRdTQ5TlV2TGhKS1g0aWR0aUxuN2U3TTlWMjUzMjlmQlBtcXFVYVU1VnFrYnRydGRIWFpIT1JLcmZ2aXhhRlhyWjJLSjJlRC9WeTRodU5kR043VnlmT0c3cEk1enc5UE9YaGs1aGloOC9qV2xCK1FpUDVCWi90ZmdpOTYvdVRXRFJQZVRMOXFRZ3ZKTEN4c0xYSWt3UmsxaXZ3ZWtIdFNDcjFBUXh3K1lLTGszMkJqeUo0T2FpWnZkUkVHczI3UjE0NVJJNVNqZnVIeHUzSlVlWGZRMmVSekJBL1orZ01CcERCTmFPTXlxSDZ6a0VBNzkrN3hNVmdDTjliSS9Ya0ppOXg4NVRKanY1bC9iNGtiRk9OVUZsZldMa2xBbFBxWTlPZU9xRVBmcWJFNTQ2ZnBNSlQ0NDR5eTcxblhGelZSdFdmTktzcDlBanJwMUxzR0pwbnkweTdITVFKK2VkdXM5ZTB0d3N0dXBuY3RWdUFCcVpidHhncGdzaHhsbS9zUVR5VFFuTWdBUnk5cnlEajRpZ211a0ZaeEwvalVUeElVUnlacW1JcCtLUjMwQTY3bE1RQ2ZwaEppUFh3eUNqRk1uaUxaN1RhVVB1TjViRllGTVdkWkFGMDI4Yy9vRFo1UCsrUnB4U3JUdXpFRW9ubC9GK0F4RmNjM0toajFzOEgyYzN1ZDdCQ0k0MXhlQlM1dzRiQmNIcUN1R1RFMVRZOWVGbE5VVUhnMWpNZVBtUFRIU2FZZGI2aTVQbU9ybXVZdWI1OEduSE83Rys5RGZwMzdxZUl4cXNZNWw5NTg4TUxmMTIwNWR2enBJeWczbTJCcnlPWDNNRzdBc0ZJYlhaZnZuUjBWSU1yNTg4WDZyVnRxVFRqWmx5UHZPQjdTeit4K0tiM0FYdUdsR0FSVnpZN0dnS29Wd29hZGF2Y2NZMlhxb0Z1L0d3NjdzZUNlMG12dFFRaStKS05QdGRxMnFFbFpvSUd6bUtaZm9Qb2U2UExGdzVWYmVMSjIzQnVmc1VMZjcxODZlWEtVOEdZQThEcmpnUlNZUjBJcnBrbHlnZE9WTXZzTFk5d2thZE9KdHRlKzFZUWVBbHBaWFJlRWU0T1hSNkNVcCtaSVhOY3ZJQVU3emdTZXVqT2ZhUzgybW1hYjgrZkRwUkg3YjFqMS84UVhNZW9NajQ1UmViR3FoZzVPMFU1KzNPVDB4bjJwUFlIVUhxdEdYc25xdDJ5Zk9BWmxodVQydGVpT3h5MjhYNmRxM09PYnlLWUc4bHlETExyYzIyRzBjaEhPeHBvNmNkR09qcmlRY3Y1RHFWVE9OSXgybm1Cb3FXT1NIODNkaDltY3lONzA5OHpQekF6M2JQb2c0dExNN3lEZmU1SkVEV2tHK1JXZ2wzbG1ZandRczJ4R04zMG9kWnZlQlRKN1dSWVZFVGxUelVrYzlYRFhtcHgycVYzYmxpc0w5YnN2UlhqVWJnYzZ0d2crRTJiTmF0R2pnSmJ1WHFZZndMSmZzNTNpdjNManViU1NGZGdqZDZWak1abkk0RThmK3R1VkRDNldpUi96Y2NGdVhxUFQwOSt2VkYvOTBwVXJ3OVE4cWxFNW40UWNmUGEwNlJDaTNWa050d2lsVGJVdG1malhFeS9UbW0vUkY3bWxRWDV1OUR6V2xTYmFlZkpzVVF5cGxHU3EyeWtjbjFaNW9zNWJ3TFBkOTdWNTQ4WDJwcDNjK3gyVmNmclBzTTA2OVlHc25zdE5mdFAybmR2L2tVTEFZd3pqQUs2NithNk9KakptS0o1NS93amMyMU8vK0pyYjBmOHhVZnUzWWRYMHVCbDB5eDlvdFUzRFV3MDhicmFNY0RKM2FEdE5idFp4QUJUZ1BiNlQ5aFA5cUhQT2dadHZZaGhQQXhPeFRXZkFRYmNFRFNlZWRackM4eWg1MlJ5QXFxU2RobkJQYzBBUHVNRExDbW9haHJZS2twZENZUVlYT0dCajlrMEpqYTY4US9ZSVY5Q1JnU2duZ1hxVmY3SWVmbEl4MkFGWmlWSnVOMncvY0FRcWd6ZEpMeVo1WUtkenF6N0Q2OWFLVEE2YTN3dlZjL1pqQWF3YndGTzMvcGRYYitYY0QyeHo5QkE3Q04xRXdVWm1KOGUvT2lkL1BVKy8rYk9ud0tKRHJEaVhlZmdvYys1c0FkaVZOYW52RHZCcER0M0cxQ04wUWkzYjZGeHE2S1JPd3lseDNRVzFtQnJ2ekJaUU0vZUVhL2lEMzNDazFHMWgrWVRxZXo2ZkgwNDFmdEc2a0hvc3Z2cXk5VGpYMVhVSm5lTkpoTlc2OXVwMXUyUFA2NDljUm9rZzYrTnlqTEg5aFRjdzVlaWx4a1M5Tk1GYzRvMEJqWHZHS3J6MVhqM25remJpZnptNWZLYlpIV1BPMnNpU0drVmQzZHc1OGcySk96N21lUWEvWkVOdjFqWk5yNHdlbitua3dLWjFwSmQ0RG02RGhKbDkxczhibm03VC9Jd1BBVUVrc0dOanRaVTRkcXovQlUyWDM1NWg5YlloZWdWUHV2NDVoaHJlNFVYREpDYVRQcXF3WDVVTE1OeGZiVVp4cHpsYkpkOVFXbm0zWWxpZWltR3o4NzQ4d3J6cDdONVJ3aXJiQ1BTejg4bmF0OWlTN002Rnk3ODhUUTJOUE82SW8xWjNROWlqTzZvcm85cFF0SE5IWTBpM1JuM0FGejQ2ZWQxdlcyN2NUUE1MUkxPdXNrWG1qdll3ejIwVWV1L2ZBK09sRGZrdUN1a3gyc1p3Ym5MTEZ0UmJrTzNGYi9tYmMxME94RHFVWGIrdXd5UHR0Z29yYzVLa3ZWdW9ZL1lSRFpoOG5mYWJmYWVxcFhQOE9XeGRLcERwMjM5eTMrRGV3YjJkN2xIOXA1dFMxZXNLZUV6WFJ5Y2VkQWMzakQ2YmZhMXp6QjFTNTJoT0Mva3lkT2tWMngrdmhkbnVMSVRydkh5MDUyWTJmYTRhbGN6cDZYQlpnaURydTc4bU1uWnJFZS81UEdacG1wSE52dWFTZG45ZjMvbTV6RlZQWVR4bWM5YVN2dkowelJjdm1XbEpnanZZdFBjdytJcndGZmpKRFBFOVowWXcvL2EySFh0VEZiMThwdXlPSGY5L05oczRtcFlXTVlBWGNKeEkwdk1NNFFiVjRTTmgzWTROdGthV0ZVWVVXMXA1eUYvU3E3Z2FpeDRUdWNtT0w5dmphcUpzVGViSHAwWE1XaE83T0gzc3M2NCtzZlAyLzNLd1kzSlpEMU9ITEh1ci8rOE1LaGkxZGFhZTR1NnhWNkoxMUx5ZU9FTHI3VU9NeTNTenNBVVZ4Q21uL0NnQ3l0T3NUUHM3K0F5cnFIdUxsNnpBWVBNYnZkMXI1anlYcURZcHlORXRxMFI5MHVYNmhWYS83RnhVRFFKdVVsOElNblJ0VnprcGdxQzM1ZlFwUlN6U0gxSEM5MmoxNzgvYVVaOWFGMzdxaHhkUFFxZmZMZWkzVnFzQUgxNm1qV2l2OU1ldUNtRStQcEcrYi9hKzVhWStPNmp2TTk5N0V2TFhmMzNxWDJTZDVkN3Z2TjFWMitscUprU1ZZUzIyUmwxbEtWaEZYYUluQmR5UlZTb3k2VXdCWGF3bWxzd3cwY0ZFWWNJRkFDSlpBTlIzSFRmVkFTRURoRjY3aHVVZjhwSE1Od2d6U1EyMEN3a1B3UURFZDFKSEhaTTNQT1hlNHU5MEhITFZyLzhISkpjWGxuenB3NU0yZG12dS9hbjZ4ZXVDcStRRTR1TEo0bkR4QURvZWxiaDIvLzRqekQ4cmNDcGhOaVFRSEx5LzBDQ2xPZjVJWFBldHgybmVGYUFNejQrcmc3NkdDa0RlajRVK2o0Z2FRR0x0VENDdVp4UWowT3VLZyt4cWFEdm4wVXlKT1Z1ZmkvR296MXhDQ29icDhZQXZsRVpVRjhLbXNaKzRtVEpnc1NJbFRGelM3MmZqQlZ6YVFldCtVNWdRMkNWYVc3d0tvY3ZHSzFBN2dxM0RkRE1LdjJzVDB6R0xwS2JuVEU3Q0RQejZrQjdLYlNsSVdUWEo0TUlMK0Q3NHRSaHg4THdxNlBUZHE1ZUNVdUhvNzlnWXlUVEVhOGw5bURBcWI0N0VnSzdnN0dmZjRrQnJHbGtWTDJYbjhNQmVuYTIrM3VvNE13dTVRTFhRNy85dGM2MW5Qenp6WS9MZjA1em0vbGhGbEFsUUxNakhyUmNkMk0yekVHcVZlb3pDR1EyUWt5SnlKWmNKQUp1cTdqRll6cTUzcWllaGdMemxNbHpNTXJwT0dTbU1VN3FRck9ES1lIcHR2ZVVjdi9lTDlRL291RHpXSFFLTm10KzRjWXVzenNYSG1IMnNVRTNvRCtEcmVNQ05VTXNQSFdzaFZtRGNsZWF6QXRQcHpNMnRnZEtUV0lTUTdRUFFrK2RCdzJMdFZGY3FROXNJT3dRM3ArdWRUSEdxYndSTXh4cVlrRDMyNnpCVXNPajhiYm56SDNRdG9NODAyWkxkRE5OaVVVaEhtNG0wR1pFMVRtY0h0MzU2akEwN0M3bzFpMzNBNUl0NEFTUS94ZE5HZ0l6b2NKb0MyT3h1TUdHNUNBTHRncWRITnk0R1JEdldLUlZGc3dITUY0WVpJQkQrUkdiNWlPbW1XSGk5Z3FXdmJSVkpaWExVT21oWmhGeSswNzV5VmVycnh6RjllWDlJL3RZaVhxU3o0aTMwQmZ1Q0FjRXI3WDRRMW40WXVTMUFQYzEwakN1NFBTOWZXOStmRWtWZGhlVU5qZHBsT3MrVmgzWG5WTUdLY2FxM3JxKzZtT010UjJEbTk1UzBBdWs2cTFxblpGc2JrMDYxUjhIalMyWDcyMEs1bkxsMmFacDVtRmdqQ3dEK2ZWeTQ1ZG1yckhRT0xtdlZwdEh1ZXBwM2JpYWNsSVZMUWhicGdVaGlDbURYYk81T0F3TERWUjJIM25mZkZMaU1tWGdxbm1OaXJmcERtQ0RjQm9HT2FrQnlEMFpmajREOEMvdWRRcmtxS0Y5RWdVZTdBOTdKNUZnNm1kV0p3aGtrUDdPMHcxRDRQdzIxYUU3TVgweTNTWEgvc2kvTjBKYnlzN1V2LzhjOERFdzloaGd2RmRCczJxTE9MdkpNSEMwUEZFZ25aK0RNbHRCa3dQNjV5bStTSmc3RGc1eHlXUXJOU3QwT2NYVXkvTExyc1daTkk3TlVSWmMydlFJdWxqWU5Yc2ltODBPaDZMTGg0ZXN1UXN2Tmo0L1dITFM4OWp4QUNrOFFYY2VxZWduN3FOQXBnUXpTSDdiaWpBWmlxYXNMSDJzYjZBZ0prZVFNQXJEQkNRSlNaV0RTdXZId0VZRU1PUlllaUFlMWc4TWhRa2tGeHNoeVJjQjM5ci9RclZBZlFBUGR1aEEvRENXSkZNNE4xdEltTG5LaW1EU25LbVN1cUJDQnNoTkhwMFV1UTZxWENkckl1QllBclQwS0o2R2ZTU3lKZTVXcVo2MUpKRHRaU0hxMlZiQURNVVAzR2hPNEJaR1FxbktIbTdvcGlONDZiTnlNeG02TG5seHg2YmFXRExhbXNNb3JoYWpyZmpBOEJpQ1RPOHFiYjFUS1p6L0ZxeVMxTUpycWs5VzVvS1RRTE9SQzJoSHJDakNjWFMyUnhUVmlOZktESG90UTZGVGFIQzBpTVV4ay80TFhOaTMraW5yZ3dlNmFhVzNzVjNBM1QxMjNqS2I2eHg2N3JYUE9TbHpmMmJOOGtIMUovWWtNVzB4T3BLVUhnQjVNSmFvSUxlQkljYUhkaFVNMEg5cDRlaFJLTTNJQkZpRWF5YTFJSHExL2wxN0pXUVFXNmNpRDNTdWlmNnZZU0o4dmR3Rys3UGNrU0x0Um9UeGlGU2NOMmFFVi9wUlAzcmZpZUltNFhObTZMRDhneC9WbFlCZzhma295UStySFo1eGhDSmkySDl3TGhqU3VoNnVqY1R2eWM2NWtKbllxM3l5KzBIVWxLRkFFbm9uc2VjclZ1M0hUMS9HT3VjRituZnRsbmV3QjdyS3U5WHhTdEhaMWRkczZFUmZsZEhzMmNrd1BDdzlFWm5qOVM3SHpwVmRiemIvQjl2SzBsK1lZV2ErcHR6NTlIVVN5MnQ2L0dremEvVE5UeW5uQllzZ3BkbWxHVVRaeDRzM0w2N1Vta3FHbFlEdzhqN004Wkp3c2FzT0RmRHdLTFI1cnFBR2RuM0hqcFFQckI2YU90Sm5zSDNpb3VaMDgwdWpNWVlOeXBSZUhEemtQUXo1V1hCaDNQRERWWEVvZ3liUnNPeUx6YWJReDBTcnhCOEVnUG9VaVdZV3JaNXpVR3krYWhYSTliMHZDVTlGeUV3VUNZUW1wN0RaaEh6eExMN3dRZEl6bml2OWViaDQ0djZHNkhjcTZYakowNlNuN1NjclcvUGxZK1ZVODZaUjdReWVmdlZsVVJyUDNtUkpGNUp2ZWM4ZHRhenNuS3U4TE9OT3h1SEw0cFB0UjdUYnBEVGp2dGdmVTlzcmt1ZndieG5WbGdYR2dhc1lLclNUbnFBMzZxaGcwWUx1NjVqMHRNY0wvVE5kR1pvWkRITnhpeW1aOEFzcHN2MmZHM0dVL1BCR0VPUVRUVk1lL0JtREdMaWhBR2dnOGVSbUJyVG95QjRGMGtNaFEzb0I1bWVnUWwyUnNQWEdOTmRuRzR5QlpWS2d5YVRvWWw0bUxVSDljK2VSdURrWGVpWFBmM3BJUEM4UWJuVHhuL3VBRlJQMnJ3Q21Ib1l1d0NyM1ZIR0ZnT3d0dzJyZWQyQndVb1k3emhVRjJBNklZYm9Mc1ptZ3dXdnBteDFqWUdiM2NWQVlKR0VVSEVFTzhLVHZraDc5N0tRNUFmYkFmZFlKSExuN2Y2d2UvVDhSU3hBR29OQUpoU0N1a01iRFRCZ0RoYzBRMktBNzdIdHdJQVRmTXBuWGJUYmZDSHN2VlVSUFgwSEFJRVlUdlJCQ1p6Z1VVUmZzRURSNE9FRGUvYm5MUnYwMllFNThneC9kcDArTy9ZT0JLajNDaURsUk1Cclo2S2dkZGVkWGhZeHNBdWFDUUFyOFdEN0F3aVU1bTBRRGVkWW1CMXRWTFJBeU1iYWluRlNVZFJSdE1SMjBYcGRZRDhzUkcrM0s2ejJnVWFVWCs4Ky81L3NXREpxYTMrLytaYjBENVluNkg2T0NqbklETEJmS1M1dDNXT2drL1NieHdjMkdqVEgvU0t2dDI2N3ZlQmRGREJVRk9hRldNQ1p1Q1M2L0pLTzlZaTZQdzZSY2loYkhYeWIwWGVORC9UYmhQRStobnFxLy9hN1V4dGd1blNud2ZyZnJmd05YWC9vb0kxRHhvQVdzRnRpVFNQQStJSE5JNGpYSlZhYXFvZ2xaNFpoQXl5NVh0WmtBZXNPZDZwZXFNa0MvMkF0b0Y0VzdTNmI2cDVrNjk3UUl6SG15Skh5UUFsdlgzdCswclFsNTljWEhTdnZ4akNteUNVbVZoYlZkS3k3OGdsMitIelNsSk04eW50azZGbnpEVEV2L2xKUUJCYzllMzRUR0kzWFJVVjRtcnBpRVcvcVJXSm5HSWZ1dHdDWWRRSlhGNkV5WVRJTzRGMHQweER6K1hrSDF5NEF2clE1MWQzbVRCZ01oNmQ3K2FQbjJiVDROenBvcE1Va1RvNC8xRXNtRFR5OUpkRlFIaFdjUW9ER01GL2lhTW8rMWdLTy9YUStzN0ZPWmhETEpsVkhrSzZGdzZnRlBTWnZsbk9hdmtFSU5WZ21CY21NUlhxaWlOTVlyUVlaTlVOTlZOZHQ3dDArWURHdmUzV1ZNWmZLWWVCLzA2YlkzWDFIVlRQZDMwUkRabFZ6T2JUZExwL3NxbVc2eFIvMU5VZHg4NThBSHhIOS82VHdSd3dsRzcyb3I4djc2K0Q5dVl3TnA0S1JsY051VGs0QzVtY2pnSE96QVQ4SEVuSXFqS0ZhVlJ2eStFUVZXZTdxRWpKSitWeElwMmllRElNZ0U2dnNjRGpmaTV6SWs5VDFZZmlKSXNOOXBPZERnTXIxYUFmeUk5NlJBZnhqYzFJTmJ6RkU3UlFFTXRJRkF0bDArNE80MGJ4YVhVVlkxdEZJa0hoNGJJT0RyUEtqWXlBcXBDVzdWVDhDMmI1cTlWTFpNdEFEM3BadEFtZTE2T21SUk9xdlpOVE9SR1gzRWNFb096MnlIMHJnSEJlNEtRZERhVDdSNWZZamJSQUlIZHVaMEwweDlqYjU3K2srWEFiclFiN1YwK3BDOXkrdXRmSkY3QlJFaHZHMlJrSUlPakJGNDIxZERkbmE4MnM3RlQ3RGhXL0lpTlJQWmIvazlvY245Q2hiODZZNkZXTlZBMzIwQnJyS3B0dmtMM1dXVEFkTHI4eDE5MzJJRE4rUjJubEN5TUl0UkxwOWJEQ1l4MloyTEwxVitmNjF3Qjd6SE96eENnTjdUR1k3NFI0dkFkeGpPdk1SQVI5eFR3eEdmWHlGOTNqdEVQeFIrZmVPZmdHdDlTL2tBL2tHalc2RDROOFFYUkJSNGZ6VVBJaEpTT2JCMmYrYTNVQXM4VHBCbkhCRXdyWnlkaDBQYkhwM3RVYndZcGR4SEl5clRjV3ArZmxsakJlaURXQStrZXlpeW1TZkY0RW1DMEdaNStuaE5FK05RdElBMVU1N1NKTlh2M3hPYi8yZFhIS3RCVTY3ZnV3UTExeGZrTjhPdEh5aGYyMHQzV2k5NzJtOU5LRS9SeDc2SE5GSnlNbnhtQ1ZjNzBzMGRrZ0llY0VRdmlYZ3FFMnRXR0VqTnltQ2RLN200dWZHaXB3VDhkZGQvSm1leGMrd3hhOUhDc2k0ZlJtV3YxamEwN1grdVErLy9sMmJZN0FoUE5uVkg3VlRjeGp2M2pPU01MMzVwUElGNjc5aHo5SmU0VHRDWXhIOHhSeEVYOE5hd1JJaW40VDM0bkRiREo3OWpSa0U0SjBwUTZzSjVwYmVzRDNmak14NGJkUjV1cTQzY29pMW5rc2oxanJRdWtPclBVd25SMkFnYklJNjBIb09wcFlNeUNacmkrQk9vZHZWdVlEOVQ1Y2Q0Y2xpeVpqbkNPc0R1NkJHenFBTTZJd1M5dzFzemgvV0s5VmFHVDJyaEhHdWZFVCtFZVpvUlJvSnZzU1JOM0lWQ0RGb2JzMXlHM1RTVlB2cjBiSURTcGJSclFMVlZ0SUdQY01RREpZOHRTbUlEUXZNUkF2VEFOOVl3aC9nalNrVThhcmRFRCsxa3JxdVdHUWYwQkhWSzVBZlJFTHgzSjQ1Tk5vb3BIc3BHR2lxMXVlQUUwZ1docVYrbzYvWisrU0Y1TlBEaUduNlpvdXRDeVB1NEZtL3pDRWFyMmFGc3ZDSHd6dG1jRjVtdXFkdEpzTXE0WDNiWm95UDJEYlR0WjlIOU0rODNybXBSM1hSSE9ydGUzelJjbGF5Mkg0aXVJVTlBb0wwOVF3MTFBVnJHNmx2YTdaQjVmUmszVkhKaTkxQmlLWFJHMnI4bjJDcDdoU1Q3SC8rMzUyVUxPSUo2UzlwN3VZVCttQjBtY25YU1paclNSTU1tWXNJbnhXdlN1dlNwK2puWjRTYWRScGdTQkdLbEhqcWloV2hhQmp5REZFQUU4ZkNyaFpodENGaC9hemtjNVUyL3ZtbmtuTkZMSlFjS1h5T1Zma09jVmgrZ1ZockRCWFpMc05URUFCK0U5L2kvQ3d3aTF1M2lKaDJNRHc2clFKNEYvSFZ4RXhtOFhUVW9lVDJMNUw3OUtYVzAxSGhmL1Z6ejJ5ZUlHV3l3ajdYTGpCc3BsR2Y2MjkvN2huK3VXZTJQbFlVbmxGY1lzSzZTRC9UQzN3L2NENnRheklNd0tEVk4yMmFaR004OHRRS0ZaWkhLNTY2QTBJWGswbmVCbnlsSHRRMm9GTUE3QUwrVFdyNjhkZ3pqc1Jxb0tEcnBmL1ExNVpXWEI0WHRmL1MybExyc2Z1STdndWNmOS9EOHFyL044K3hlVnFNa2Vmd09aYlk3ZnE2eEo3RGhwV0hvVThnMmVDSWRWVUhQWU10OFVDZ3BPdUZxL1FaN3ZQUWM0MTRDdkFNSzJUQzV6dC8wOFhXK1N4NWpUd2xPYW1kendIVzByb29DMjQ1ejE4NkVKYzhESEhKTXhCeDZlemFsMVBsQjlmRXMwdExnWE1YZlJucTMxOFRCT1dhOERMaVpZNUREVWhoTjRDVkNudytJQ2ZiUFlZQmJnZWRUVjFVd0ZuYjNIaDIzVVU2L1M5L2VZM2xGaUVzRjRnVCtPNGtPdEtWanYrRFhIOUI1c1NiOHVkb3pKd1VPSldlYW9KemNxUW5CczVwc1hNQXZWRklqMzF3SGVuZk9VWXVpTzhxSHhjMDZrdEp6UXZFNUFDeEJkZjBHdEpjYUM0NzBNN2tPZTdSTEkxODZGOFp0d0p2Nk56c3NhWENHMlN0OWNMSmgxKzlpaUJIcnF2UFBVVS9QcGJUbDR5RmI1L0FXRy8vNWpYNWo2MC9SaXpYdEhCSWFJekRHUkUwbXo2b1B3SVFyMTFXeG5kRzh3QjlqTEdiNlRDWWx3WUsrakYyazZHb05TdmFDM3BNTitHZTArOGhpZTY1NStRY2piZWsvZHlqeHZuckkrVHpKQVZEejgvaTBEUDV4Q2VYVzBkYlg1TTl6T0cremw0K2dLSG5iOEhROCtOYlE4L1oxRGV6NVBPczV0WGEvTDVsdy9vcEd2OGZwVGJTT01xNXdKRUczVnFzVkJyemNOWi9yQitMZE9NM09xaWtqMEh6UVUwM0VJdlNZM1FRU3NQbGFvcmtheG1qdmtwL3R1cXAzMDNWc1kvbUNmczg2d2ZaTmRmQjZmcHZ3V1hydUtwZEhyTm95WFQrS0FSWEI4UElqbVJ6K3lZakM5V1BIWUZrNFc2MXRyZGEyNmZWRGtCTDVGSDRCNXFlTVNwM0hiem4zbVZXSmRrSlJ6WHh4dWRuUFFnZTQvVjVLOTdaTkFERzdPYmtlTFBBRlNQUmtKZ2U1SDZWSmhkaUVTbXR2MXBjV21wOTEwdXppT1hEMWlYNkVzOHMzMWlXN3FKZkZpY2p4ZVZUeTJ2Rkg3cVgxMDRWZFdER1dUdTFkdFQzZk5IdFhpc3FtV0pSZHhmMUpYZVJ2aTh5MnV2bDUrOHAwMTliblY4aXJ1VTFNZS8yM3ZvdjhRL2NQeFJmLzkzRFZybDE2Q3V0djVhZUxhNHR1ZU1mLzlXN3A0NDQ5WGVLNHRQa1Y2MXJHMHRGOGdUNVpmcWQxbnQzN2tmZlFmOVRMaW9YcVlVV2VBY3dNY2NGU1UwMklmem9idU12ZFFXM3dSNTFTb1hmdTNVYzc5T3ZTY2NzVHlDdTBsN29iTUlLV2FTQzQ3OTFsWjY0WTBaampyQkdPQ3VlUThuSUhBMy9aUHFqY2FNaEo5czhob3VST1Z1KzZaNnoyMWlLWTMyck5tVWdkbGNZN3pEajFCTGkwL0FWMUJtSzlQc3pFSVV2c0h0WlNHZG1ySUNCbjZDeDRrSVJVQk05dWZ6MG5rV01zV1hnUHhRQVUyQlJiZmdEK1U3U3cvUUl5a09sSHpVZDQwR015WU9KRU1XbmU5bnJnQnJ4NmxCaVJGZGZlanU2NTVBYjB2cFRxdWRab2NrWjQyYTd0VnlDY3pBcFIwdGpkUDlVc09XblE3dnVhSW1YSlFmckZYeU9RZCs1aklhUmhkODBLalNDenhyd1paWm1qMWlIakZ1UjRnVFlCNEhmcEpZRnh0K2FvZFk5czlWT1JkZlZLTlJ0L2VrUG8yclNUWnV3QXlXZjYrQjZHNjNmalJQOTZPRCtHei91Y3JjQUFRQUFBQUVBZzN2cnFycGZEenoxQUI4SUFBQUFBQURCRUdISUFBQUFBTlNqMmtQL0xQdXFCdjBMZUFBQUFBZ0FBZ0FBQUFBQUFIamFZMkJrWU9CZTk3c0pTRmI4MS9uN21lMHZBMUFFQmJ3QUFLbDBCOElBZU5wdGswRklWRUVZeC8venpieDFLZkVRWnJLSTFscG1HaXEwYldKbHNleEJkS3RGUEN6UlFhU0R4S0llUWlRa05rbFBVaGVSaUE1aEViSklkWkRxRUxKNHNBNUxSSWlFUklkT0d3a1ZXSFNvbmY1djNJVU9QZmp4Zi9QbW0vbG12di83WkF0eDhKRXNTWk5PTE1nR2JubnppT2gzbU5ZZG1ETVp6S29aSkJselRLNGdxZlBvTTRPNHlOZzdlZ3FqMURVZHdMUnNRVlFCY1ZsRmt3Wk95VTN5R0RIU3F3K2lWaGFvQVJ4aS9EeUo2a25jTUV2SWt3Rlp4eXJ6aEhRS05Ucks5U0UwazZDdVI1c01VQWY0TFc1L3FEUWlNb1g5c28xR2JaQXdMWWlZSUxyMENOcGxFV2QxQWEzeURmczQ3dEZCVzlSaDVtbEJqYm1IQ3pwcEM5eTd5OFdzb0VHV2JWSG1tQytIR2E4SDlUenpoUHhDdjN4Q0IrZjM4aDVubkhiYUhQT0ZkQ1YyS2E1WGF6YkpzMVdxTGlUMEJucGtHYzJTNHJsR2NFQUtPQ25qQ0V2TXJxaXNmYzMzdzVKQXpGUXg1eHY3aC9OdE9zNzRKVFJLTlJMVU91ODhicGRxLzk3UFp4N2FUVk9QakJUdFQ1WEVFTys5R2NpcXRFa2lyUEpvTUMrUU1YTVk5R3ZQZTdiSmZZeXBhNmh5bnJTd3Z0VTR6andUOUtxSzllNVZHUXlicDloV0taeG1YTml2dDVkR3pBdVJEWjUzWFpwYzNmK0ROMHQxWHRpdjFDTmxWTnFlODcyZ2ZxZTJjdjZKQ2RyZnZnLy9JTTZYUEdyZE9JekR6bzh5cktWa3VIZlVmbURkSzF6dEhmWjYrWjIrOVRzUFZ1eVhIZDFCUlcwM09VcXk1SzZ1dzJYNmVVbFM5cm56d2tIZmZPM0VDV3BJeHUwcjUwY1plaUcxMk9Pcjl3enQ1aEgvZVo3Sk5HUFI5OFI3Q2V5ZUFNcktmb0I4Qk5UbkVxTWM5N0Y1SG5ETzk2SUUvUmltRHZrOVUyTGM3Nmt5S29mSlFCWnIvbHIyUU1iOS85elh2RVYzUmNRV1BmYWlIck01ZmRYbS9nSWsyTmhIQUhqYVkyQmcwSUhDSW9adGpQdVltcGllTU5jd3IyQit3TUxETW8zbERhc1Fxd2xyRkdzUDZ6azJOcllBdGhQc1d1dzk3Rzg0NGppMmNkcHhObkR1NEh6RHBjSVZ4bldKTzQzN0VFOEV6eTVlQWQ0eVBpYStJTDRsZk5mNHhmanorUGNKbUFnY0VPUVRyQkQ4SnRRZ2RFL1lTM2llOEN1UkdwRUxvaGFpWGFMSFJEK0lXWWtWaUMwUzJ5Y3VJdDRpZmtiQ1JtS0ZwSUxrSkNrR0tUZXBlZEpLMG5FeWJESlZNa2RrVFdUbnlENlNNNUNiSXZkQjNrUCtsSUtJd2lTRko0cHBpc3VVeEpRQ2dMQkY2WTl5aWZJTmxYVXFmMVFqVlB0VW42bFpxRFdvclZFN29CNmozcVIrUkNOSVk0SW1nNmFTNWd3dEhpMExyVFN0S1ZyWHREVzBMK2lFNldycFR0SjlwZWVpdDAvZlFYK1pnWjNCSDhNdXd6OUdCY1pNeGszR3gwejRUQXBNRHBrYW1ENHlzek9iWXk1Z1BzZUN3OExGWW91bGhHV041UStyREt0NzFsYldLMno0Yk1wc3Z0azIyZjZ4bTJMdlozL013YzdoZ0dPRTR6c25GNmNtcHd2T0VzNUZMaW91RFM3M1hLTmM3N21GdUMxelYzR2Y0UDdQbzgyVHhYT0s1eCt2ZWQ1QlBndytMVDU3Zkw1aGg3NWN2bksrUnI1K3ZtVytpM3pQK2Y3d3MvRnI4RHZrOThGZkR3aVQvS2NBNForQUI0Rk1nZHVDMGdDb3hKM2RBQUFCQUFBQTZBQlVBQVFBQUFBQUFBSUFBUUFDQUJZQUFBRUFBVElBQUFBQWVOckZranRQQWxFUWhjK3lhSlFvaVkyRnNiZ2FDMDE4SUJHTnhNSkhvb2xTQ1dxOUlPSkdRSlRGeDkrd3NMQ3lOUDRTSDUyZHZUL0VNM012WWtnTXBkbnMzbS91bkh0bWRuWUJqT0FEUHJ6NElJQWIzcFk5VERLeUhFTVNENDU5ck9ISmNSeHBmRG51dzVRMzZyZ2Y0MTdXOFFDTWQraDRrSHpsT0lFYjc5N3hFSlppU2NmRFhpSzI2ZmdGbzM3TzhTdFNmdEh4RzVMK25lTjNKUHhIeTU4K3h2eG5iT0VjRGR6aUVpRXFPRVVFZzJtVU1NTTFqUlN2WlZLUkNvTTlhbXJrTXRWVjNka2hOM0hOWjRnNjVybXp3VXlWYThldnFaSG81TndWbjhkVTVsalhjdHM5b3Jyc3F0UjVkcDlSQlMyNkJUelhXNS9Gb1Zab01qN25qc0VpNjhnYjlENXJ1cXI5NVpUK05aV09xM2hheDdaZnIwbjF5di9YVjVGTXhNcFpMUEE2NjNLdWRQbVcyR1VOMitvajB6eGhmTW0xNGFZbnN3dTBia3ZyU0NlR2VxdXlwMnVxTGRIeHQzSldYYXFrUUdORFhjQitoQUxlNGx6R0hIc04xY0hnQUhsTUlhUG5BdllxdTNXZFcwUzE2ZXI5aEpvYVNkNXFuVGx4bDZqOVRvWVRDYldTZFd0b2Q1MnNRWUd6Q3VoMFJyN2xiZ3NUT0tKN1VhZGdLOXUvcHNDY2RMaXJldGxkNFRPRlZVNDVUYzV5SitPK3ErU09xWmIrNUYrTWRGYjJMOXorOGMzamd0bVFHWmw4OVJ1UXhiaU9BSGphYmM5SFRGUmhGSWJoOThBd0EwUHZWYkgzY3U4ZEJnYjdESER0dlhkUllHWVVBUWRIeFc3RVhxSXgwWlhHdGxGanI5R29DelgyRmt2VWhXdXNjYUd1WEFqYzM1MW44K1I4aXkvbkVFSHIvUEd3bi85TkUwaUVSQktKalNqc09JZ21CaWV4eEJGUEFva2trVXdLcWFTUlRnYVpaSkZORHJuazBZYTI1Tk9POW5TZ0k1M29UQmU2MG8zdTlLQW52ZWhOSC9xaW9XUGdvZ0EzaFJUaG9aaCs5R2NBQXhuRVlJYmd4VWNKcFpSaE1wUmhER2NFSXhuRmFNWXdsbkdNWndJVG1jUmtwakNWYVV4bkJqT1p4V3ptTUpkNWxJdU5ZelN5aVp2Tlh6YXhtZDNzNENBbk9DNVJiT2NERzlrbmRuR3dpd05zNVE0ZkpacERuT1FYUC9uTlVVN3prUHVjWVQ0TDJFTUZqNm5rQVk5NHpoT2U4b3hQVlBHS0Y3emtMSDUrc0plM3ZPWU5BYjd3alcwc0pNZ2lGbE5ORFllcFpRbDFoS2duekZLV3NaelByR0FsRGF4aURhdTV4aEhXc1piMWJPQXIzN25PT2M1emczZThseGh4U3F6RVNid2tTS0lrU2JLa1NLcWtTYnBrY0lHTFhPRXFkN25FWmU2eGhWT1N5UzF1UzVaa3MxTnlKRmZ5N1A3cWhycUFibUU0d2pWQlRmTnF5bEpMbjhwOUxtVnhpNGFtYVVwZGFTaGR5Z0tsVzFtb0xGSjZsUC82dkphNjZ0VjFaMVhRSHc1VlZwVFhCNnpJTUMzZHBxMHNIS3B0WGR4bVNZdW16N3FqV2VNdmJ2cVlwd0FBZU5vMXphRU93akFVQmRCMjNicHVvNENZSVFGU0ZPSWxXSDZBenN3c3FEYmhPN0Jna1BBdHJ5akN6NDBYOHVidXVlTGVqeHdmS0oraVJ6T0VKT1VycGs1RDJPRXk5dGllS2R6akJqVmNna0RsUENvNFllNzhXNjB5K0tNZzVCTTBvVGd5U29JK01BeWgzRE1xZ3RreWFrSzFaalNFZWxxYkVScUdSTXZ2YzJwdHlDQ3A3a3BjT1A4VjlqYUtxWW5Zd2cvaXVqdUpBQUFBQVZoK0tjTUFBQT09XCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy9mb250cy9Mb3ZlZGJ5dGhlS2luZy53b2ZmXG4vLyBtb2R1bGUgaWQgPSAyNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxBQUVBQUFBUkFRQUFCQUFRVEZSVFNPRC9LWlFBQUFkOEFBQUJaVTlUTHpKTGprQlBBQUFCbUFBQUFHQldSRTFZZXk2Q1RRQUFDT1FBQUFYZ1kyMWhjTDFwT3VJQUFDN0lBQUFIYm1OMmRDQXFBQUFxQUFBNUtBQUFBQVJtY0dkdGRDZ05OQUFBTmpnQUFBTG1aMkZ6Y1AvL0FBTUFBTFFJQUFBQUNHZHNlV2JPdVlWdUFBQTVMQUFBYUlSb1pHMTQ4WnpTWUFBQURzUUFBQ0FFYUdWaFpQRCt1UThBQUFFY0FBQUFObWhvWldFUldBSnJBQUFCVkFBQUFDUm9iWFI0TDN3Nmd3QUFBZmdBQUFXRWJHOWpZVEtaVENvQUFLR3dBQUFDeEcxaGVIQURnZ09QQUFBQmVBQUFBQ0J1WVcxbHZaNTRBZ0FBcEhRQUFBaG1jRzl6ZExjM0FQUUFBS3pjQUFBSEszQnlaWEJ3QUFwV0FBQTVJQUFBQUFnQUFRQUFBQUVBZzlnSHJyQmZEenoxQUJzSUFBQUFBQURCRUdISUFBQUFBTXNwQ203K212dXFCdjBMcmdBQUFBa0FBUUFBQUFBQUFBQUJBQUFMZVB1cUFFWUhOUDZhL2lzRy9RQUJBQUFBQUFBQUFBQUFBQUFBQUFBQllRQUJBQUFCWVFCVUFBUUFVd0FGQUFFQUFBQUFBQlFBQUFJQUF1WUFBd0FCQUFNRENBR1FBQVVBQ0FXYUJUTUFBQUViQlpvRk13QUFBOUVBWmdJQUFBQUNBQUFBQUFBQUFBQUFvQUFBTDBBQUFFb0FBQUFBQUFBQUFFaE1JQ0FBUUFBZyt3SUgzdnoyQUlnTGVBUldBQUFBa3dBQUFBQUZyQWgyQUFBQUlBQUFCaFFBQUFMV0FJNEZsZ0EwQTlJQWhRTXdBSlFFZ0FDTUFZWUFVQUtxQURNQ2FnQlFBOHdBU3dSZ0FGb0NPQUNZQTRJQWJ3STRBTVlEQmdDRkF1d0FBZ0hvQUVRQ3dnQW1Bd0FBUEFLRUFEd0NyZ0JDQXE0QVNnTWtBQmdDb2dCS0F3WUFKUUk0QUpZQ09BQTJBM3dBZ1FTc0FNd0VyQUJVQXRRQXdnU0FBQm9EV0FBV0F6WUFKZ01hQUNnREdnQUlBeDRBTGdKVUFBZ0RWQUFtQTBULzlRRnNBRFFDZ2dBZ0F2UUFJd01FQUV3RUtnQTBCQWdBT2dOdUFDOENxQUJBQStnQUt3THdBQmNEYmdCSUF3ai8vZ01pQURZREtnQVdCSndBVHdOUS8rZ0ROZ0E2QStnQUt3SytBQjhDdFAvK0FwUUFGZ1BBQUlZRlNBQWVBd0FBZUFMNEFGSUM0Z0F3QXI0QUZRTENBRDhDdmdBVkFqai93QUwwQUJvRERBQUtBVFlBT2dIRy8xQURHZ0FNQVRvQVRBUFdBRWdDdEFBb0FsZ0FOQUp1QUNFQzZBQTdBbllBSWdKQy83NEJxdi9JQW5ZQUp3Sk1BRUlFRGdBckFzNy8vUUxvQUM0RFJBQW9BcXdBSXdJVUFFd0NyQUFjQW13QUFBUW9BS2dHcWdIc0EzRC93QU4wLzhBREJBQWtBVHIvUGdQb0FDc0RSQUFvQlU0QWp3VFFBRDRHcWdER0Jxb0JiQUxvQUhnRlRnQ1BCTEFBOUFHR0FGQUJoZ0JRQXRZQWpnTFdBSTREYmdCSUJiWUFMd2MwLy80Q1F2KytCS1lBTkFNMkFEb0NPQURiQXI0QUZRSXFBQ1lDRkFBN0FWZ0FSQVZzQUVJRkdnQkNCZFlBT2dMVS8vMERXQUFXQTFnQUZnTllBQllEV0FBV0ExZ0FGZ2FxQWhZRFdBQVdCWXdBRmdNYUFDZ0RHdi92QXhvQUtRTWFBQ2tER2dBcEFXei9UUUZzQURRQmJQL3hBV3dBS3dNYS82OEVDUC84QTI0QUx3TnVBQzhEYmdBdkEyNEFBZ051QUM4RGJnQXZBeUlBSndNaUFEWURJZ0EyQXlJQU5nTTJBRG9DK0FBSEF2Z0FVZ0w0QUZJQytQOStBdmdBVWdMNEFGSUVuQUJTQXI0QUZRSysvK3NDdmdBVkFyNEFGUUsrQUJVQk52OCtBVGIvTEFFMi82b0JOdithQXJUL1hBSlkvN2NDV0FBMEFsZ0FOQUpZLzhBQ1dBQTBBbGdBR2dKMi84Y0NkZ0FuQW5ZQUp3SjJBQ2NDNkFBdUF1Z0FMZ0k0QUtJRXJBQlVCS3dBVkFMMEFHSUJQZ0FtQXpvQWFBR0dBSFlDMWdDT0FYb0FJd0Y2QUFRQy92LzJCS1QvMmdRZUFJQUJVQUJpQTBULzJnUlFBQ0lDT1A5Y0Fjd0FFd044QUlBRXVBQ0FBY0FBZkFLZ0FHZ0RnZ0JpQkhJQTlnUnlBTllCdkFBNEFUWUFPZ1NVQUdBQ29BQm9BMjRBTGdSZ0FGb0NhZ0FPQXdZQVNnR0FBR2dDT0FBM0F6Yi8zQUtBQUNnQ0dBQVNBeHdBWkFMTUFCZ0NvQUJ3QXdZQWhBRmNBSEFEV0FBV0ExZ0FGZ05ZQUJZRmpBQVdBeG9BS0FNYUFDZ0RHZ0FvQXhvQUtBTWFBQWdER3YvTEF4NEFMZ01lQUM0REhnQXVBeDRBTGdOVUFDWURIZ0F1QTFRQUpnTlVBQ1lEVkFBbUEwVC85UUZzQURRQmJBQTBBV3ovNFFGc0FEUUJiQUEwQW9JQUlBTDBBQ01EQkFCTUF3UUFUQU1FQUV3REJBQk1CQWdBT2dRSUFEb0VDQUE2QTI0QUx3TnVBQzhEYmdBdkEyNEFMd0x3QUJjQzhBQVhBdkFBRndOdUFFZ0RiZ0JGQTI0QVNBTnVBRWdEQ1AvK0F3ai8vZ01pQURZRElnQTJBeUlBTmdNaUFEWURJZ0EyQXlMLzRnU2NBRThFbkFCUEJKd0FUd1NjQUU4RE5nQTZBK2dBS3dNMkFEb0Q2QUFyQXZnQVVnTDRBRklDK0FCU0JKd0FVZ0srQUJVQ3ZnQVZBcjRBRlFLK0FCVUVTQUEvQXNJQVB3SytBQlVDdmdBVkFyNEFGUUsrQUJVQ3ZnQVZBdlFBR2dMMEFCb0M5QUFhQXZRQUdnTU0vNjBEREFBS0FUYi95QUUyLzZJQk5nQWpBVGIrbWdIRy8xQURHZ0FNQVRyLzJ3SUFBRXdCT2dBVkFyb0FUQUswQUNnQ3RBQVJBclFBS0FLMEFDZ0NXQUFiQWxnQUJ3SllBRE1DV0FBSUFuWUFJZ0oyQUEwQ2RnQWlBa0wvdmdKQy83NENRdisrQWtML3ZnTXcvOGdCcXYvSUFuWUFKd0oyQUJVQ2RnQW5BbllBSndKMkFDY0Nkdjg4QkE0QUt3UU9BQ3NFRGdBckJBNEFLd0xvQUM0QzZBQXVBMFFBS0FORUFDZ0FBQUZoQVFGTFJBRkxBVXRFU3dFQlN3RkxURHNCSGdFQk96c0JTd0VCU3dGTE96TUJPMHRMQVFFQlJBRXJTd0UzQVI1TVRFeExBVXNCUkFFQlMwc0JSQUVCQVVzdlMwUkxBVXM3QVFGTEFVUXpSRGM3U3dFQk8wczdTMFJMUzBzbUFRRUJTMHNCQVV0TFMwc0JBUUZMQVFFQkFRRkxTenNCQVFFQlMwc0JBUUZMU3dFQkFRRUJBUUVCUzB0TFMwdExBUUVCQVV3QlMwdExTMHRMUzB0TFN3RkxTMHRMUzB0TFMwdExTMHNCQVFFQkFRRUJBUUVCQVV0TFMwdExTd0VCUkFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFN0FRRUJFQUUzQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFBQUFBQUFCQUFFQkFRRUJBQXdBK0FqL0FBZ0FEUC83QUFrQURmLzdBQW9BRC8vNkFBc0FFUC82QUF3QUV2LzVBQTBBRS8vNEFBNEFGZi80QUE4QUZ2LzNBQkFBRi8vM0FCRUFHZi8yQUJJQUd2LzJBQk1BSFAvMUFCUUFIZi8xQUJVQUgvLzBBQllBSVAvMEFCY0FJZi96QUJnQUkvL3lBQmtBSlAveUFCb0FKdi94QUJzQUovL3hBQndBS2Yvd0FCMEFLdi93QUI0QUxQL3ZBQjhBTGYvdkFDQUFMdi91QUNFQU1QL3VBQ0lBTWYvdEFDTUFNLy90QUNRQU5QL3NBQ1VBTnYvckFDWUFOLy9yQUNjQU9QL3FBQ2dBT3YvcUFDa0FPLy9wQUNvQVBmL3BBQ3NBUHYvb0FDd0FRUC9vQUMwQVFmL25BQzRBUXYvbkFDOEFSUC9tQURBQVJmL2xBREVBUi8vbEFESUFTUC9rQURNQVN2L2tBRFFBUy8vakFEVUFUUC9qQURZQVR2L2lBRGNBVC8vaUFEZ0FVZi9oQURrQVV2L2hBRG9BVlAvZ0FEc0FWZi9nQUR3QVYvL2ZBRDBBV1AvZUFENEFXZi9lQUQ4QVcvL2RBRUFBWFAvZEFFRUFYdi9jQUVJQVgvL2NBRU1BWWYvYkFFUUFZdi9iQUVVQVkvL2FBRVlBWmYvYUFFY0Fadi9aQUVnQWFQL1lBRWtBYWYvWUFFb0FhLy9YQUVzQWJQL1hBRXdBYmYvV0FFMEFiLy9XQUU0QWNQL1ZBRThBY3YvVkFGQUFjLy9VQUZFQWRmL1VBRklBZHYvVEFGTUFkLy9UQUZRQWVmL1NBRlVBZXYvUkFGWUFmUC9SQUZjQWZmL1FBRmdBZi8vUUFGa0FnUC9QQUZvQWd2L1BBRnNBZy8vT0FGd0FoUC9PQUYwQWh2L05BRjRBaC8vTkFGOEFpZi9NQUdBQWl2L0xBR0VBalAvTEFHSUFqZi9LQUdNQWp2L0tBR1FBa1AvSkFHVUFrZi9KQUdZQWsvL0lBR2NBbFAvSUFHZ0Fsdi9IQUdrQWwvL0hBR29BbVAvR0FHc0Ftdi9HQUd3QW0vL0ZBRzBBbmYvRUFHNEFudi9FQUc4QW9QL0RBSEFBb2YvREFIRUFvdi9DQUhJQXBQL0NBSE1BcGYvQkFIUUFwLy9CQUhVQXFQL0FBSFlBcXYvQUFIY0FxLysvQUhnQXJmKytBSGtBcnYrK0FIb0FyLys5QUhzQXNmKzlBSHdBc3YrOEFIMEF0UCs4QUg0QXRmKzdBSDhBdC8rN0FJQUF1UCs2QUlFQXVmKzZBSUlBdS8rNUFJTUF2UCs0QUlRQXZ2KzRBSVVBdi8rM0FJWUF3ZiszQUljQXd2KzJBSWdBdy8rMkFJa0F4ZisxQUlvQXh2KzFBSXNBeVArMEFJd0F5ZiswQUkwQXkvK3pBSTRBelArekFJOEF6dit5QUpBQXovK3hBSkVBMFAreEFKSUEwdit3QUpNQTAvK3dBSlFBMWYrdkFKVUExdit2QUpZQTJQK3VBSmNBMmYrdUFKZ0Eydit0QUprQTNQK3RBSm9BM2Yrc0FKc0EzLytyQUp3QTRQK3JBSjBBNHYrcUFKNEE0LytxQUo4QTVQK3BBS0FBNXYrcEFLRUE1LytvQUtJQTZmK29BS01BNnYrbkFLUUE3UCtuQUtVQTdmK21BS1lBN3YrbUFLY0E4UCtsQUtnQThmK2tBS2tBOC8ra0FLb0E5UCtqQUtzQTl2K2pBS3dBOS8raUFLMEErZitpQUs0QSt2K2hBSzhBKy8raEFMQUEvZitnQUxFQS92K2dBTElCQVArZkFMTUJBZitlQUxRQkEvK2VBTFVCQlArZEFMWUJCZitkQUxjQkIvK2NBTGdCQ1ArY0FMa0JDditiQUxvQkMvK2JBTHNCRGYrYUFMd0JEdithQUwwQkQvK1pBTDRCRWYrWkFMOEJFditZQU1BQkZQK1hBTUVCRmYrWEFNSUJGLytXQU1NQkdQK1dBTVFCR2YrVkFNVUJHLytWQU1ZQkhQK1VBTWNCSHYrVUFNZ0JILytUQU1rQklmK1RBTW9CSXYrU0FNc0JKUCtSQU13QkpmK1JBTTBCSnYrUUFNNEJLUCtRQU04QktmK1BBTkFCSy8rUEFORUJMUCtPQU5JQkx2K09BTk1CTC8rTkFOUUJNUCtOQU5VQk12K01BTllCTS8rTUFOY0JOZitMQU5nQk52K0tBTmtCT1ArS0FOb0JPZitKQU5zQk92K0pBTndCUFArSUFOMEJQZitJQU40QlAvK0hBTjhCUVArSEFPQUJRditHQU9FQlEvK0dBT0lCUlArRkFPTUJSditFQU9RQlIvK0VBT1VCU2YrREFPWUJTditEQU9jQlRQK0NBT2dCVGYrQ0FPa0JULytCQU9vQlVQK0JBT3NCVWYrQUFPd0JVLytBQU8wQlZQOS9BTzRCVnY5L0FPOEJWLzkrQVBBQldmOTlBUEVCV3Y5OUFQSUJXLzk4QVBNQlhmOThBUFFCWHY5N0FQVUJZUDk3QVBZQllmOTZBUGNCWS85NkFQZ0JaUDk1QVBrQlpmOTVBUG9CWi85NEFQc0JhUDkzQVB3QmF2OTNBUDBCYS85MkFQNEJiZjkyQVA4QmJ2OTFBQUFBRndBQUFXUUpEdzRHQmdVSEJRTURCZ1FLQlFRRkF3Y0VCZ1VHQmdjSUJnTUZCUVFMQlFjTENBWURBd2NGQndRREJnTUhDZ2tGQmdVRUJBY0VCd1lIQndRREJnTUlEQWNEQndNRUF3VURCd01FQXdNSkJ3WUVCUU1GQkFRREJnTUVCQU1DQkFVSkR3UUVCd01FQkFZRkR3OEhCZ3NEQXdZR0JBWUpCUW9IQlFNQ0JRTU1CZ2NHQ0FnSUNBZ1BDQVlEQXdNREF3TURBd01EQ1FRRUJBUUVCQVFFQkFRSEF3TURBd01EQlFNREF3TURBd01EQXdZRkJRVUZCUVVEQXdNREF3TUZDd3NIQXdjREJnTURCd29KQXdjS0JRUUlDd1FHQ0FvS0JBTUtCZ2dLQmdjREJRY0dCUWNHQmdjRENBZ0lEQWNIQndjSEJ3Y0hCd2NIQndjSEJ3Y0RBd01EQXdZSEJ3Y0hCd2tKQ1FnSUNBZ0hCd2NJQ0FnSUJ3Y0hCd2NIQndjS0Nnb0tCd2tIQ1FjSEJ3b0dCZ1lHQ2dZR0JnWUdCZ2NIQndjSEJ3TURBd01FQndNRkF3WUdCZ1lHQlFVRkJRWUdCZ1VGQlFVSEJBWUdCZ1lHQmdrSkNRa0hCd2NIQUFvUkR3Y0hCUWdHQkFNSEJRc0dCQVlFQ0FVSEJRWUhCd2dIQkFZR0JBd0dCd3dJQndRRUNBWUlCUVFIQkFnTENnVUdCUVVFQ0FRSUJ3Z0lCUU1IQkFrTkNBUUlBd1VEQmdRSUF3UUVBd29IQmdRRkF3WUVCQU1HQkFRRUF3TUVCZ29SQkFRSUF3VUVCd1lSRVFjSERBUUVCd2NFQndvR0RBZ0dBd01GQXc0R0J3Y0lDQWdJQ0JFSUJ3UUVCQVFFQkFRRUJBUUtCQVFFQkFRRUJBUUVCQWdFQkFRRUJBUUdBd01EQXdNREF3TURCd1lHQmdZR0JnTURBd01FQkFZTURBY0RDQVFIQkFRSERBb0RDQXNHQlFrTUJBY0pDd3NFQXdzSENRc0dDQVFHQ0FZR0NBY0hDQU1JQ0FnT0NBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FRRUJBUUVCZ2NJQ0FnSUNnb0tDUWtKQ1FjSEJ3a0pDUWtJQ0FnSUNBZ0lDQXdNREF3SUNnZ0tCd2NIREFjSEJ3Y0xCd2NIQndjSEJ3Y0hCd2dJQXdNREF3UUlBd1VEQndjSEJ3Y0dCZ1lHQmdZR0JnWUdCZ2dFQmdZR0JnWUdDZ29LQ2djSENBZ0FDeElSQ0FnRkNRWUVCQWNGREFZRkJnUUlCZ2dGQndjSUNRY0VCZ1lGRFFZSURRa0lCQVFKQmdrRkJBY0VDQXdMQmdjR0JRVUlCQWtIQ1FrRkJBY0VDZzhJQkFnRUJRUUdCQWdEQlFRREN3Z0hCQVVEQmdVRUF3Y0VCUVFFQXdRSEN4SUZCUWdEQlFRSEJ4SVNDQWNOQkFRSUNBVUlDd1lOQ1FZRUF3WUVEd2NJQ0FrSkNRa0pFZ2tJQkFRRUJBUUVCQVFFQkFzRkJRVUZCUVVFQkFRRUNRUUVCQVFFQkFZRUJBUUVCQU1EQXdNSEJnWUdCZ1lHQXdNREF3UUVCZzBOQ0FNSkJBZ0VCQWdOQ3dRSkRBWUZDZzBGQndvTURBVUREUWNKREFjSUJBWUpCd1lKQ0FjSUJBa0pDUThKQ1FrSkNRa0pDUWtKQ1FrSkNRa0pCQVFFQkFRSENBZ0lDQWdMQ3dzSkNRa0pDQWdJQ1FrSkNRZ0lDUWtKQ1FrSkRRME5EUWtMQ1FzSUNBZ05DQWdJQ0F3SUNBZ0lDQWdJQ0FnSUNBZ0RBd01EQlFrREJnTUlCd2NIQndZR0JnWUhCd2NHQmdZR0NRVUhCd2NIQndjTEN3c0xDQWdKQ1FBTUZCSUpDQVlLQndVRUNBWU5Cd1VIQlFrR0NBVUlDQWdKQ0FVSEJ3VU9Cd2dPQ2drRkJRa0hDZ1VFQ0FRSkRRd0dDQVlGQlFrRkNnZ0tDZ1lFQ0FRTEVBa0VDUVFGQkFjRUNRUUZCUVFNQ0FjRUJRUUhCUVVEQndRRkJRUURCUWNNRkFVRkNRUUdCUWdIRkJRSkNBNEZCUWtKQlFrTUJ3NEtCd1FEQmdRUUNBa0lDZ29LQ2dvVUNnZ0ZCUVVGQlFRRUJBUUVEQVVGQlFVRkJRVUZCUVVLQkFRRUJBUUVCd1FFQkFRRUJBUUVCQWdIQndjSEJ3Y0VCQVFFQkFRSERnOEpCQW9GQ1FRRUNRNE1CQW9OQndVS0RnVUlDdzBOQlFRT0NBb05Cd2tGQndrSUJ3a0lDQWtFQ2dvS0VRa0pDUWtKQ1FrSkNRa0tDUW9LQ2dvRUJBUUVCQWdKQ1FrSkNRd01EQW9LQ2dvSkNRa0tDZ29LQ1FrSkNRa0pDUWtPRGc0T0Nnd0tEQWtKQ1E0SUNBZ0lEUWdJQ0FnSUNBa0pDUWtKQ1FRRUJBUUZDUVFHQkFnSUNBZ0lCd2NIQndjSEJ3Y0hCd2NLQlFjSEJ3Y0hCd3dNREF3SkNRb0tBQTBXRkFrSkJ3b0hCUVFJQmc0SEJnY0ZDUVlKQmdnSkNRb0pCUWNIQmc4SUNnOExDZ1VGQ2dnTEJRVUlCUW9PRFFZSUJ3WUdDZ1VLQ0FzS0JnUUpCQXdSQ2dVS0JBVUVCd1VLQkFZRkJBMEpDQVVHQkFjRkJRUUlCUVVGQkFNRkNBNFdCZ1lLQkFZRkNRZ1dGZ2tKRHdVRkNRa0dDUTBIRHdvSEJBUUhCQklJQ1FrTEN3c0xDeFlMQ1FVRkJRVUZCUVVGQlFVTkJnWUdCZ1lHQlFVRkJRb0ZCUVVGQlFVSEJBUUVCQVFFQkFRRUNRZ0lDQWdJQ0FRRUJBUUZCUWNQRUFvRUNnVUpCUVVLRHcwRUN3NEhCZ3NQQmdrTERnNEdCQThKQ3c0SUNnVUhDZ2dIQ2drSkNnUUxDd3NTQ2dvS0Nnb0tDZ29LQ2dzS0N3c0xDd1VGQlFVRkNBb0tDZ29LRFEwTkN3c0xDd29LQ2dzTEN3c0tDZ29LQ2dvS0NnOFBEdzhLRFFvTkNnb0tEd2tKQ1FrT0NRa0pDUWtKQ2dvS0Nnb0tCQVFFQkFZS0JBY0VDUWtKQ1FrSUNBZ0lDQWdJQndjSEJ3b0ZDQWdJQ0FnSURRME5EUWtKQ3dzQUR4a1hDd29IREFnR0JRb0hFQWdIQ0FZTEJ3b0dDUW9LREFvR0NBZ0hFZ2tMRVEwTEJnWU1DUXdHQlFrR0N4QVBCd3NIQmdZTEJnd0pEQXdIQlFvRkRoUUxCZ3dGQmdVSUJnc0ZCd1lGRHdvSkJRWUZDQVlGQkFnRkJnWUZCQVVKRUJrR0Jnc0ZCd1lLQ1JrWkN3b1NCZ1lMQ3dZTERnZ1JEQWdGQkFnRkZBb0xDdzBORFEwTkdRMEtCZ1lHQmdZRkJRVUZCUThHQmdZR0JnWUdCZ1lHREFZR0JnWUdCZ2tGQlFVRkJRVUZCUVVLQ1FrSkNRa0pCUVVGQlFVRkNCSVNDd1VNQmdzR0Jnc1JEd1VNRUFnSERSSUhDZzBSRVFjRkVRb05FQW9MQmdnTkNRa01DZ29MQlEwTkRSVU1EQXdNREF3TURBd01EQXdNREF3TUJRVUZCUVVKQ3dzTEN3c1BEdzhORFEwTkN3c0xEUTBORFFzTERBd01EQXdNRVJFUkVRd1BEQThMQ3dzUkNnb0tDaEFLQ2dvS0Nnb0xDd3NMQ3dzRkJRVUZCd3dGQ0FVS0Nnb0tDZ2tKQ1FrSkNRa0lDQWdJREFZSkNRa0pDUWtQRHc4UEN3c01EQUFRR3hnTEN3Z05DUVlGQ2dnU0NRY0pCZ3NJQ3djS0N3b05Dd1lKQ1FjVENRc1NEUXdHQmd3SkRRWUdDZ1lNRVJBSUN3Z0hCd3dHRFFvTkRRZ0ZDd1VQRlF3R0RBVUdCUWtHREFVSEJnVVFDd2tGQndVSkJ3WUZDUVlHQndVRUJnb1JHd2NIREFVSUJ3c0tHeHNNQ3hNR0Jnc0xCd3NQQ1JNTkNRVUVDQVVXQ2d3TERRME5EUTBiRFFzR0JnWUdCZ1lHQmdZR0VBY0hCd2NIQndZR0JnWU5CZ1lHQmdZR0NRVUZCUVVGQlFVRkJRc0pDUWtKQ1FrRkJRVUZCZ1lKRXhNTUJRMEdDd1lHREJNUUJRMFJDUWNPRXdjTERoSVNCd1VTQ3c0U0Nnd0dDUTBLQ1F3TEN3d0ZEUTBORmd3TURBd01EQXdNREF3TkRBME5EUTBHQmdZR0Jnb01EQXdNREJBUUVBNE9EZzRNREF3T0RnNE9EQXdORFEwTkRRMFNFaElTRFJBTkVBd01EQklMQ3dzTEVRc0xDd3NMQ3d3TURBd01EQVVGQlFVSERBVUlCUXNMQ3dzTENRa0pDUW9LQ2drSkNRa05Cd29LQ2dvS0NoQVFFQkFNREEwTkFCRWNHZ3dNQ0E0S0JnWUxDQk1KQndrR0RRZ01Cd3NMQ3cwTEJna0pCeFFLREJRT0RRY0hEUW9PQndZTEJnMFNFUWdNQ0FjSERRY05DZzRPQ0FZTEJSQVdEUVlOQmdZR0NRWU5CUWdIQlJFTEN3VUhCUW9IQmdVSkJnWUhCZ1FHQ2hJY0J3Y05CUWdIQ3dvY0hBd0xGQVlHREF3SERCQUtGQTRKQmdVSkJoY0xEQXdPRGc0T0Rod09EQWNIQndjSEJnWUdCZ1lSQndjSEJ3Y0hCd2NIQnc0R0JnWUdCZ1lLQmdZR0JnWUZCUVVGQ3dvS0Nnb0tDZ1VGQlFVR0Jna1VGQTBGRGdZTUJnWU5GQklHRGhJSkNBOFVCd3NQRXhNSEJSTUxEeE1LRFFZSkRnc0pEUXdMRFFZT0RnNFlEUTBORFEwTkRRME5EUTRORGc0T0RnWUdCZ1lHQ3cwTkRRME5FUkVSRHc4UER3d01EQThQRHc4TkRRME5EUTBORFJRVUZCUU9FUTRSRFEwTkZBd01EQXdTREF3TURBd01EUTBORFEwTkJRVUZCUWdOQlFrRkRBc0xDd3NLQ2dvS0Nnb0tDZ29LQ2c0SENnb0tDZ29LRVJFUkVRd01EZzRBRXlBZERRMEpEd3NIQmd3SkZRc0lDd2NPQ1EwSERBME5EdzBIQ3dzSUZnc05GaEFPQndjUEN4QUlCd3dIRGhRVENRd0pDQWdPQnc4TEVBOEpCdzBHRWhrT0J3NEhCd2NMQnc0R0NBY0dFZzBMQmdjR0N3Z0dCUW9IQndnR0JRY01GQ0FJQ0E0R0NRZ05DeUFnRGcwV0J3Y05EUWdPRWdzV0R3c0hCUW9HR2d3T0RSQVFFQkFRSUJBTkJ3Y0hCd2NIQndjSEJ4TUlDQWdJQ0FnSEJ3Y0hEd2NIQndjSEJ3c0hCd2NIQndZR0JnWU5Dd3NMQ3dzTEJnWUdCZ2NIQ3hZWERnWVBCdzBIQnc0V0ZBWVFGQXNKRVJZSURCRVZGUWdHRmd3UUZRc09Cd3NQREFvUERRd09CaEFRRUJvUER3OFBEdzhQRHc4UEVBOFFFQkFRQndjSEJ3Y01EZzRPRGc0VEV4TVFFQkFRRGc0T0VCQVFFQTRPRHc4UER3OFBGaFlXRmc4VER4TU9EZzRXRFEwTkRSUU5EUTBORFEwT0RnNE9EZzRHQmdZR0NBOEdDZ1lORFEwTkRRc0xDd3NNREF3TEN3c0xEd2dNREF3TURBd1RFeE1URGc0UUVBQVZJeUFQRHdvUkRBZ0hEUW9YREFrTUNCQUtEZ2dORGc0UkRnZ01EQWtaREE4WUVoQUlDQkFNRVFnSERRZ1FGaFVLRGdzSUNSQUlFUXdSRVFvSERnY1VIQkFJRHdjSEJ3d0lFQVlKQ0FZVURnd0dDQVlNQ1FjR0N3Y0hDUWNGQncwV0l3a0pFQVlLQ1E0Tkl5TVBEaGtJQ0E4UENROFREQmdSREFjR0N3Y2NEUThQRWhJU0VoSWpFZzhJQ0FnSUNBY0hCd2NIRlFrSkNRa0pDUWdJQ0FnUkNBZ0lDQWdJREFjSEJ3Y0hCZ1lHQmc0TURBd01EQXdHQmdZR0NBZ01HUmtRQnhFSUR3Z0lFQmdXQnhFWERBa1NHUWtPRWhjWENRWVlEaElYREJBSURCRU5DeEFQRGhBSEVoSVNIUkFRRUJBUUVCQVFFQkFSRUJFUkVSRUhCd2NIQncwUUVCQVFFQlVWRlJJU0VoSVBEdzhTRWhJU0VCQVFFQkFRRUJBWUdCZ1lFUlVSRlJBUUVCZ09EZzRPRmc0T0RnNE9EaEFRRUJBUUVBWUdCZ1lKRUFZTEJnNE9EZzRPREF3TURBME5EUXdNREF3UkNRME5EUTBORFJVVkZSVVBEeEVSQUJnb0pCRVJDeE1PQ1FnT0N4b05DdzBKRWd3UkNROFFFQklRQ1EwTkNod09FUndVRXdrSkV3NFVDZ2tQQ1JJWUdBc1FEQWtLRWdrVERoUVREQWdRQ0JjZ0Vna1NDQWdJRFFrU0J3c0pCeGNRRGdjSkJ3NEtCd2NNQ0FnS0NBWUlEeGtvQ2dvU0J3d0tFQTRvS0JFUUhBa0pFUkVLRVJZT0hCTU5DQWNNQ0NFUEVoRVVGQlFVRkNnVUVRa0pDUWtKQ1FrSkNRa1lDZ29LQ2dvS0NRa0pDUk1KQ1FrSkNRa09DQWdJQ0FnSEJ3Y0hFQTRPRGc0T0RnY0hCd2NKQ1EwY0hCSUhFd2tSQ1FrU0hCa0lGQm9OQ3hVY0N4QVZHeHNLQnhzUUZSb09FZ2tORXc4TkV4RVFFZ2dVRkJRaEV4TVRFeE1URXhNVEV4UVRGQlFVRkFrSkNRa0pEeElTRWhJU0dCZ1lGUlVWRlJJU0VoVVZGUlVTRWhNVEV4TVRFeHdjSEJ3VEZ4TVhFaElTSEJBUUVCQWFFUkFRRUJBUUVoSVNFaElTQndjSEJ3c1RCd3dIRUJBUUVCQU9EZzRPRHc4UERnNE9EaE1LRHc4UER3OFBHQmdZR0JFUkZCUUFHeTBwRXhNTUZnOEtDUkFOSGc4TUR3b1REUk1LRVJJU0ZoSUtEdzhNSUJBVEh4Y1ZDZ29WRUJZTENoRUtGQndiREJNTkN3d1VDeFVQRmhZTkNSSUpHU1FVQ2hRSkNRa1BDaFVJREFvSUdoTVBCd29JRHdzSkNBMEpDd3NKQndrUUhDME1EQlFJRFFzU0VDMHRGQklnQ2dvVEV3d1RHQThmRmc4SkJ3NEpKUkVVRXhjWEZ4Y1hMUmNUQ2dvS0Nnb0tDZ29LQ2hzTURBd01EQXdMQ3dzTEZnb0tDZ29LQ2hBSkNRa0pDUWdJQ0FnU0VCQVFFQkFRQ0FnSUNBb0tEeUFnRkFnV0NoTUtDaFFmSEFrV0hROE1HQ0FNRWhnZUhnd0lIeElYSGhFVUNnOFdFUTRWRXhJVUNSY1hGeVVWRlJVVkZSVVZGUlVWRmhVV0ZoWVdDZ29LQ2dvUkZCUVVGQlFiR3hzWEZ4Y1hGQlFVRnhjWEZ4UVVGUlVWRlJVVkh4OGZIeFlhRmhvVUZCUWZFeE1URXgwVEV4TVRFeE1VRkJRVUZSVUlDQWdJREJVSURnZ1NFaElTRWhBUUVCQVJFUkVQRHc4UEZnc1JFUkVSRVJFYkd4c2JGQlFXRmdBZE1Dd1ZGQTRYRUFzS0VRNGdFQTBRQ3hVT0ZBb1NFeFFYRXdzUUVBMGlFUlFoR0JZTEN4Y1JHQXdLRWdzV0h4ME5FdzRMREJZTEZ4RVlGdzRLRkFrYkpoWUxGUW9LQ2hBTEZna05Dd2tjRkJJSkNna1FEQW9JRGdvTERBb0lDUkllTUF3TkZna09EQk1STURBVkV5SUxDeFVWREJVYUVDSVhFQW9JRHdvbkV4VVZHQmdZR0Jnd0dCUUxDd3NMQ3dvS0Nnb0tIUXdNREF3TURBc0xDd3NYQ3dzTEN3c0xFUW9LQ2dvS0NRa0pDUlFSRVJFUkVSRUpDUWtKQ3dzUUlpSVZDUmNMRlFzTEZpSWVDaGdmRUEwWklnMFRHU0FnRFFraEV4a2dFaFlMRUJjU0R4Y1VFeFlLR0JnWUtCWVdGaFlXRmhjWEZ4Y1lGeGdZR0JnS0Nnb0tDaElWRmhZV0ZoMGRIUmtaR1JrVkZSVVpHUmtaRmhZWEZ4Y1hGeGNoSVNFaEZ4d1hIQllXRmlFVUZCUVVIeFFVRkJRVUZCVVZGUlVXRmdrSkNRa05GZ2tQQ1JRVUZCUVVFUkVSRVJJU0VoQVFFQkFYREJJU0VoSVNFaDBkSFIwVkZSZ1lBQ0ExTVJjV0VCb1NEQXNURHlNU0RoSU1GdzhXREJRVkZob1ZEQklTRGlVVEZ5UWJHUXdNR1JNYkRRc1VEQmdoSUE0VkR3d09HQTBaRXhzYUVBc1dDaDRxR0F3WEN3c0xFZ3daQ2c0TUNoOFZFd29NQ2hJTkNna1FDd3dOQ3dnTEV5RTFEZzRZQ2hBTkZSTTFOUmNWSmd3TUZ4Y09GeDBTSlJvU0N3a1JDeXNVRnhjYkd4c2JHelViRmd3TURBd01Dd3NMQ3d3Z0RnNE9EZzRPRFEwTkRSb01EQXdNREF3U0N3c0xDd3NLQ2dvS0ZoTVRFeE1URXdvS0Nnb01EQklsSlJnS0dnd1hEQXdZSlNFTEdpTVNEaHdtRGhVY0pDUU9DaVVWR3lNVUdBd1NHaFFSR1JZVkdBc2JHeHNzR1JrWkdSa1pHUmtaR1JzWkd4c2JHZ3NMQ3dzTEZCZ1lHQmdZSUNBZ0d4c2JHeGdZR0JzYkd4c1lHQmtaR1JrWkdTVWxKU1VhSHhvZkdCZ1lKUllXRmhZaUZoWVdGaFlXR0JnWUdCZ1lDZ29LQ2c0WkNoQUtGaFlXRmhZVEV4TVRGQlFVRWhJU0Vob05GQlFVRkJRVUlDQWdJQmNYR2hvQUlUY3lGeGNRR2hNTkN4TVFKQklPRWd3WUR4Y01GUllXR2hZTUVoSU9KeE1ZSmh3YURRMGFFeHNOREJRTUdTSWhEaFVRRFE0WkRSb1RHeG9RQ3hZTEh5d1pEQmdMREFzU0RCa0tEdzBLSUJZVUN3d0tFdzRLQ1JBTURBMExDUXNVSWpjT0Roa0tFQTBXRkRjM0dCWW5EUTBYRnc0WUhoTW1HaElMQ1JFTExSVVlGeHdjSEJ3Y054d1hEUTBORFEwTURBd01EU0VPRGc0T0RnNE5EUTBOR2d3TURBd01EQk1MQ3dzTEN3b0tDZ29XRXhNVEV4TVRDZ29LQ2d3TUVpY21HQW9iRFJjTURCa21JZ3NiSkJJUEhTY09GaDBsSlE0S0poWWNKQlFaREJJYUZSRWFGeFlaQ3h3Y0hDNGFHaG9hR2hvYUdob2FHeG9iR3hzYkRBd01EQXdWR0JrWkdSa2hJU0VjSEJ3Y0dCZ1lIQndjSEJrWkdob2FHaG9hSmlZbUpob2dHaUFaR1JrbUZ4Y1hGeU1YRnhjWEZ4Y1lHQmdZR1JrS0Nnb0tEeG9LRVFvWEZoWVdGaE1URXhNVUZCUVRFeE1UR2c0VUZCUVVGQlFoSVNFaEdCZ2JHd0FsUGpnYUdoSWRGUTRNRnhJb0ZSQVZEaHNTR2c0WEdSZ2RHQTRWRlJBckZob3FIeDBPRGgwV0h3OE5HQTRjSnlVUUdSSU9FQndPSFJVZkhoSU5HUXdqTVJ3T0dnME5EUlVPSEFzUURnc2tHUlVMRGdzVkR3c0xFdzBORHd3S0RSWW1QaEFRSEFzU0R4a1dQajRiR1NzT0Rob2FFQm9oRlNzZUZRMEtFd3d5R0JzYUh4OGZIeDgrSHhvT0RnNE9EZzBORFEwT0pSQVFFQkFRRUE0T0RnNGVEZzRPRGc0T0ZRME5EUTBOQ3dzTEN4a1dGaFlXRmhZTEN3c0xEUTBWS3lzYkN4NE9HZzRPSENzbURCNG9GUkVnTEJBWUlDa3BFQXNxR0NBb0Zod09GUjRYRXgwYUdCd05IeDhmTXgwZEhSMGRIUjBkSFIwZkhSOGZIeDRORFEwTkRSY2JIQndjSENVbEpTQWdJQ0FiR3hzZ0lDQWdIQndkSFIwZEhSMHJLeXNySGlRZUpCc2JHeXNaR1JrWktCb1pHUmtaR1JzYkd4c2NIQXNMQ3dzUUhRc1RDeGtaR1JrWkZoWVdGaGNYRnhVVkZSVWREeGNYRnhjWEZ5WW1KaVliR3g0ZUFDcEdRQjRkRkNFWUVBNFpGQzRYRWhjUUh4UWRFQm9jSENBY0VCY1hFakVaSFM4aklSQVFJUmdqRVE4YkVDQXJLaEliRlE4U0lCQWhHQ01pRlE0Y0RTYzNJQkFlRGc4T0Z4QWdEUk1RRFNnY0dRd1BEUmdSREF3V0R3OFJEZ3NPR1N4R0VoSWdEUlVSSEJsR1JoOGNNUkFRSGg0U0hpWVlNU0lYRGdzV0Rqa2JIeDRqSXlNakkwWWpIUkFRRUJBUUR3OFBEeEFxRWhJU0VoSVNFQkFRRUNJUUVCQVFFQkFZRGc0T0RnNE5EUTBOSEJrWkdSa1pHUTBORFEwUER4Y3hNUjhOSWhBZUVCQWZNU3NPSWkwWEV5VXlFaHdsTHk4U0RUQWNKQzRaSUJBWElob1dJUjBjSUE0akl5TTZJU0VoSVNFaElTRWhJU01oSXlNaklnOFBEdzhQR2g4Z0lDQWdLaW9xSkNRa0pCOGZIeVFrSkNRZ0lDRWhJU0VoSVRBd01EQWlLU0lwSHg4Zk1CMGRIUjB0SFIwZEhSMGRIeDhmSHlBZ0RRME5EUk1oRFJVTkhSd2NIQndaR1JrWkdob2FHQmdZR0NFUkdob2FHaG9hS3lzckt4OGZJaUlBTGsxR0lTQVZKUm9TRHh3V01ob1VHaEVoRlNBUkhSOGZKQjRSR2hvVU5oc2hOQ1lrRWhJa0d5WVNFQjBSSXpBdUZCOFdFUlFqRWlRYUppVVdFQjhQS3owakVTQVFFQkFhRVNRT0ZCSU9MQjhhRFJBT0doTU9EUmdRRVJNUERBOGNNRTBVRkNNT0ZoTWZIRTFOSVI4MkVoSWhJUlFoS1JvMUpSb1FEQmdQUGgwaUlTWW1KaVltVFNZZ0VoSVNFaElRRUJBUUVTNFVGQlFVRkJRU0VoSVNKUkVSRVJFUkVSc1FFQkFRRUE0T0RnNGZHeHNiR3hzYkRnNE9EaEVSR2pZMklnNGxFaUVSRVNJMUx3OG1NaG9WS0RZVUhpZ3pNeFFPTlI0bk1od2pFUm9sSFJna0lCNGpFQ1ltSmtBa0pDUWtKQ1FrSkNRa0ppUW1KaVltRUJBUUVCQWRJaU1qSXlNdUxpNG5KeWNuSWlJaUp5Y25KeU1qSkNRa0pDUWtOVFUxTlNVdEpTMGlJaUkxSUNBZ0lERWdJQ0FnSUNBaUlpSWlJeU1PRGc0T0ZDUU9GdzRmSHg4Zkh4c2JHeHNjSEJ3YUdob2FKUk1jSEJ3Y0hCd3ZMeTh2SVNFbUpnQXlVMHdqSXhnb0hCTVJIaGczSEJZY0V5UVlJaE1mSWlFb0lSTWNIQlk2SFNRNUtpZ1RFeWNkS2hRU0h4SW1ORElWSVJrU0ZTWVVLQjRwS0JnUkloQXZRaVlUSkJFU0VSd1NKZzhXRXc4d0lSMFFFZzhjRlE4T0dSSVNGQkVORVI0MFV4VVdKZzhZRkNFZVUxTWtJVHNURXlNakZTUXRIRG9vSEJFT0doRkVJQ1FqS2lvcUtpcFRLaU1URXhNVEV4SVNFaElVTWhVVkZSVVZGUlFVRkJRb0V4TVRFeE1USFJFUkVSRVJEdzhQRHlJZEhSMGRIUjBQRHc4UEVoSWNPanNsRUNnVEl4SVNKVG96RUNrMkhCWXNPeFloTERnNEZnODVJU3MzSHlZVEhDZ2ZHeWNqSVNZUktpb3FSU2NuSnljbkp5Y25KeWNxSnlvcUtpa1NFaElTRWg4bEppWW1Kakl5TWlzckt5c2xKU1VyS3lzckppWW5KeWNuSnljNk9qbzZLREVvTVNVbEpUb2lJaUlpTmlJaUlpSWlJaVVsSlNVbUpnOFBEdzhXSnc4WkR5SWlJaUlpSFIwZEhSOGZIeHdjSEJ3b0ZSOGZIeDhmSHpNek16TWtKQ2twQURaYVVpWW1HaXNlRlJJZ0dqc2VHQjRVS0JvbEZDSWtKQ29rRkI0ZUdEOGdKajB0S3hVVktoOHRGaE1pRkNrNU5oY2pHeFFYS1JVcklDMHJHaE1sRVROSEtSUW5FeE1USGhRcEVCZ1ZFVFFsSUJFVEVSNFdFQkFiRXhRV0VnNFNJVGhhRnhjcEVSb1dKQ0JhV2lja1B4VVZKaVlYSnpBZVB5c2VFdzhjRWtraUp5WXRMUzB0TFZvdEpSVVZGUlVWRXhNVEV4VTJGeGNYRnhjWEZSVVZGU3NVRkJRVUZCUWZFeE1URXhNUUVCQVFKU0FnSUNBZ0lCRVJFUkVVRkI0L1B5Z1JMQlVtRkJRb1B6Z1NMRG9lR0M5QUdDTXZQRHdYRUQ0akxqc2hLUlFlS3lJZEtpWWpLUkl0TFMxTEtpb3FLaW9xS2lvcUtpMHFMUzB0TEJNVEV4TVRJaWdwS1NrcE5qWTJMaTR1TGlnb0tDNHVMaTRwS1NvcUtpb3FLajQrUGo0ck5TczFLQ2dvUGlVbEpTVTZKU1VsSlNVbEtDZ29LQ2twRUJBUUVCZ3FFUnNSSlNVbEpTVWdJQ0FnSVNFaEhoNGVIaXNXSVNFaElTRWhOemMzTnljbkxDd0FPbUZZS1NrY0xpRVdFeU1jUHlBWklCWXFHeWdXSkNjbUxTWVdJQ0FaUkNJcVFUQXVGaFl0SWpBWEZTUVZMRHc2R1NjY0ZSa3NGeTRpTUM4Y0ZDY1NOazBzRmlvVUZCUWdGUzBTR2hZU09DY2lFaFlTSVJnUkVSNFVGUmdURHhNalBHRVpHU3dTSEJnbUkyRmhLaVpFRmhZcEtSa3BOU0ZETHlBVUVCNFRUeVVxS1RBd01EQXdZVEFvRmhZV0ZoWVZGUlVWRnpvWkdSa1pHUmtYRnhjWEx4WVdGaFlXRmlFVUZCUVVGQklTRWhJbklpSWlJaUlpRWhJU0VoVVZJRVJFS3hJdkZpa1ZGU3REUEJNdlB5QWFNMFFaSmpOQVFCa1NRaVl5UHlJc0ZpQXZKQjR0S1NZc0ZEQXdNRkF0TFMwdExTMHRMUzB0TUMwd01EQXZGUlVWRlJVa0t5d3NMQ3c2T2pveU1qSXlLeXNyTWpJeU1pd3NMUzB0TFMwdFEwTkRReTg1THprckt5dERLQ2dvS0Q0b0tDZ29LQ2dyS3lzckxDd1NFaElTR2kwU0hSSW9KeWNuSnlJaUlpSWtKQ1FoSVNFaExoZ2tKQ1FrSkNRN096czdLaW92THdCRGNHWXdMeUUxSmhvV0tTQkpKUjBsR1RFZ0xoa3FMUzAxTEJrbEpSMU9KeTlMT0RZYUdqUW5PQndZS2hrelJrUWRMQ0VZSFRNYU5TWTNOaUVYTFJVL1dESVpNQmNXRnlVWk14UWVHaFZCTFNnVUdCVW1IQlVUSWhjWkd4WVJGaWxHY0IwZE14VWhHeXdvY0hBeExFOGFHakF3SFRBOEprNDJKUmNTSXhkYkt6RXZPRGc0T0Rod09DNGFHaG9hR2hnWUdCZ2FSQjBkSFIwZEhSb2FHaG8yR1JrWkdSa1pKeGNYRnhjWEZCUVVGQzBuSnljbkp5Y1ZGUlVWR0JnbFRrOHhGVFlhTUJrWk1rNUZGamRJSlI0NlR4MHNPMHBLSFJSTkxEbEpLRE1aSlRZcUl6UXZMRE1YT0RnNFhUUTBORFEwTkRRME5EUTRORGc0T0RjWUdCZ1lHQ294TXpNek0wUkVSRGs1T1RreE1URTVPVGs1TXpNME5EUTBORFJOVFUxTk5rRTJRVEl5TWswdUxpNHVTQzR1TGk0dUxqRXhNVEV6TXhRVUZCUWVOQlVpRlM0dExTMHRKeWNuSnlrcEtTWW1KaVkxSENrcEtTa3BLVVJFUkVReE1UYzNBRXQ5Y2pVMEpEd3FIUmt0SkZJcUlTb2NPQ1EwSEM4eU1qc3hIQ29xSVZnc05WUS9QQjBkT2l3K0h4c3ZIRGxPVENBekpCc2dPUjA3S3o0OEpSb3pHRVpqT0J3Mkdob2FLaHc1RnlFZEYwZ3pMQmNiRnlvZkZ4WW1HaHNmR1JNWkxVNTlJQ0E1RnlVZk1pMTlmVGN5V0IwZE5UVWdOa1FxVnp3cUdoUW5HV1l3TnpVL1B6OC9QMzAvTkIwZEhSMGRHeHNiR3g1TUlDQWdJQ0FnSFIwZEhUd2NIQndjSEJ3ckdob2FHaG9YRnhjWE15d3NMQ3dzTEJjWEZ4Y2JHeXBZV0RjWFBSMDFIQnc0VjAwWlBWRXFJa0ZZSVRGQ1UxTWhGMVl4UUZJdE9Sd3FQQzhuT2pReE9Say9QejlvT2pvNk9qbzZPam82T2o0NlBqNCtQUnNiR3hzYkx6YzVPVGs1VEV4TVFFQkFRRGMzTjBCQVFFQTVPVHM3T3pzN08xWldWbFk4U1R4Sk9EZzRWak16TXpOUU5ETXpNek16TnpjM056azVGeGNYRnlFNkZ5WVhNek16TXpNc0xDd3NMaTR1S2lvcUtqd2ZMaTR1TGk0dVRFeE1URGMzUFQwQUFBQUFBd0FBQUFNQUFBU3FBQUVBQUFBQUFCd0FBd0FCQUFBQjVnQUdBY29BQUFBZ0FPQUFYUUM3QUFFQUFnQURBQVFBQlFBR0FBY0FDQUFKQUFvQUN3QU1BQTBBRGdBUEFCQUFFUUFTQUJNQUZBQVZBQllBRndBWUFCa0FHZ0FiQUJ3QUhRQWVBQjhBSUFBaEFDSUFJd0FrQUNVQUpnQW5BQ2dBS1FBcUFDc0FMQUF0QUM0QUx3QXdBREVBTWdBekFEUUFOUUEyQURjQU9BQTVBRG9BT3dBOEFEMEFQZ0EvQUVBQVFRQkNBRU1BUkFCRkFFWUFSd0JJQUVrQVNnQkxBRXdBVFFCT0FFOEFVQUJSQUZJQVV3QlVBRlVBVmdCWEFGZ0FXUUJhQUZzQVhBQm1BQUFBaEFDR0FJZ0FpZ0NTQUpjQW5BQ2ZBSjRBb0FDaUFLRUFvd0NsQUtjQXBnQ29BS2tBcXdDcUFLd0FyUUN1QUxBQXJ3Q3hBTE1Bc2dDMkFMVUF0d0M0QU5JQXhBQjRBTVlBeVFEUEFOc0EzZ0RZQU1vQWN3QnFBR2tBQUFDSEFKZ0FBQURaQUFBQUFBREZBTm9BQUFBQUFBQUFBQUFBQU13QXd3QUFBS1FBdEFCL0FIY0ExZ0FBQU1zQUFBQUFBTTRBdlFCb0FBQUFnQUNEQUpZQWNnQjFBTkFBMFFCdkFIQUFiZ0J0QU4wQUFBQzZBSFlBNUFESEFNMEF2QUJnQUdFQTB3RGNBTUVBd2dBQUFJSUFpd0NCQUl3QWlRQ09BSThBa0FDTkFKUUFsUUFBQUpNQW1nQ2JBSmtBMVFCZUFHc0E0d0MrQUw4QWhRQnNBTUFBMUFCZkFBUUN4QUFBQUVnQVFBQUZBQWdBSVFCOUFINEFyQUM3QU1RQTFnRGZBTzhCSlFFcEFTd0JNUUUzQVVrQlpRRitBWklCL3dJWkFzY0MzUjZGSHZNZ0ZDQWFJQjRnSWlBbUlEb2dSQ0NzSVNJaUV2c0MvLzhBQUFBZ0FDSUFmZ0NoQUs0QXZBREZBTmNBNEFEd0FTY0JLd0V1QVRRQk9RRk1BV2dCa2dIOEFoZ0N4Z0xZSG9BZThpQVRJQmdnSENBZ0lDWWdPU0JFSUt3aElpSVMrd0gvL3dBQS85OEFBQUFBQUFEL3dQL0JBQUQvdmdBQUFBQUFBQUFBQUFBQUFBQUFBQUQvT1FBQUFBRDltQUFBQUFBQUFPQzlBQUFBQUFBQTRFSUFBT0NnMzd2ZlVkN0ZCVjhBQVFCSUFBQUFTQUJJQUY0QUFBQUFBSFFBQUFDQ0FPd0E4QUR5QVBnQS9nRWVBVkFBQUFGNkFZQUFBQUdBQVlvQmxBQUFBWlFCbUFHY0FBQUJuZ0FBQUFBQUFBQUFBQUFBQUFCZEFMc0FaZ0IzQUhnQXhnREhBTVVBeUFESkFHa0F5Z0RNQU00QTFnRFlBT01BeEFEWkFIa0FlZ0JxQU5vQTJ3RGNBR3dBZXdEREFMMEE0Z0NZQUprQW1nQ2JBSndBblFEZkFONEE0UUN1QUs4QXNBQ3hBTElBc3dEZEFMUUF0UUMyQUxjQXVBQzVBT0FBdWdEb0FTUUE1Z0VqQU9jQkpRRHFBU2NBNndFcEFPMEJLZ0RzQVNnQTdnRXJBTzhCTEFEekFUQUE4QUV0QVBJQkx3RDFBVEVBOFFFdUFQWUJNd0QwQVRJQStBRTFBUGNCTkFENUFUY0JOZ0QrQVRzQk9RRDZBUHdCT2dEN0FOVUEvd0U4QVFBQlBRRUJBVDRCQXdGQUFRSUJQd0VFQVVFQVlnQmpBUVVCUWdFSEFVVUJCZ0ZFQVVNQkN3RklBUWdCUmdFSkFVY0FjZ0IxQVF3QlNnRU9BVXdCRFFGTEFROEJUUUVSQVU4QkVBRk9BSEVBZEFFVUFWSUJFd0ZSQVJvQldBRVdBVlVCRlFGVEFSZ0JWd0VYQVZRQkdRRldBUndCV2dFZkFWMEFkZ0VnQVY4QklnRmdBR1FBWlFEcEFTWUJDZ0ZKQVJJQlVBQytBTDhBaFFEVUFHc0F3QUVlQVZ3Qkd3RlpBUjBCV3dFaEFWNEFiZ0J0QU1FQWJ3QndBTUlBMGdEVEFNOEF6UUM4QUFRQ3hBQUFBRWdBUUFBRkFBZ0FJUUI5QUg0QXJBQzdBTVFBMWdEZkFPOEJKUUVwQVN3Qk1RRTNBVWtCWlFGK0FaSUIvd0laQXNjQzNSNkZIdk1nRkNBYUlCNGdJaUFtSURvZ1JDQ3NJU0lpRXZzQy8vOEFBQUFnQUNJQWZnQ2hBSzRBdkFERkFOY0E0QUR3QVNjQkt3RXVBVFFCT1FGTUFXZ0JrZ0g4QWhnQ3hnTFlIb0FlOGlBVElCZ2dIQ0FnSUNZZ09TQkVJS3doSWlJUyt3SC8vd0FBLzk4QUFBQUFBQUQvd1AvQkFBRC92Z0FBQUFBQUFBQUFBQUFBQUFBQUFBRC9PUUFBQUFEOW1BQUFBQUFBQU9DOUFBQUFBQUFBNEVJQUFPQ2czN3ZmVWQ3RkJWOEFBUUJJQUFBQVNBQklBRjRBQUFBQUFIUUFBQUNDQU93QThBRHlBUGdBL2dFZUFWQUFBQUY2QVlBQUFBR0FBWW9CbEFBQUFaUUJtQUdjQUFBQm5nQUFBQUFBQUFBQUFBQUFBQUJkQUxzQVpnQjNBSGdBeGdESEFNVUF5QURKQUdrQXlnRE1BTTRBMWdEWUFPTUF4QURaQUhrQWVnQnFBTm9BMndEY0FHd0Fld0REQUwwQTRnQ1lBSmtBbWdDYkFKd0FuUURmQU40QTRRQ3VBSzhBc0FDeEFMSUFzd0RkQUxRQXRRQzJBTGNBdUFDNUFPQUF1Z0RvQVNRQTVnRWpBT2NCSlFEcUFTY0E2d0VwQU8wQktnRHNBU2dBN2dFckFPOEJMQUR6QVRBQThBRXRBUElCTHdEMUFURUE4UUV1QVBZQk13RDBBVElBK0FFMUFQY0JOQUQ1QVRjQk5nRCtBVHNCT1FENkFQd0JPZ0Q3QU5VQS93RThBUUFCUFFFQkFUNEJBd0ZBQVFJQlB3RUVBVUVBWWdCakFRVUJRZ0VIQVVVQkJnRkVBVU1CQ3dGSUFRZ0JSZ0VKQVVjQWNnQjFBUXdCU2dFT0FVd0JEUUZMQVE4QlRRRVJBVThCRUFGT0FIRUFkQUVVQVZJQkV3RlJBUm9CV0FFV0FWVUJGUUZUQVJnQlZ3RVhBVlFCR1FGV0FSd0JXZ0VmQVYwQWRnRWdBVjhCSWdGZ0FHUUFaUURwQVNZQkNnRkpBUklCVUFDK0FMOEFoUURVQUdzQXdBRWVBVndCR3dGWkFSMEJXd0VoQVY0QWJnQnRBTUVBYndCd0FNSUEwZ0RUQU04QXpRQzhBQUM0QUFBc1M3Z0FDVkJZc1FFQmpsbTRBZitGdUFCRUhia0FDUUFEWDE0dHVBQUJMQ0FnUldsRXNBRmdMYmdBQWl5NEFBRXFJUzI0QUFNc0lFYXdBeVZHVWxnaldTQ0tJSXBKWklvZ1JpQm9ZV1N3QkNWR0lHaGhaRkpZSTJXS1dTOGdzQUJUV0drZ3NBQlVXQ0d3UUZrYmFTQ3dBRlJZSWJCQVpWbFpPaTI0QUFRc0lFYXdCQ1ZHVWxnamlsa2dSaUJxWVdTd0JDVkdJR3BoWkZKWUk0cFpMLzB0dUFBRkxFc2dzQU1tVUZoUldMQ0FSQnV3UUVSWkd5RWhJRVd3d0ZCWXNNQkVHeUZaV1MyNEFBWXNJQ0JGYVVTd0FXQWdJRVY5YVJoRXNBRmdMYmdBQnl5NEFBWXFMYmdBQ0N4TElMQURKbE5Zc0VBYnNBQlppb29nc0FNbVUxZ2pJYkNBaW9vYmlpTlpJTEFESmxOWUl5RzRBTUNLaWh1S0kxa2dzQU1tVTFnakliZ0JBSXFLRzRvaldTQ3dBeVpUV0NNaHVBRkFpb29iaWlOWklMZ0FBeVpUV0xBREpVVzRBWUJRV0NNaHVBR0FJeUVic0FNbFJTTWhJeUZaR3lGWlJDMjRBQWtzUzFOWVJVUWJJU0ZaTGJnQUNpeEx1QUFKVUZpeEFRR09XYmdCLzRXNEFFUWR1UUFKQUFOZlhpMjRBQXNzSUNCRmFVU3dBV0F0dUFBTUxMZ0FDeW9oTGJnQURTd2dSckFESlVaU1dDTlpJSW9naWtsa2lpQkdJR2hoWkxBRUpVWWdhR0ZrVWxnalpZcFpMeUN3QUZOWWFTQ3dBRlJZSWJCQVdSdHBJTEFBVkZnaHNFQmxXVms2TGJnQURpd2dSckFFSlVaU1dDT0tXU0JHSUdwaFpMQUVKVVlnYW1Ga1VsZ2ppbGt2L1MyNEFBOHNTeUN3QXlaUVdGRllzSUJFRzdCQVJGa2JJU0VnUmJEQVVGaXd3RVFiSVZsWkxiZ0FFQ3dnSUVWcFJMQUJZQ0FnUlgxcEdFU3dBV0F0dUFBUkxMZ0FFQ290dUFBU0xFc2dzQU1tVTFpd1FCdXdBRm1LaWlDd0F5WlRXQ01oc0lDS2lodUtJMWtnc0FNbVUxZ2pJYmdBd0lxS0c0b2pXU0N3QXlaVFdDTWh1QUVBaW9vYmlpTlpJTEFESmxOWUl5RzRBVUNLaWh1S0kxa2d1QUFESmxOWXNBTWxSYmdCZ0ZCWUl5RzRBWUFqSVJ1d0F5VkZJeUVqSVZrYklWbEVMYmdBRXl4TFUxaEZSQnNoSVZrdEFBQzRBQW9ydUFBQUt5b0FBQ29BQWdDT0JRNENKQWM2QUFrQUV3QVh1QUFLSzdvQURnQVNBQTByQUxnQUFDKzRBQTh2TURFVE1oY0NLd0VpRVRVMkJSWVZCZzhCSXlJMUVyeFFHQ3dlSGk0S0FWQThUQTRRRGp3ZUJ6bzgvbm9CT2k1YVdoWVlvUFFRdEFFZUFBQUFBZ0EwQUlrRkVRWUxBRUVBU3dBdEFMZ0FBQys0QUJJdnVnQkdBQmNBQXl1NkFESUFMUUFESzdvQURRQVNBQUFSRWptNEFCY1F1QUFoMERBeEFSY0hGemNYRlFjVkZ6TXlOeGNGQnhjR0t3RXZBU00zSndjakZSUUhJeUluQnlNaUp6UTNGak0zTlNjR0JTWTFOeGN6TWpVM0p6WTdBVElWRXpNMlBRRUxBUlVVT3dFM05RTWpCZ09MUEE4ZXREendEeTJBUXp6KzFBOFBGU2NlRHc4UEhoNXBTeTB0SGc5cHRFZ3dTM0haSGg1bC9ySThQSmFIcFE4ZUZ4WWVIZzg4bGg2MExaWWVEdy9EQmdzdGgvOFBMVHdlaC84ZUxXbDRlR2tQTGY4ZUQxcE9ETFFQU3lnakxYakRIaDRQRDBzdEQxcGE0VHd0L3BnVEtSNEJodjJLUy9BZUhnRktGUUFBQXdDRkFBQURaQWgvQURBQU5nQkFBR0c2QUNVQUh3QURLN29BRWdBcEFBTXJ1Z0FKQUNrQUVoRVNPYmdBQ1MrNEFBZmN1QUFmRUxnQUR0eTZBQmdBS1FBU0VSSTV1QUFmRUxnQUxOQzRBQklRdUFBOTNMZ0FFaEM0QUVMY0FMZ0FBQys0QUJvdnVnQVlBQm9BQUJFU09UQXhFeFlkQVJBekJCRUhJelFsSXdjVkVCY1NGUlFQQVJVV0Z3WUhJeUlESkJFU093RVhCaDBCRmpNMUFpTW5OVFEzQXhNVkZ6TW5JeE1WRWpzQk5qMEJOQ2Z1UzJrQnBBOHQvc1U4RCtILzRVc1BIaDBmRDBVVi9zVWtOZzhQSGo2Rkw0VnBoMHN0U3c4ZUhzTXhLUjZsL3doL0V4bzgvbHhrL3Q0dHpZd1BELzZEa1A3NDUzaHBEMXBtQTBRSEFRNmVBUVlCRGkwN2FualNEd001cFMxTFdnSCsvVjBlV3BiK0FoNzl4aU56TGJiZkFBTUFsQUFNQXNJSXVBQU1BQk1BR2dBWHVBQUtLN29BQmdBSUFBMHJBTGdBQnkrNEFBQXZNREVCTXhVQ0F5SVZCeWMxRWhNMEF6TVhGQWNtSndNekZ4UUhKaWNDb0NLazVpQXlVdTdNSml3OFNqNGM2QzQ4VEQ0Y0NMZ28rNEw4M3JvcUZsSUNYQVVha1BoaVBDZ2lGRFlIdmp3b0pCWTJBQU1BakFFS0JEMEhFd0FlQUNZQUxRQjF1Z0FqQUI4QUF5dTZBQk1BQ1FBREswRWJBQVlBSXdBV0FDTUFKZ0FqQURZQUl3QkdBQ01BVmdBakFHWUFJd0IyQUNNQWhnQWpBSllBSXdDbUFDTUF0Z0FqQU1ZQUl3QU5YVUVGQU5VQUl3RGxBQ01BQWwyNEFDTVF1QUFDM0FDNEFBQXZ1Z0FHQUJZQUF5dTRBQllRdUFBcDNEQXhBUllWRUFNVUV6TXlFelFuTlRjWE16Y1hGUWNWRUNFaklqVUFOUU0xTmhNU016WVROQ2NpQXhVek5TY2pJZ0hIdEhoYUxWNExoM2lIV21rUDhQNWNsb2NCRG5nbVF5TTNJUnRMT0VDSER4NG5CeE5FeXY3QS9sSlUvdXdCaGpVbFBCNFBEdzg4UEtYK1RWb0JEclFDN2t1MC92TCtFU3NCUGRRNit3VVBlRXNBQUFFQVVBVDhBUW9HN0FBSkFBKzRBQW9yQUxnQUFpKzRBQWd2TURFQkFnY2pKelEzRWpNV0FRcHNJQW9rSkRRb09nYVMvb29nTGo0NkFVb2VBQUVBTS8vNUFvc0lMUUFUQUJPNkFBVUFFQUFES3dDNEFBNHZ1QUFBTHpBeEFSVVVCd01WRUFFZkFUY1hGUVlqSUFNMUVEY0JRWWN0QVRzUExYZ1BGMkgreUtqd0NDMFBLdVQrbU1QOTd2MnREeDVMRHcrSEJPelNBZEdsQUFBQUFBRUFVQUFNQWo0SHVBQVBBQis0QUFvcnVnQUVBQW9BRFN1NEFBUVF1QUFSM0FDNEFBWXZ1QUFBTHpBeEV6SVhBQkVDSXljMU5oRTFFQUVuTkl4V0VnRktkTGdzOFA2bUxBZTQ0UDA2L2pUOXhnNHVzZ0ZxUEFHUUF1UThRQUFBQUFRQVN3R05BNFFHTGdBbkFDd0FNd0E1QUFzQXVBQUFMN2dBRVM4d01RRXpGaGNHSFFFVUh3RVZGQThCRlJjR0t3RW1KemNtTHdFaklnRW1OUk0xSnpZM0Z6SVhNeklmQVRNMUl3Y1ZGanNCTnljSE1qMEJJeUlDV0VzZkhUeTBMZkFQTFFsUkR4OGREeTBQRHc4YS91NUw4RXNET1E4aEtnODRRQjRQRDFvSkpCNFBMY05hSGljR0xnZEVyMThlSGc4OEhpSTRTL0REU3dkRWFVeVZELzdGRHp3Q09pMkhUaW9QYVMwZVBMUVBXa3NlLzFvZUFBQUJBRm9CRmdPU0JPWUFIQUFQdUFBS0t3QzRBQTR2dUFBQUx6QXhBUmNIRlJRekpSY1ZGQVVWRXdZckFTWVNJd1VuTlRRN0FUYzFKellCN2p3T0xBRXNIdjZvUEJRYUhtZ1lLUDdHSHJSYVNnNFVCT1lldEhnZUhpNE9LaUlPL2x4TVNBRzJIaTRzSGhDV1dsQUFBQUFBQVFDWS9qd0JlQUd3QUFzQUQ3Z0FDaXNBdUFBQUw3Z0FCQzh3TVFFeUZ3SXJBU0kxRWpVbk53RWVIRDVTWWc0ZWFBNHNBYkJLL05Zc0FhNjZwQzRBQUFFQWJ3TU1BekFEendBSEFBc0F1QUFBTDdnQUJTOHdNUUV6RnhVRUJ5YzFBdlFQTGY1dTh6d0R6eTB0TFR3dFN3QUFBQUFCQU1ZQUFBRjBBTHdBQmdBUHVBQUtLd0M0QUFBdnVBQUVMekF4SlRNWEZBY21Kd0VHTGtCUVFCNjhWRGd3SEV3QUFBQUFBUUNGQUFjQ2d3Wk1BQXdBQ3dDNEFBQXZ1QUFITHpBeEFUTVZBZ01pRlFjbk5SSVROQUpsSHBiU0hpMUwyYndHVEI3OHd2MjhoeDRQUEFHMUE2OXBBQUlBQXYvc0FxQUdtZ0FKQUJRQWViZ0FDaXU0QUJVdnVBQVFMMEVGQU5vQUVBRHFBQkFBQWwxQkd3QUpBQkFBR1FBUUFDa0FFQUE1QUJBQVNRQVFBRmtBRUFCcEFCQUFlUUFRQUlrQUVBQ1pBQkFBcVFBUUFMa0FFQURKQUJBQURWMjRBQUxjdUFBVkVMZ0FDTkM0QUFndnVBQUwzTGdBQWhDNEFCYmNBTG9BRGdBRkFBMHJNREVCSkJNUUJTTWdBelVDRXhVUUZ6TXlFeEF2QVFZQklBRWlYdjdVRHY3Mk1paUNwaDdZSnFROHVnWmFRUDFlL0lLT0FySk1BeUQ5b25qOTBxSURLZ0g0VWg0cUFBRUFSQUFBQVp3R3pBQVBBQis0QUFvcnVnQUlBQTBBRFN1NEFBZ1F1QUFSM0FDNEFBQXZ1QUFLTHpBeEV6TVhCeFVVRXhjVkZBY2lKemMwQTNBdVBCNjBMRm8ySkJDMEJzdzhXbHEwKzdnc0VING1MRnJzQlR3QUFBQUFBUUFtLy9vQ2ZnYW9BQlVBR2JnQUNpc0F1QUFLTDdnQUFDKzZBQVFBQ2dBQUVSSTVNREVCRmhFQ0F6WTNNeGNVQlNjMUFDY2lBd2NpSnpZU0FUUjRTbXFlckJBcy9teDRBU3lJVmhJdUpqUXNvQWFvSnY3TS9PcitXQkxBTHJTR0hnNEZyaUQrWEI1YTZBRXdBQUFBQUFFQVBBQVpBcklHSWdBbUFKRzRBQ2N2dUFBUkw3Z0FKeEM0QUJ6UXVBQWNMN2dBQXR5NkFBUUFIQUFDRVJJNVFRVUEyZ0FSQU9vQUVRQUNYVUViQUFrQUVRQVpBQkVBS1FBUkFEa0FFUUJKQUJFQVdRQVJBR2tBRVFCNUFCRUFpUUFSQUprQUVRQ3BBQkVBdVFBUkFNa0FFUUFOWGJnQUVSQzRBQWZjdUFBbzNBQzRBQUF2dUFBSkw3b0FCUUFUQUFNcnVnQU1BQWtBQUJFU09UQXhBUllWRkFNek1oRVFBU1kxSXpZM0Z3QVJOQ2NpRHdFakppY0FQUUVuTlNJREZ4UUhKaWNTQVlaTGFVdi8vaEZMRHgwZkxRRjNhY0pNTFI0ZkhRRU9EMndiRDFvdEQzQUdJaGhSV3Y1Ni92TCtxdjZrQ2tGRUJ3OEJHQUV4T0Uvd0xRZEVBYzdHUEE4UC92SVBMUzBMTVFIUkFBQUFBQUVBUFAvNkFsZ0hBZ0FlQUJlNEFBb3J1Z0FFQUIwQURTc0F1QUFNTDdnQUFDOHdNUUV5RndNUk14WUhGUWNYQmlzQkpqVVRCeWNTSnpZek1oY0hFeGN6TnhBQndpSUtIaEI0bGhBdUhoNGVQQlRZUEJBZUdESW9KQjRPTGtvdUJ3Sk0vdFQ5WGg2V3B2QktXaDQ4QWNnV0xnT09VRXBLV3Z6MExpNEVWZ0FBQVFCQy8vd0M3QWJtQUNJQUU3Z0FDaXNBdUFBQUw3b0FDZ0FhQUEwck1ERUJGeFVHQlFZUkZ6TTNNeklURlFJRUp6VTNOVElYTmhNMUppTWlCeUlDTXpRek1nTE9IazcrUUVvT0VLUVE4Q3l5L3NaT0VCNWMwbllhbWphNk1nSkNlSFFHNWg0UWdJNlMvcVNJSHY2WUR2NlVkS1FlRUE1d01BRk9IdUphQXpocUFBQUFBZ0JLLytnQ2RBYVdBQlVBSWdBN3VBQUtLN2dBSXkrNEFCMHZ1QUFqRUxnQUU5QzRBQk12dUFBRzNMZ0FIUkM0QUE3Y3VBQWszQUM0QUFBdnVBQVJMN29BQ3dBZ0FBMHJNREVUTXpJWEJoVVJGQk16RWlFV0hRRVFEd0VpRVRVUUV4Y0hGanNCTWhNMU5DY2pJckllSWd4YUxCNHNBUkJLNEV6Ky9oQVFEQ0lzV2g0c0VHWUdsa3lBblA3eTl2NnNBZUFtVXRMK0hJSWVCRVpxQWY3N0ZFeG9UQUcwZUU0TUFBQUFBQUVBR1AvdUFzb0ZuQUFlQUVHNEFBb3J1Z0FMQUE0QURTdTRBQXNRdUFBRjBMZ0FDeEM0QUFmUXVBQU9FTGdBRXRDNEFBc1F1QUFnM0FDNEFBNHZ1QUFBTDdvQUJnQU9BQUFSRWprd01RRXpGeFVHQXpNSEZSY0hGUmNHSXlJbkVoTWpCU2NISmowQk54WTdBVElDY0M0c1BCNFFFQkFRUEJ4Y0tDSW9JZzcrOGk1NFdqdzhhaDdNQlp3c0VIYjlMZzRlTGtyU1BIaEtBUmdEbUN3T0RoNGVIandlQUFBQUFBTUFTZ0FHQW5ZR3RBQVJBQm9BSWdBdHVBQUtLN29BRWdBT0FBMHJ1Z0FMQUE0QUVoRVNPYmdBQ3krNEFCdmNBTGdBQUMrNkFCd0FDUUFOS3pBeEFSWWRBUUlWRmhjQ0l5STFFeVlETkNVM0FSVVVGek1UTlNNRUV4Y3lOelUwSndZQ09qendlQ3hHMW5oNGpqWUJ0QTcrdG1vZWxoRCs4andlaEJKYVJnYTBFRXBNL1VKYzJMNytxTFFDS3Z3Qk1PNklFUDVxRHVwd0FmNXFSUHJnSHNJOGFuZzBBQUFBQUFJQUpmLzZBdGNHUHdBYUFDVUFOYm9BSlFBWEFBTXJBTGdBQUMrNEFBb3Z1Z0FaQUNJQUF5dTZBQjBBRlFBREs3Z0FGUkM0QUFYUXVnQUdBQW9BQUJFU09UQXhBVE15RlFZUk13Y1JGd2NpSnpjMUV5YzNOU01HSXlJMUVpRVhBUll6TWhNMUppc0JCZ2NDakI0dFN3OFBMVHc4TFE4UER3OGVnSjNTbGdFN1MvNWNMVHkvYlE5TFdvZGFCajg4dC80RkQvMm90RHhhYVMwQjRGcTBIcVgvQWRFUC9mTkxBWlVlTFRMY0FBQUFBZ0NXQWhRQmFBUnNBQWdBRUFBWHVBQUtLN29BREFBUEFBMHJBTGdBQUMrNEFBMHZNREVCRmgwQkJ5TWlKellURmgwQkJ5WTFOQUVBU2l3UVNEQUVoRXBLVEFSc0ZGUVFMRW93L21nU0dpNDhGQnBVQUFBQUFBSUFOdjFBQVlBRGRnQUdBQk1BSzdnQUNpdTZBQUlBQlFBTks3b0FCd0FGQUFJUkVqa0F1QUFBTDdnQURTKzZBQWNBRFFBQUVSSTVNREVURmhVSEpqVTBFeGNIRXdJakZTWTFOaEVuTitwYUxuaVdUQkFRT05ZODhCNHNBM1lnV0M0dUxDaitGaXc4L3dEOVRnNFdGcVFDV3NJdUFBQUFBQUVBZ1FFMkF2Y0Vid0FRQUFzQXVBQUFMN2dBQ0M4d01RRVdGUlFCQndFVkJ5SWxKaThCTkRjMkFyczgvbm9QQVpVdEt2N0NLWm9lbGxVRWJ3OHRIZjdUUy83eUxTM2hIZzg4U3kyQUFBQUFBZ0RNQVF3RHBnTElBQWNBRHdBUHVBQUtLd0M0QUFBdnVBQU5MekF4QVRNWEZRUUhKelVGTXhjVkJBY25OUU5RRUN6K2J2SThBcDRPTHY1dTlEd0N5QzRzTGp3dVNxd3VMQzQ4TGtvQUFBQUJBRlFCcFFMb0JVY0FFZ0FMQUxnQUFDKzRBQWd2TURFVE1oY0VGUlFCRkFjbk5UUTNOalVCTlRRM2tDM1NBVm4rcDJscHcrSDk4endGUitHV2gwdis4aUVxSGp3eU42SmRBV2c4SmdjQUFBSUF3Z0JFQW9RSGlBQWNBQ1lBVWJnQUNpdTRBQ2N2dUFBV0w3Z0FBOXk0QUNjUXVBQVAwTGdBRHkrNEFBZmN1QUFUMExnQUJ4QzRBQm5RdUFBSEVMZ0FIZEM2QUNNQUR3QURFUkk1dUFBREVMZ0FLTndBdUFBQUw3Z0FJeTh3TVFFek1oVVVBd2NWRmhjR0J5TW1KemNRSnpRM0VqMEJKeUlQQVNjU0F6TVdGUlFqRlNZbk5RSGVIb2ppTEFna0ZEWVFIaDRRV3JTV0xpbytManh1QkN3OFdqNGNCNGppZHY0ZXBKYlFFajRjQ0VSYUFTcHFQSGdCSEZ4b0x2QWVMQUdXK1dBZVBEd09GRFlRQUFNQUd2OWFCR3dHRUFBTEFDWUFLd0M1dUFBS0s3b0FIZ0FiQUEwcnVnQUNBQ01BRFN1NEFCc1F1QUFuMExnQUp5KzZBQkVBSndBQ0VSSTV1Z0FXQUJzQUhoRVNPVUVGQU5vQUl3RHFBQ01BQWwxQkd3QUpBQ01BR1FBakFDa0FJd0E1QUNNQVNRQWpBRmtBSXdCcEFDTUFlUUFqQUlrQUl3Q1pBQ01BcVFBakFMa0FJd0RKQUNNQURWMjRBQnNRdUFBbzBMZ0FLQys0QUFJUXVBQXQzQUM0QUFBdnVnQVBBQVVBRFN1NkFDQUFFd0FOSzdvQUVRQVRBQ0FSRWptNkFCWUFFd0FnRVJJNU1ERUJNaE1RQlNNRUV6VVFKVElCQWdVek1qY0dCeU1pTlFBU056UVhNeGNIRWpNM05oTVFKUVFCRXdJREFnTFErcUw5L0JqOXloZ0NCSnI5L0hRQmtEVEFjQm9pUER6K1RqenNTQ3d1Q0NoZVRqNFkvbjcrdmdGQ0NpYUVxQVlRL1diOGpvd2VBc2hLQXd4Ni9VRDgyaGJZRGd4dy90d0VjRjRlQWg2Ry9PWVd0Z0VjQWZKc0tQeGFBY29CalA2US9UNEFBQUlBRnY5eUF5SUk3QUFTQUJ3QUU3Z0FDaXNBdUFBRUw3b0FBQUFiQUEwck1ERUJGZ01UQnlNbkVTY2pCQlVDQnlNbkVoTVNBeGNrTlJFM0F5WWpJZ0pncEJBdVRCNHNFQTcrbUZvZVBEeEtwb3BlTGdFc0RnNHNMbUFJMWdUNGp2NGdEaXdDTE9Bc2VQM3FCandDT2dNTUE0RDZHQ3hFSkFFT3hBSTZ0QUFBQXdBbS80NERRZ2gyQUJzQUpBQXVBSGU0QUFvcnVnQU5BQ3NBRFN1NkFBY0FLd0FORVJJNXVBQUhMN2dBSWR4QkJRRGFBQ0VBNmdBaEFBSmRRUnNBQ1FBaEFCa0FJUUFwQUNFQU9RQWhBRWtBSVFCWkFDRUFhUUFoQUhrQUlRQ0pBQ0VBbVFBaEFLa0FJUUM1QUNFQXlRQWhBQTFkdUFBTkVMZ0FNTndBdUFBUkw3Z0FBQzh3TVJNV0ZUTTJOeklYRkFNVk56SVhFQUVHQnlNbU5UWVJKelUzRURNVEF4VXpBQkVtSnlJREZRTXpNZ0UzTkNNRStFd09pbmFBSk9DR2NEYit4TURHTEM1YUxDeE1MQTRzQVdnY0lKakFFQkMrQVFRZWVQNllDSFl1U2xZU3ducitRQkFROFA3TS9ncjh4ZzVNK0FNaUxCQjRBOEQrbVA0dVNnRnNBVVpFQnZ2Mkx2MFNBc0o0OElJQUFBQUFBUUFvLytZRE5BZ3BBQm9BRjdvQUNnQVhBQU1yQUxnQUFDKzZBQXdBRkFBREt6QXhBUllkQVJRakJBTUNFUlVTTXhjek5oTXpGUUlqSWdNbkVBRTJBdHBhaC83MlhyUWR0UzFhVjJ3dFRzRCtsdzhCZDhNSUtSNGVIaDdSL3RQK0wvNWNELzQrRHlZQlFnLytMd0YzbGdLSUFyN3dBQUFBQWdBSS83QURRUWdDQUJBQUdnQVR1Z0FhQUE0QUF5c0F1QUFJTDdnQUFDOHdNUUVXTXdRUkVBRUdJeUkxSXhNU0V6VTBBek1rRXpjMUFpRWlGUUZEYkdZQkxQMXNGa1E4RDFwTEhnOFBBUVBzSGpyKzhHa0lBcGFsL3JiOWlQMUJsa3NCZHdKUEF0bWx3L2tIbkFLcy8xb0JkOUlBQUFBQUFRQXUvOW9DNEFnc0FDQUFJN2dBQ2l1NkFBWUFIQUFOSzdnQUJoQzRBQTdRQUxnQUFDKzZBQklBRmdBTkt6QXhBUllkQVJRRkF4VVVNeVVYRlJRRkF4VVVNeVVYRmdVaUF4TW5OalVSTkNNMEFnNUsvcVljTEFFZUR2Nm9QSGdCbEJvVS9oQ1NNRW9zUEI0SUxCUWFMQzVDL1NoTUhoNE9FRHc4L1d3ZXBLUmFGcXdCTEFLRVRISkNBa2lXZUFBQUFRQUkvNllERkFmYUFDUUFEN2dBQ2lzQXVBQVVMN2dBQUM4d01RRVhGUlFGQmhVREZ5VVhGUlFIRkFjaUF3Y1ZCeWNTRVNZMU5EOEJFVGNuTkRjWE16WUM2Q3orNU5JUUVBRXNIdUphS0ZBT1dreW1hbW9PRUM1cURwYnFCOW84RGlna1Fzeit0aXhLSGg0aUtCNFEvSXhxbGp3OEFqWUI1Q0lxSkRZOEFSendUQ3c4RGtvQUFBRUFKdis0QTI0SUdBQWVBQis0QUFvcnVnQUlBQm9BRFNzQXVnQUtBQmdBRFN1NkFBQUFBd0FOS3pBeEFSWWRBU0FEQWhVUkVqTVNFVFUwTHdFMEpUSVhCeGNDSXlRUk5SQUJOZ01pVFA0Mm5uZzh4TFMwRUFFc0tDUnFIa2prL3FnQmRyWUlHQklhTHYyYS9vTE0vdFQrVGdFc0FaUk1ya0lzYWc1S2VNVDhicDRCcW5nQ2dBSjhwQUFBQWYvMS81Y0RUQWZwQUNZQWo3b0FEd0FsQUFNcnVBQVBFTGdBQ054QkJRRGFBQ1VBNmdBbEFBSmRRUnNBQ1FBbEFCa0FKUUFwQUNVQU9RQWxBRWtBSlFCWkFDVUFhUUFsQUhrQUpRQ0pBQ1VBbVFBbEFLa0FKUUM1QUNVQXlRQWxBQTFkdWdBVkFDVUFEeEVTT2JnQUR4QzRBQ2pjQUxnQUFDKzRBQjR2dWdBR0FCa0FBeXU2QUJVQUhnQUFFUkk1dWdBakFCa0FCaEVTT1RBeEFUTVhGU0lERnlRMUVqTTNGaFVHQXdJckFTY1RJemMxTnljRUZRTVZCeUkxSXhNbk1oTVNBVEFQUEZCa0xRRm9Qam90UzFvOEUxWVBMUzBQRHc4UC9tczhQQzBQV2g1SVAwTUg2VHdlKy9VUEd5RUQzZzhUR3AzOEtmekhMUUd6RDViaER4eGMvVjFhTFR3REcxb0RkUUVzQUFBQkFEVC83Z0c2QjV3QUVRQVB1QUFLS3dDNEFBQXZ1QUFLTHpBeEFSWWRBUVlSQWhFWEZRY2lKellURWpzQkFWQnFpSGdlU2tBYUhtaE1MQjRIbkNRWUhtaiswdnkyL2tCYUhqeHFKQVQwQWh3QUFBQUJBQ0FBQUFJOEJyd0FFd0F6dUFBS0s3b0FBd0FRQUEwcnVBQURFTGdBQWRDNEFBTVF1QUFWM0FDNEFBQXZ1Z0FOQUFjQURTdTRBQTBRdUFBRjNEQXhBVE1IRXdJakZDTW1OVGN6RmpzQk1oTTFBellDSGg0UUVDVGNocFlPTGlJNFdyQWlFQjRHdktUOXR2eFFIaHE0UEtZRGxBNENEcVFBQUFBQUFRQWovMmtETHdjbEFCd0FLN29BRkFBYkFBTXJ1QUFVRUxnQUE5QzRBQlFRdUFBSDNBQzRBQll2dUFBQUw3b0FEd0FSQUFNck1ERVRGaGNIRVRNQU5UWXpGd1lCRlJJekZRY2lBeU1EQnlNaUp6SVRBOGd4Q3g0dEFXZy9PVHhwL29tQTJVdTFzdzlMRHp3bENETTJEd2NsRHkzaC9QUUNlTzQ4UzVEODBDMzkxVHdQQWczOWV3ODhCQm9ET1FBQUFRQk0vK29Dd2dlMkFCUUFIYmdBQ2lzQXVBQUFMN29BQ0FBTkFBMHJ1Z0FRQUEwQUNCRVNPVEF4QVJjSEV4VVFBeFVYSVRjWEZDRWlOU01TRVFNMkFRQThMaEE4SGdFT2xoNzkxRHdPZUJBUUI3WXUwdjNrNFA2ZS9rWU9IaXdzaUR3Qk5nSmVBOEE4QUFBQUFRQTAvN29EOUFkWUFDNEFZN2dBQ2l1NEFDOHZ1QUFKTDdnQUx4QzRBQi9RdUFBZkw3Z0FDUkM0QUFQY3VnQUFBQjhBQXhFU09iZ0FIeEM0QUJmY3VBQVUwTGdBSHhDNEFCblF1QUFmRUxnQUhOQzRBQU1RdUFBdzNBQzRBQUF2dUFBWkw3b0FIUUFaQUFBUkVqa3dNUUVXRlJNVkZBY2pKemMxRUFNakFnTUhJZ01DSnlNWEVSQXJBU2NUSXpjMUVDYzJOek1XRXhZVE14TTFKelF6QXpCYWFpNGVMQTVhRGxwcVdsSVdwaXdRRUZvdURqd1FFQzRlSGk1S2FrcGFMc0lPU2dkWUpFYjU2R2hPREI3Z0xnS0tBZmorNXYwOExBR0dBZlFvNHY3eS9GQktBbWdPeEFMS1lFUUdCUDVDanY2UUE1UXNXandBQUFBQUFRQTYvOUlEdmdoQ0FDMEFQYmdBQ2l1NkFCRUFHUUFOSzdvQUdBQVpBQkVSRWptNEFCZ3Z1QUFTM0xnQUVOQzRBQmdRdUFBYTBMZ0FHQkM0QUIvUUFMZ0FDUys0QUFBdk1ERUJNaFVIRVJNSEZ3WUhJeUlEQUNjaUF4Y0hFd2NqSWljVEp6Y1JORGMxSnpVMk16SVRGaE1YTXpVRE55YzJBemhLSGt3UUhod2dMRGg4L3BCRUtCUVFFQjRzRUU0TUhnNE9QRHdlUEVLK1dyUjREa29PRGdvSVFwWmEvajc3ZkR5MFJBWUJ3Z1A2SVA0QzBvaitNRHdzQWJRT1RBSjJ0Rm9lU2k0OC9pQ3cvYkx3cGdVMjBrd3NBQUFDQUM4QUFBTTdCcEFBRGdBYUFCKzZBQVVBRmdBREs3Z0FCUkM0QUJ6Y0FMZ0FBQys2QUJRQUNBQURLekF4QVRNeUZ3UVJFQVVISWdNMUVqTTBBeGNWQnhJeklCRTFBaU1pQVpjUFV5VUJIZjdVbHZkVGFYaVdEdzh0NFFGWlQrekZCcENIM3YzUy9jNjhEd0h2dEFOSUx2eHNEdzh0L2lBQ3dUd0NoUUFBQUFJQVFQL3lBd0FITmdBVUFCd0FmYmdBQ2l1NEFCMHZ1QUFaTDBFRkFOb0FHUURxQUJrQUFsMUJHd0FKQUJrQUdRQVpBQ2tBR1FBNUFCa0FTUUFaQUZrQUdRQnBBQmtBZVFBWkFJa0FHUUNaQUJrQXFRQVpBTGtBR1FESkFCa0FEVjI0QUFUY3VBQWRFTGdBRU5DNEFCQXZ1QUFWM0xnQUN0QzRBQVFRdUFBZTNBQzRBQUF2dUFBTUx6QXhFeGMzQkJVUUFRWVZFUmNHQnljakV6VTBKelkxRXhFekFEYzBJeUxHUE1RQk92M2tIaEFVT0N3UUxqd3NhaXdCYUM3aTRBYzJMQTRnN3Y3by9raE13djZvV2w0cUxnVDZ4RUkyVGxiKzVQM2tBU0Q4NEFBQUFBSUFLd0FBQTc0SFJBQVlBRElBSDdvQUNBQW5BQU1ydUFBSUVMZ0FOTndBdUFBQUw3b0FHd0FTQUFNck1ERUJNeGNVQnhVQUVSVVFBeFlYQnlJbkJnOEJJZ01uTlJBSkFSSXpOalUwQVRVM016SVRNellUQWlzQklnY2pKemNqSWdNQ0doNHRXZ0ZLU3pwNlBDaDlyMEdINFVzUEFWbis4alRwLy83akhoNGY3dzh0RDJxR0R5VUlIZzhQRDV1UkIwUXRHU01QL3VQK1BoNysvZjdZazExTHBld0VIZ0dWMGg0Q3hBSE8rc24rZW9hMVNnRzBMUjcrWEZBQmdRSkpQRXRML0h3QUFBQUFBZ0FYL3lRQzlnYWtBQ0FBS3dBZnVnQURBQ2NBQXl1NEFBTVF1QUF0M0FDNEFBc3Z1Z0FBQUNvQUF5c3dNUUV6TWhVQ0JSVUFId0VWQnlJTEFTTVZGeEFyQVNJbk54TWlOVFk5QVRjekZ3Y0RGUmN6QUQwQkp5TWlBZ1k4aDRIKzNRRVJoRHhMWDgybExROUxMU0lMTFI1TFBDMFBhUzBQSGg0QldUd1BxQWFrMHY1Unh5Mzh6VkVQUER3Q0t3RjNELy8rVFV1V0JEZzhXaTE0TFI2bC9tdHBIZ0V1N2tzOEFBQUFBQUVBU1A3cEJGTUlvd0FkQUJVQXVBQUFMN2dBRHkrNkFBVUFEd0FBRVJJNU1ERUJNaGNWSXhVbUt3RUVBeE1YRUFVSEpqVTJPd0VXTXlBVE5Rc0JFaVVEbnpWL0hubEtTLzdMQnZBUC9xZHA0Uk1hSGpJM0FWZ3UwaDVHQVY0SW8yazhEMHVyL1JqOG1rdisxY1FlUUtGTHd3R2tTd0x1QVE0REhUb0FBQUFBQWYvK0FBQUQ2Z1crQUNRQUQ3Z0FDaXNBdUFBQUw3Z0FEeTh3TVFFWEZSUWpGU2NFQnhNUkZ3Y1ZGQWNtSnpVMlBRRVRKemNDS3dFSEpqMEJOeGMyTnhjRHZpdzhQUDZzRkJBT0RreEVCandPRGc0aUtFendTaXkwdER4YUJiNFFMQzRPRGl3ZS9qNytlbHBNcEVnd0hDQXNVRGc4QVE1S1dnSXNFQlFhTEM0ZURpNGVBQUFBQUFFQU52L3JBdWdGaXdBWkFCKzZBQVVBR0FBREs3Z0FCUkM0QUFqUUFMZ0FBQys2QUFzQUZnQURLekF4RXpNWEZRWWRBUmNIRlJJN0FUSVROeWMzTWgwQkFpRWlFUktRTFI1TER3OHpWQS9YY3c4OExYaVgvc2JoRndXTEhnL3J5Rm9QRDB2OWlnTkl0TU04dER6N2JnUXBBWGNBQVFBVy8vd0RJZ1plQUJVQUQ3Z0FDaXNBdUFBQUw3Z0FCeTh3TVFFV0ZSUUhFQU1ISWljQ0F6Y3lFUk1XTXhJUk5RTUN5Rm91OEVwR0ZHcmdQRnJDVUJxMEVBWmVIaDR5TnYyWS9OWXM0QUVTQTd3OC9xajlBc0lDZWdGa2hnRUFBQUFBQUFFQVQvKzFCRm9HVkFBdEFHTzRBQzR2dUFBV0w3Z0FMaEM0QUNyUXVBQXFMN2dBQmR5NEFBRFF1QUFGRUxnQUI5QzRBQllRdUFBYTBMZ0FGaEM0QUIzY3VnQWhBQ29BSFJFU09iZ0FMOXdBdUFBQUw3Z0FHaSs0QUNVdnVnQVVBQjhBQXl1NkFDRUFKUUFBRVJJNU1ERVRGaGNDRlJFWEJ4WXpOaE0xSnpZek1oY0hFak15RXpVMEp6Y1dGUk1DSXlJREJnTUNCeU1pSnlNRE5SQXpxVEVMUEE4UEN5S1d3eDRsTlZZVEQwS0JVQms4UER3dE9KcXhYU2VjckZNZUpRZ1BEMHNHVkE4dC91bjIvaS9TTGFYYkF4SnBMV2xwYWZ4ZUFoei8yT3BwRDB2OWJQMERBMlliL2YvK0NnZzhBc0cwQXU0QUFBQUFBZi9vL3dBRFRnYzBBQjRBRDdnQUNpc0F1QUFRTDdnQUFDOHdNUUVXRndZREZSSVhCaXNCSmdNR0N3RUhKd0FUTlFNM016SVRGeFE3QVJJREVqSUtlTktlZ0JZWURpTHNLc2FXVEI0QlJsN2dMQkF3aEE0ZUhyZ0hOQkFzb3Z6RUVQNnd6RHdFQWI0aS9jcis4ZzRzQWV3QjFFd0NzaXorRWhBc0F1UUFBQUFCQURyL29nT0NCK1lBSWdBanVBQUtLN29BSFFBV0FBMHJBTGdBQUMrNkFBMEFCd0FOSzdnQURSQzRBQWJjTURFQk14Y0dBd0loRlNJbk5UTTFGeUFUSXdNR0t3RWlKelVTTXhjVkJoRVdNeVFUTlFNS1BEeDhaSFQrL05BZ0hvZ0JVbUFPMHFZc0xrQUtKbkFzV2hBZUFRekVCK1k4dlB4SS9Id1FwZzRRV2dWay9walMwb1lDMEE0dTl2NElhUG9DWElnQUFRQXJBQUFEdmdXdkFCc0FFN29BQXdBVEFBTXJBTGdBQUMrNEFBOHZNREVCTXhjVkZBRVZNeVV5SFFFR0l5Y0ZJaWNBRVNjRkppYzFORGMwQXBJdExmM3pQQUpKV2g0OGFmMktMUzBDT2kzK1RVUUg4QVd2TFErdisvQXRwV2tQUEI2V1BBTytBUzRQbGgwZkR5MFBIZ0FBQUFBQkFCLy84QUtrQnEwQUZnQUxBTGdBQUMrNEFCQXZNREVUQlJVR0l5VWlBeFk3QVRJM014VVVCeVExTmhNME05TUIwUTlML3JZOExTTytTMFZSTGZEK2lUd2VXZ2F0YVI0dEh2cjJ0Rm9Qa3lGTHRMY0V2RHdBQWYvK0FDb0NvZ1lHQUF3QUQ3Z0FDaXNBdUFBQUw3Z0FCeTh3TVJNek1oTVNFd1lyQVNJQkFnTTZMaWhReVBvV0dCNDIvckJVZmdZRy9wajl3UDRJUEFPRUFTSUJDQUFBQVFBV0FBVUNqQWJnQUJrQUpib0FCZ0FVQUFNcnVBQUdFTGdBRzl3QXVBQUFMN2dBQ3krNkFCRUFDd0FBRVJJNU1ERVRGek0zRndZUkF4UVhCaU1rUFFFL0FUVVdNelVTRXlROUFWTHdXcVZMbGg1NEdGSCthdzh0ZW1jdExmNU5CdUF0RHp5Ri9TNytQcE9LUzBRbExROFBEeTJXQTZrQlVpMDhIZ0FBQUFBQkFJWUMxZ04wQmp3QUVRQVB1QUFLS3dDNEFBNHZ1QUFBTHpBeEFUTXlFeGNWQnlJUkFpY2pCZ01ISXpVQUFmd2VQdUE4UEpaMEloQmEwandPQVQ0R1BQM1VTandRQVFBQkNBWmUvZGdzU2dNY0FBQUJBQjRBQ0FVYUFMd0FEZ0FUdUFBS0t3QzRBQUF2dWdBT0FBY0FEU3N3TVNVV0Z4VUhKeU1GSVNJbk5UY0ZNd1RBUGh3ZXRCRDlxUDdHZEJRZUFRN2l2QlEyRUN3T1BEd3VIaDRBQVFCNEJUZ0NzQWFDQUFRQUM3Z0FDaXNBdUFBREx6QXhFellGQnlXU1RBSFNlUDVBQms0MDZtREFBQUFDQUZML1dRSzVCSjhBRlFBZ0FDKzRBQ0V2dUFBY0w3Z0FBOXk0QUNFUXVBQVIwTGdBRVMrNEFCZmN1QUFQMEFDNEFBQXZ1Z0FaQUE4QUF5c3dNUUV6RndjU093RVZGQWNqSWdNakFpTWlFVFVRTnpJREZSUXpNaE0xSmlzQklnSEpMUzBQS2wwZVBEdzhMUTlYdDJuL0tiOHRZV0lMSWkyV0JKOGU0ZnpsRDFFWUFVcitBZ0U3cFFLeFcvMGgwcVVEREEvU0FBQUFBQUlBTVAvZUFzUUhCQUFXQUI0QU83Z0FDaXU0QUI4dnVBQWJMN2dBQ2R5NEFCOFF1QUFUMExnQUV5KzRBQmZjdUFBSkVMZ0FJTndBdUFBQUw3Z0FEQys2QUFZQUhRQU5LekF4RXhjSEV6TTJPd0VXRlFJRkJ5WTFJeUluTlRjUUF6UVRGellUTnhBaklucE1FRHdRZ2w0dXRHYisvaEE4SG00S0htandEb3gwSG9pT0J3UXVodjBTdEppay9nNzhEZzQ4TGc1NEJBQUIzQ2o1aEE1U0FYNTRBUUFBQVFBVi8rY0NmQVVlQUJVQUY3b0FCZ0FTQUFNckFMZ0FBQys2QUFnQURnQURLekF4QVJjVkJCRUhGUlFYTWpjekZ4UUhJaWNtUFFFUU53R01MZjdVRCtHeE1DMFA4UEZaTGVFRkhnOGV5djZmaDhQb1JKWXRvakR3ZW1kcEFiYjhBQUFBQUFJQVAvL1NBcndHZVFBWEFDRUFPYmdBSWkrNEFCVXZ1QUFEM0xnQUloQzRBQkRRdUFBUUw3Z0FHTnk0QUFNUXVBQWozQUM0QUFBdnVBQUdMN29BQlFBR0FBQVJFamt3TVFFeUZ3Y1NOd2NtSXdNbkl3SXJBU0lSRURjMlBRRUROZ0VWRkJjek1oTW5Jd1lDTGxRVkhpTWdMejhHQ3c4UFc3TWV0UC9TSGgzK3FFc1BXSG9QUE9FR2VVdHArZzRpSXhvQ2N3LzlpZ0ZvQVFiNE0zTFNBVmxFK3lxV2RDSUNsQStMQUFBQ0FCWC82d0o4Qk9ZQUZ3QWhBQ1c2QUIwQUdBQURLN2dBSFJDNEFBUGNBTGdBQUMrNEFCQXZ1Z0FPQUJBQUFCRVNPVEF4QVJZZEFSQUZJeFVRRnpNeU54Y3pBaU1pQXlJbk5oTTJBeFk3QVRZUk5TWWpJZ0ZmOFA3VWFZY3RWNWtQRDJuRHNHMGFCRHd0ZFVnTElscTBGWEswQk9aSXFDMytzb01lL3ZKcDhBLytwd0puU3k4QlY4UDkxVXRVQVFVUGxnQUFBZi9BLytZRFJBYUdBQ1lBRTdnQUNpc0F1QUFXTDdvQUFBQUlBQTByTURFQkZoMEJEd0VWSnlNaUF4RXpOamNYRlFZRkV4VVVCeU1uTndNbkl5SW5OanNCRnpNeUp4SUNWUEFRTEJDMDhDd09vcWdRRVA2b0Rqd09MaDRPRUI2NEtCNGVIbmdPSWdRNEJvWUtNaDRRRGhBUS9reis1QnBPRGg1R1lQNGdobklXUEpZQjRDNDhXaDdnQW1nQUFBQUFBZ0FhL0J3Q3pBUzVBQjRBSndBanVnQWdBQm9BQXlzQXVBQUFMN2dBQ2krNkFCQUFDQUFESzdvQUlnQVhBQU1yTURFQk14Y1ZCaEVURUNNVUl5WTlBVE1XTXpJWkFTY2pBaXNCSmljUUFUYzBBUlVVTXpJVE5TSURBb0VlTFdrUDBrdTBIbU5DcFE4ZWN0Z1BOVFFCSGVIK2VqeDZzdjViQkxrdFM4aisyZnlML1YwZUpuOFBTd0h2QXQ5cC9sd0oyQUhFQVZkYVMvejA4QzBDMElmK1BnQUFBQUFCQUFyL3hnTGFCdm9BSUFCZnVBQUtLN29BRlFBY0FBMHJ1Z0FNQUJFQURTdTZBQmNBSEFBTUVSSTV1Z0FkQUJ3QUZSRVNPYmdBSFMrNEFCcmN1QUFNRUxnQUl0d0F1QUFBTDdnQUdTKzZBQW9BRXdBTks3b0FGd0FaQUFBUkVqbTZBQjhBR1FBQUVSSTVNREVUTXhjVkJ4VVRGek1TTXpJVEZ3Y2lKelVRSXdZREZqTUdCeU1tTlRjQ0l6WmtMQzRlSGc0ZVpNaVFGaDR1VGd4NHVDZ0lGaDRlTGtvZVFEZ1lCdm9zRUhoby9SSXVBWGo4eHFSTWxtb0Nva2I5ZHRKRUJpcE9TZ1lLUkFBQUFBQUNBRHIvOWdFY0JYZ0FCd0FVQUYyNEFBb3J1Z0FMQUJJQURTdEJHd0FHQUFzQUZnQUxBQ1lBQ3dBMkFBc0FSZ0FMQUZZQUN3Qm1BQXNBZGdBTEFJWUFDd0NXQUFzQXBnQUxBTFlBQ3dER0FBc0FEVjFCQlFEVkFBc0E1UUFMQUFKZEFMZ0FBQys0QUE4dk1ERVRNaGNVQnlJbk5oTVhCaEVTRXhVSEl5SURFRE95T2pCcUtDSWVMQzQ4Q0ZJdUxFWWtXZ1Y0UEN3OFNsTCtnancrL3ZUKzVQN3lIaTRDd2dFNkFBQUFBdjlRKzZvQlRnVUtBQWNBR3dBcnVBQUtLN29BREFBWUFBMHJ1QUFZRUxnQUNkQUF1QUFBTDdvQUZnQVBBQTBydWdBRUFBZ0FEU3N3TVJNV0Z4VUhJeVkxSHdFSEVoRVZFQ0VtUFFFekh3RXpNaEVDQXpadVlBZ3NUQ3lXTEE1by9xaW1IbW9PSHZBc2FoWUZDaVlrTGl3T1RLWXN4UHpZL3dCTS9QUldtbHJTRGdNTUF1SUJ6a29BQUFBQkFBei8zd0w2QmxFQUp3QWR1Z0FZQUNFQUF5c0F1QUFWTDdnQUFDKzZBQklBRlFBQUVSSTVNREVURmhjSEV6TTJFemN6RnhVQUhRRVVBVE0zRlFZSEpnRUhGUllYQmlzQkp6YzFOQ00zQXlNMFYwUUhIaDRQYXFRUEhqeitwd0hDRDFvY1BvZit0ZzhISmg0ZUhrc1BIZzh0RHdaUkhSK2wvWXBRQVVVUFBCNytNRDBQdVA3WUhqdzJGUjRCU2c5YWJTbGFTMmw0L3p3RG9od0FBQUFBQVFCTS8rWUE0Z2ZlQUE0QUw3Z0FDaXU2QUFJQURRQU5LN2dBQWhDNEFBWFF1QUFGTDdnQURSQzRBQXZRdUFBTEx3QzRBQUV2dUFBSUx6QXhFemNUQnhNREZ4UUhKelk5QVJNMmtEUUVCQTRPSGt4S0hnUWNCOUlNL283Mi9LcisxTFFjUGp4TzdCNEdKaklBQVFCSUFBQURvQVQ2QUN3QVFiZ0FDaXU2QUNNQUh3QU5LN29BREFBU0FBMHJ1Z0FDQUFjQURTdTZBQjBBSHdBakVSSTV1QUFkTDdnQUY5eTRBQUlRdUFBdTNBQzRBQUF2dUFBYkx6QXhBVElURVFjaUp4TUNKeU1DRVFjaklpYzJFUUlyQVNJUkZSY0dJeWMzTlFNME54WVZCeFV6TmpNeUZ6SVRBdHlNT0M1QUdoNGdTQjZJTER3YUZEd1VOaEI0RUNCWVBCNHVURHdlRG5SQVVGWWVTZ1Q2L0c3KzFDNDhBVHdDbmhUK2l2MjJIa3BxQWFRQkhQMWVlRnBhU3NSS0FxUlVGQTVNV2g3aXBnRUFBQUFBQUFFQUtQKzBBb0FGSmdBZ0FDZTRBQW9ydWdBR0FBb0FEU3U0QUFZUXVBQUQwTGdBQmhDNEFDTGNBTGdBRkMrNEFBQXZNREVCTXpJVEVSY0hGd2NtTlJFUUp5TUdBeEVYQmlNaUp4TUROVGNXRlFjWE16UUJrQTZ5SUJBUUVDNUthZzZnSkJBZUhrd09EaXc4UEJBUUhnVW0vVjcrOHFZOGhoNFVWQUh3QWc0c1V2MisvbHc4V2p3QmxBS2tXandXR09BUTNBQUNBRFQvMWdJeUJKUUFDd0FWQUlHNEFBb3J1QUFXTDdnQUVTKzRBQVRjdUFBV0VMZ0FDdEM0QUFvdnVBQU0zRUViQUFZQURBQVdBQXdBSmdBTUFEWUFEQUJHQUF3QVZnQU1BR1lBREFCMkFBd0FoZ0FNQUpZQURBQ21BQXdBdGdBTUFNWUFEQUFOWFVFRkFOVUFEQURsQUF3QUFsMjRBQVFRdUFBWDNBQzRBQUF2dUFBSEw3b0FEd0FHQUEwck1ERUJNaE1IRlFJakJ5TW1FUkFURWpzQk1oTTFOQ2NHQVc2TU9CQW15ZzRRNEZvaVpCQitKb2EwQkpUK2JCQmEvVTRPTWdJSUFvVDl4djMwQWh6U3pCUTJBQUFBQUFJQUlmejNBZ0VEOEFBVUFCMEFnYmdBSGkrNEFCa3ZRUVVBMmdBWkFPb0FHUUFDWFVFYkFBa0FHUUFaQUJrQUtRQVpBRGtBR1FCSkFCa0FXUUFaQUdrQUdRQjVBQmtBaVFBWkFKa0FHUUNwQUJrQXVRQVpBTWtBR1FBTlhiZ0FBdHk0QUI0UXVBQVEwTGdBRUMrNEFCYmN1QUFKMExnQUVCQzRBQlBRdUFBQ0VMZ0FIOXdBdUFBQUw3Z0FDQzh3TVFFeUV4UUJGUkFUQnlNaU5TYzNOUU0zRVRjakVoTVJNellSSmlzQkJnRStuQ2YrdGkwdEQxb1BEeTBQRHc5UEtRL2hPeTRQZUFQdy9xZncvb2tQL3F6K1NCNmxodzhQQWVCYUFUdTBBWWI5NVA3eTJBRW10R0FBQUFBQUFnQTcvUHNDc1FTWkFCY0FJZ0NSdUFBakw3Z0FEQzlCQlFEYUFBd0E2Z0FNQUFKZFFSc0FDUUFNQUJrQURBQXBBQXdBT1FBTUFFa0FEQUJaQUF3QWFRQU1BSGtBREFDSkFBd0FtUUFNQUtrQURBQzVBQXdBeVFBTUFBMWR1QUFGM0xnQUl4QzRBQlBRdUFBVEw3b0FDZ0FUQUFVUkVqbTRBQmpjdUFBRkVMZ0FKTndBdUFBQUw3Z0FCeSs2QUJzQUVRQURLN29BQ2dBSEFBQVJFamt3TVFFeUZ3Y1NFeEFISWpVak5oRVFBeU1DSXlJUk5SQUJNZ0VWRkJjek1oTTNKaU1pQWJLS0tnOUxEMW84RHp3dEhuS2N0QUVzUy83eVBCNTFiQThQTGVBRW1WbzgvVVg5Vi82TU1FdE1BZEFCbWdFMi9oRUJTbG9CaFFFUC9UOTRjeFFDV0MzaEFBQUFBUUFpQUFRQ1RRU2xBQmtBTDdvQUZ3QVBBQU1ydUFBUEVMZ0FDTnk2QUF3QUR3QUlFUkk1QUxnQUFDKzRBQXd2dWdBUkFBd0FBQkVTT1RBeEFUTVhGUWNuQWhFVkZ4UWpGU1k5QVFJak5qc0JGaDBCTXhJQjVDMDhIa3Z3RDBzOE55TWVIZzg4RDVjRXBUd2VIZy8rd3Y3bThLVThEeGNXcFFMUVdoaFJwUUZFQUFBQUFmKysvOVlDRmdUZ0FCWUFEN2dBQ2lzQXVBQUtMN2dBQUM4d01RRVhGUVFkQVJRQkZ3SWhJalVYTXpZOUFUUURKeEFsQWdZUS91SUJBQTVzL3Npa3REelMwaTRCYUFUZ0VCN0syaDZnL3Q0OC91UjRFRFNBRUNZQk1xWUJGTXdBQWYvSS8vd0J1Z2NBQUI0QVY3Z0FDaXU2QUFNQUZRQU5LN2dBQXhDNEFBSFF1QUFCTDdvQUVRQVZBQU1SRWptNEFCRXZ1QUFGM0xnQUVSQzRBQTNjdUFBUkVMZ0FFOUM0QUJEUXVBQVFMd0M0QUFFdnVBQVBMN29BQ2dBUEFBRVJFamt3TVJNM0Z4VVFNemNXRndZWEJ4TVZCZ2N2QVJFMUVDTUhKejhCTXpZMUF6ZTJJZ1lzbEJBTUdoQzBIZ1FhU0FRc2lqSUdHaHlPSGhBRy9nSnNFUDZvTWlBZ0dnWmEvUFE4Mm9ZRTZnRnlwQUdHREJRa0NCUk9BY0lPQUFBQUFRQW4vKzhDVWdSVUFCZ0FMN2dBR1MrNEFCVXZ1QUFFM0xnQUdSQzRBQWpRdUFBSUw3Z0FEOXk0QUFRUXVBQWEzQUM0QUFBdnVBQUdMekF4QVJjSEZSY0NJeUlETlRRM014Y0hGUkFUTXpZVE5UUW5OQUkwSGg0UFBNUEZXRHdlTFErSEhta2VIZ1JVSG5ndGVQeldBdjFhY3hRZWFaYisyZjdlS1FJUmxtbzdZUUFBQVFCQy8rTUNYZ1NFQUJNQUc3b0FEUUFJQUFNcnVBQU5FTGdBRWR3QXVBQUFMN2dBQmk4d01RRVdGd1lEQmdjaUVRTTJNeGNIRWpNU05TYzJBaUlmSFMzaE9qNWFQQlZGTFE4SlFzTVBOd1NFQjBSYS9JdDNFQUdrQW5aYVBIajlQd0pVcVhndEFBQUJBQ3NBQUFPK0JPd0FKUUE3dUFBbUw3Z0FJaSs0QUFQY3VBQW1FTGdBRDlDNEFBOHZ1QUFWM0xnQUV0QzRBQU1RdUFBbjNBQzRBQUF2dUFBRkw3b0FGd0FNQUFNck1ERUJGaDBCQWlNaUF5TUNLd0VWSWdNMUVqc0JGd1lWRWpNeUV5YzNGeFVRRnpNeUV3TTFOQU9STFNhN2lEc2VpbGNlcEM0UFN3OHRMUjVMYVhnUFdqeHBEMTBxTFFUc09VNy8vSm9DV1AzVkR3SllMUUdWTFlhWC9jWURETFFlTFV2OVlPUUN3UUVzRDFvQUFBQUIvLzMraGdMTkJhd0FHd0FMQUxnQURTKzRBQUF2TURFQkZ3QURFd1lyQVRRREl3SVBBU1kxTmhNQ0p6VTNNeklURnpNU0FvSkwvdjRxd3hNYVMya2U1VGdQUEZEY2xpMHRMU3hNRHkzREJhdzgvZ2Irc3Y0UlM0WUJBUDFSTUE4UExXSUM5UUhzTUMwdC9ub3RBdEFBQVFBdS9Jb0NwQVJWQUNRQU03b0FId0FZQUFNcnVnQUdBQ1FBQXl1NEFBWVF1QUFKMExnQUJoQzRBQkhjdUFBR0VMZ0FKdHdBdUFBQUw3Z0FDeTh3TVFFekZ3WWRBUU1YRlFjUUt3RW5OalVTRVNNR0F3WUhJaEVRTnhjVkJoMEJFRHNCQUJFQ095MDhIZzhQRDJrOFBGb3REeGE4UUVlSGh5MUxQQThCSFFSVlBEdHFhZjU2RHcrVys3bExSZGdCbXdMb0J2NFhQQThCd2dGbVRRODhYY0JhL3ZJQjRBRTdBQUFBQUFFQUtQL1dBd2NGWndBZkFCTzZBQVFBRndBREt3QzRBQUF2dUFBU0x6QXhBVE1XSFFFUUFSVVhNeklsTXhjVkJ5Y2pCU1kxQUQwQkl5SUhJeWMwTnpZQjZnODgvcWNlTFRVQlVTMHRTdzh0L29uU0FZWWVLdk10TGVGbEJXY1VjeDcrL1B6YkhoNldMUjVMRDVZa1JRTW01WmFXUENWaVZnQUFBQUFCQUNQL0RBS29CMjBBTHdBVHVnQUdBQ3dBQXlzQXVBQUFMN2dBSHk4d01RRVZBQWNHSFFFVUZ6Y1dIUUVIQmgwQk16Y3pGeFVHRVJZek1qY3pGd1lISWljVEp5TUhKelVTTlNJdkFSQUJOZ0tLL24wd1BNUERMZUY0RCtFUExjTTNNaUdFRHkxbHFZY2VXZzhQd3p6L21tVVBBYVIyQjIwZS91SEJYMVZwbGg0dEQwc1Bsb2M4RHp3dExkditvUzE0SHBZdDBnR0dEdzh0U3dFd0tkSThBWG9CWlVzQUFBQUJBRXovNWdEaUI5OEFEZ0EzdWdBQ0FBMEFBeXU0QUFJUXVBQUUwTGdBQkMrNEFBSVF1QUFGMExnQUJTKzRBQTBRdUFBTDBMZ0FDeThBdUFBQkw3Z0FDQzh3TVJNM0V3Y1RBeGNVQnljMlBRRVROcEV6QlFVUER4NUxTeDRFSEFmU0RmNk45ZnlwL3RTMEhENDhUK3dlQmlZeEFBRUFIUCtHQW1VSFVRQXRBQzI2QUFRQUtBQURLN2dBQkJDNEFCSFF1QUFFRUxnQUw5d0F1QUFBTDdnQUZDKzZBQklBRkFBQUVSSTVNREVCTXhZZEFRSURGUll6SHdFR0J4VXpNaFV6QWdjakp6VUFOelVqQnljL0FUUWpCeWMxTmpVMkV6VTBJeWMyQVF4YThEbnpDVzg4TFE5YWh5MFB0L3d0TFFGSkVBL2hQS1V0TGVFdC82c244QzBqQjFGcWxVdit3UDdLSGkwUFN6aGVQRHorbVBBdEhnRVNraTBlV3BZOEhnODhMYnRFd2dFQVM0YzhXZ0FCQUtnR2ZBTUdDTndBRHdBUHVBQUtLd0M0QUFRdnVBQUFMekF4QVRNeUV4Y2lKd0luSXdZUEFTTTFFZ0cySGo3Z0ZKWVVkQ0lRV21vOER0WUkzUDNXTnA0QkNBWmU3Q3hLQWVBQUFRSHNCc3dFU2dqa0FBOEFEN2dBQ2lzQXVBQU1MN2dBQUM4d01RRWlBelV6RnhZWE16WTNOak1IQWlNQytqaldEanhxV2hBaWRCU1dGT0ErQnN3QnBrSW96bFFHNkl3dy9oZ0EvLy8vd1AvbUExUUdoZ0FtQUVVQUFBQUhBRWdDT0FBQS8vLy93UC9tQTBRSDNnQW1BRVVBQUFBSEFFc0NPQUFBLy84QUpQL3FBdVVIdGdJbUFDc0FBQUFHQUF5MUFBQUEvLy8vUHYvbUFmOEgzZ0ltQUVzQUFBQUhBQXorendBQS8vOEFLd0FBQTc0SVB3SW1BRGtBQUFBSEFGLytuZjliLy84QUtQL1dBd2NIL3dJbUFGa0FBQUFuQUYvK1gvOGJBQWNBWC81Zi94c0FBUUNQQllNRWtBZHJBQlFBQndDNEFBd3ZNREVCQmk4QkppOEJKZzhCSnpZM0Z4SWZBUlkzSHdFRWk4ZlFkOG9kREdCQ0NGRXA1U3UzZVJla3ZSWUtCbi84T2tmc0NRTWJvVEVKL3g0Wi92SWlCaTYvQmc4QUFBTUFQdi9tQkhJSDJnQVhBQjhBSndBWHVnQUtBQlFBQXlzQXVBQUFMN29BREFBUkFBTXJNREVCRmgwQkZDTUVBd0lSRlJJekZ5VTJGZ1VpQXljUUFTUURNeGNWQkFjbk5RVXpGeFVFQnljMUJCaGFoLzZUWHJRZHRTMEJSMWRML2xQK2x3OEJkd0VtM1E4dC9tN3pQQUtlRHkzK2J2TThCOW9lSGg0ZWd2N1QvaS8rWEEvK1BnOHBKcDRwQVhlV0FvZ0N2cUg4ekMwdExUd3RTNjB0TFMwOExVc0FBd0RHQUFBRjVnQzhBQVlBRFFBVUFCKzRBQW9yQUxnQUFDKzRBQWN2dUFBT0w3Z0FCQys0QUFzdnVBQVNMekF4SlRNWEZBY21KeVV6RnhRSEppY2xNeGNVQnlZbkFRWXVRRkJBSGdKNE1FQlFRaDRDZWk1QVVFQWV2RlE0TUJ4TVZGUTRNQnhNVkZRNE1CeE1BQUFBQUFJQmJBWkdBMndIRGdBR0FBMEFEN2dBQ2lzQXVBQUVMN2dBQnk4d01RRXpGeFFISmljbE14Y1VCeVluQWF3dVFGQkFIZ0dTTGtCUVFCNEhCRlE0TWg1TVhsUTRNQnhNQUFFQWVBWFlBZ0FITUFBRUFBKzRBQW9yQUxnQUFDKzRBQU12TURFVEp3QTNGOEJJQVRnWU9BWFlRQUVPQ2pnQUFBRUFqd1dEQkpBSGF3QVVBQWNBdUFBTUx6QXhBUVl2QVNZdkFTWVBBU2MyTnhjU0h3RVdOeDhCQkl2SDBIZktIUXhnUWdoUktlVXJ0M2tYcEwwV0NnWi8vRHBIN0FrREc2RXhDZjhlR2Y3eUlnWXV2d1lQQUFBQkFQVDg5QU04QUM0QUVBQUx1QUFLS3dDNEFBQXZNREVsRlJRQkZ3SWhJalVYTXpZOUFUUURKd0l1QVFBT2JQN0lwTFE4MHRJdUxoNmkvdUE4L3VKNERqS0NEaWdCTXFRQUFBQUFBUUJRQlB3QkNnYnNBQWtBRDdnQUNpc0F1QUFDTDdnQUNDOHdNUUVDQnlNbk5EY1NNeFlCQ213Z0NpUWtOQ2c2QnBMK2lpQXVQam9CU2g0QUFRQlFCUHdCQ2dic0FBa0FEN2dBQ2lzQXVBQUNMN2dBQ0M4d01RRUNCeU1uTkRjU014WUJDbXdnQ2lRa05DZzZCcEwraWlBdVBqb0JTaDRBQWdDT0JRNENKQWM2QUFrQUV3QVh1QUFLSzdvQURnQVNBQTByQUxnQUFDKzRBQTh2TURFVE1oY0NLd0VpRVRVMkJSWVZCZzhCSXlJMUVyeFFHQ3dlSGk0S0FWQThUQTRRRGp3ZUJ6bzgvbm9CT2k1YVdoWVlvUFFRdEFFZUFBQUFBZ0NPQlE0Q0pBYzZBQWtBRXdBWHVBQUtLN29BRGdBU0FBMHJBTGdBQUMrNEFBOHZNREVUTWhjQ0t3RWlFVFUyQlJZVkJnOEJJeUkxRXJ4UUdDd2VIaTRLQVZBOFRBNFFEandlQnpvOC9ub0JPaTVhV2hZWW9QUVF0QUVlQUFELy93QkkvdWtFWGd0cUFpWUFNZ0FBQUFjQVh3QVVBb2IvL3dBdi80Y0ZlQWZaQUNZQUxnQUFBQWNBSkFLWS82MEFBdi8rLzdvRy9RZFlBQ1FBVXdCcHVnQU5BQThBQXl1NkFEd0FSQUFESzdvQUtBQXVBQU1ydUFBTkVMZ0FDZEM0QUE4UXVBQVcwTGdBRHhDNEFCalF1Z0FsQUE4QUtCRVNPYmdBUkJDNEFFSFF1Z0JDQUE4QUtCRVNPYmdBS0JDNEFGWGNBTGdBSlMrNEFENHZ1Z0JDQUQ0QUpSRVNPVEF4QVJjVkZDTVZKd1FIRXhFWEJ4VVVCeVluTlRZOUFSTW5Od0lyQVFjbVBRRTNGelkzRndFV0ZSTVZGQWNqSnpjMUVBTWpBZ01ISWdNQ0p5TVhFUkFyQVNjVEl6YzFFQ2MyTnpNV0V4WVRNeE0xSnpRekE3NHRQRHorcXhNUER3OUxSQWM4RHc4UEl5aEw4RXN0dExROFdnUVJXbWt0SGkwUFdnOWFhVnBURnFVdER3OWFMUTg4RHc4dEhSOHRTMmxMV2kzREQwc0Z2Zzh0TFE4UExSNytQdjU2V2t1bFNEQWRIeTFRTnp3QkRrdGFBaXNQRXhvdExSNFBMUjRCMWlORytlaHBUZ3dlNFMwQ2lnSDUvdWI5UEMwQmhnSDFKK0grOHZ4UFN3Sm5EOE1DeTE5RUJ3VCtRby8ra1FPVExWbzhBQUFBLy8vL3Z2L1dBbHNHMFFJbUFGSUFBQUFIQUYvK0VmM3QvLzhBTlAvV0JFNEUwd0FtQUU0QUFBQUhBRVFCMHYvdC8vOEFPditpQTRJSlFnSW1BRGdBQUFBSEFHbi91UUkwLy84QTJ3QkpBWlVIYmdCSEFMc0FRQWR1UFdESGRRQUFBQUlBRmY5RUFud0dzQUFVQUNNQVo3b0FCZ0FSQUFNcnVnQVhBQ0lBQXl1NEFDSVF1QUFNM0xvQUFRQWlBQXdSRWptNEFCY1F1QUFaMExnQUdTKzRBQmNRdUFBYTBMZ0FHaSs0QUNJUXVBQWUwTGdBSGkrNEFDSVF1QUFnMExnQUlDOEF1QUFXTDdnQUhTKzZBQUVBSFFBV0VSSTVNREVCTndjRUF3Y1ZGQmN5TnpNWEZBUW5KajBCRURjVE54Y0hFd01URkFjbk5qMEJBellCak53aC9uMDNEK0d4TUMwUC9oOVpMZUZjTXd3RkR3OHRTMHNQQXh3RkhoQlZQZjRxaDhQb1JKWXRvakR3ZW1kcEFiYjhBZEFOUlBYOHFmN1UvcW9jUGp6eDdCNEU5ekVBLy84QUpnT0JBZW9HcHdCSEFCRUFDZ09FTURjZUt3QUEvLzhBT3dNWUFlb0dJQUJIQUJJQUVnTU1LOGtnSlFBQS8vOEFSQU5FQVM0R3l3QkhBQkFBRmdORUs1Z2hRQUFBLy84QVFnQTdCUDRHeWdCbkFCQUFDQUttTjBnbkJnQW5BQTRBa0FBMEFFY0FFd0syQUZvK1Z5U2ZBQUQvL3dCQ0FCRUVzZ2JNQUdjQUVBQUlBcnczU0NaQkFDWUFEbHdLQUVjQUVRSWlBR1pCMEIzeC8vOEFPZ0FiQlc0R1lBQm5BQklBQWdNWVBNQWZ1d0FuQUE0QktnQVVBRWNBRXdOWUFFWTVBaUdqQUFELy8vLzkvOWtDdUFjU0FFY0FIZ1BtQjFhY2w4QmlBQUQvL3dBVy8zSURJZ3BzQWlZQUlBQUFBQWNBUC8vMUErci8vd0FXLzNJRElnc0dBaVlBSUFBQUFBY0FhZ0M4QTliLy93QVcvM0lESWd0NEFpWUFJQUFBQUFjQVh2L1hBcHovL3dBVy8zSUVRUXJ0QWlZQUlBQUFBQWNBYS8reEE0TC8vd0FXLzNJRElnblVBaVlBSUFBQUFBY0FhZisxQXNZQUFnSVdCa2dFQkFmK0FBc0FGZ0IxdUFBS0s3Z0FGeSs0QUJJdlFRVUEyZ0FTQU9vQUVnQUNYVUViQUFrQUVnQVpBQklBS1FBU0FEa0FFZ0JKQUJJQVdRQVNBR2tBRWdCNUFCSUFpUUFTQUprQUVnQ3BBQklBdVFBU0FNa0FFZ0FOWGJnQUF0eTRBQmNRdUFBSTBMZ0FDQys0QUEzY0FMZ0FBQys2QUJBQUJRQU5LekF4QVRJWEZBY2pJaWMxTkRjeUJ4VVVGek15TnpRdkFRWURTSEpLN0F6UUp1cEk3SUlXcWg2QU1KSUgvcTdrSkxBVXlpQzRJSTRxMElBV0NBei8vd0FXLzNJRElncG1BaVlBSUFBQUFBY0FoZjdyQW1qLy93QVcvM0lGT2dqc0FDWUFJQUFBQUFjQUpBSmFBQXIvL3dBby9QUUROQWdwQWlZQUlnQUFBQWNBYlA5M0FBRC8vLy92LzlvQzJ3cFdBQ1lBSlBzQUFBY0FQLzkzQTlULy93QXAvOW9DMndweUFDWUFKUHNBQUFjQWFnQ1NBMEwvL3dBcC85b0Myd3NPQUNZQUpQc0FBQWNBWHYrM0FqTC8vd0FwLzlvQzJ3bXFBQ1lBSlBzQUFBY0FhZjhqQXB6Ly8vOU4vKzRCdWduNEFpWUFLQUFBQUFjQVAvN1ZBM2IvL3dBMC8rNEJ2UW5NQWlZQUtBQUFBQWNBYXYrOUFwei8vLy94Lys0Q1R3cXlBaVlBS0FBQUFBY0FYdjlKQWRiLy93QXIvKzRDS3draUFpWUFLQUFBQUFjQWFmNi9BaFFBQS8rdi83QURRUWdDQUJBQUdnQWhBRUc0QUNJdnVBQVZMN2dBQk55NEFDSVF1QUFPMExnQURpKzRBQkxRdUFBT0VMZ0FHdHk0QUFRUXVBQWozQUM0QUFndnVBQUFMN29BSVFBSUFBQVJFamt3TVFFV013UVJFQUVHSXlJMUl4TVNFelUwQXpNa0V6YzFFaVVpRlJNekZ4VWxKelVCUTJ4bUFTejliQlpFUEE5YVN4NFBEd0VEN0I0Ry9yQnBxUTh0L2VFOENBS1dwZjYyL1lqOVFaWkxBWGNDVHdMWnBjUDVCNXdDclA5YUFWTWswdjRmTFMxK0xVc0FBUC8vLy96LzBnUDlDa1VDSmdBdEFBQUFCd0JyLzIwQzJ2Ly9BQzhBQUFNN0NSNENKZ0F1QUFBQUJ3QS8vOHNDblAvL0FDOEFBQU03Q2N3Q0pnQXVBQUFBQndCcUFMd0NuUC8vQUM4QUFBTTdDTk1DSmdBdUFBQUFCZ0JlNGZjQUFQLy9BQUlBQUFRRENERUNKZ0F1QUFBQUJ3QnIvM01BeHYvL0FDOEFBQU03QitnQ0pnQXVBQUFBQndCcC8wRUEydi8vQUM4QUFBTTdCcEFDSmdBdUFBQUFCZ0FPTWdBQUFQLy9BQ2YvNndMb0I1QUNKZ0EwQUFBQUJ3QS8vNjhCRHYvL0FEYi82d0xvQ0RRQ0pnQTBBQUFBQndCcUFMUUJCUC8vQURiLzZ3TG9DRXNDSmdBMEFBQUFCd0JlLzZmL2IvLy9BRGIvNndMb0Jyc0NKZ0EwQUFBQUJ3QnAveWYvcmYvL0FEci9vZ09DQ2N3Q0pnQTRBQUFBQndCcUFLQUNuUC8vQUFmL1dRSzVCb0lDSmdCQUFBQUFCZ0EvandBQUFQLy9BRkwvV1FLNUJ6QUNKZ0JBQUFBQUJ3QnFBSUFBQVAvL0FGTC9XUUxyQnljQ0pnQkFBQUFBQndCZS8rWCtTLy8vLzM3L1dRTi9CMnNDSmdCQUFBQUFCd0JyL3U4QUFQLy9BRkwvV1FLNUJlRUNKZ0JBQUFBQUJ3QnAvd2YrMC8vL0FGTC9XUUs1QmdzQ0pnQkFBQUFBQndDRi9tWCtEZi8vQUZML1dRUk9CUEFBSmdCQUFBQUFCd0JFQWRJQUN2Ly9BQlg4OUFLRkJSNENKZ0JDQUFBQUJ3QnMvMGtBQVAvLy8rdi82d0o4Qm9JQ0pnQkVBQUFBQndBLy8zTUFBUC8vQUJYLzZ3SjhCekFDSmdCRUFBQUFCZ0JxWkFBQUFQLy9BQlgvNndLdkI0OENKZ0JFQUFBQUJ3QmUvNm4rcy8vL0FCWC82d0o4QmdzQ0pnQkVBQUFBQndCcC90WCsvUUFEL3o3LzlnSDRCb0lBREFBVkFDSUFiYmdBQ2l1NkFBTUFDZ0FOSzBFYkFBWUFBd0FXQUFNQUpnQURBRFlBQXdCR0FBTUFWZ0FEQUdZQUF3QjJBQU1BaGdBREFKWUFBd0NtQUFNQXRnQURBTVlBQXdBTlhVRUZBTlVBQXdEbEFBTUFBbDI0QUFNUXVBQVowTGdBQ2hDNEFDRFFBTGdBQnkrNEFCMHZNREVURndZUkVoTVZCeU1pQXhBekFUYzJBUjhCQmdBSEFSY0dFUklURlFjaklnTVFNN0l1UEFoU0xpeEdKRnIrcWhveUFmQmNJbkQrU0NBQkFpNDhDRkl1TEVZa1dnUHlQRDcrOVA3ay92SWVMZ0xDQVRvQ1hCSWkvckljTWtJQkxBNytNRHcrL3ZUKzVQN3lIaTRDd2dFNkFBQUMveXovOWdJS0JvNEFEQUFWQUZtNEFBb3J1Z0FEQUFvQURTdEJHd0FHQUFNQUZnQURBQ1lBQXdBMkFBTUFSZ0FEQUZZQUF3Qm1BQU1BZGdBREFJWUFBd0NXQUFNQXBnQURBTFlBQXdER0FBTUFEVjFCQlFEVkFBTUE1UUFEQUFKZEFMZ0FCeTh3TVJNWEJoRVNFeFVISXlJREVETUJKZ0FuUHdFQUh3R3lMandJVWk0c1JpUmFBUUFpL2pCMkpHQUNDallhQS9JOFB2NzAvdVQrOGg0dUFzSUJPZ0gwRFA3Nk9pd1lBU1FlRUFBQUFBQUMvNnIvOWdJSUJ0SUFEQUFjQUdlNEFBb3J1Z0FEQUFvQURTdEJHd0FHQUFNQUZnQURBQ1lBQXdBMkFBTUFSZ0FEQUZZQUF3Qm1BQU1BZGdBREFJWUFBd0NXQUFNQXBnQURBTFlBQXdER0FBTUFEVjFCQlFEVkFBTUE1UUFEQUFKZEFMZ0FCeSs0QUEwdnVnQVJBQWNBRFJFU09UQXhFeGNHRVJJVEZRY2pJZ01RTXhNek1oTVhJaWNDSnlNR0R3RWpOUkt5TGp3SVVpNHNSaVJhSkI0KzRCU1dGSFFpRUZwcVBBN1dBL0k4UHY3MC91VCs4aDR1QXNJQk9nTGcvZFEyb0FFSUJsN3NMa3dCNEFBRC81ci85Z0djQld3QURBQVRBQm9BWGJnQUNpdTZBQU1BQ2dBTkswRWJBQVlBQXdBV0FBTUFKZ0FEQURZQUF3QkdBQU1BVmdBREFHWUFBd0IyQUFNQWhnQURBSllBQXdDbUFBTUF0Z0FEQU1ZQUF3QU5YVUVGQU5VQUF3RGxBQU1BQWwwQXVBQUhMN2dBRkM4d01STVhCaEVTRXhVSEl5SURFRE1ETXhjVUJ5WW5KVE1YRkFjbUo3SXVQQWhTTGl4R0pGcTZNRUJRUWg0QmtqQkFVRUllQS9JOFB2NzAvdVQrOGg0dUFzSUJPZ0Z3VkRneUhreGVWRGd3SEV3QUFQLy8vMXovdEFOZEIyc0NKZ0JOQUFBQUJ3QnIvczBBQVAvLy83Zi8xZ0l5Qm9JQ0pnQk9BQUFBQndBLy96OEFBUC8vQURULzFnSXlCekFDSmdCT0FBQUFCZ0JxTWdBQUFQLy9BRFQvMWdLbEJ2MENKZ0JPQUFBQUJ3QmUvNS8rSWYvLy84RC8xZ1BCQm9ZQ0pnQk9BQUFBQndCci96SC9HLy8vQURULzFnSkRCYTBDSmdCT0FBQUFCd0JwL3RmK24vLy9BQnIvTGdJeUJYTUNKZ0JPQUFBQUJ3QU8vNVgvSi8vLy84Zi83d0pTQm9JQ0pnQlVBQUFBQndBLy8wOEFBUC8vQUNmLzd3SlNCekFDSmdCVUFBQUFCZ0JxUUFBQUFQLy9BQ2YvN3dLVkJ4TUNKZ0JVQUFBQUJ3QmUvNC8rTi8vL0FDZi83d0pTQllNQ0pnQlVBQUFBQndCcC91WCtkZi8vQUM3OGlnS2tCekFDSmdCWUFBQUFCZ0JxZUFBQUFQLy9BQzc4aWdLMUJhMENKZ0JZQUFBQUJ3QnAvMG4rbndBQ0FLSUFBQUZrQ0JZQUJnQVBBQmU0QUFvcnVnQUJBQUFBRFNzQXVBQUFMN2dBREM4d01STVhFUWNqSmhFVEZoY1ZCaU1pSnpUT2FoQWVQQzVlQ2g0c1doNElGano2b2hRcUFpejhNQ2c4T2xCMlBBQUJBRlFCcEFMb0JVWUFFZ0FYdUFBS0s3b0FCQUFPQUEwckFMZ0FBQys0QUFndk1ERVRNaGNFRlJRQkZBY25OVFEzTmpVQk5UUTNrQ3pTQVZyK3BtaHF4T0Q5OUR3RlJ1Q1dpRXIrOGlJcUhqd3lPS0pjQVdnOEpnZ0FBQUlBVkFGWUJKUUZVQUFNQUJvQU03Z0FDaXU0QUJzdnVBQVhMN2dBR3hDNEFBalF1QUFJTDdnQUF0eTRBQmNRdUFBUTNMZ0FITndBdUFBRUw3Z0FEUzh3TVJNQUZSUUJKellBTlFFMU5EY2xNZ0FWRkFBSEp6WUFOUUUxTkt3Q1BQM3lXaFFCelAzMFBBR3NMQUlzL2xwb1VDd0JxdjMwQlRUK25JaEsvbHBNT0FFdVhBRm9QQ1lJR1A2SWhreitoaW95TEFGU1hnRm9QQ1lBQUFFQVlnWm1BbmdJdkFBR0FBdTRBQW9yQUxnQUJDOHdNUk0zSGdFM0Z3QmlLb2lBb2tMKy9BaHlMc0lHNUFyOXRBQUFBQUFCQUNZRjdnRG9CdDRBQ0FBUHVBQUtLd0M0QUFVdnVBQUFMekF4RXhZWEZRWWpJaWMwZ0Y0S0hpeGFIZ2JlS0R3OFVIZzhBQUFBQUFJQWFBVkdBcllIeUFBRUFBa0FJN2dBQ2lzQXVBQURMN2dBQlMrNkFBQUFCUUFERVJJNXVnQUlBQVVBQXhFU09UQXhFeWNBTnhjREp3QTNGNlkrQVJ3R1NrcEFBUndHU2dWd1pnSFFJbEQ5em1RQjBDUlFBQUFCQUhiL1hBRXdBVXdBQ1FBUHVBQUtLd0M0QUFJdnVBQUlMekF4SlFJSEl5YzBOeEl6RmdFd2JDQUtKQ1EwS0RyeS9vb2dMajQ2QVVvZUFBQUNBSTcvYkFJaUFaWUFDUUFUQUJlNEFBb3J1Z0FPQUJJQURTc0F1QUFBTDdnQUR5OHdNUk15RndJckFTSVJOVFlGRmhVR0R3RWpJalVTdWxJWUxoNGVMQWdCVUR4S0VBNFFQQjRCbGp6K2VnRThMRnBhRmhhZzlnNjBBUndBQVAvL0FDTURQd0ZaQlljQVJ3Qk9BQVFEVkNibkhzTUFBUC8vQUFRRVVBRmdCWndBUndCTy8rRUVYQ3VzRVlFQUFBQUIvL2IvbkFMYUJkZ0FLZ0FadUFBS0t3QzRBQTR2dUFBZ0w3b0FJd0FPQUNBUkVqa3dNUUV6RnhVR0R3RTNNeGNWQmdjREJ6WVRCZ2NuTlNVMk53WUhKelVsTndNMk14Y1dFeElSTmhjQ0F3Y0NnQkFzZW13Q3lnNHVqbndTbGdnU2htZzhBVEFFQktSNlBBRmlCS1kwUmg0T1VvWTRVRWFjQWdMS0xpd0dDRllZTGl3UUV2NFFITTRCSmhZYUxrb2tMQ3dVSGk1S0dpZ0NubDYwa1A3aUFTZ0JDaTVXL3VEK2ZCNEFBZi9hLzJZRCtBZ0VBQjBBQUFFekZ4VUdCd0lISlFVSEpBY0FOellUQmdjbk5UY0RBZ0VYQVNjU0V3Sk1FQ3orWGlBK0FWUUIxaTcrWGdiK0JDWlNHSEl1UE9RY2pBUE1CdjNRamdJSUF0NHVMQklPL3FTOHJJeDJ0aXIrNU1EU0FWd1NEQzVLRkFNcUFoajlUSUlCS0VUOTJQNjZBQUFBQWdDQUFDWURTZ1dHQUNjQU1BQkp1QUFLSzdvQUFBQXRBQTByQUxnQUZDKzRBQUF2dWdBTUFCUUFBQkVTT2JvQUVRQVVBQUFSRWptNkFCWUFGQUFBRVJJNXVnQWlBQlFBQUJFU09ib0FKZ0FVQUFBUkVqa3dNUUVYQmdjV0VBY1RCaXNCTkNjR0p5TW1Kd1lQQVNZMUZoTW1OamNDSnpVM016SVhOaGNXRnhJQkJoY1dFelVtSndZREFFcFdQa3crZkJRYVNqaEllQkJBTG1Ja0VEd2tkam9LSW1vY0xDNGNVRTZXSkI1ZS9xUkVpTUFnSG9adUJZWThxSlNrL3JxTy92WktkSTVPQ2c0MDdpQU9EaTRvQVdTUXpKWUJFaDR1TE9weURnb2NBUmo5dk15eXFnR2FSdHdVUGdBQ0FHTC81Z0Q0Qjk0QUJ3QVBBQmU0QUFvckFMZ0FEQys0QUFRdnVnQVBBQUFBRFNzd01Sc0NGQWNuTmhNbkV6WXpOeE1IQStBSUVFeEtIZ0lLREJ3R05BUUVEQVB3L2pEK0lCdytQRTREZm1vRFNESU0vbzcyL3VJQUFBTC8yZ0FtQkI0R29BQWFBQ0VBQUFFSEZTUUhGUlFYQUFVaUp3UUNKU0kxRnpNRUpTWUNKU1luQWhNM05pY2xCaGNDbmhEKzFpVEdBaGo5UUM0Z0FnQ28vcmlrdER3Qm5QNmE2dDRCVWhwR0pNYkFqa3IrM3Y2MEJadytIcjYwSHFDdS9tUStDcVQrdkRSNEVDRFlOZ0hPeUNhdUFZYjd6QlFxYXZ6QTNBQUFBd0FpLzc0RVZBVmtBQk1BR3dBaUFBNjRBQW9ydWdBRkFCRUFEU3N3TVFFSEFnOEJGUlFYTmpjekZ3WUhJaWNtUFFFU0Z3UUNKU1FURWpZQkVqTUVFaVVpQXR3YTlqUU80SFl3TEJBVW9QSllMazZTQWxUay9pRCtraWlHdHY3Mk9PSUI4REQrSk1ZREdHSUJRQ3FJd3VoRU5KWXVwbUR3ZW1ob0FqZ1FoUHIwWWo0Q2VnSG9wUDFPL2N3c0JJUXlBQUFBQUFIL1hQNUlBMFFHaGdBakFCTzRBQW9yQUxnQUZDKzZBQUFBQ0FBTkt6QXhBUllkQVE4QkZTY2pJZ01STXpZM0Z4VUdCUU1GSmlVVEp5TWlKelk3QVJjek1pY1NBbFR3RUN3UXRQQXNEcUtvRUJEK3FCaitpRHdCV0JvUUhyZ29IaDRlZUE0aUJEZ0doZ295SGhBT0VCRCtUUDdrR2s0T0hrWmcrNGdVZUFnRDBDNDhXaDdnQW1nQUFBRC8vd0FUQW9jQnVnVUJBRWNBUVAvYkF0WXIvUjRPQUFBQUFRQ0FBVFlDOWdSdUFCQUFEN2dBQ2lzQXVBQUlMN2dBQUM4d01RRVdGUlFCQndFVkJ5SWxKaThCTkRjMkFybzgvbm9PQVpRc0t2N0NLcG9lbGxZRWJnNHVIUDdTU3Y3eUxpemdIaEE4U2k2QUFBQUFBZ0NBQVRZRWFnU2lBQkFBSVFBUHVBQUtLd0M0QUFndnVBQVJMekF4QVJZVkZBRUhBUlVISWlVbUx3RTBOellCRmhVVUFRY0JGUWNpSlNZdkFUUTNOZ0s2UFA1NkRnR1VMQ3Ird2lxYUhwWldBc0k4L25vT0FaUXNLdjdDS3BvZWxsWUViZzR1SFA3U1N2N3lMaXpnSGhBOFNpNkFBU29PTGh6KzBrcis4aTRzNEI0UVBFb3VnQUFBQUFBQkFId0J4Z0dJQXd3QUJ3QUFFellYQmljbUp6VFdqQ1l3WkZvZUF2UVluS29XS0hnOEFBQUFBUUJvQXdZQ1hBT0VBQVVBRjdnQUNpc0F1QUFGTDdnQUFpKzZBQUVBQkFBTkt6QXhBVGNYSmdVM0Fpd3NCTXorMkFZRGNnWnlKaEJvQUFBQUFRQmlBdUFEdEFOWUFBY0FHN2dBQ2lzQXVBQUJMN2dBQnkrNEFBVXZ1QUFCRUxnQUE5d3dNUUV6RnhVa0J5YzFBM2dPTHYzSTNqd0RWaXd1Q2lZc1RBQUFBQUFCQVBiLzVnTzRCOTRBR3dCVHVBQUtLN29BQlFBTkFBMHJ1QUFGRUxnQUI5QzRBQWN2dUFBTkVMZ0FEOUM0QUE4dnVBQU5FTGdBRk5DNEFCUXZ1QUFGRUxnQUdOQzRBQmd2dUFBRkVMZ0FHdEM0QUJvdkFMZ0FDaSs0QUJndk1ERUJNeGNWQmdjVEF4Y1VCeWMyUFFFVEJnY25OU1VUTmpNM0V3Y1ZBM3dPTHJxV0RBNGVURW9lQW54Z1BBRVlBaHdHTkFRRUJZZ3NMaFFZL1I3KzFMUWNQanhPN0I0RGVoWVlMRXdnQWtJeURQNk85ZzRBQUFBQUFRRFcvK1lEc0FmZUFDUUFRN2dBQ2l1NkFDUUFHQUFOSzdnQUdCQzRBQWJjdUFBTTBMZ0FEQys0QUJnUXVBQVQwTGdBR0JDNEFCN1F1QUFlTDdnQUpCQzRBQ0xRQUxnQUVDKzRBQ0l2TURFQk14Y1ZCZ2NYTnpNWEZRWVBBUk1VQnljMkV3WUhKelVsSndZSEp6VWxBell6TnhNSEExb1FMSnlFQXZ3T0xxeVFCQlJNU2g0S2hHZzhBU2dDa25BOEFUNEVIQVkwQkFRRm5DNHNFaFNXSGk0c0ZCWlkvSGdjUGp4TUE2SVdHaTVLSXBJWUhDNUtKZ0lxTWd6K2p1d0FBUUE0L25nQm1nQlFBQTBBR2JnQUNpc0F1QUFJTDdnQURTKzZBQVVBQ0FBTkVSSTVNREUzQndZM01qY1hCaXNCSmljME4raEtIbXd3T0VaZ2loQmNER0FNdHA0NGNENnFETlFxemdBQUFBQUJBRHIvOWdEK0EvSUFEQUJkdUFBS0s3b0FBd0FLQUEwclFSc0FCZ0FEQUJZQUF3QW1BQU1BTmdBREFFWUFBd0JXQUFNQVpnQURBSFlBQXdDR0FBTUFsZ0FEQUtZQUF3QzJBQU1BeGdBREFBMWRRUVVBMVFBREFPVUFBd0FDWFFDNEFBY3Z1QUFBTHpBeEV4Y0dFUklURlFjaklnTVFNN0l1UEFoU0xpeEdKRm9EOGp3Ky92VCs1UDd5SGk0Q3dnRTZBQUFBQVFCZ0FUQUVQQU0rQUFzQUM3Z0FDaXNBdUFBSEx6QXhFelkzQlFRM05nTW5FeU1FWUFvcUFUWUJmdHdZTUdBVURQN21BcUJRRUF3Y05ETDk4Z2dCWERBQUFBQUJBR2dEQmdKY0E0UUFCUUFYdUFBS0t3QzRBQVV2dUFBQ0w3b0FBUUFFQUEwck1ERUJOeGNtQlRjQ0xDd0V6UDdZQmdOeUJuSW1FR2dBQUFBREFDNEFBQU02Qnp3QUNRQXFBRFFBSjdnQUNpdTZBQmdBQlFBTks3b0FEQUF3QUEwcnVnQUFBQklBRFNzQXVnQWFBQU1BRFNzd01RRVFCUWNpQXpVU013QUJGaFVHQnhJWE5oRURBaU1pQXhVU016STNKaThCSXhVWEZDc0JJaWNUTnpNWEJ4VVhOajBCSnlNaUF6cisxSmIyVkdwNEFpTCs0bmdPeW9aS1hDZ203TVptTE9LR1VESllXaGdJTEJZVUJpQWFDQ0lJRU5BaUNGd0MvUDNPdkE0QjdyUURTQUZTL2J3ZWRPWisvaTR5c0FGc0FaQUJNdnlvU3Y0Z2FqanEwQWlPOGlvRFdoaHM0RG9TcUlRcUlBQUFBQUVBV2dEYUErSUU1Z0FwQUQrNEFBb3J1Z0FKQUJJQURTdTZBQTRBRWdBSkVSSTV1QUFTRUxnQUdkQzRBQWtRdUFBZTBMZ0FIaThBdUFBTEw3Z0FIUys2QUE0QUN3QWRFUkk1TURFQk14Y1ZCZ2NHS3dFbkJnY25OU1VtTnpZakJTYzFORHNCTnpVbk5qY1hCeFVVTXlVWEZSUUZGUk1EcGc0dTNxd0lDQjRFNG9ROEFXQWVDQXdvL3NZZXRGcEtEaFEyUEE0c0FTd2UvcWcyQWFBc0xoUVVDQUllSUN4TUlreDQzQjR1TEI0UWxscFFLQjYwZUI0ZUxnNHFJZzcrZkFBQUFBQUJBQTcvbEFJMkJEd0FJd0EydUFBS0s3Z0FKQys0QUI4dnVBQUUzTGdBQXRDNEFBSXZ1QUFrRUxnQUZOQzRBQlF2dUFBYjNMZ0FETkM0QUFRUXVBQWwzREF4QVJVWEFoTUdJeVlIQmlNaUp3WUhGaWMyTlRZRE5UUTNNeGNIRlJJM05oTTFOQ2MwQWlnT0dCSW9HRFFNTkVRd2Rob29GRllpRUNZOEhpNFFRbVJvSGg0RHZpNTQvckwrU2dSYUdHUjJLcFlRSXA1WThnRk9XbklVSG1pVy9ZZ3VLZ0lRbG1vOFlBQUFBUUJLLys0RHVnVGVBQjBBQzdnQUNpc0F1QUFITHpBeEFUTTJCd01URkFjbk5CTUdCd1lERndjaUp6YzFFelVqQmlNaUVSSWhBckllNmg0WUVFd3NKQ0FxUkNZc1BEd3NEalllZ0o3U2xnRThCTlFLTnYyQS9pQWNQanBPQS9JRUFvRDlDTFE4V21ndUFZUWVwZ0VBQWRBQUFBQUJBR2dCNGdEOEFxZ0FCd0FBRXpZWEJpY21KelNhVGhRYU9ESVFBcG9PWG1nT0dFZ21BQUQvL3dBM0FKMENLd0wxQWljQUdRQXMvb2tBQndEWC84Ly9DUUFBQUFILzNQM2dBeHdIZWdBakFKTzRBQW9ydWdBVUFCQUFEU3U2QUJrQUNRQU5LN29BQmdBUUFCa1JFamxCQlFEYUFBa0E2Z0FKQUFKZFFSc0FDUUFKQUJrQUNRQXBBQWtBT1FBSkFFa0FDUUJaQUFrQWFRQUpBSGtBQ1FDSkFBa0FtUUFKQUtrQUNRQzVBQWtBeVFBSkFBMWR1QUFVRUxnQUk5eTRBQTNRdUFBTkw3Z0FHUkM0QUNYY0FMZ0FGeSs2QUJzQUJBQU5LN2dBR3hDNEFCM1FNREUzQkJNU0l3WUhKd0FSSmljaUJ3TUNBd1luTmhNM05qY3lGeFFERlRjeUZ3SUhCaWZPQVVwdUhuaWFXQjRCUEJ3Z21MSU9FRW91WUVwWXJvcDJnQ1RnaG5BMkZ2aVFzdGpnQXFZQmFEZzZvQUZTQVRKRUJ1RCtMdjVFKyt5Z1FzNEhvSUpXRXNKNi9rQVFFUEQ5c09aMFVBQUFBQUlBS1AvRUFxQUc1Z0FSQUJnQVA3Z0FDaXU2QUJJQURnQU5LN2dBRWhDNEFBSFF1QUFCTDdvQUN3QU9BQklSRWprQXVBQUFMN2dBREMrNkFBWUFGd0FOSzdvQUN3QU1BQUFSRWprd01STVhCeEV6TmpzQkZnSUdKd01qRXhBbk5CTVNHd0VRSXdaMFRCQVFnbDR1MHRqNkxnaHdMaXlRVUxwR2lPSUc1aTZHL3A2MHF2ellXRDcrTEFLR0JBQlFLUHVXL3VJQmtnRklBUUM2QUFJQUV2N0tBZmdFOEFBUUFCa0FiN2dBQ2l1NkFBSUFGUUFOSzBFRkFOb0FGUURxQUJVQUFsMUJHd0FKQUJVQUdRQVZBQ2tBRlFBNUFCVUFTUUFWQUZrQUZRQnBBQlVBZVFBVkFJa0FGUUNaQUJVQXFRQVZBTGtBRlFESkFCVUFEVjI0QUFJUXVBQWIzQUM0QUFndnVBQU5MN29BQndBSUFBMFJFamt3TVFFeUV4UUJGUkEzQnlNaU53TTNBaWMyQXhFek5nTVNKeU1HQVQ2Y0h2NitCQzRPV2hncVpoSUVVQW9PMmdvQ1dnNTRBL0QrUFBEKzlCRCtyQndlbGdWNEdQNFdHdEQ5NVA3eWJnRWVBUm9NWUFBQ0FHVC9RZ1BrQmJ3QUZnQWhBQnU0QUFvcnVnQWRBQWdBRFNzQXVBQUNMN29BQ3dBYUFBMHJNREVCTmpjWEJ3QUJCQU0xTkRjZ0V4SUJCeWMzQmljMkZ4TUNLd0VHSFFFU0Z6TXlBWkF1Vmx4b0FkeitEUDZpTGxJQktqTHkvdFJFVmpvZTBob3E0alJ3RWpBd1ZEQW1CTlJNbkN6ay9mejlSS29DbHNSTUpQNCtBYWdCSk1JbThneFVmQkQ4QWdGc0NrcHcvbm9TQUFFQUdBQnNBb3dFSkFBWEFDMjRBQW9yQUxnQUN5KzRBQk12dWdBQUFBc0FFeEVTT2JvQUNBQUxBQk1SRWptNkFCY0FDd0FURVJJNU1ERUJGd1lIRXdZakJnTUdEd0VtTlRZVEFpYzFOek15RXhjQ0htNm9STFFVR2pxY3REZ1FQRkRBbGl3c0xpeE1MQVFBWkxxNi9yeEtKZ0V3K2pBT0RpNWlBUTRCZ2pBdUxQN2tiQUFBQUFBQkFIQUZWZ0prQmRRQUJRQVh1QUFLS3dDNEFBVXZ1QUFDTDdvQUFRQUVBQTByTURFQk54Y21CVGNDTkN3RXpQN1lCZ1hDQm5JbUVHZ0FBQUFCQUlRQUJnS0NCa3dBREFBUHVBQUtLd0M0QUFjdnVBQUFMekF4QVRNVkFnTWlGUWNuTlJJVE5BSmtIcGJTSGl4TTJyd0dUQjc4d3YyOGlCNFFQQUcwQTdCb0FBRUFjUDNrQVlUL2lnQUhBQSs0QUFvckFMZ0FBQys0QUFJdk1ERVhGZ2NqSWpVMkovaU02QTRldUdSMjBOWXMrR0FBQVAvL0FCYi9jZ011Q240Q0pnQWdBQUFBQndDK0FMWUJ3di8vQUJiK0FRT0NDT3dDSmdBZ0FBQUFCd0RVQWVqL2lmLy9BQmIvY2dNaUNkNENKZ0FnQUFBQUJ3RGpBSm9FQ3YvL0FCYi9jZ1U2QzZJQUpnQWdBQUFBSndBa0Fsb0FDZ0FIQUdvQ3FnUnkvLzhBS1AvbUF6UUtjZ0ltQUNJQUFBQUhBR29CSWdOQy8vOEFLUC9tQTRRTHBnSW1BQ0lBQUFBSEFGNEFmZ0xLLy84QUtQL21BNjBMQmdJbUFDSUFBQUFIQUYvL1l3SWkvLzhBS1AvbUF6UUptQUltQUNJQUFBQUhBTDhCeGdLNi8vOEFDUCt3QTBFTEpnSW1BQ01BQUFBSEFGLytRd0pDLy8vL3kvK3dBMEVJQWdJbUFDTUFBQUFIQU9QL1cvN1QvLzhBTHYvYUF1QUtUZ0ltQUNRQUFBQUhBTDcvMHdHUy8vOEFMdi9hQXVBTHJnSW1BQ1FBQUFBSEFGLytkUUxLLy84QUx2L2FBdUFKcUFJbUFDUUFBQUFIQUw4QkNBTEsvLzhBTHYvYUF1QUpQZ0ltQUNRQUFBQUhBT01BSEFOcS8vOEFKdis0QTI0SjVnSW1BQ1lBQUFBSEFMNEFUQUVxLy84QUx2NmdBdUFJTEFJbUFDUUFBQUFIQU5RQTFnQW8vLzhBSnYrNEEyNExwZ0ltQUNZQUFBQUhBRjcvMVFMSy8vOEFKdjNrQTI0SUdBSW1BQ1lBQUFBSEFPVUFzQUFBLy84QUp2KzRBMjRKcUFJbUFDWUFBQUFIQUw4QklnTEsvLy8vOWYrWEEwd0xwZ0ltQUNjQUFBQUhBRjcvelFMSy8vOEFOUC91QW5vS0JnSW1BQ2dBQUFBSEFMNEFBZ0ZLLy84QU5QL3VBYm9Kc0FJbUFDZ0FBQUFIQUw4QXZnTFMvLy8vNGY1eEFib0huQUltQUNnQUFBQUdBTlNwK1FBQS8vOEFOUC91QXJnSXBnSW1BQ2dBQUFBSEFPTUFWQUxTLy84QU5QL3VBMEVKeUFJbUFDZ0FBQUJIQUd2LzZRTVlMdWs1dFAvL0FDQUFBQU9ZQ1o0Q0pnQXBBQUFBQndCZUFKSUF3di8vQUNQOTVBTXZCeVVDSmdBcUFBQUFCd0RsQUlBQUFQLy9BRXovNmdMQ0Nmb0NKZ0FyQUFBQUJ3QnFBRVlDeXYvL0FFei82Z0xDQ0NZQ0pnQXJBQUFBQndCdEFZUUJPdi8vQUV6OTVBTENCN1lDSmdBckFBQUFCd0RsQUlnQUFQLy9BRXovNmdMQ0I3WUNKZ0FyQUFBQUJ3RGNBVWdBQVAvL0FEci8wZ08rQ2ZvQ0pnQXRBQUFBQndCcUFNZ0N5di8vQURyLzBnTytDNjRDSmdBdEFBQUFCd0JmL3VzQ3l2Ly9BRHI5NUFPK0NFSUNKZ0F0QUFBQUJ3RGxBUW9BQVAvL0FDOEFBQU03Q0hjQ0pnQXVBQUFBQmdDK1Nyc0FBUC8vQUM4QUFBTTdDWElDSmdBdUFBQUFCd0RBQUR3QnF2Ly9BQzhBQUFNN0NOb0NKZ0F1QUFBQUpnQU9OQUFBQndCcUFDSUJxZ0FBLy84QUx3QUFBenNIdGdJbUFDNEFBQUFIQU9NQUpBSGkvLzhBRi84a0F2WUlzZ0ltQURFQUFBQUhBR29BVEFHQy8vOEFGLzhrQXZZSkRnSW1BREVBQUFBSEFGLytQd0FxLy84QUYvM2tBdllHcEFJbUFERUFBQUFHQU9WK0FBQUEvLzhBU1A3cEJGTUtjZ0ltQURJQUFBQUhBR29CWWdOQy8vOEFSZndGQkZNSW93SW1BRElBQUFBSEFHei9VZjhSLy84QVNQN3BCSFlMcGdJbUFESUFBQUFIQUY0QmNBTEsvLzhBU1B5MUJGTUlvd0ltQURJQUFBQUhBT1VCSHY3Ui8vLy8vZ0FBQStvSXR3SW1BRE1BQUFBSEFGLys2Ly9ULy8vLy92M2tBK29GdmdJbUFETUFBQUFIQU9VQWlnQUEvLzhBTnYvckF1Z0g5d0ltQURRQUFBQUhBTDRBTFA4Ny8vOEFOdi9yQXVnR3JnSW1BRFFBQUFBSEFPTUFUZ0RhLy84QU52L3JBdWdJc2dJbUFEUUFBQUFIQU1BQUVnRHEvLzhBTnYvckF1Z0h1UUltQURRQUFBQUhBSVgrWmYrNy8vOEFOdjU0QXVnRml3SW1BRFFBQUFBR0FOUmVBQUFBLy8vLzR2L3JBK01IOVFJbUFEUUFBQUFIQUd2L1V3Q0svLzhBVC8rMUJGb0lnZ0ltQURZQUFBQUhBR29BK2dGUy8vOEFULysxQkZvSnZnSW1BRFlBQUFBSEFGNEFsZ0RpLy84QVQvKzFCRm9IdUFJbUFEWUFBQUFIQUduL3V3Q3EvLzhBVC8rMUJGb0pUQUltQURZQUFBQUhBRDhBdWdMSy8vOEFPditpQTVJTERnSW1BRGdBQUFBSEFGNEFqQUl5Ly84QUt3QUFBNzRIbWdJbUFEa0FBQUFIQUdvQXVBQnEvLzhBT3YraUE0SUpUQUltQURnQUFBQUhBRDhBQmdMSy8vOEFLd0FBQTc0SEFBSW1BRGtBQUFBSEFMOEJJZ0FpLy84QVV2OVpBcmtHWlFJbUFFQUFBQUFIQUw3LzkvMnAvLzhBVXY5WkFya0YxQUltQUVBQUFBQUdBT01TQUFBQS8vOEFVdjZJQXlBRW53SW1BRUFBQUFBSEFOUUJoZ0FRLy84QVV2OVpCRTRITUFBbUFFQUFBQUFuQUVRQjBnQUtBQWNBYWdFU0FBRC8vd0FWLytjQ2ZBY3dBaVlBUWdBQUFBWUFhaUlBQUFELy93QVYvK2NDandqa0FpWUFRZ0FBQUFjQVgvNUZBQUQvL3dBVi8rY0Nqd2pjQWlZQVFnQUFBQVlBWG9rQUFBRC8vd0FWLytjQ2ZBYmVBaVlBUWdBQUFBY0F2d0RZQUFELy93QS8vOUlEekFic0FDWUFRd0FBQUFjQWJRTENBQUQvL3dBLy85SUQ0Z1o1QWlZQVF3QUFBQWNBREFDeUFhRC8vd0FWLytzQ2dnYnRBaVlBUkFBQUFBY0F2Z0FLL2pILy93QVYvK3NDZkFlZEFpWUFSQUFBQUFjQVgvNHQvcm4vL3dBVi8rc0NmQWJlQWlZQVJBQUFBQWNBdndEWUFBRC8vd0FWLytzQ2ZBWFVBaVlBUkFBQUFBWUE0L2NBQUFELy93QVYvbmdDZkFUbUFpWUFSQUFBQUFjQTFBRGlBQUQvL3dBYS9Cd0N6QWFGQWlZQVJnQUFBQWNBdmdCRS9jbi8vd0FhL0J3RFlnZXRBaVlBUmdBQUFBY0FYZ0JjL3RILy93QWEvQndDekFjK0FpWUFSZ0FBQUFjQWJnRjhBRkwvL3dBYS9Cd0N6QWJlQWlZQVJnQUFBQWNBdndEeUFBRC8vLyt0LzhZQzJnYjZBaVlBUndBQUFBY0E0Lzg5L3luLy93QUsvOFlEcmdlMUFpWUFSd0FBQUFjQVhnQ28vdGtBQXYvSS8vWUIzZ1lrQUF3QUV3Qm51QUFLSzdvQUF3QUtBQTByUVJzQUJnQURBQllBQXdBbUFBTUFOZ0FEQUVZQUF3QldBQU1BWmdBREFIWUFBd0NHQUFNQWxnQURBS1lBQXdDMkFBTUF4Z0FEQUExZFFRVUExUUFEQU9VQUF3QUNYUUM0QUFjdnVBQVJMN29BRWdBSEFCRVJFamt3TVJNWEJoRVNFeFVISXlJREVETUROeDRCTnhjQXNpNDhDRkl1TEVZa1dzd3FpSUNpUXY3OEEvSThQdjcwL3VUKzhoNHVBc0lCT2dIb0xzSUc1QXI5dEFBQUFBTC9vdi8yQVpZRjFBQU1BQklBWmJnQUNpdTZBQU1BQ2dBTkswRWJBQVlBQXdBV0FBTUFKZ0FEQURZQUF3QkdBQU1BVmdBREFHWUFBd0IyQUFNQWhnQURBSllBQXdDbUFBTUF0Z0FEQU1ZQUF3QU5YVUVGQU5VQUF3RGxBQU1BQWwwQXVBQVNMN2dBQnkrNkFBNEFFUUFOS3pBeEV4Y0dFUklURlFjaklnTVFNeE0zRnlZRk43SXVQQWhTTGl4R0pGclNMQVRNL3RnR0EvSThQdjcwL3VUKzhoNHVBc0lCT2dIUUJuSW1FR2ovL3dBai9wZ0JoUVY0QWlZQVNBQUFBQVlBMU9zZ0FBQUFBdjZhLy9ZQ25BZHFBQXdBSVFCZHVBQUtLN29BQXdBS0FBMHJRUnNBQmdBREFCWUFBd0FtQUFNQU5nQURBRVlBQXdCV0FBTUFaZ0FEQUhZQUF3Q0dBQU1BbGdBREFLWUFBd0MyQUFNQXhnQURBQTFkUVFVQTFRQURBT1VBQXdBQ1hRQzRBQWN2dUFBWkx6QXhFeGNHRVJJVEZRY2pJZ01RTXdFR0x3RW1Md0VtRHdFbk5qY1hFaDhCRmpjZkFiSXVQQWhTTGl4R0pGb0NBc2JRZU1vY0RHQkNDRklxNUN5MmVoYWt2aFlLQS9JOFB2NzAvdVQrOGg0dUFzSUJPZ0tNL0RwSTdBZ0VHcUF5Q3Y0ZUdQN3lJZ1l1dmdZT0FBQUFBdjlRKzZvQ0tnYkVBQk1BSXdBanVBQUtLN29BQkFBUUFBMHJ1QUFRRUxnQUFkQUF1QUFVTDdvQURnQUhBQTByTURFVEZ3Y1NFUlVRSVNZOUFUTWZBVE15RVFJRE5oTXpNaE1YSWljQ0p5TUdEd0VqTlJMSUxBNW8vcWltSG1vT0h2QXNhaFptSGo3Z0ZKWVVkQ0lRV21vOER0WUVHaXpFL05qL0FFejg5RmFhV3RJT0F3d0M0Z0hPU2dLcS9kWTJuZ0VJQmw3c0xFb0I0QUQvL3dBTS9lUUMrZ1pSQWlZQVNnQUFBQWNBNVFDU0FBRC8vLy9iLytZQll3bUFBaVlBU3dBQUFBY0FhdjlqQWxELy93Qk0vK1lCdkFoa0FDWUFTd0FBQUFjQWJRQ3lBWGovL3dBVi9lUUJLUWZlQWlZQVN3QUFBQVlBNWFVQUFBRC8vd0JNLytZQ05nZmVBQ1lBU3dBQUFBY0EzQUU2QUFELy93QW8vN1FDZ0Fjd0FpWUFUUUFBQUFZQWFoNEFBQUQvL3dBUi8rd0NhUWRVQWlZQVRlazRBQWNBNWYvWkI4ci8vd0FvLzdRQ2l3ZjFBaVlBVFFBQUFBY0FYLzVCL3hILy93QW8vZVFDZ0FVbUFpWUFUUUFBQUFZQTVXQUFBQUQvL3dBYi85WUNNZ2FsQWlZQVRnQUFBQWNBdnYrNS9lbi8vd0FILzlZQ1ZRZklBaVlBVGdBQUFBWUF3SjhBQUFELy93QXovOVlDTWdYVUFpWUFUZ0FBQUFZQTQ4TUFBQUQvL3dBSS93Z0NNZ2N3QWlZQVRnQUFBQ2NBRHYrRC93RUFCZ0JxOFFBQUFQLy9BQ0lBQkFKTkJ6QUNKZ0JSQUFBQUJnQnFBQUFBQVAvL0FBMEFCQUpyQ09RQ0pnQlJBQUFBQndCZi9pRUFBUC8vQUNMOTVBSk5CS1VDSmdCUkFBQUFCZ0RsUUFBQUFQLy8vNzcvMWdJV0J6QUNKZ0JTQUFBQUJnQnE1d0FBQVAvLy83Nzg5QUpIQk9BQ0pnQlNBQUFBQndCcy93c0FBUC8vLzc3LzFnSlJDTndDSmdCU0FBQUFCd0JlLzBzQUFQLy8vNzc5NUFJV0JPQUNKZ0JTQUFBQUJnRGxKZ0FBQVAvLy84ai8vQUswQndBQUpnQlRBQUFBQndCdEFhb0FBUC8vLzhqOTVBRzZCd0FDSmdCVEFBQUFCZ0RsM1FBQUFQLy9BQ2YvN3dKU0NMd0NKZ0JVQUFBQUJnQyt6d0FBQVAvL0FCWC83d0pqQjhnQ0pnQlVBQUFBQmdEQXJRQUFBUC8vQUNmLzd3SlNCZFFDSmdCVUFBQUFCZ0RqMHdBQUFQLy9BQ2YrZUFKU0JGUUNKZ0JVQUFBQUJ3RFVBTGdBQVAvL0FDZi83d0pTQi80Q0pnQlVBQUFBQndDRi9pOEFBUC8vL3p6Lzd3TTlCMnNDSmdCVUFBQUFCd0JyL3EwQUFQLy9BQ3NBQUFPK0J6QUNKZ0JXQUFBQUJ3QnFBTW9BQVAvL0FDc0FBQU8rQ053Q0pnQldBQUFBQmdCZU1BQUFBUC8vQUNzQUFBTytCdzRDSmdCV0FBQUFCZ0JwblFBQUFQLy9BQ3NBQUFPK0JvSUNKZ0JXQUFBQUJnQS9jZ0FBQVAvL0FDNzhpZ0tsQ053Q0pnQllBQUFBQmdCZW53QUFBUC8vQUM3OGlnS2tCb0lDSmdCWUFBQUFCZ0EvNFFBQUFQLy9BQ2ovMWdNSEJ6QUNKZ0JaQUFBQUJnQnFaZ0FBQVAvL0FDai8xZ01IQnQ0Q0pnQlpBQUFBQndDL0FSb0FBQUFBQUFBQU1BQzBBVVlCZ2dJR0FpUUNWQUtFQXVBREdBTTRBMUlEYkFPTUEvSUVJQVJZQk9JRklnVmtCYm9HRGdaaUJyb0c1Z2NpQjBvSGNnZWFDQUFJcmdqdUNYZ0p0QW53Q2pnS2ZBckNDMG9MZEF1eUMvb01NQXl1RFJnTldBM0tEaTRPaEE3RUR3Z1BRZzkwRC9BUU1CQjZFTFFRNEJFRUVVUVJiaEdVRWFvUjloSklFbm9TMEJNYUUySVR0QlFhRkhBVXRoVUdGVHdWcEJYdUZsZ1d6aGRTRjVRWHhCZ2tHR1lZbWhqMEdTd1pnaG5BR2hRYVRocXFHcW9hMEJyMkd3SWJEaHNhR3lZYk1odENHMjRid0J2NEhCd2NOQnhnSElZY3BCekNIUElkSWgwdUhUb2Q4QjM4SGdnZUZCNGdIcEllbmg2cUhyWWV6QjdnSHZZZkFoOE9IeG9mSmg4eUh6NGZuaCtxSDdZZndoL09IOW9mNWgveUgvNGdDaUFXSUNJZ2dDQ01JSmdncENDd0lMd2d5Q0RVSU9BZzdDRDRJUVFoRUNFY0lTZ2hOQ0ZBSVV3aFdDRmtJWEFoZkNHSUlaUWhvQ0lZSW5JaTJDTTRJMFFqVUNOY0kyZ2pkQ09BSTR3am1DT2tJN0FqdkNQSUk5UWovaVFzSkhva2xDU3dKTndrK2lVcUpUWWxRaVdZSmRRbVNpWjRKcmduQWlkSUoxUW5maWZFSjlnbjlpZ1lLSFFvMUNqOEtVWXBhQ21HS2ZBcVVpcW9LdUlxOWlzRUs0NHIzQ3hFTEpBczFDenlMUlF0TGkwNkxVWXRVaTFpTFc0dGVpMkdMWkl0bmkycUxiWXR3aTNPTGRvdDVpM3lMZjR1Q2k0V0xpSXVMaTQ2TGtZdVVpNWdMbXd1ZUM2RUxwQXVuQzZvTHJRdXdDN01MdGd1NUM3MEx3QXZEQzhZTHlRdk1DODhMMGd2VkM5Z0wyd3ZlQytFTDVBdm5DK29MN1F2d0MvTUw5Z3Y1Qy93TC93d0NEQVVNQ0F3TERBNE1FZ3dWREJnTUd3d2VEQ0VNSkF3bkRDb01MUXd3RERNTU5ndzVERHdNUHd4Q0RFVU1YQXh5REhVTWtBeWpqS2FNcVl5c2pLK01zb3kxakxpTXU0eStqTUdNeEl6SGpNdU16b3pSak5TTTE0emFqTjJNNEl6ampPYU02WXpzak8rTThvejFqUGlNKzR6K2pRR05CSTBIalFxTkRZMFFnQUFBREFDUmdBQkFBQUFBQUFBQUR3QUFBQUJBQUFBQUFBQkFCRUFQQUFCQUFBQUFBQUNBQWNBVFFBQkFBQUFBQUFEQUI0QVZBQUJBQUFBQUFBRUFCRUFjZ0FCQUFBQUFBQUZBQklBZ3dBQkFBQUFBQUFHQUE0QWxRQUJBQUFBQUFBSUFCQUFvd0FCQUFBQUFBQUpBQkFBc3dBQkFBQUFBQUFLQUR3QXd3QUJBQUFBQUFBTUFCb0Evd0FCQUFBQUFBQU5BSVVCR1FBREFBRUVBd0FDQUF3Qm5nQURBQUVFQlFBQ0FCQUJxZ0FEQUFFRUJnQUNBQXdCdWdBREFBRUVCd0FDQUJBQnhnQURBQUVFQ0FBQ0FCQUIxZ0FEQUFFRUNRQUFBSGdCNWdBREFBRUVDUUFCQUNJQ1hnQURBQUVFQ1FBQ0FBNENnQUFEQUFFRUNRQURBRHdDamdBREFBRUVDUUFFQUNJQ3lnQURBQUVFQ1FBRkFDUUM3QUFEQUFFRUNRQUdBQndERUFBREFBRUVDUUFJQUNBRExBQURBQUVFQ1FBSkFDQURUQUFEQUFFRUNRQUtBSGdEYkFBREFBRUVDUUFNQURRRDVBQURBQUVFQ1FBTkFRb0VHQUFEQUFFRUNnQUNBQXdGSWdBREFBRUVDd0FDQUJBRkxnQURBQUVFREFBQ0FBd0ZQZ0FEQUFFRURnQUNBQXdGU2dBREFBRUVFQUFDQUE0RlZnQURBQUVFRXdBQ0FCSUZaQUFEQUFFRUZBQUNBQXdGZGdBREFBRUVGUUFDQUJBRmdnQURBQUVFRmdBQ0FBd0ZrZ0FEQUFFRUdRQUNBQTRGbmdBREFBRUVHd0FDQUJBRnJBQURBQUVFSFFBQ0FBd0Z2QUFEQUFFRUh3QUNBQXdGeUFBREFBRUVKQUFDQUE0RjFBQURBQUVFTFFBQ0FBNEY0Z0FEQUFFSUNnQUNBQXdGOEFBREFBRUlGZ0FDQUF3Ri9BQURBQUVNQ2dBQ0FBd0dDQUFEQUFFTURBQUNBQXdHRkVOdmNIbHlhV2RvZENBb1l5a2dNakF3TmlCaWVTQkxhVzFpWlhKc2VTQkhaWE4zWldsdUxpQkJiR3dnY21sbmFIUnpJSEpsYzJWeWRtVmtMa3h2ZG1Wa0lHSjVJSFJvWlNCTGFXNW5VbVZuZFd4aGNreHZkbVZrSUdKNUlIUm9aU0JMYVc1bk9sWmxjbk5wYjI0Z01TNHdNRXh2ZG1Wa0lHSjVJSFJvWlNCTGFXNW5WbVZ5YzJsdmJpQXhMakF3TWlBeU1EQTJURzkyWldSaWVYUm9aVXRwYm1kTGFXMWlaWEpzZVNCSFpYTjNaV2x1UzJsdFltVnliSGtnUjJWemQyVnBia052Y0hseWFXZG9kQ0FvWXlrZ01qQXdOaUJpZVNCTGFXMWlaWEpzZVNCSFpYTjNaV2x1TGlCQmJHd2djbWxuYUhSeklISmxjMlZ5ZG1Wa0xtaDBkSEE2THk5cmFXMWlaWEpzZVdkbGMzZGxhVzR1WTI5dFJuSmxaU0JtYjNJZ2NHVnljMjl1WVd3Z2RYTmxMaUFnUm05eUlHTnZiVzFsY21OcFlXd2dkWE5sTENCd2JHVmhjMlVnYldGclpTQmhJRzl1WlMxMGFXMWxJRlZUSkRVZ2NHRjViV1Z1ZENCMGJ5Qm5aWE4zWldsdVptRnRhV3g1UUdkdFlXbHNMbU52YlNCMmFXRWdjR0Y1Y0dGc0xtTnZiU0FnVkdoaGJtc2dlVzkxSVFCT0FHOEFjZ0J0QUdFQWJBQnZBR0lBZVFFTkFHVUFhZ0J1QU9rQWJnQnZBSElBYlFCaEFHd0FVd0IwQUdFQWJnQmtBR0VBY2dCa0E1b0RzUU85QTc4RHZRTzVBN29EckFCREFHOEFjQUI1QUhJQWFRQm5BR2dBZEFBZ0FDZ0FZd0FwQUNBQU1nQXdBREFBTmdBZ0FHSUFlUUFnQUVzQWFRQnRBR0lBWlFCeUFHd0FlUUFnQUVjQVpRQnpBSGNBWlFCcEFHNEFMZ0FnQUVFQWJBQnNBQ0FBY2dCcEFHY0FhQUIwQUhNQUlBQnlBR1VBY3dCbEFISUFkZ0JsQUdRQUxnQk1BRzhBZGdCbEFHUUFJQUJpQUhrQUlBQjBBR2dBWlFBZ0FFc0FhUUJ1QUdjQVVnQmxBR2NBZFFCc0FHRUFjZ0JNQUc4QWRnQmxBR1FBSUFCaUFIa0FJQUIwQUdnQVpRQWdBRXNBYVFCdUFHY0FPZ0JXQUdVQWNnQnpBR2tBYndCdUFDQUFNUUF1QURBQU1BQk1BRzhBZGdCbEFHUUFJQUJpQUhrQUlBQjBBR2dBWlFBZ0FFc0FhUUJ1QUdjQVZnQmxBSElBY3dCcEFHOEFiZ0FnQURFQUxnQXdBREFBTWdBZ0FESUFNQUF3QURZQVRBQnZBSFlBWlFCa0FHSUFlUUIwQUdnQVpRQkxBR2tBYmdCbkFFc0FhUUJ0QUdJQVpRQnlBR3dBZVFBZ0FFY0FaUUJ6QUhjQVpRQnBBRzRBU3dCcEFHMEFZZ0JsQUhJQWJBQjVBQ0FBUndCbEFITUFkd0JsQUdrQWJnQkRBRzhBY0FCNUFISUFhUUJuQUdnQWRBQWdBQ2dBWXdBcEFDQUFNZ0F3QURBQU5nQWdBR0lBZVFBZ0FFc0FhUUJ0QUdJQVpRQnlBR3dBZVFBZ0FFY0FaUUJ6QUhjQVpRQnBBRzRBTGdBZ0FFRUFiQUJzQUNBQWNnQnBBR2NBYUFCMEFITUFJQUJ5QUdVQWN3QmxBSElBZGdCbEFHUUFMZ0JvQUhRQWRBQndBRG9BTHdBdkFHc0FhUUJ0QUdJQVpRQnlBR3dBZVFCbkFHVUFjd0IzQUdVQWFRQnVBQzRBWXdCdkFHMEFSZ0J5QUdVQVpRQWdBR1lBYndCeUFDQUFjQUJsQUhJQWN3QnZBRzRBWVFCc0FDQUFkUUJ6QUdVQUxnQWdBQ0FBUmdCdkFISUFJQUJqQUc4QWJRQnRBR1VBY2dCakFHa0FZUUJzQUNBQWRRQnpBR1VBTEFBZ0FIQUFiQUJsQUdFQWN3QmxBQ0FBYlFCaEFHc0FaUUFnQUdFQUlBQnZBRzRBWlFBdEFIUUFhUUJ0QUdVQUlBQlZBRk1BSkFBMUFDQUFjQUJoQUhrQWJRQmxBRzRBZEFBZ0FIUUFid0FnQUdjQVpRQnpBSGNBWlFCcEFHNEFaZ0JoQUcwQWFRQnNBSGtBUUFCbkFHMEFZUUJwQUd3QUxnQmpBRzhBYlFBZ0FIWUFhUUJoQUNBQWNBQmhBSGtBY0FCaEFHd0FMZ0JqQUc4QWJRQWdBQ0FBVkFCb0FHRUFiZ0JyQUNBQWVRQnZBSFVBSVFCT0FHOEFjZ0J0QUdFQWJBQk9BRzhBY2dCdEFHRUFZUUJzQUdrQVRnQnZBSElBYlFCaEFHd0FUZ0J2QUhJQWJRRGhBR3dBVGdCdkFISUFiUUJoQUd3QVpRQlRBSFFBWVFCdUFHUUFZUUJoQUhJQVpBQk9BRzhBY2dCdEFHRUFiQUJPQUc4QWNnQnRBR0VBYkFCdUFIa0FUZ0J2QUhJQWJRQmhBR3dFSGdReEJFc0VSd1E5QkVzRU9RQk9BRzhBY2dCdEFPRUFiQUJ1QUdVQVRnQnZBSElBYlFCaEFHd0FUZ0J2QUhJQWJRQmhBR3dBVGdCaEFIWUFZUUJrQUc0QWJ3QkJBSElBY2dCMUFHNEFkQUJoQUU0QWJ3QnlBRzBBWVFCc0FFNEFid0J5QUcwQVlRQnNBRTRBYndCeUFHMEFZUUJzQUU0QWJ3QnlBRzBBWVFCc0FBQUFBZ0FBQUFBQUFQOG1BSllBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFGaEFBQUFCUUFHQUFjQUNBQUpBQW9BQ3dBTUFBMEFEZ0FQQUJBQUVRQVNBQk1BRkFBVkFCWUFGd0FZQUJrQUdnQWJBQndBSFFBZUFCOEFJQUFoQUNJQUl3QWtBQ1VBSmdBbkFDZ0FLUUFxQUNzQUxBQXRBQzRBTHdBd0FERUFNZ0F6QURRQU5RQTJBRGNBT0FBNUFEb0FPd0E4QUQwQVBnQS9BRUFBUVFCQ0FFTUFSQUJGQUVZQVJ3QklBRWtBU2dCTEFFd0FUUUJPQUU4QVVBQlJBRklBVXdCVUFGVUFWZ0JYQUZnQVdRQmFBRnNBWEFCZEFGNEFYd0JnQUFNQTJBRGhBTUFBd1FEaUFPTUE1Z0RuQUdFQkFnQ3JBSTRBalFEWkFONEF0d0MyQUxRQXRRRGtBTEFBakFEbEFMRUF1d0NqQUlRQThnRHpBUEVBOVFEMEFQWUFvZ0N0QU1rQXh3Q3VBR0lBM1FCakFKQUFaQURMQUdVQXlBREtBTThBekFETkFNNEE2UUJtQU5NQTBBRFJBSzhBWndDUkFOWUExQURWQUdnQTZ3QnFBR2tBYXdCdEFHd0FiZ0NnQUc4QWNRQndBSElBY3dCMUFIUUFkZ0IzQUhnQWVnQjVBSHNBZlFCOEFLRUFmd0IrQUlBQWdRRHNBTG9BQkFDL0FLb0Eyd0RjQU44QXhBREZBSjRBZ3dDV0FJVUF2UURvQUlZQWl3Q21BSjBBdmdDcEFJY0FzZ0N6QUlJQXdnRGdBTmNBcEFEdkFJb0Frd0NYQUlnQkF3QzRBSWtBN1FEdUFPb0E4QUVFQUx3QkJRRUdBUWNCQ0FFSkFQMEJDZ0QvQVFzQkRBRU5BUTRCRHdFUUFSRUErQUVTQVJNQkZBRVZBUllCRndFWUFSa0JHZ0ViQVJ3QkhRRWVBUjhCSUFFaEFTSUJJd0VrQVNVQkpnRW5BU2dCS1FFcUFTc0JMQUQ3QVMwQkxnRXZBVEFCTVFFeUFUTUJOQUUxQVRZQk53RTRBVGtCT2dFN0FUd0JQUUUrQVQ4QlFBRkJBVUlBL2dFQUFVTUJSQUZGQVVZQlJ3RklBVWtCU2dGTEFQa0JUQUZOQVU0QlR3RlFBVkVCVWdGVEFWUUJWUUZXQVZjQldBRlpBVm9CV3dGY0FWMEJYZ0ZmQVdBQllRRmlBV01CWkFGbEFXWUEvQUZuQVdnQmFRRnFBV3NCYkFGdEFXNEJid0Z3QVhFQmNnRnpBWFFCZFFGMkFYY0JlQVJGZFhKdkRuQmxjbWx2WkdObGJuUmxjbVZrQm0xaFkzSnZiZ3RqYjIxdFlXRmpZMlZ1ZEFaQlluSmxkbVVIUVc5bmIyNWxhd2RCYldGamNtOXVCMEZGWVdOMWRHVUxRMk5wY21OMWJXWnNaWGdLUTJSdmRHRmpZMlZ1ZEFaRVkyRnliMjRHUkdOeWIyRjBCa1ZpY21WMlpRWkZZMkZ5YjI0S1JXUnZkR0ZqWTJWdWRBZEZiV0ZqY205dUIwVnZaMjl1WldzTFIyTnBjbU4xYldac1pYZ01SMk52YlcxaFlXTmpaVzUwQ2tka2IzUmhZMk5sYm5RTFNHTnBjbU4xYldac1pYZ0dTV0p5WlhabENrbGtiM1JoWTJObGJuUUhTVzluYjI1bGF3ZEpiV0ZqY205dUJrbDBhV3hrWlF0S1kybHlZM1Z0Wm14bGVBeExZMjl0YldGaFkyTmxiblFHVEdGamRYUmxCa3hqWVhKdmJneE1ZMjl0YldGaFkyTmxiblFFVEdSdmRBWk9ZV04xZEdVR1RtTmhjbTl1REU1amIyMXRZV0ZqWTJWdWRBWlBZbkpsZG1VTlQyaDFibWRoY25WdGJHRjFkQXRQYzJ4aGMyaGhZM1YwWlFkUGJXRmpjbTl1QmxKaFkzVjBaUVpTWTJGeWIyNE1VbU52YlcxaFlXTmpaVzUwQmxOaFkzVjBaUXRUWTJseVkzVnRabXhsZUF4VFkyOXRiV0ZoWTJObGJuUUdWR05oY205dURGUmpiMjF0WVdGalkyVnVkQVpWWW5KbGRtVUhWVzFoWTNKdmJnMVZhSFZ1WjJGeWRXMXNZWFYwQlZWeWFXNW5CMVZ2WjI5dVpXc0dWWFJwYkdSbEJsZGhZM1YwWlF0WFkybHlZM1Z0Wm14bGVBbFhaR2xsY21WemFYTUdWMmR5WVhabEMxbGphWEpqZFcxbWJHVjRCbHBoWTNWMFpRWlpaM0poZG1VS1dtUnZkR0ZqWTJWdWRBWmhZbkpsZG1VSFlXMWhZM0p2YmdkaGIyZHZibVZyQjJGbFlXTjFkR1VMWTJOcGNtTjFiV1pzWlhnS1kyUnZkR0ZqWTJWdWRBWmtZMkZ5YjI0R1pHTnliMkYwQm1WaWNtVjJaUVpsWTJGeWIyNEtaV1J2ZEdGalkyVnVkQWRsYldGamNtOXVCMlZ2WjI5dVpXc0xaMk5wY21OMWJXWnNaWGdNWjJOdmJXMWhZV05qWlc1MENtZGtiM1JoWTJObGJuUUVhR0poY2d0b1kybHlZM1Z0Wm14bGVBWnBZbkpsZG1VSGFXMWhZM0p2YmdkcGIyZHZibVZyQm1sMGFXeGtaUXRxWTJseVkzVnRabXhsZUF4clkyOXRiV0ZoWTJObGJuUUdiR0ZqZFhSbEJteGpZWEp2Ymd4c1kyOXRiV0ZoWTJObGJuUUViR1J2ZEFadVlXTjFkR1VMYm1Gd2IzTjBjbTl3YUdVR2JtTmhjbTl1REc1amIyMXRZV0ZqWTJWdWRBWnZZbkpsZG1VTmIyaDFibWRoY25WdGJHRjFkQWR2YldGamNtOXVDMjl6YkdGemFHRmpkWFJsQm5KaFkzVjBaUVp5WTJGeWIyNE1jbU52YlcxaFlXTmpaVzUwQm5OaFkzVjBaUXR6WTJseVkzVnRabXhsZUF4elkyOXRiV0ZoWTJObGJuUUdkR05oY205dURIUmpiMjF0WVdGalkyVnVkQVoxWW5KbGRtVU5kV2gxYm1kaGNuVnRiR0YxZEFkMWJXRmpjbTl1QjNWdloyOXVaV3NGZFhKcGJtY0dkWFJwYkdSbEJuZGhZM1YwWlF0M1kybHlZM1Z0Wm14bGVBbDNaR2xsY21WemFYTUdkMmR5WVhabEMzbGphWEpqZFcxbWJHVjRCbmxuY21GMlpRWjZZV04xZEdVS2VtUnZkR0ZqWTJWdWRBQUFBQUFCLy84QUFnPT1cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3R5bGVzL2ZvbnRzL0xvdmVkYnl0aGVLaW5nLnR0ZlxuLy8gbW9kdWxlIGlkID0gMjQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImFzc2V0cy9Mb3ZlZGJ5dGhlS2luZy5zdmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3N0eWxlcy9mb250cy9Mb3ZlZGJ5dGhlS2luZy5zdmdcbi8vIG1vZHVsZSBpZCA9IDI0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG52YXIgc3R5bGVzSW5Eb20gPSB7fSxcclxuXHRtZW1vaXplID0gZnVuY3Rpb24oZm4pIHtcclxuXHRcdHZhciBtZW1vO1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0cmV0dXJuIG1lbW87XHJcblx0XHR9O1xyXG5cdH0sXHJcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gL21zaWUgWzYtOV1cXGIvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XHJcblx0fSksXHJcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcclxuXHR9KSxcclxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcclxuXHRzaW5nbGV0b25Db3VudGVyID0gMDtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XHJcblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XHJcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xyXG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XHJcblx0XHR9XHJcblx0XHRpZihuZXdMaXN0KSB7XHJcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XHJcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcclxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xyXG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XHJcblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xyXG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XHJcblx0XHRpZihkb21TdHlsZSkge1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcclxuXHR2YXIgc3R5bGVzID0gW107XHJcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xyXG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XHJcblx0XHR2YXIgaWQgPSBpdGVtWzBdO1xyXG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XHJcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xyXG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XHJcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XHJcblx0XHRpZighbmV3U3R5bGVzW2lkXSlcclxuXHRcdFx0c3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0bmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xyXG5cdH1cclxuXHRyZXR1cm4gc3R5bGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQoKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0c3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XHJcblx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KCkge1xyXG5cdHZhciBsaW5rRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xyXG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRoZWFkLmFwcGVuZENoaWxkKGxpbmtFbGVtZW50KTtcclxuXHRyZXR1cm4gbGlua0VsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xyXG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xyXG5cclxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcclxuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KCk7XHJcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcclxuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdFx0XHRpZihzdHlsZUVsZW1lbnQuaHJlZilcclxuXHRcdFx0XHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR1cGRhdGUob2JqKTtcclxuXHJcblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xyXG5cdFx0aWYobmV3T2JqKSB7XHJcblx0XHRcdGlmKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcClcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmVtb3ZlKCk7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgdGV4dFN0b3JlID0gW107XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XHJcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XHJcblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcclxuXHR9O1xyXG59KSgpO1xyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xyXG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcclxuXHJcblx0aWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcclxuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XHJcblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xyXG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xyXG5cclxuXHRpZihtZWRpYSkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxyXG5cdH1cclxuXHJcblx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcclxuXHR2YXIgY3NzID0gb2JqLmNzcztcclxuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==